function dge(t, e) { for (var n = 0; n < e.length; n++) { const r = e[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in t)) { const a = Object.getOwnPropertyDescriptor(r, i); a && Object.defineProperty(t, i, a.get ? a : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const s of a.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function r(i) { if (i.ep) return; i.ep = !0; const a = n(i); fetch(i.href, a) } })(); var OE = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Fr(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var xj = { exports: {} }, qb = {}, bj = { exports: {} }, hr = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var t8; function fge() { if (t8) return hr; t8 = 1; var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), o = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.iterator; function h(X) { return X === null || typeof X != "object" ? null : (X = f && X[f] || X["@@iterator"], typeof X == "function" ? X : null) } var m = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, g = Object.assign, x = {}; function v(X, Q, re) { this.props = X, this.context = Q, this.refs = x, this.updater = re || m } v.prototype.isReactComponent = {}, v.prototype.setState = function (X, Q) { if (typeof X != "object" && typeof X != "function" && X != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, X, Q, "setState") }, v.prototype.forceUpdate = function (X) { this.updater.enqueueForceUpdate(this, X, "forceUpdate") }; function b() { } b.prototype = v.prototype; function E(X, Q, re) { this.props = X, this.context = Q, this.refs = x, this.updater = re || m } var M = E.prototype = new b; M.constructor = E, g(M, v.prototype), M.isPureReactComponent = !0; var C = Array.isArray, N = Object.prototype.hasOwnProperty, A = { current: null }, j = { key: !0, ref: !0, __self: !0, __source: !0 }; function O(X, Q, re) { var ce, be = {}, de = null, ae = null; if (Q != null) for (ce in Q.ref !== void 0 && (ae = Q.ref), Q.key !== void 0 && (de = "" + Q.key), Q) N.call(Q, ce) && !j.hasOwnProperty(ce) && (be[ce] = Q[ce]); var se = arguments.length - 2; if (se === 1) be.children = re; else if (1 < se) { for (var he = Array(se), Ae = 0; Ae < se; Ae++)he[Ae] = arguments[Ae + 2]; be.children = he } if (X && X.defaultProps) for (ce in se = X.defaultProps, se) be[ce] === void 0 && (be[ce] = se[ce]); return { $$typeof: t, type: X, key: de, ref: ae, props: be, _owner: A.current } } function I(X, Q) { return { $$typeof: t, type: X.type, key: Q, ref: X.ref, props: X.props, _owner: X._owner } } function D(X) { return typeof X == "object" && X !== null && X.$$typeof === t } function F(X) { var Q = { "=": "=0", ":": "=2" }; return "$" + X.replace(/[=:]/g, function (re) { return Q[re] }) } var B = /\/+/g; function G(X, Q) { return typeof X == "object" && X !== null && X.key != null ? F("" + X.key) : Q.toString(36) } function z(X, Q, re, ce, be) { var de = typeof X; (de === "undefined" || de === "boolean") && (X = null); var ae = !1; if (X === null) ae = !0; else switch (de) { case "string": case "number": ae = !0; break; case "object": switch (X.$$typeof) { case t: case e: ae = !0 } }if (ae) return ae = X, be = be(ae), X = ce === "" ? "." + G(ae, 0) : ce, C(be) ? (re = "", X != null && (re = X.replace(B, "$&/") + "/"), z(be, Q, re, "", function (Ae) { return Ae })) : be != null && (D(be) && (be = I(be, re + (!be.key || ae && ae.key === be.key ? "" : ("" + be.key).replace(B, "$&/") + "/") + X)), Q.push(be)), 1; if (ae = 0, ce = ce === "" ? "." : ce + ":", C(X)) for (var se = 0; se < X.length; se++) { de = X[se]; var he = ce + G(de, se); ae += z(de, Q, re, he, be) } else if (he = h(X), typeof he == "function") for (X = he.call(X), se = 0; !(de = X.next()).done;)de = de.value, he = ce + G(de, se++), ae += z(de, Q, re, he, be); else if (de === "object") throw Q = String(X), Error("Objects are not valid as a React child (found: " + (Q === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : Q) + "). If you meant to render a collection of children, use an array instead."); return ae } function q(X, Q, re) { if (X == null) return X; var ce = [], be = 0; return z(X, ce, "", "", function (de) { return Q.call(re, de, be++) }), ce } function Y(X) { if (X._status === -1) { var Q = X._result; Q = Q(), Q.then(function (re) { (X._status === 0 || X._status === -1) && (X._status = 1, X._result = re) }, function (re) { (X._status === 0 || X._status === -1) && (X._status = 2, X._result = re) }), X._status === -1 && (X._status = 0, X._result = Q) } if (X._status === 1) return X._result.default; throw X._result } var Z = { current: null }, $ = { transition: null }, V = { ReactCurrentDispatcher: Z, ReactCurrentBatchConfig: $, ReactCurrentOwner: A }; function K() { throw Error("act(...) is not supported in production builds of React.") } return hr.Children = { map: q, forEach: function (X, Q, re) { q(X, function () { Q.apply(this, arguments) }, re) }, count: function (X) { var Q = 0; return q(X, function () { Q++ }), Q }, toArray: function (X) { return q(X, function (Q) { return Q }) || [] }, only: function (X) { if (!D(X)) throw Error("React.Children.only expected to receive a single React element child."); return X } }, hr.Component = v, hr.Fragment = n, hr.Profiler = i, hr.PureComponent = E, hr.StrictMode = r, hr.Suspense = c, hr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = V, hr.act = K, hr.cloneElement = function (X, Q, re) { if (X == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + X + "."); var ce = g({}, X.props), be = X.key, de = X.ref, ae = X._owner; if (Q != null) { if (Q.ref !== void 0 && (de = Q.ref, ae = A.current), Q.key !== void 0 && (be = "" + Q.key), X.type && X.type.defaultProps) var se = X.type.defaultProps; for (he in Q) N.call(Q, he) && !j.hasOwnProperty(he) && (ce[he] = Q[he] === void 0 && se !== void 0 ? se[he] : Q[he]) } var he = arguments.length - 2; if (he === 1) ce.children = re; else if (1 < he) { se = Array(he); for (var Ae = 0; Ae < he; Ae++)se[Ae] = arguments[Ae + 2]; ce.children = se } return { $$typeof: t, type: X.type, key: be, ref: de, props: ce, _owner: ae } }, hr.createContext = function (X) { return X = { $$typeof: s, _currentValue: X, _currentValue2: X, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, X.Provider = { $$typeof: a, _context: X }, X.Consumer = X }, hr.createElement = O, hr.createFactory = function (X) { var Q = O.bind(null, X); return Q.type = X, Q }, hr.createRef = function () { return { current: null } }, hr.forwardRef = function (X) { return { $$typeof: o, render: X } }, hr.isValidElement = D, hr.lazy = function (X) { return { $$typeof: d, _payload: { _status: -1, _result: X }, _init: Y } }, hr.memo = function (X, Q) { return { $$typeof: u, type: X, compare: Q === void 0 ? null : Q } }, hr.startTransition = function (X) { var Q = $.transition; $.transition = {}; try { X() } finally { $.transition = Q } }, hr.unstable_act = K, hr.useCallback = function (X, Q) { return Z.current.useCallback(X, Q) }, hr.useContext = function (X) { return Z.current.useContext(X) }, hr.useDebugValue = function () { }, hr.useDeferredValue = function (X) { return Z.current.useDeferredValue(X) }, hr.useEffect = function (X, Q) { return Z.current.useEffect(X, Q) }, hr.useId = function () { return Z.current.useId() }, hr.useImperativeHandle = function (X, Q, re) { return Z.current.useImperativeHandle(X, Q, re) }, hr.useInsertionEffect = function (X, Q) { return Z.current.useInsertionEffect(X, Q) }, hr.useLayoutEffect = function (X, Q) { return Z.current.useLayoutEffect(X, Q) }, hr.useMemo = function (X, Q) { return Z.current.useMemo(X, Q) }, hr.useReducer = function (X, Q, re) { return Z.current.useReducer(X, Q, re) }, hr.useRef = function (X) { return Z.current.useRef(X) }, hr.useState = function (X) { return Z.current.useState(X) }, hr.useSyncExternalStore = function (X, Q, re) { return Z.current.useSyncExternalStore(X, Q, re) }, hr.useTransition = function () { return Z.current.useTransition() }, hr.version = "18.3.1", hr } var n8; function IS() { return n8 || (n8 = 1, bj.exports = fge()), bj.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var r8; function hge() { if (r8) return qb; r8 = 1; var t = IS(), e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 }; function s(o, c, u) { var d, f = {}, h = null, m = null; u !== void 0 && (h = "" + u), c.key !== void 0 && (h = "" + c.key), c.ref !== void 0 && (m = c.ref); for (d in c) r.call(c, d) && !a.hasOwnProperty(d) && (f[d] = c[d]); if (o && o.defaultProps) for (d in c = o.defaultProps, c) f[d] === void 0 && (f[d] = c[d]); return { $$typeof: e, type: o, key: h, ref: m, props: f, _owner: i.current } } return qb.Fragment = n, qb.jsx = s, qb.jsxs = s, qb } var i8; function pge() { return i8 || (i8 = 1, xj.exports = hge()), xj.exports } var l = pge(), DE = {}, wj = { exports: {} }, To = {}, Sj = { exports: {} }, _j = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var a8; function mge() { return a8 || (a8 = 1, (function (t) { function e($, V) { var K = $.length; $.push(V); e: for (; 0 < K;) { var X = K - 1 >>> 1, Q = $[X]; if (0 < i(Q, V)) $[X] = V, $[K] = Q, K = X; else break e } } function n($) { return $.length === 0 ? null : $[0] } function r($) { if ($.length === 0) return null; var V = $[0], K = $.pop(); if (K !== V) { $[0] = K; e: for (var X = 0, Q = $.length, re = Q >>> 1; X < re;) { var ce = 2 * (X + 1) - 1, be = $[ce], de = ce + 1, ae = $[de]; if (0 > i(be, K)) de < Q && 0 > i(ae, be) ? ($[X] = ae, $[de] = K, X = de) : ($[X] = be, $[ce] = K, X = ce); else if (de < Q && 0 > i(ae, K)) $[X] = ae, $[de] = K, X = de; else break e } } return V } function i($, V) { var K = $.sortIndex - V.sortIndex; return K !== 0 ? K : $.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var a = performance; t.unstable_now = function () { return a.now() } } else { var s = Date, o = s.now(); t.unstable_now = function () { return s.now() - o } } var c = [], u = [], d = 1, f = null, h = 3, m = !1, g = !1, x = !1, v = typeof setTimeout == "function" ? setTimeout : null, b = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M($) { for (var V = n(u); V !== null;) { if (V.callback === null) r(u); else if (V.startTime <= $) r(u), V.sortIndex = V.expirationTime, e(c, V); else break; V = n(u) } } function C($) { if (x = !1, M($), !g) if (n(c) !== null) g = !0, Y(N); else { var V = n(u); V !== null && Z(C, V.startTime - $) } } function N($, V) { g = !1, x && (x = !1, b(O), O = -1), m = !0; var K = h; try { for (M(V), f = n(c); f !== null && (!(f.expirationTime > V) || $ && !F());) { var X = f.callback; if (typeof X == "function") { f.callback = null, h = f.priorityLevel; var Q = X(f.expirationTime <= V); V = t.unstable_now(), typeof Q == "function" ? f.callback = Q : f === n(c) && r(c), M(V) } else r(c); f = n(c) } if (f !== null) var re = !0; else { var ce = n(u); ce !== null && Z(C, ce.startTime - V), re = !1 } return re } finally { f = null, h = K, m = !1 } } var A = !1, j = null, O = -1, I = 5, D = -1; function F() { return !(t.unstable_now() - D < I) } function B() { if (j !== null) { var $ = t.unstable_now(); D = $; var V = !0; try { V = j(!0, $) } finally { V ? G() : (A = !1, j = null) } } else A = !1 } var G; if (typeof E == "function") G = function () { E(B) }; else if (typeof MessageChannel < "u") { var z = new MessageChannel, q = z.port2; z.port1.onmessage = B, G = function () { q.postMessage(null) } } else G = function () { v(B, 0) }; function Y($) { j = $, A || (A = !0, G()) } function Z($, V) { O = v(function () { $(t.unstable_now()) }, V) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function ($) { $.callback = null }, t.unstable_continueExecution = function () { g || m || (g = !0, Y(N)) }, t.unstable_forceFrameRate = function ($) { 0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < $ ? Math.floor(1e3 / $) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(c) }, t.unstable_next = function ($) { switch (h) { case 1: case 2: case 3: var V = 3; break; default: V = h }var K = h; h = V; try { return $() } finally { h = K } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function ($, V) { switch ($) { case 1: case 2: case 3: case 4: case 5: break; default: $ = 3 }var K = h; h = $; try { return V() } finally { h = K } }, t.unstable_scheduleCallback = function ($, V, K) { var X = t.unstable_now(); switch (typeof K == "object" && K !== null ? (K = K.delay, K = typeof K == "number" && 0 < K ? X + K : X) : K = X, $) { case 1: var Q = -1; break; case 2: Q = 250; break; case 5: Q = 1073741823; break; case 4: Q = 1e4; break; default: Q = 5e3 }return Q = K + Q, $ = { id: d++, callback: V, priorityLevel: $, startTime: K, expirationTime: Q, sortIndex: -1 }, K > X ? ($.sortIndex = K, e(u, $), n(c) === null && $ === n(u) && (x ? (b(O), O = -1) : x = !0, Z(C, K - X))) : ($.sortIndex = Q, e(c, $), g || m || (g = !0, Y(N))), $ }, t.unstable_shouldYield = F, t.unstable_wrapCallback = function ($) { var V = h; return function () { var K = h; h = V; try { return $.apply(this, arguments) } finally { h = K } } } })(_j)), _j } var s8; function gge() { return s8 || (s8 = 1, Sj.exports = mge()), Sj.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o8; function vge() {
	if (o8) return To; o8 = 1; var t = IS(), e = gge(); function n(p) { for (var y = "https://reactjs.org/docs/error-decoder.html?invariant=" + p, T = 1; T < arguments.length; T++)y += "&args[]=" + encodeURIComponent(arguments[T]); return "Minified React error #" + p + "; visit " + y + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var r = new Set, i = {}; function a(p, y) { s(p, y), s(p + "Capture", y) } function s(p, y) { for (i[p] = y, p = 0; p < y.length; p++)r.add(y[p]) } var o = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), c = Object.prototype.hasOwnProperty, u = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, d = {}, f = {}; function h(p) { return c.call(f, p) ? !0 : c.call(d, p) ? !1 : u.test(p) ? f[p] = !0 : (d[p] = !0, !1) } function m(p, y, T, k) { if (T !== null && T.type === 0) return !1; switch (typeof y) { case "function": case "symbol": return !0; case "boolean": return k ? !1 : T !== null ? !T.acceptsBooleans : (p = p.toLowerCase().slice(0, 5), p !== "data-" && p !== "aria-"); default: return !1 } } function g(p, y, T, k) { if (y === null || typeof y > "u" || m(p, y, T, k)) return !0; if (k) return !1; if (T !== null) switch (T.type) { case 3: return !y; case 4: return y === !1; case 5: return isNaN(y); case 6: return isNaN(y) || 1 > y }return !1 } function x(p, y, T, k, U, W, le) { this.acceptsBooleans = y === 2 || y === 3 || y === 4, this.attributeName = k, this.attributeNamespace = U, this.mustUseProperty = T, this.propertyName = p, this.type = y, this.sanitizeURL = W, this.removeEmptyString = le } var v = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (p) { v[p] = new x(p, 0, !1, p, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (p) { var y = p[0]; v[y] = new x(y, 1, !1, p[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (p) { v[p] = new x(p, 2, !1, p.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (p) { v[p] = new x(p, 2, !1, p, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (p) { v[p] = new x(p, 3, !1, p.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (p) { v[p] = new x(p, 3, !0, p, null, !1, !1) }), ["capture", "download"].forEach(function (p) { v[p] = new x(p, 4, !1, p, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (p) { v[p] = new x(p, 6, !1, p, null, !1, !1) }), ["rowSpan", "start"].forEach(function (p) { v[p] = new x(p, 5, !1, p.toLowerCase(), null, !1, !1) }); var b = /[\-:]([a-z])/g; function E(p) { return p[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (p) { var y = p.replace(b, E); v[y] = new x(y, 1, !1, p, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (p) { var y = p.replace(b, E); v[y] = new x(y, 1, !1, p, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (p) { var y = p.replace(b, E); v[y] = new x(y, 1, !1, p, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (p) { v[p] = new x(p, 1, !1, p.toLowerCase(), null, !1, !1) }), v.xlinkHref = new x("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (p) { v[p] = new x(p, 1, !1, p.toLowerCase(), null, !0, !0) }); function M(p, y, T, k) { var U = v.hasOwnProperty(y) ? v[y] : null; (U !== null ? U.type !== 0 : k || !(2 < y.length) || y[0] !== "o" && y[0] !== "O" || y[1] !== "n" && y[1] !== "N") && (g(y, T, U, k) && (T = null), k || U === null ? h(y) && (T === null ? p.removeAttribute(y) : p.setAttribute(y, "" + T)) : U.mustUseProperty ? p[U.propertyName] = T === null ? U.type === 3 ? !1 : "" : T : (y = U.attributeName, k = U.attributeNamespace, T === null ? p.removeAttribute(y) : (U = U.type, T = U === 3 || U === 4 && T === !0 ? "" : "" + T, k ? p.setAttributeNS(k, y, T) : p.setAttribute(y, T)))) } var C = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, N = Symbol.for("react.element"), A = Symbol.for("react.portal"), j = Symbol.for("react.fragment"), O = Symbol.for("react.strict_mode"), I = Symbol.for("react.profiler"), D = Symbol.for("react.provider"), F = Symbol.for("react.context"), B = Symbol.for("react.forward_ref"), G = Symbol.for("react.suspense"), z = Symbol.for("react.suspense_list"), q = Symbol.for("react.memo"), Y = Symbol.for("react.lazy"), Z = Symbol.for("react.offscreen"), $ = Symbol.iterator; function V(p) { return p === null || typeof p != "object" ? null : (p = $ && p[$] || p["@@iterator"], typeof p == "function" ? p : null) } var K = Object.assign, X; function Q(p) {
		if (X === void 0) try { throw Error() } catch (T) { var y = T.stack.trim().match(/\n( *(at )?)/); X = y && y[1] || "" } return `
`+ X + p
	} var re = !1; function ce(p, y) {
		if (!p || re) return ""; re = !0; var T = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (y) if (y = function () { throw Error() }, Object.defineProperty(y.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(y, []) } catch (qe) { var k = qe } Reflect.construct(p, [], y) } else { try { y.call() } catch (qe) { k = qe } p.call(y.prototype) } else { try { throw Error() } catch (qe) { k = qe } p() } } catch (qe) {
			if (qe && k && typeof qe.stack == "string") {
				for (var U = qe.stack.split(`
`), W = k.stack.split(`
`), le = U.length - 1, we = W.length - 1; 1 <= le && 0 <= we && U[le] !== W[we];)we--; for (; 1 <= le && 0 <= we; le--, we--)if (U[le] !== W[we]) {
					if (le !== 1 || we !== 1) do if (le--, we--, 0 > we || U[le] !== W[we]) {
						var Pe = `
`+ U[le].replace(" at new ", " at "); return p.displayName && Pe.includes("<anonymous>") && (Pe = Pe.replace("<anonymous>", p.displayName)), Pe
					} while (1 <= le && 0 <= we); break
				}
			}
		} finally { re = !1, Error.prepareStackTrace = T } return (p = p ? p.displayName || p.name : "") ? Q(p) : ""
	} function be(p) { switch (p.tag) { case 5: return Q(p.type); case 16: return Q("Lazy"); case 13: return Q("Suspense"); case 19: return Q("SuspenseList"); case 0: case 2: case 15: return p = ce(p.type, !1), p; case 11: return p = ce(p.type.render, !1), p; case 1: return p = ce(p.type, !0), p; default: return "" } } function de(p) { if (p == null) return null; if (typeof p == "function") return p.displayName || p.name || null; if (typeof p == "string") return p; switch (p) { case j: return "Fragment"; case A: return "Portal"; case I: return "Profiler"; case O: return "StrictMode"; case G: return "Suspense"; case z: return "SuspenseList" }if (typeof p == "object") switch (p.$$typeof) { case F: return (p.displayName || "Context") + ".Consumer"; case D: return (p._context.displayName || "Context") + ".Provider"; case B: var y = p.render; return p = p.displayName, p || (p = y.displayName || y.name || "", p = p !== "" ? "ForwardRef(" + p + ")" : "ForwardRef"), p; case q: return y = p.displayName || null, y !== null ? y : de(p.type) || "Memo"; case Y: y = p._payload, p = p._init; try { return de(p(y)) } catch { } }return null } function ae(p) { var y = p.type; switch (p.tag) { case 24: return "Cache"; case 9: return (y.displayName || "Context") + ".Consumer"; case 10: return (y._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return p = y.render, p = p.displayName || p.name || "", y.displayName || (p !== "" ? "ForwardRef(" + p + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return y; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return de(y); case 8: return y === O ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof y == "function") return y.displayName || y.name || null; if (typeof y == "string") return y }return null } function se(p) { switch (typeof p) { case "boolean": case "number": case "string": case "undefined": return p; case "object": return p; default: return "" } } function he(p) { var y = p.type; return (p = p.nodeName) && p.toLowerCase() === "input" && (y === "checkbox" || y === "radio") } function Ae(p) { var y = he(p) ? "checked" : "value", T = Object.getOwnPropertyDescriptor(p.constructor.prototype, y), k = "" + p[y]; if (!p.hasOwnProperty(y) && typeof T < "u" && typeof T.get == "function" && typeof T.set == "function") { var U = T.get, W = T.set; return Object.defineProperty(p, y, { configurable: !0, get: function () { return U.call(this) }, set: function (le) { k = "" + le, W.call(this, le) } }), Object.defineProperty(p, y, { enumerable: T.enumerable }), { getValue: function () { return k }, setValue: function (le) { k = "" + le }, stopTracking: function () { p._valueTracker = null, delete p[y] } } } } function Ce(p) { p._valueTracker || (p._valueTracker = Ae(p)) } function fe(p) { if (!p) return !1; var y = p._valueTracker; if (!y) return !0; var T = y.getValue(), k = ""; return p && (k = he(p) ? p.checked ? "true" : "false" : p.value), p = k, p !== T ? (y.setValue(p), !0) : !1 } function oe(p) { if (p = p || (typeof document < "u" ? document : void 0), typeof p > "u") return null; try { return p.activeElement || p.body } catch { return p.body } } function xe(p, y) { var T = y.checked; return K({}, y, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: T ?? p._wrapperState.initialChecked }) } function _e(p, y) { var T = y.defaultValue == null ? "" : y.defaultValue, k = y.checked != null ? y.checked : y.defaultChecked; T = se(y.value != null ? y.value : T), p._wrapperState = { initialChecked: k, initialValue: T, controlled: y.type === "checkbox" || y.type === "radio" ? y.checked != null : y.value != null } } function je(p, y) { y = y.checked, y != null && M(p, "checked", y, !1) } function ke(p, y) { je(p, y); var T = se(y.value), k = y.type; if (T != null) k === "number" ? (T === 0 && p.value === "" || p.value != T) && (p.value = "" + T) : p.value !== "" + T && (p.value = "" + T); else if (k === "submit" || k === "reset") { p.removeAttribute("value"); return } y.hasOwnProperty("value") ? Xe(p, y.type, T) : y.hasOwnProperty("defaultValue") && Xe(p, y.type, se(y.defaultValue)), y.checked == null && y.defaultChecked != null && (p.defaultChecked = !!y.defaultChecked) } function Ze(p, y, T) { if (y.hasOwnProperty("value") || y.hasOwnProperty("defaultValue")) { var k = y.type; if (!(k !== "submit" && k !== "reset" || y.value !== void 0 && y.value !== null)) return; y = "" + p._wrapperState.initialValue, T || y === p.value || (p.value = y), p.defaultValue = y } T = p.name, T !== "" && (p.name = ""), p.defaultChecked = !!p._wrapperState.initialChecked, T !== "" && (p.name = T) } function Xe(p, y, T) { (y !== "number" || oe(p.ownerDocument) !== p) && (T == null ? p.defaultValue = "" + p._wrapperState.initialValue : p.defaultValue !== "" + T && (p.defaultValue = "" + T)) } var nt = Array.isArray; function Tt(p, y, T, k) { if (p = p.options, y) { y = {}; for (var U = 0; U < T.length; U++)y["$" + T[U]] = !0; for (T = 0; T < p.length; T++)U = y.hasOwnProperty("$" + p[T].value), p[T].selected !== U && (p[T].selected = U), U && k && (p[T].defaultSelected = !0) } else { for (T = "" + se(T), y = null, U = 0; U < p.length; U++) { if (p[U].value === T) { p[U].selected = !0, k && (p[U].defaultSelected = !0); return } y !== null || p[U].disabled || (y = p[U]) } y !== null && (y.selected = !0) } } function St(p, y) { if (y.dangerouslySetInnerHTML != null) throw Error(n(91)); return K({}, y, { value: void 0, defaultValue: void 0, children: "" + p._wrapperState.initialValue }) } function ee(p, y) { var T = y.value; if (T == null) { if (T = y.children, y = y.defaultValue, T != null) { if (y != null) throw Error(n(92)); if (nt(T)) { if (1 < T.length) throw Error(n(93)); T = T[0] } y = T } y == null && (y = ""), T = y } p._wrapperState = { initialValue: se(T) } } function ne(p, y) { var T = se(y.value), k = se(y.defaultValue); T != null && (T = "" + T, T !== p.value && (p.value = T), y.defaultValue == null && p.defaultValue !== T && (p.defaultValue = T)), k != null && (p.defaultValue = "" + k) } function Re(p) { var y = p.textContent; y === p._wrapperState.initialValue && y !== "" && y !== null && (p.value = y) } function Ue(p) { switch (p) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function et(p, y) { return p == null || p === "http://www.w3.org/1999/xhtml" ? Ue(y) : p === "http://www.w3.org/2000/svg" && y === "foreignObject" ? "http://www.w3.org/1999/xhtml" : p } var Ge, Xt = (function (p) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (y, T, k, U) { MSApp.execUnsafeLocalFunction(function () { return p(y, T, k, U) }) } : p })(function (p, y) { if (p.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in p) p.innerHTML = y; else { for (Ge = Ge || document.createElement("div"), Ge.innerHTML = "<svg>" + y.valueOf().toString() + "</svg>", y = Ge.firstChild; p.firstChild;)p.removeChild(p.firstChild); for (; y.firstChild;)p.appendChild(y.firstChild) } }); function yt(p, y) { if (y) { var T = p.firstChild; if (T && T === p.lastChild && T.nodeType === 3) { T.nodeValue = y; return } } p.textContent = y } var Yt = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, en = ["Webkit", "ms", "Moz", "O"]; Object.keys(Yt).forEach(function (p) { en.forEach(function (y) { y = y + p.charAt(0).toUpperCase() + p.substring(1), Yt[y] = Yt[p] }) }); function pt(p, y, T) { return y == null || typeof y == "boolean" || y === "" ? "" : T || typeof y != "number" || y === 0 || Yt.hasOwnProperty(p) && Yt[p] ? ("" + y).trim() : y + "px" } function bt(p, y) { p = p.style; for (var T in y) if (y.hasOwnProperty(T)) { var k = T.indexOf("--") === 0, U = pt(T, y[T], k); T === "float" && (T = "cssFloat"), k ? p.setProperty(T, U) : p[T] = U } } var pn = K({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Se(p, y) { if (y) { if (pn[p] && (y.children != null || y.dangerouslySetInnerHTML != null)) throw Error(n(137, p)); if (y.dangerouslySetInnerHTML != null) { if (y.children != null) throw Error(n(60)); if (typeof y.dangerouslySetInnerHTML != "object" || !("__html" in y.dangerouslySetInnerHTML)) throw Error(n(61)) } if (y.style != null && typeof y.style != "object") throw Error(n(62)) } } function Fe(p, y) { if (p.indexOf("-") === -1) return typeof y.is == "string"; switch (p) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var ht = null; function Ee(p) { return p = p.target || p.srcElement || window, p.correspondingUseElement && (p = p.correspondingUseElement), p.nodeType === 3 ? p.parentNode : p } var De = null, gt = null, Bt = null; function mt(p) { if (p = oc(p)) { if (typeof De != "function") throw Error(n(280)); var y = p.stateNode; y && (y = Rv(y), De(p.stateNode, p.type, y)) } } function ot(p) { gt ? Bt ? Bt.push(p) : Bt = [p] : gt = p } function it() { if (gt) { var p = gt, y = Bt; if (Bt = gt = null, mt(p), y) for (p = 0; p < y.length; p++)mt(y[p]) } } function Ft(p, y) { return p(y) } function un() { } var wn = !1; function wr(p, y, T) { if (wn) return p(y, T); wn = !0; try { return Ft(p, y, T) } finally { wn = !1, (gt !== null || Bt !== null) && (un(), it()) } } function Tr(p, y) { var T = p.stateNode; if (T === null) return null; var k = Rv(T); if (k === null) return null; T = k[y]; e: switch (y) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (k = !k.disabled) || (p = p.type, k = !(p === "button" || p === "input" || p === "select" || p === "textarea")), p = !k; break e; default: p = !1 }if (p) return null; if (T && typeof T != "function") throw Error(n(231, y, typeof T)); return T } var Ua = !1; if (o) try { var Vr = {}; Object.defineProperty(Vr, "passive", { get: function () { Ua = !0 } }), window.addEventListener("test", Vr, Vr), window.removeEventListener("test", Vr, Vr) } catch { Ua = !1 } function zi(p, y, T, k, U, W, le, we, Pe) { var qe = Array.prototype.slice.call(arguments, 3); try { y.apply(T, qe) } catch (wt) { this.onError(wt) } } var po = !1, ks = null, Zi = !1, Hn = null, Ql = { onError: function (p) { po = !0, ks = p } }; function Of(p, y, T, k, U, W, le, we, Pe) { po = !1, ks = null, zi.apply(Ql, arguments) } function ie(p, y, T, k, U, W, le, we, Pe) { if (Of.apply(this, arguments), po) { if (po) { var qe = ks; po = !1, ks = null } else throw Error(n(198)); Zi || (Zi = !0, Hn = qe) } } function ue(p) { var y = p, T = p; if (p.alternate) for (; y.return;)y = y.return; else { p = y; do y = p, (y.flags & 4098) !== 0 && (T = y.return), p = y.return; while (p) } return y.tag === 3 ? T : null } function Ne(p) { if (p.tag === 13) { var y = p.memoizedState; if (y === null && (p = p.alternate, p !== null && (y = p.memoizedState)), y !== null) return y.dehydrated } return null } function He(p) { if (ue(p) !== p) throw Error(n(188)) } function Qe(p) { var y = p.alternate; if (!y) { if (y = ue(p), y === null) throw Error(n(188)); return y !== p ? null : p } for (var T = p, k = y; ;) { var U = T.return; if (U === null) break; var W = U.alternate; if (W === null) { if (k = U.return, k !== null) { T = k; continue } break } if (U.child === W.child) { for (W = U.child; W;) { if (W === T) return He(U), p; if (W === k) return He(U), y; W = W.sibling } throw Error(n(188)) } if (T.return !== k.return) T = U, k = W; else { for (var le = !1, we = U.child; we;) { if (we === T) { le = !0, T = U, k = W; break } if (we === k) { le = !0, k = U, T = W; break } we = we.sibling } if (!le) { for (we = W.child; we;) { if (we === T) { le = !0, T = W, k = U; break } if (we === k) { le = !0, k = W, T = U; break } we = we.sibling } if (!le) throw Error(n(189)) } } if (T.alternate !== k) throw Error(n(190)) } if (T.tag !== 3) throw Error(n(188)); return T.stateNode.current === T ? p : y } function Je(p) { return p = Qe(p), p !== null ? Nt(p) : null } function Nt(p) { if (p.tag === 5 || p.tag === 6) return p; for (p = p.child; p !== null;) { var y = Nt(p); if (y !== null) return y; p = p.sibling } return null } var te = e.unstable_scheduleCallback, ye = e.unstable_cancelCallback, Me = e.unstable_shouldYield, Te = e.unstable_requestPaint, ge = e.unstable_now, at = e.unstable_getCurrentPriorityLevel, Ke = e.unstable_ImmediatePriority, st = e.unstable_UserBlockingPriority, ft = e.unstable_NormalPriority, At = e.unstable_LowPriority, $t = e.unstable_IdlePriority, Pt = null, kt = null; function Zt(p) { if (kt && typeof kt.onCommitFiberRoot == "function") try { kt.onCommitFiberRoot(Pt, p, void 0, (p.current.flags & 128) === 128) } catch { } } var tn = Math.clz32 ? Math.clz32 : Vt, _n = Math.log, nn = Math.LN2; function Vt(p) { return p >>>= 0, p === 0 ? 32 : 31 - (_n(p) / nn | 0) | 0 } var Vn = 64, bn = 4194304; function gr(p) { switch (p & -p) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return p & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return p & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return p } } function tr(p, y) { var T = p.pendingLanes; if (T === 0) return 0; var k = 0, U = p.suspendedLanes, W = p.pingedLanes, le = T & 268435455; if (le !== 0) { var we = le & ~U; we !== 0 ? k = gr(we) : (W &= le, W !== 0 && (k = gr(W))) } else le = T & ~U, le !== 0 ? k = gr(le) : W !== 0 && (k = gr(W)); if (k === 0) return 0; if (y !== 0 && y !== k && (y & U) === 0 && (U = k & -k, W = y & -y, U >= W || U === 16 && (W & 4194240) !== 0)) return y; if ((k & 4) !== 0 && (k |= T & 16), y = p.entangledLanes, y !== 0) for (p = p.entanglements, y &= k; 0 < y;)T = 31 - tn(y), U = 1 << T, k |= p[T], y &= ~U; return k } function Sr(p, y) { switch (p) { case 1: case 2: case 4: return y + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return y + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function vr(p, y) { for (var T = p.suspendedLanes, k = p.pingedLanes, U = p.expirationTimes, W = p.pendingLanes; 0 < W;) { var le = 31 - tn(W), we = 1 << le, Pe = U[le]; Pe === -1 ? ((we & T) === 0 || (we & k) !== 0) && (U[le] = Sr(we, y)) : Pe <= y && (p.expiredLanes |= we), W &= ~we } } function yn(p) { return p = p.pendingLanes & -1073741825, p !== 0 ? p : p & 1073741824 ? 1073741824 : 0 } function ur() { var p = Vn; return Vn <<= 1, (Vn & 4194240) === 0 && (Vn = 64), p } function di(p) { for (var y = [], T = 0; 31 > T; T++)y.push(p); return y } function yr(p, y, T) { p.pendingLanes |= y, y !== 536870912 && (p.suspendedLanes = 0, p.pingedLanes = 0), p = p.eventTimes, y = 31 - tn(y), p[y] = T } function ri(p, y) { var T = p.pendingLanes & ~y; p.pendingLanes = y, p.suspendedLanes = 0, p.pingedLanes = 0, p.expiredLanes &= y, p.mutableReadLanes &= y, p.entangledLanes &= y, y = p.entanglements; var k = p.eventTimes; for (p = p.expirationTimes; 0 < T;) { var U = 31 - tn(T), W = 1 << U; y[U] = 0, k[U] = -1, p[U] = -1, T &= ~W } } function yl(p, y) { var T = p.entangledLanes |= y; for (p = p.entanglements; T;) { var k = 31 - tn(T), U = 1 << k; U & y | p[k] & y && (p[k] |= y), T &= ~U } } var nr = 0; function Df(p) { return p &= -p, 1 < p ? 4 < p ? (p & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var Rp, J0, V_, ev, tv, ad = !1, nv = [], xl = null, sr = null, Jl = null, sd = new Map, Lf = new Map, eu = [], HP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Qi(p, y) { switch (p) { case "focusin": case "focusout": xl = null; break; case "dragenter": case "dragleave": sr = null; break; case "mouseover": case "mouseout": Jl = null; break; case "pointerover": case "pointerout": sd.delete(y.pointerId); break; case "gotpointercapture": case "lostpointercapture": Lf.delete(y.pointerId) } } function od(p, y, T, k, U, W) { return p === null || p.nativeEvent !== W ? (p = { blockedOn: y, domEventName: T, eventSystemFlags: k, nativeEvent: W, targetContainers: [U] }, y !== null && (y = oc(y), y !== null && J0(y)), p) : (p.eventSystemFlags |= k, y = p.targetContainers, U !== null && y.indexOf(U) === -1 && y.push(U), p) } function WP(p, y, T, k, U) { switch (y) { case "focusin": return xl = od(xl, p, y, T, k, U), !0; case "dragenter": return sr = od(sr, p, y, T, k, U), !0; case "mouseover": return Jl = od(Jl, p, y, T, k, U), !0; case "pointerover": var W = U.pointerId; return sd.set(W, od(sd.get(W) || null, p, y, T, k, U)), !0; case "gotpointercapture": return W = U.pointerId, Lf.set(W, od(Lf.get(W) || null, p, y, T, k, U)), !0 }return !1 } function rv(p) { var y = ou(p.target); if (y !== null) { var T = ue(y); if (T !== null) { if (y = T.tag, y === 13) { if (y = Ne(T), y !== null) { p.blockedOn = y, tv(p.priority, function () { V_(T) }); return } } else if (y === 3 && T.stateNode.current.memoizedState.isDehydrated) { p.blockedOn = T.tag === 3 ? T.stateNode.containerInfo : null; return } } } p.blockedOn = null } function iv(p) { if (p.blockedOn !== null) return !1; for (var y = p.targetContainers; 0 < y.length;) { var T = go(p.domEventName, p.eventSystemFlags, y[0], p.nativeEvent); if (T === null) { T = p.nativeEvent; var k = new T.constructor(T.type, T); ht = k, T.target.dispatchEvent(k), ht = null } else return y = oc(T), y !== null && J0(y), p.blockedOn = T, !1; y.shift() } return !0 } function kp(p, y, T) { iv(p) && T.delete(y) } function bl() { ad = !1, xl !== null && iv(xl) && (xl = null), sr !== null && iv(sr) && (sr = null), Jl !== null && iv(Jl) && (Jl = null), sd.forEach(kp), Lf.forEach(kp) } function Ip(p, y) { p.blockedOn === y && (p.blockedOn = null, ad || (ad = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, bl))) } function Op(p) { function y(U) { return Ip(U, p) } if (0 < nv.length) { Ip(nv[0], p); for (var T = 1; T < nv.length; T++) { var k = nv[T]; k.blockedOn === p && (k.blockedOn = null) } } for (xl !== null && Ip(xl, p), sr !== null && Ip(sr, p), Jl !== null && Ip(Jl, p), sd.forEach(y), Lf.forEach(y), T = 0; T < eu.length; T++)k = eu[T], k.blockedOn === p && (k.blockedOn = null); for (; 0 < eu.length && (T = eu[0], T.blockedOn === null);)rv(T), T.blockedOn === null && eu.shift() } var Qa = C.ReactCurrentBatchConfig, mo = !0; function av(p, y, T, k) { var U = nr, W = Qa.transition; Qa.transition = null; try { nr = 1, sv(p, y, T, k) } finally { nr = U, Qa.transition = W } } function eb(p, y, T, k) { var U = nr, W = Qa.transition; Qa.transition = null; try { nr = 4, sv(p, y, T, k) } finally { nr = U, Qa.transition = W } } function sv(p, y, T, k) { if (mo) { var U = go(p, y, T, k); if (U === null) Tv(p, y, k, ov, T), Qi(p, k); else if (WP(U, p, y, T, k)) k.stopPropagation(); else if (Qi(p, k), y & 4 && -1 < HP.indexOf(p)) { for (; U !== null;) { var W = oc(U); if (W !== null && Rp(W), W = go(p, y, T, k), W === null && Tv(p, y, k, ov, T), W === U) break; U = W } U !== null && k.stopPropagation() } else Tv(p, y, k, null, T) } } var ov = null; function go(p, y, T, k) { if (ov = null, p = Ee(k), p = ou(p), p !== null) if (y = ue(p), y === null) p = null; else if (T = y.tag, T === 13) { if (p = Ne(y), p !== null) return p; p = null } else if (T === 3) { if (y.stateNode.current.memoizedState.isDehydrated) return y.tag === 3 ? y.stateNode.containerInfo : null; p = null } else y !== p && (p = null); return ov = p, null } function H_(p) { switch (p) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (at()) { case Ke: return 1; case st: return 4; case ft: case At: return 16; case $t: return 536870912; default: return 16 }default: return 16 } } var Ho = null, tb = null, hs = null; function Dp() { if (hs) return hs; var p, y = tb, T = y.length, k, U = "value" in Ho ? Ho.value : Ho.textContent, W = U.length; for (p = 0; p < T && y[p] === U[p]; p++); var le = T - p; for (k = 1; k <= le && y[T - k] === U[W - k]; k++); return hs = U.slice(p, 1 < k ? 1 - k : void 0) } function ld(p) { var y = p.keyCode; return "charCode" in p ? (p = p.charCode, p === 0 && y === 13 && (p = 13)) : p = y, p === 10 && (p = 13), 32 <= p || p === 13 ? p : 0 } function ec() { return !0 } function lv() { return !1 } function Ja(p) { function y(T, k, U, W, le) { this._reactName = T, this._targetInst = U, this.type = k, this.nativeEvent = W, this.target = le, this.currentTarget = null; for (var we in p) p.hasOwnProperty(we) && (T = p[we], this[we] = T ? T(W) : W[we]); return this.isDefaultPrevented = (W.defaultPrevented != null ? W.defaultPrevented : W.returnValue === !1) ? ec : lv, this.isPropagationStopped = lv, this } return K(y.prototype, { preventDefault: function () { this.defaultPrevented = !0; var T = this.nativeEvent; T && (T.preventDefault ? T.preventDefault() : typeof T.returnValue != "unknown" && (T.returnValue = !1), this.isDefaultPrevented = ec) }, stopPropagation: function () { var T = this.nativeEvent; T && (T.stopPropagation ? T.stopPropagation() : typeof T.cancelBubble != "unknown" && (T.cancelBubble = !0), this.isPropagationStopped = ec) }, persist: function () { }, isPersistent: ec }), y } var cd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (p) { return p.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Lp = Ja(cd), ud = K({}, cd, { view: 0, detail: 0 }), Ff = Ja(ud), ps, vo, yo, Uf = K({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: nu, button: 0, buttons: 0, relatedTarget: function (p) { return p.relatedTarget === void 0 ? p.fromElement === p.srcElement ? p.toElement : p.fromElement : p.relatedTarget }, movementX: function (p) { return "movementX" in p ? p.movementX : (p !== yo && (yo && p.type === "mousemove" ? (ps = p.screenX - yo.screenX, vo = p.screenY - yo.screenY) : vo = ps = 0, yo = p), ps) }, movementY: function (p) { return "movementY" in p ? p.movementY : vo } }), nb = Ja(Uf), tc = K({}, Uf, { dataTransfer: 0 }), tu = Ja(tc), cv = K({}, ud, { relatedTarget: 0 }), uv = Ja(cv), dv = K({}, cd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), W_ = Ja(dv), G_ = K({}, cd, { clipboardData: function (p) { return "clipboardData" in p ? p.clipboardData : window.clipboardData } }), rb = Ja(G_), fv = K({}, cd, { data: 0 }), ib = Ja(fv), q_ = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, X_ = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, ab = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Bf(p) { var y = this.nativeEvent; return y.getModifierState ? y.getModifierState(p) : (p = ab[p]) ? !!y[p] : !1 } function nu() { return Bf } var hv = K({}, ud, { key: function (p) { if (p.key) { var y = q_[p.key] || p.key; if (y !== "Unidentified") return y } return p.type === "keypress" ? (p = ld(p), p === 13 ? "Enter" : String.fromCharCode(p)) : p.type === "keydown" || p.type === "keyup" ? X_[p.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: nu, charCode: function (p) { return p.type === "keypress" ? ld(p) : 0 }, keyCode: function (p) { return p.type === "keydown" || p.type === "keyup" ? p.keyCode : 0 }, which: function (p) { return p.type === "keypress" ? ld(p) : p.type === "keydown" || p.type === "keyup" ? p.keyCode : 0 } }), pv = Ja(hv), xo = K({}, Uf, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Is = Ja(xo), dd = K({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: nu }), nc = Ja(dd), rc = K({}, cd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), fd = Ja(rc), Y_ = K({}, Uf, { deltaX: function (p) { return "deltaX" in p ? p.deltaX : "wheelDeltaX" in p ? -p.wheelDeltaX : 0 }, deltaY: function (p) { return "deltaY" in p ? p.deltaY : "wheelDeltaY" in p ? -p.wheelDeltaY : "wheelDelta" in p ? -p.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), sb = Ja(Y_), ob = [9, 13, 27, 32], es = o && "CompositionEvent" in window, xa = null; o && "documentMode" in document && (xa = document.documentMode); var fi = o && "TextEvent" in window && !xa, $f = o && (!es || xa && 8 < xa && 11 >= xa), bo = " ", lb = !1; function cb(p, y) { switch (p) { case "keyup": return ob.indexOf(y.keyCode) !== -1; case "keydown": return y.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function mv(p) { return p = p.detail, typeof p == "object" && "data" in p ? p.data : null } var ru = !1; function K_(p, y) { switch (p) { case "compositionend": return mv(y); case "keypress": return y.which !== 32 ? null : (lb = !0, bo); case "textInput": return p = y.data, p === bo && lb ? null : p; default: return null } } function Fp(p, y) { if (ru) return p === "compositionend" || !es && cb(p, y) ? (p = Dp(), hs = tb = Ho = null, ru = !1, p) : null; switch (p) { case "paste": return null; case "keypress": if (!(y.ctrlKey || y.altKey || y.metaKey) || y.ctrlKey && y.altKey) { if (y.char && 1 < y.char.length) return y.char; if (y.which) return String.fromCharCode(y.which) } return null; case "compositionend": return $f && y.locale !== "ko" ? null : y.data; default: return null } } var zf = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function gv(p) { var y = p && p.nodeName && p.nodeName.toLowerCase(); return y === "input" ? !!zf[p.type] : y === "textarea" } function Vf(p, y, T, k) { ot(k), y = Cv(y, "onChange"), 0 < y.length && (T = new Lp("onChange", "change", null, T, k), p.push({ event: T, listeners: y })) } var iu = null, Hf = null; function Z_(p) { Xf(p, 0) } function ic(p) { var y = Ii(p); if (fe(y)) return p } function Q_(p, y) { if (p === "change") return y } var Wf = !1; if (o) { var ms; if (o) { var hd = "oninput" in document; if (!hd) { var pd = document.createElement("div"); pd.setAttribute("oninput", "return;"), hd = typeof pd.oninput == "function" } ms = hd } else ms = !1; Wf = ms && (!document.documentMode || 9 < document.documentMode) } function Wo() { iu && (iu.detachEvent("onpropertychange", vv), Hf = iu = null) } function vv(p) { if (p.propertyName === "value" && ic(Hf)) { var y = []; Vf(y, Hf, p, Ee(p)), wr(Z_, y) } } function Gf(p, y, T) { p === "focusin" ? (Wo(), iu = y, Hf = T, iu.attachEvent("onpropertychange", vv)) : p === "focusout" && Wo() } function J_(p) { if (p === "selectionchange" || p === "keyup" || p === "keydown") return ic(Hf) } function ub(p, y) { if (p === "click") return ic(y) } function Si(p, y) { if (p === "input" || p === "change") return ic(y) } function yv(p, y) { return p === y && (p !== 0 || 1 / p === 1 / y) || p !== p && y !== y } var Os = typeof Object.is == "function" ? Object.is : yv; function md(p, y) { if (Os(p, y)) return !0; if (typeof p != "object" || p === null || typeof y != "object" || y === null) return !1; var T = Object.keys(p), k = Object.keys(y); if (T.length !== k.length) return !1; for (k = 0; k < T.length; k++) { var U = T[k]; if (!c.call(y, U) || !Os(p[U], y[U])) return !1 } return !0 } function Up(p) { for (; p && p.firstChild;)p = p.firstChild; return p } function Ds(p, y) { var T = Up(p); p = 0; for (var k; T;) { if (T.nodeType === 3) { if (k = p + T.textContent.length, p <= y && k >= y) return { node: T, offset: y - p }; p = k } e: { for (; T;) { if (T.nextSibling) { T = T.nextSibling; break e } T = T.parentNode } T = void 0 } T = Up(T) } } function gd(p, y) { return p && y ? p === y ? !0 : p && p.nodeType === 3 ? !1 : y && y.nodeType === 3 ? gd(p, y.parentNode) : "contains" in p ? p.contains(y) : p.compareDocumentPosition ? !!(p.compareDocumentPosition(y) & 16) : !1 : !1 } function _i() { for (var p = window, y = oe(); y instanceof p.HTMLIFrameElement;) { try { var T = typeof y.contentWindow.location.href == "string" } catch { T = !1 } if (T) p = y.contentWindow; else break; y = oe(p.document) } return y } function la(p) { var y = p && p.nodeName && p.nodeName.toLowerCase(); return y && (y === "input" && (p.type === "text" || p.type === "search" || p.type === "tel" || p.type === "url" || p.type === "password") || y === "textarea" || p.contentEditable === "true") } function ca(p) { var y = _i(), T = p.focusedElem, k = p.selectionRange; if (y !== T && T && T.ownerDocument && gd(T.ownerDocument.documentElement, T)) { if (k !== null && la(T)) { if (y = k.start, p = k.end, p === void 0 && (p = y), "selectionStart" in T) T.selectionStart = y, T.selectionEnd = Math.min(p, T.value.length); else if (p = (y = T.ownerDocument || document) && y.defaultView || window, p.getSelection) { p = p.getSelection(); var U = T.textContent.length, W = Math.min(k.start, U); k = k.end === void 0 ? W : Math.min(k.end, U), !p.extend && W > k && (U = k, k = W, W = U), U = Ds(T, W); var le = Ds(T, k); U && le && (p.rangeCount !== 1 || p.anchorNode !== U.node || p.anchorOffset !== U.offset || p.focusNode !== le.node || p.focusOffset !== le.offset) && (y = y.createRange(), y.setStart(U.node, U.offset), p.removeAllRanges(), W > k ? (p.addRange(y), p.extend(le.node, le.offset)) : (y.setEnd(le.node, le.offset), p.addRange(y))) } } for (y = [], p = T; p = p.parentNode;)p.nodeType === 1 && y.push({ element: p, left: p.scrollLeft, top: p.scrollTop }); for (typeof T.focus == "function" && T.focus(), T = 0; T < y.length; T++)p = y[T], p.element.scrollLeft = p.left, p.element.scrollTop = p.top } } var xv = o && "documentMode" in document && 11 >= document.documentMode, wl = null, vd = null, Bp = null, ua = !1; function bv(p, y, T) { var k = T.window === T ? T.document : T.nodeType === 9 ? T : T.ownerDocument; ua || wl == null || wl !== oe(k) || (k = wl, "selectionStart" in k && la(k) ? k = { start: k.selectionStart, end: k.selectionEnd } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = { anchorNode: k.anchorNode, anchorOffset: k.anchorOffset, focusNode: k.focusNode, focusOffset: k.focusOffset }), Bp && md(Bp, k) || (Bp = k, k = Cv(vd, "onSelect"), 0 < k.length && (y = new Lp("onSelect", "select", null, y, T), p.push({ event: y, listeners: k }), y.target = wl))) } function qf(p, y) { var T = {}; return T[p.toLowerCase()] = y.toLowerCase(), T["Webkit" + p] = "webkit" + y, T["Moz" + p] = "moz" + y, T } var au = { animationend: qf("Animation", "AnimationEnd"), animationiteration: qf("Animation", "AnimationIteration"), animationstart: qf("Animation", "AnimationStart"), transitionend: qf("Transition", "TransitionEnd") }, Go = {}, qo = {}; o && (qo = document.createElement("div").style, "AnimationEvent" in window || (delete au.animationend.animation, delete au.animationiteration.animation, delete au.animationstart.animation), "TransitionEvent" in window || delete au.transitionend.transition); function Sl(p) { if (Go[p]) return Go[p]; if (!au[p]) return p; var y = au[p], T; for (T in y) if (y.hasOwnProperty(T) && T in qo) return Go[p] = y[T]; return p } var $p = Sl("animationend"), zp = Sl("animationiteration"), db = Sl("animationstart"), fb = Sl("transitionend"), hb = new Map, pb = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ac(p, y) { hb.set(p, y), a(y, [p]) } for (var wv = 0; wv < pb.length; wv++) { var Vp = pb[wv], Hp = Vp.toLowerCase(), eE = Vp[0].toUpperCase() + Vp.slice(1); ac(Hp, "on" + eE) } ac($p, "onAnimationEnd"), ac(zp, "onAnimationIteration"), ac(db, "onAnimationStart"), ac("dblclick", "onDoubleClick"), ac("focusin", "onFocus"), ac("focusout", "onBlur"), ac(fb, "onTransitionEnd"), s("onMouseEnter", ["mouseout", "mouseover"]), s("onMouseLeave", ["mouseout", "mouseover"]), s("onPointerEnter", ["pointerout", "pointerover"]), s("onPointerLeave", ["pointerout", "pointerover"]), a("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), a("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), a("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), a("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var su = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Sv = new Set("cancel close invalid load scroll toggle".split(" ").concat(su)); function _v(p, y, T) { var k = p.type || "unknown-event"; p.currentTarget = T, ie(k, y, void 0, p), p.currentTarget = null } function Xf(p, y) { y = (y & 4) !== 0; for (var T = 0; T < p.length; T++) { var k = p[T], U = k.event; k = k.listeners; e: { var W = void 0; if (y) for (var le = k.length - 1; 0 <= le; le--) { var we = k[le], Pe = we.instance, qe = we.currentTarget; if (we = we.listener, Pe !== W && U.isPropagationStopped()) break e; _v(U, we, qe), W = Pe } else for (le = 0; le < k.length; le++) { if (we = k[le], Pe = we.instance, qe = we.currentTarget, we = we.listener, Pe !== W && U.isPropagationStopped()) break e; _v(U, we, qe), W = Pe } } } if (Zi) throw p = Hn, Zi = !1, Hn = null, p } function Kr(p, y) { var T = y[bd]; T === void 0 && (T = y[bd] = new Set); var k = p + "__bubble"; T.has(k) || (Mv(y, p, 2, !1), T.add(k)) } function Ev(p, y, T) { var k = 0; y && (k |= 4), Mv(T, p, k, y) } var Wp = "_reactListening" + Math.random().toString(36).slice(2); function Yf(p) { if (!p[Wp]) { p[Wp] = !0, r.forEach(function (T) { T !== "selectionchange" && (Sv.has(T) || Ev(T, !1, p), Ev(T, !0, p)) }); var y = p.nodeType === 9 ? p : p.ownerDocument; y === null || y[Wp] || (y[Wp] = !0, Ev("selectionchange", !1, y)) } } function Mv(p, y, T, k) { switch (H_(y)) { case 1: var U = av; break; case 4: U = eb; break; default: U = sv }T = U.bind(null, y, T, p), U = void 0, !Ua || y !== "touchstart" && y !== "touchmove" && y !== "wheel" || (U = !0), k ? U !== void 0 ? p.addEventListener(y, T, { capture: !0, passive: U }) : p.addEventListener(y, T, !0) : U !== void 0 ? p.addEventListener(y, T, { passive: U }) : p.addEventListener(y, T, !1) } function Tv(p, y, T, k, U) { var W = k; if ((y & 1) === 0 && (y & 2) === 0 && k !== null) e: for (; ;) { if (k === null) return; var le = k.tag; if (le === 3 || le === 4) { var we = k.stateNode.containerInfo; if (we === U || we.nodeType === 8 && we.parentNode === U) break; if (le === 4) for (le = k.return; le !== null;) { var Pe = le.tag; if ((Pe === 3 || Pe === 4) && (Pe = le.stateNode.containerInfo, Pe === U || Pe.nodeType === 8 && Pe.parentNode === U)) return; le = le.return } for (; we !== null;) { if (le = ou(we), le === null) return; if (Pe = le.tag, Pe === 5 || Pe === 6) { k = W = le; continue e } we = we.parentNode } } k = k.return } wr(function () { var qe = W, wt = Ee(T), Ct = []; e: { var xt = hb.get(p); if (xt !== void 0) { var rn = Lp, dn = p; switch (p) { case "keypress": if (ld(T) === 0) break e; case "keydown": case "keyup": rn = pv; break; case "focusin": dn = "focus", rn = uv; break; case "focusout": dn = "blur", rn = uv; break; case "beforeblur": case "afterblur": rn = uv; break; case "click": if (T.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": rn = nb; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": rn = tu; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": rn = nc; break; case $p: case zp: case db: rn = W_; break; case fb: rn = fd; break; case "scroll": rn = Ff; break; case "wheel": rn = sb; break; case "copy": case "cut": case "paste": rn = rb; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": rn = Is }var mn = (y & 4) !== 0, ea = !mn && p === "scroll", Be = mn ? xt !== null ? xt + "Capture" : null : xt; mn = []; for (var Ie = qe, ze; Ie !== null;) { ze = Ie; var Ut = ze.stateNode; if (ze.tag === 5 && Ut !== null && (ze = Ut, Be !== null && (Ut = Tr(Ie, Be), Ut != null && mn.push(Kf(Ie, Ut, ze)))), ea) break; Ie = Ie.return } 0 < mn.length && (xt = new rn(xt, dn, null, T, wt), Ct.push({ event: xt, listeners: mn })) } } if ((y & 7) === 0) { e: { if (xt = p === "mouseover" || p === "pointerover", rn = p === "mouseout" || p === "pointerout", xt && T !== ht && (dn = T.relatedTarget || T.fromElement) && (ou(dn) || dn[Ls])) break e; if ((rn || xt) && (xt = wt.window === wt ? wt : (xt = wt.ownerDocument) ? xt.defaultView || xt.parentWindow : window, rn ? (dn = T.relatedTarget || T.toElement, rn = qe, dn = dn ? ou(dn) : null, dn !== null && (ea = ue(dn), dn !== ea || dn.tag !== 5 && dn.tag !== 6) && (dn = null)) : (rn = null, dn = qe), rn !== dn)) { if (mn = nb, Ut = "onMouseLeave", Be = "onMouseEnter", Ie = "mouse", (p === "pointerout" || p === "pointerover") && (mn = Is, Ut = "onPointerLeave", Be = "onPointerEnter", Ie = "pointer"), ea = rn == null ? xt : Ii(rn), ze = dn == null ? xt : Ii(dn), xt = new mn(Ut, Ie + "leave", rn, T, wt), xt.target = ea, xt.relatedTarget = ze, Ut = null, ou(wt) === qe && (mn = new mn(Be, Ie + "enter", dn, T, wt), mn.target = ze, mn.relatedTarget = ea, Ut = mn), ea = Ut, rn && dn) t: { for (mn = rn, Be = dn, Ie = 0, ze = mn; ze; ze = yd(ze))Ie++; for (ze = 0, Ut = Be; Ut; Ut = yd(Ut))ze++; for (; 0 < Ie - ze;)mn = yd(mn), Ie--; for (; 0 < ze - Ie;)Be = yd(Be), ze--; for (; Ie--;) { if (mn === Be || Be !== null && mn === Be.alternate) break t; mn = yd(mn), Be = yd(Be) } mn = null } else mn = null; rn !== null && tE(Ct, xt, rn, mn, !1), dn !== null && ea !== null && tE(Ct, ea, dn, mn, !0) } } e: { if (xt = qe ? Ii(qe) : window, rn = xt.nodeName && xt.nodeName.toLowerCase(), rn === "select" || rn === "input" && xt.type === "file") var xn = Q_; else if (gv(xt)) if (Wf) xn = Si; else { xn = J_; var Tn = Gf } else (rn = xt.nodeName) && rn.toLowerCase() === "input" && (xt.type === "checkbox" || xt.type === "radio") && (xn = ub); if (xn && (xn = xn(p, qe))) { Vf(Ct, xn, T, wt); break e } Tn && Tn(p, xt, qe), p === "focusout" && (Tn = xt._wrapperState) && Tn.controlled && xt.type === "number" && Xe(xt, "number", xt.value) } switch (Tn = qe ? Ii(qe) : window, p) { case "focusin": (gv(Tn) || Tn.contentEditable === "true") && (wl = Tn, vd = qe, Bp = null); break; case "focusout": Bp = vd = wl = null; break; case "mousedown": ua = !0; break; case "contextmenu": case "mouseup": case "dragend": ua = !1, bv(Ct, T, wt); break; case "selectionchange": if (xv) break; case "keydown": case "keyup": bv(Ct, T, wt) }var Cn; if (es) e: { switch (p) { case "compositionstart": var Un = "onCompositionStart"; break e; case "compositionend": Un = "onCompositionEnd"; break e; case "compositionupdate": Un = "onCompositionUpdate"; break e }Un = void 0 } else ru ? cb(p, T) && (Un = "onCompositionEnd") : p === "keydown" && T.keyCode === 229 && (Un = "onCompositionStart"); Un && ($f && T.locale !== "ko" && (ru || Un !== "onCompositionStart" ? Un === "onCompositionEnd" && ru && (Cn = Dp()) : (Ho = wt, tb = "value" in Ho ? Ho.value : Ho.textContent, ru = !0)), Tn = Cv(qe, Un), 0 < Tn.length && (Un = new ib(Un, p, null, T, wt), Ct.push({ event: Un, listeners: Tn }), Cn ? Un.data = Cn : (Cn = mv(T), Cn !== null && (Un.data = Cn)))), (Cn = fi ? K_(p, T) : Fp(p, T)) && (qe = Cv(qe, "onBeforeInput"), 0 < qe.length && (wt = new ib("onBeforeInput", "beforeinput", null, T, wt), Ct.push({ event: wt, listeners: qe }), wt.data = Cn)) } Xf(Ct, y) }) } function Kf(p, y, T) { return { instance: p, listener: y, currentTarget: T } } function Cv(p, y) { for (var T = y + "Capture", k = []; p !== null;) { var U = p, W = U.stateNode; U.tag === 5 && W !== null && (U = W, W = Tr(p, T), W != null && k.unshift(Kf(p, W, U)), W = Tr(p, y), W != null && k.push(Kf(p, W, U))), p = p.return } return k } function yd(p) { if (p === null) return null; do p = p.return; while (p && p.tag !== 5); return p || null } function tE(p, y, T, k, U) { for (var W = y._reactName, le = []; T !== null && T !== k;) { var we = T, Pe = we.alternate, qe = we.stateNode; if (Pe !== null && Pe === k) break; we.tag === 5 && qe !== null && (we = qe, U ? (Pe = Tr(T, W), Pe != null && le.unshift(Kf(T, Pe, we))) : U || (Pe = Tr(T, W), Pe != null && le.push(Kf(T, Pe, we)))), T = T.return } le.length !== 0 && p.push({ event: y, listeners: le }) } var GP = /\r\n?/g, nE = /\u0000|\uFFFD/g; function mb(p) {
		return (typeof p == "string" ? p : "" + p).replace(GP, `
`).replace(nE, "")
	} function Gp(p, y, T) { if (y = mb(y), mb(p) !== y && T) throw Error(n(425)) } function qp() { } var Zf = null, gb = null; function vb(p, y) { return p === "textarea" || p === "noscript" || typeof y.children == "string" || typeof y.children == "number" || typeof y.dangerouslySetInnerHTML == "object" && y.dangerouslySetInnerHTML !== null && y.dangerouslySetInnerHTML.__html != null } var yb = typeof setTimeout == "function" ? setTimeout : void 0, xb = typeof clearTimeout == "function" ? clearTimeout : void 0, Nv = typeof Promise == "function" ? Promise : void 0, qP = typeof queueMicrotask == "function" ? queueMicrotask : typeof Nv < "u" ? function (p) { return Nv.resolve(null).then(p).catch(rE) } : yb; function rE(p) { setTimeout(function () { throw p }) } function Av(p, y) { var T = y, k = 0; do { var U = T.nextSibling; if (p.removeChild(T), U && U.nodeType === 8) if (T = U.data, T === "/$") { if (k === 0) { p.removeChild(U), Op(y); return } k-- } else T !== "$" && T !== "$?" && T !== "$!" || k++; T = U } while (T); Op(y) } function sc(p) { for (; p != null; p = p.nextSibling) { var y = p.nodeType; if (y === 1 || y === 3) break; if (y === 8) { if (y = p.data, y === "$" || y === "$!" || y === "$?") break; if (y === "/$") return null } } return p } function bb(p) { p = p.previousSibling; for (var y = 0; p;) { if (p.nodeType === 8) { var T = p.data; if (T === "$" || T === "$!" || T === "$?") { if (y === 0) return p; y-- } else T === "/$" && y++ } p = p.previousSibling } return null } var xd = Math.random().toString(36).slice(2), Ji = "__reactFiber$" + xd, Qf = "__reactProps$" + xd, Ls = "__reactContainer$" + xd, bd = "__reactEvents$" + xd, Pv = "__reactListeners$" + xd, jv = "__reactHandles$" + xd; function ou(p) { var y = p[Ji]; if (y) return y; for (var T = p.parentNode; T;) { if (y = T[Ls] || T[Ji]) { if (T = y.alternate, y.child !== null || T !== null && T.child !== null) for (p = bb(p); p !== null;) { if (T = p[Ji]) return T; p = bb(p) } return y } p = T, T = p.parentNode } return null } function oc(p) { return p = p[Ji] || p[Ls], !p || p.tag !== 5 && p.tag !== 6 && p.tag !== 13 && p.tag !== 3 ? null : p } function Ii(p) { if (p.tag === 5 || p.tag === 6) return p.stateNode; throw Error(n(33)) } function Rv(p) { return p[Qf] || null } var wb = [], da = -1; function Ni(p) { return { current: p } } function Zr(p) { 0 > da || (p.current = wb[da], wb[da] = null, da--) } function Hr(p, y) { da++, wb[da] = p.current, p.current = y } var lc = {}, ba = Ni(lc), ts = Ni(!1), cc = lc; function wd(p, y) { var T = p.type.contextTypes; if (!T) return lc; var k = p.stateNode; if (k && k.__reactInternalMemoizedUnmaskedChildContext === y) return k.__reactInternalMemoizedMaskedChildContext; var U = {}, W; for (W in T) U[W] = y[W]; return k && (p = p.stateNode, p.__reactInternalMemoizedUnmaskedChildContext = y, p.__reactInternalMemoizedMaskedChildContext = U), U } function Ba(p) { return p = p.childContextTypes, p != null } function Xp() { Zr(ts), Zr(ba) } function Sb(p, y, T) { if (ba.current !== lc) throw Error(n(168)); Hr(ba, y), Hr(ts, T) } function Yp(p, y, T) { var k = p.stateNode; if (y = y.childContextTypes, typeof k.getChildContext != "function") return T; k = k.getChildContext(); for (var U in k) if (!(U in y)) throw Error(n(108, ae(p) || "Unknown", U)); return K({}, T, k) } function Sd(p) { return p = (p = p.stateNode) && p.__reactInternalMemoizedMergedChildContext || lc, cc = ba.current, Hr(ba, p), Hr(ts, ts.current), !0 } function _b(p, y, T) { var k = p.stateNode; if (!k) throw Error(n(169)); T ? (p = Yp(p, y, cc), k.__reactInternalMemoizedMergedChildContext = p, Zr(ts), Zr(ba), Hr(ba, p)) : Zr(ts), Hr(ts, T) } var Xo = null, Kp = !1, kv = !1; function Zp(p) { Xo === null ? Xo = [p] : Xo.push(p) } function iE(p) { Kp = !0, Zp(p) } function _l() { if (!kv && Xo !== null) { kv = !0; var p = 0, y = nr; try { var T = Xo; for (nr = 1; p < T.length; p++) { var k = T[p]; do k = k(!0); while (k !== null) } Xo = null, Kp = !1 } catch (U) { throw Xo !== null && (Xo = Xo.slice(p + 1)), te(Ke, _l), U } finally { nr = y, kv = !1 } } return null } var _d = [], gs = 0, Iv = null, Ov = 0, ns = [], fa = 0, Ed = null, zt = 1, wo = ""; function uc(p, y) { _d[gs++] = Ov, _d[gs++] = Iv, Iv = p, Ov = y } function Eb(p, y, T) { ns[fa++] = zt, ns[fa++] = wo, ns[fa++] = Ed, Ed = p; var k = zt; p = wo; var U = 32 - tn(k) - 1; k &= ~(1 << U), T += 1; var W = 32 - tn(y) + U; if (30 < W) { var le = U - U % 5; W = (k & (1 << le) - 1).toString(32), k >>= le, U -= le, zt = 1 << 32 - tn(y) + U | T << U | k, wo = W + p } else zt = 1 << W | T << U | k, wo = p } function Mb(p) { p.return !== null && (uc(p, 1), Eb(p, 1, 0)) } function dc(p) { for (; p === Iv;)Iv = _d[--gs], _d[gs] = null, Ov = _d[--gs], _d[gs] = null; for (; p === Ed;)Ed = ns[--fa], ns[fa] = null, wo = ns[--fa], ns[fa] = null, zt = ns[--fa], ns[fa] = null } var wa = null, rs = null, ii = !1, So = null; function Tb(p, y) { var T = Nl(5, null, null, 0); T.elementType = "DELETED", T.stateNode = y, T.return = p, y = p.deletions, y === null ? (p.deletions = [T], p.flags |= 16) : y.push(T) } function Cb(p, y) { switch (p.tag) { case 5: var T = p.type; return y = y.nodeType !== 1 || T.toLowerCase() !== y.nodeName.toLowerCase() ? null : y, y !== null ? (p.stateNode = y, wa = p, rs = sc(y.firstChild), !0) : !1; case 6: return y = p.pendingProps === "" || y.nodeType !== 3 ? null : y, y !== null ? (p.stateNode = y, wa = p, rs = null, !0) : !1; case 13: return y = y.nodeType !== 8 ? null : y, y !== null ? (T = Ed !== null ? { id: zt, overflow: wo } : null, p.memoizedState = { dehydrated: y, treeContext: T, retryLane: 1073741824 }, T = Nl(18, null, null, 0), T.stateNode = y, T.return = p, p.child = T, wa = p, rs = null, !0) : !1; default: return !1 } } function Dv(p) { return (p.mode & 1) !== 0 && (p.flags & 128) === 0 } function Lv(p) { if (ii) { var y = rs; if (y) { var T = y; if (!Cb(p, y)) { if (Dv(p)) throw Error(n(418)); y = sc(T.nextSibling); var k = wa; y && Cb(p, y) ? Tb(k, T) : (p.flags = p.flags & -4097 | 2, ii = !1, wa = p) } } else { if (Dv(p)) throw Error(n(418)); p.flags = p.flags & -4097 | 2, ii = !1, wa = p } } } function Fv(p) { for (p = p.return; p !== null && p.tag !== 5 && p.tag !== 3 && p.tag !== 13;)p = p.return; wa = p } function Jf(p) { if (p !== wa) return !1; if (!ii) return Fv(p), ii = !0, !1; var y; if ((y = p.tag !== 3) && !(y = p.tag !== 5) && (y = p.type, y = y !== "head" && y !== "body" && !vb(p.type, p.memoizedProps)), y && (y = rs)) { if (Dv(p)) throw Nb(), Error(n(418)); for (; y;)Tb(p, y), y = sc(y.nextSibling) } if (Fv(p), p.tag === 13) { if (p = p.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(n(317)); e: { for (p = p.nextSibling, y = 0; p;) { if (p.nodeType === 8) { var T = p.data; if (T === "/$") { if (y === 0) { rs = sc(p.nextSibling); break e } y-- } else T !== "$" && T !== "$!" && T !== "$?" || y++ } p = p.nextSibling } rs = null } } else rs = wa ? sc(p.stateNode.nextSibling) : null; return !0 } function Nb() { for (var p = rs; p;)p = sc(p.nextSibling) } function lu() { rs = wa = null, ii = !1 } function eh(p) { So === null ? So = [p] : So.push(p) } var XP = C.ReactCurrentBatchConfig; function Qp(p, y, T) { if (p = T.ref, p !== null && typeof p != "function" && typeof p != "object") { if (T._owner) { if (T = T._owner, T) { if (T.tag !== 1) throw Error(n(309)); var k = T.stateNode } if (!k) throw Error(n(147, p)); var U = k, W = "" + p; return y !== null && y.ref !== null && typeof y.ref == "function" && y.ref._stringRef === W ? y.ref : (y = function (le) { var we = U.refs; le === null ? delete we[W] : we[W] = le }, y._stringRef = W, y) } if (typeof p != "string") throw Error(n(284)); if (!T._owner) throw Error(n(290, p)) } return p } function Jp(p, y) { throw p = Object.prototype.toString.call(y), Error(n(31, p === "[object Object]" ? "object with keys {" + Object.keys(y).join(", ") + "}" : p)) } function Ab(p) { var y = p._init; return y(p._payload) } function Pb(p) { function y(Be, Ie) { if (p) { var ze = Be.deletions; ze === null ? (Be.deletions = [Ie], Be.flags |= 16) : ze.push(Ie) } } function T(Be, Ie) { if (!p) return null; for (; Ie !== null;)y(Be, Ie), Ie = Ie.sibling; return null } function k(Be, Ie) { for (Be = new Map; Ie !== null;)Ie.key !== null ? Be.set(Ie.key, Ie) : Be.set(Ie.index, Ie), Ie = Ie.sibling; return Be } function U(Be, Ie) { return Be = dh(Be, Ie), Be.index = 0, Be.sibling = null, Be } function W(Be, Ie, ze) { return Be.index = ze, p ? (ze = Be.alternate, ze !== null ? (ze = ze.index, ze < Ie ? (Be.flags |= 2, Ie) : ze) : (Be.flags |= 2, Ie)) : (Be.flags |= 1048576, Ie) } function le(Be) { return p && Be.alternate === null && (Be.flags |= 2), Be } function we(Be, Ie, ze, Ut) { return Ie === null || Ie.tag !== 6 ? (Ie = hj(ze, Be.mode, Ut), Ie.return = Be, Ie) : (Ie = U(Ie, ze), Ie.return = Be, Ie) } function Pe(Be, Ie, ze, Ut) { var xn = ze.type; return xn === j ? wt(Be, Ie, ze.props.children, Ut, ze.key) : Ie !== null && (Ie.elementType === xn || typeof xn == "object" && xn !== null && xn.$$typeof === Y && Ab(xn) === Ie.type) ? (Ut = U(Ie, ze.props), Ut.ref = Qp(Be, Ie, ze), Ut.return = Be, Ut) : (Ut = CE(ze.type, ze.key, ze.props, null, Be.mode, Ut), Ut.ref = Qp(Be, Ie, ze), Ut.return = Be, Ut) } function qe(Be, Ie, ze, Ut) { return Ie === null || Ie.tag !== 4 || Ie.stateNode.containerInfo !== ze.containerInfo || Ie.stateNode.implementation !== ze.implementation ? (Ie = pj(ze, Be.mode, Ut), Ie.return = Be, Ie) : (Ie = U(Ie, ze.children || []), Ie.return = Be, Ie) } function wt(Be, Ie, ze, Ut, xn) { return Ie === null || Ie.tag !== 7 ? (Ie = gm(ze, Be.mode, Ut, xn), Ie.return = Be, Ie) : (Ie = U(Ie, ze), Ie.return = Be, Ie) } function Ct(Be, Ie, ze) { if (typeof Ie == "string" && Ie !== "" || typeof Ie == "number") return Ie = hj("" + Ie, Be.mode, ze), Ie.return = Be, Ie; if (typeof Ie == "object" && Ie !== null) { switch (Ie.$$typeof) { case N: return ze = CE(Ie.type, Ie.key, Ie.props, null, Be.mode, ze), ze.ref = Qp(Be, null, Ie), ze.return = Be, ze; case A: return Ie = pj(Ie, Be.mode, ze), Ie.return = Be, Ie; case Y: var Ut = Ie._init; return Ct(Be, Ut(Ie._payload), ze) }if (nt(Ie) || V(Ie)) return Ie = gm(Ie, Be.mode, ze, null), Ie.return = Be, Ie; Jp(Be, Ie) } return null } function xt(Be, Ie, ze, Ut) { var xn = Ie !== null ? Ie.key : null; if (typeof ze == "string" && ze !== "" || typeof ze == "number") return xn !== null ? null : we(Be, Ie, "" + ze, Ut); if (typeof ze == "object" && ze !== null) { switch (ze.$$typeof) { case N: return ze.key === xn ? Pe(Be, Ie, ze, Ut) : null; case A: return ze.key === xn ? qe(Be, Ie, ze, Ut) : null; case Y: return xn = ze._init, xt(Be, Ie, xn(ze._payload), Ut) }if (nt(ze) || V(ze)) return xn !== null ? null : wt(Be, Ie, ze, Ut, null); Jp(Be, ze) } return null } function rn(Be, Ie, ze, Ut, xn) { if (typeof Ut == "string" && Ut !== "" || typeof Ut == "number") return Be = Be.get(ze) || null, we(Ie, Be, "" + Ut, xn); if (typeof Ut == "object" && Ut !== null) { switch (Ut.$$typeof) { case N: return Be = Be.get(Ut.key === null ? ze : Ut.key) || null, Pe(Ie, Be, Ut, xn); case A: return Be = Be.get(Ut.key === null ? ze : Ut.key) || null, qe(Ie, Be, Ut, xn); case Y: var Tn = Ut._init; return rn(Be, Ie, ze, Tn(Ut._payload), xn) }if (nt(Ut) || V(Ut)) return Be = Be.get(ze) || null, wt(Ie, Be, Ut, xn, null); Jp(Ie, Ut) } return null } function dn(Be, Ie, ze, Ut) { for (var xn = null, Tn = null, Cn = Ie, Un = Ie = 0, Ha = null; Cn !== null && Un < ze.length; Un++) { Cn.index > Un ? (Ha = Cn, Cn = null) : Ha = Cn.sibling; var Ir = xt(Be, Cn, ze[Un], Ut); if (Ir === null) { Cn === null && (Cn = Ha); break } p && Cn && Ir.alternate === null && y(Be, Cn), Ie = W(Ir, Ie, Un), Tn === null ? xn = Ir : Tn.sibling = Ir, Tn = Ir, Cn = Ha } if (Un === ze.length) return T(Be, Cn), ii && uc(Be, Un), xn; if (Cn === null) { for (; Un < ze.length; Un++)Cn = Ct(Be, ze[Un], Ut), Cn !== null && (Ie = W(Cn, Ie, Un), Tn === null ? xn = Cn : Tn.sibling = Cn, Tn = Cn); return ii && uc(Be, Un), xn } for (Cn = k(Be, Cn); Un < ze.length; Un++)Ha = rn(Cn, Be, Un, ze[Un], Ut), Ha !== null && (p && Ha.alternate !== null && Cn.delete(Ha.key === null ? Un : Ha.key), Ie = W(Ha, Ie, Un), Tn === null ? xn = Ha : Tn.sibling = Ha, Tn = Ha); return p && Cn.forEach(function (fh) { return y(Be, fh) }), ii && uc(Be, Un), xn } function mn(Be, Ie, ze, Ut) { var xn = V(ze); if (typeof xn != "function") throw Error(n(150)); if (ze = xn.call(ze), ze == null) throw Error(n(151)); for (var Tn = xn = null, Cn = Ie, Un = Ie = 0, Ha = null, Ir = ze.next(); Cn !== null && !Ir.done; Un++, Ir = ze.next()) { Cn.index > Un ? (Ha = Cn, Cn = null) : Ha = Cn.sibling; var fh = xt(Be, Cn, Ir.value, Ut); if (fh === null) { Cn === null && (Cn = Ha); break } p && Cn && fh.alternate === null && y(Be, Cn), Ie = W(fh, Ie, Un), Tn === null ? xn = fh : Tn.sibling = fh, Tn = fh, Cn = Ha } if (Ir.done) return T(Be, Cn), ii && uc(Be, Un), xn; if (Cn === null) { for (; !Ir.done; Un++, Ir = ze.next())Ir = Ct(Be, Ir.value, Ut), Ir !== null && (Ie = W(Ir, Ie, Un), Tn === null ? xn = Ir : Tn.sibling = Ir, Tn = Ir); return ii && uc(Be, Un), xn } for (Cn = k(Be, Cn); !Ir.done; Un++, Ir = ze.next())Ir = rn(Cn, Be, Un, Ir.value, Ut), Ir !== null && (p && Ir.alternate !== null && Cn.delete(Ir.key === null ? Un : Ir.key), Ie = W(Ir, Ie, Un), Tn === null ? xn = Ir : Tn.sibling = Ir, Tn = Ir); return p && Cn.forEach(function (uge) { return y(Be, uge) }), ii && uc(Be, Un), xn } function ea(Be, Ie, ze, Ut) { if (typeof ze == "object" && ze !== null && ze.type === j && ze.key === null && (ze = ze.props.children), typeof ze == "object" && ze !== null) { switch (ze.$$typeof) { case N: e: { for (var xn = ze.key, Tn = Ie; Tn !== null;) { if (Tn.key === xn) { if (xn = ze.type, xn === j) { if (Tn.tag === 7) { T(Be, Tn.sibling), Ie = U(Tn, ze.props.children), Ie.return = Be, Be = Ie; break e } } else if (Tn.elementType === xn || typeof xn == "object" && xn !== null && xn.$$typeof === Y && Ab(xn) === Tn.type) { T(Be, Tn.sibling), Ie = U(Tn, ze.props), Ie.ref = Qp(Be, Tn, ze), Ie.return = Be, Be = Ie; break e } T(Be, Tn); break } else y(Be, Tn); Tn = Tn.sibling } ze.type === j ? (Ie = gm(ze.props.children, Be.mode, Ut, ze.key), Ie.return = Be, Be = Ie) : (Ut = CE(ze.type, ze.key, ze.props, null, Be.mode, Ut), Ut.ref = Qp(Be, Ie, ze), Ut.return = Be, Be = Ut) } return le(Be); case A: e: { for (Tn = ze.key; Ie !== null;) { if (Ie.key === Tn) if (Ie.tag === 4 && Ie.stateNode.containerInfo === ze.containerInfo && Ie.stateNode.implementation === ze.implementation) { T(Be, Ie.sibling), Ie = U(Ie, ze.children || []), Ie.return = Be, Be = Ie; break e } else { T(Be, Ie); break } else y(Be, Ie); Ie = Ie.sibling } Ie = pj(ze, Be.mode, Ut), Ie.return = Be, Be = Ie } return le(Be); case Y: return Tn = ze._init, ea(Be, Ie, Tn(ze._payload), Ut) }if (nt(ze)) return dn(Be, Ie, ze, Ut); if (V(ze)) return mn(Be, Ie, ze, Ut); Jp(Be, ze) } return typeof ze == "string" && ze !== "" || typeof ze == "number" ? (ze = "" + ze, Ie !== null && Ie.tag === 6 ? (T(Be, Ie.sibling), Ie = U(Ie, ze), Ie.return = Be, Be = Ie) : (T(Be, Ie), Ie = hj(ze, Be.mode, Ut), Ie.return = Be, Be = Ie), le(Be)) : T(Be, Ie) } return ea } var Md = Pb(!0), em = Pb(!1), Td = Ni(null), Cd = null, fc = null, th = null; function Nd() { th = fc = Cd = null } function tm(p) { var y = Td.current; Zr(Td), p._currentValue = y } function nm(p, y, T) { for (; p !== null;) { var k = p.alternate; if ((p.childLanes & y) !== y ? (p.childLanes |= y, k !== null && (k.childLanes |= y)) : k !== null && (k.childLanes & y) !== y && (k.childLanes |= y), p === T) break; p = p.return } } function cu(p, y) { Cd = p, th = fc = null, p = p.dependencies, p !== null && p.firstContext !== null && ((p.lanes & y) !== 0 && (rr = !0), p.firstContext = null) } function Fs(p) { var y = p._currentValue; if (th !== p) if (p = { context: p, memoizedValue: y, next: null }, fc === null) { if (Cd === null) throw Error(n(308)); fc = p, Cd.dependencies = { lanes: 0, firstContext: p } } else fc = fc.next = p; return y } var hc = null; function jb(p) { hc === null ? hc = [p] : hc.push(p) } function rm(p, y, T, k) { var U = y.interleaved; return U === null ? (T.next = T, jb(y)) : (T.next = U.next, U.next = T), y.interleaved = T, Yo(p, k) } function Yo(p, y) { p.lanes |= y; var T = p.alternate; for (T !== null && (T.lanes |= y), T = p, p = p.return; p !== null;)p.childLanes |= y, T = p.alternate, T !== null && (T.childLanes |= y), T = p, p = p.return; return T.tag === 3 ? T.stateNode : null } var Ur = !1; function Zn(p) { p.updateQueue = { baseState: p.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Oi(p, y) { p = p.updateQueue, y.updateQueue === p && (y.updateQueue = { baseState: p.baseState, firstBaseUpdate: p.firstBaseUpdate, lastBaseUpdate: p.lastBaseUpdate, shared: p.shared, effects: p.effects }) } function Br(p, y) { return { eventTime: p, lane: y, tag: 0, payload: null, callback: null, next: null } } function hi(p, y, T) { var k = p.updateQueue; if (k === null) return null; if (k = k.shared, (Ar & 2) !== 0) { var U = k.pending; return U === null ? y.next = y : (y.next = U.next, U.next = y), k.pending = y, Yo(p, T) } return U = k.interleaved, U === null ? (y.next = y, jb(k)) : (y.next = U.next, U.next = y), k.interleaved = y, Yo(p, T) } function $a(p, y, T) { if (y = y.updateQueue, y !== null && (y = y.shared, (T & 4194240) !== 0)) { var k = y.lanes; k &= p.pendingLanes, T |= k, y.lanes = T, yl(p, T) } } function Ad(p, y) { var T = p.updateQueue, k = p.alternate; if (k !== null && (k = k.updateQueue, T === k)) { var U = null, W = null; if (T = T.firstBaseUpdate, T !== null) { do { var le = { eventTime: T.eventTime, lane: T.lane, tag: T.tag, payload: T.payload, callback: T.callback, next: null }; W === null ? U = W = le : W = W.next = le, T = T.next } while (T !== null); W === null ? U = W = y : W = W.next = y } else U = W = y; T = { baseState: k.baseState, firstBaseUpdate: U, lastBaseUpdate: W, shared: k.shared, effects: k.effects }, p.updateQueue = T; return } p = T.lastBaseUpdate, p === null ? T.firstBaseUpdate = y : p.next = y, T.lastBaseUpdate = y } function Ai(p, y, T, k) { var U = p.updateQueue; Ur = !1; var W = U.firstBaseUpdate, le = U.lastBaseUpdate, we = U.shared.pending; if (we !== null) { U.shared.pending = null; var Pe = we, qe = Pe.next; Pe.next = null, le === null ? W = qe : le.next = qe, le = Pe; var wt = p.alternate; wt !== null && (wt = wt.updateQueue, we = wt.lastBaseUpdate, we !== le && (we === null ? wt.firstBaseUpdate = qe : we.next = qe, wt.lastBaseUpdate = Pe)) } if (W !== null) { var Ct = U.baseState; le = 0, wt = qe = Pe = null, we = W; do { var xt = we.lane, rn = we.eventTime; if ((k & xt) === xt) { wt !== null && (wt = wt.next = { eventTime: rn, lane: 0, tag: we.tag, payload: we.payload, callback: we.callback, next: null }); e: { var dn = p, mn = we; switch (xt = y, rn = T, mn.tag) { case 1: if (dn = mn.payload, typeof dn == "function") { Ct = dn.call(rn, Ct, xt); break e } Ct = dn; break e; case 3: dn.flags = dn.flags & -65537 | 128; case 0: if (dn = mn.payload, xt = typeof dn == "function" ? dn.call(rn, Ct, xt) : dn, xt == null) break e; Ct = K({}, Ct, xt); break e; case 2: Ur = !0 } } we.callback !== null && we.lane !== 0 && (p.flags |= 64, xt = U.effects, xt === null ? U.effects = [we] : xt.push(we)) } else rn = { eventTime: rn, lane: xt, tag: we.tag, payload: we.payload, callback: we.callback, next: null }, wt === null ? (qe = wt = rn, Pe = Ct) : wt = wt.next = rn, le |= xt; if (we = we.next, we === null) { if (we = U.shared.pending, we === null) break; xt = we, we = xt.next, xt.next = null, U.lastBaseUpdate = xt, U.shared.pending = null } } while (!0); if (wt === null && (Pe = Ct), U.baseState = Pe, U.firstBaseUpdate = qe, U.lastBaseUpdate = wt, y = U.shared.interleaved, y !== null) { U = y; do le |= U.lane, U = U.next; while (U !== y) } else W === null && (U.shared.lanes = 0); fm |= le, p.lanes = le, p.memoizedState = Ct } } function nh(p, y, T) { if (p = y.effects, y.effects = null, p !== null) for (y = 0; y < p.length; y++) { var k = p[y], U = k.callback; if (U !== null) { if (k.callback = null, k = T, typeof U != "function") throw Error(n(191, U)); U.call(k) } } } var El = {}, Us = Ni(El), Pd = Ni(El), pc = Ni(El); function Vi(p) { if (p === El) throw Error(n(174)); return p } function im(p, y) { switch (Hr(pc, y), Hr(Pd, p), Hr(Us, El), p = y.nodeType, p) { case 9: case 11: y = (y = y.documentElement) ? y.namespaceURI : et(null, ""); break; default: p = p === 8 ? y.parentNode : y, y = p.namespaceURI || null, p = p.tagName, y = et(y, p) }Zr(Us), Hr(Us, y) } function uu() { Zr(Us), Zr(Pd), Zr(pc) } function jd(p) { Vi(pc.current); var y = Vi(Us.current), T = et(y, p.type); y !== T && (Hr(Pd, p), Hr(Us, T)) } function rh(p) { Pd.current === p && (Zr(Us), Zr(Pd)) } var ai = Ni(0); function Ko(p) { for (var y = p; y !== null;) { if (y.tag === 13) { var T = y.memoizedState; if (T !== null && (T = T.dehydrated, T === null || T.data === "$?" || T.data === "$!")) return y } else if (y.tag === 19 && y.memoizedProps.revealOrder !== void 0) { if ((y.flags & 128) !== 0) return y } else if (y.child !== null) { y.child.return = y, y = y.child; continue } if (y === p) break; for (; y.sibling === null;) { if (y.return === null || y.return === p) return null; y = y.return } y.sibling.return = y.return, y = y.sibling } return null } var ih = []; function Ml() { for (var p = 0; p < ih.length; p++)ih[p]._workInProgressVersionPrimary = null; ih.length = 0 } var Rd = C.ReactCurrentDispatcher, kd = C.ReactCurrentBatchConfig, mc = 0, Qr = null, Pi = null, Cr = null, Zo = !1, za = !1, du = 0, vs = 0; function Sa() { throw Error(n(321)) } function am(p, y) { if (y === null) return !1; for (var T = 0; T < y.length && T < p.length; T++)if (!Os(p[T], y[T])) return !1; return !0 } function sm(p, y, T, k, U, W) { if (mc = W, Qr = y, y.memoizedState = null, y.updateQueue = null, y.lanes = 0, Rd.current = p === null || p.memoizedState === null ? dE : fE, p = T(k, U), za) { W = 0; do { if (za = !1, du = 0, 25 <= W) throw Error(n(301)); W += 1, Cr = Pi = null, y.updateQueue = null, Rd.current = hE, p = T(k, U) } while (za) } if (Rd.current = Wv, y = Pi !== null && Pi.next !== null, mc = 0, Cr = Pi = Qr = null, Zo = !1, y) throw Error(n(300)); return p } function Rb() { var p = du !== 0; return du = 0, p } function _a() { var p = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Cr === null ? Qr.memoizedState = Cr = p : Cr = Cr.next = p, Cr } function Bs() { if (Pi === null) { var p = Qr.alternate; p = p !== null ? p.memoizedState : null } else p = Pi.next; var y = Cr === null ? Qr.memoizedState : Cr.next; if (y !== null) Cr = y, Pi = p; else { if (p === null) throw Error(n(310)); Pi = p, p = { memoizedState: Pi.memoizedState, baseState: Pi.baseState, baseQueue: Pi.baseQueue, queue: Pi.queue, next: null }, Cr === null ? Qr.memoizedState = Cr = p : Cr = Cr.next = p } return Cr } function ah(p, y) { return typeof y == "function" ? y(p) : y } function om(p) { var y = Bs(), T = y.queue; if (T === null) throw Error(n(311)); T.lastRenderedReducer = p; var k = Pi, U = k.baseQueue, W = T.pending; if (W !== null) { if (U !== null) { var le = U.next; U.next = W.next, W.next = le } k.baseQueue = U = W, T.pending = null } if (U !== null) { W = U.next, k = k.baseState; var we = le = null, Pe = null, qe = W; do { var wt = qe.lane; if ((mc & wt) === wt) Pe !== null && (Pe = Pe.next = { lane: 0, action: qe.action, hasEagerState: qe.hasEagerState, eagerState: qe.eagerState, next: null }), k = qe.hasEagerState ? qe.eagerState : p(k, qe.action); else { var Ct = { lane: wt, action: qe.action, hasEagerState: qe.hasEagerState, eagerState: qe.eagerState, next: null }; Pe === null ? (we = Pe = Ct, le = k) : Pe = Pe.next = Ct, Qr.lanes |= wt, fm |= wt } qe = qe.next } while (qe !== null && qe !== W); Pe === null ? le = k : Pe.next = we, Os(k, y.memoizedState) || (rr = !0), y.memoizedState = k, y.baseState = le, y.baseQueue = Pe, T.lastRenderedState = k } if (p = T.interleaved, p !== null) { U = p; do W = U.lane, Qr.lanes |= W, fm |= W, U = U.next; while (U !== p) } else U === null && (T.lanes = 0); return [y.memoizedState, T.dispatch] } function gc(p) { var y = Bs(), T = y.queue; if (T === null) throw Error(n(311)); T.lastRenderedReducer = p; var k = T.dispatch, U = T.pending, W = y.memoizedState; if (U !== null) { T.pending = null; var le = U = U.next; do W = p(W, le.action), le = le.next; while (le !== U); Os(W, y.memoizedState) || (rr = !0), y.memoizedState = W, y.baseQueue === null && (y.baseState = W), T.lastRenderedState = W } return [W, k] } function kb() { } function Ib(p, y) { var T = Qr, k = Bs(), U = y(), W = !Os(k.memoizedState, U); if (W && (k.memoizedState = U, rr = !0), k = k.queue, Lb(aE.bind(null, T, k, p), [p]), k.getSnapshot !== y || W || Cr !== null && Cr.memoizedState.tag & 1) { if (T.flags |= 2048, Qo(9, lm.bind(null, T, k, U, y), void 0, null), Va === null) throw Error(n(349)); (mc & 30) !== 0 || Uv(T, y, U) } return U } function Uv(p, y, T) { p.flags |= 16384, p = { getSnapshot: y, value: T }, y = Qr.updateQueue, y === null ? (y = { lastEffect: null, stores: null }, Qr.updateQueue = y, y.stores = [p]) : (T = y.stores, T === null ? y.stores = [p] : T.push(p)) } function lm(p, y, T, k) { y.value = T, y.getSnapshot = k, sE(y) && Ob(p) } function aE(p, y, T) { return T(function () { sE(y) && Ob(p) }) } function sE(p) { var y = p.getSnapshot; p = p.value; try { var T = y(); return !Os(p, T) } catch { return !0 } } function Ob(p) { var y = Yo(p, 1); y !== null && wc(y, p, 1, -1) } function Db(p) { var y = _a(); return typeof p == "function" && (p = p()), y.memoizedState = y.baseState = p, p = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ah, lastRenderedState: p }, y.queue = p, p = p.dispatch = Id.bind(null, Qr, p), [y.memoizedState, p] } function Qo(p, y, T, k) { return p = { tag: p, create: y, destroy: T, deps: k, next: null }, y = Qr.updateQueue, y === null ? (y = { lastEffect: null, stores: null }, Qr.updateQueue = y, y.lastEffect = p.next = p) : (T = y.lastEffect, T === null ? y.lastEffect = p.next = p : (k = T.next, T.next = p, p.next = k, y.lastEffect = p)), p } function oE() { return Bs().memoizedState } function Tl(p, y, T, k) { var U = _a(); Qr.flags |= p, U.memoizedState = Qo(1 | y, T, void 0, k === void 0 ? null : k) } function cm(p, y, T, k) { var U = Bs(); k = k === void 0 ? null : k; var W = void 0; if (Pi !== null) { var le = Pi.memoizedState; if (W = le.destroy, k !== null && am(k, le.deps)) { U.memoizedState = Qo(y, T, W, k); return } } Qr.flags |= p, U.memoizedState = Qo(1 | y, T, W, k) } function is(p, y) { return Tl(8390656, 8, p, y) } function Lb(p, y) { return cm(2048, 8, p, y) } function Fb(p, y) { return cm(4, 2, p, y) } function lE(p, y) { return cm(4, 4, p, y) } function cE(p, y) { if (typeof y == "function") return p = p(), y(p), function () { y(null) }; if (y != null) return p = p(), y.current = p, function () { y.current = null } } function Ub(p, y, T) { return T = T != null ? T.concat([p]) : null, cm(4, 4, cE.bind(null, y, p), T) } function Bv() { } function uE(p, y) { var T = Bs(); y = y === void 0 ? null : y; var k = T.memoizedState; return k !== null && y !== null && am(y, k[1]) ? k[0] : (T.memoizedState = [p, y], p) } function $s(p, y) { var T = Bs(); y = y === void 0 ? null : y; var k = T.memoizedState; return k !== null && y !== null && am(y, k[1]) ? k[0] : (p = p(), T.memoizedState = [p, y], p) } function $v(p, y, T) { return (mc & 21) === 0 ? (p.baseState && (p.baseState = !1, rr = !0), p.memoizedState = T) : (Os(T, y) || (T = ur(), Qr.lanes |= T, fm |= T, p.baseState = !0), y) } function YP(p, y) { var T = nr; nr = T !== 0 && 4 > T ? T : 4, p(!0); var k = kd.transition; kd.transition = {}; try { p(!1), y() } finally { nr = T, kd.transition = k } } function vc() { return Bs().memoizedState } function zv(p, y, T) { var k = ch(p); if (T = { lane: k, action: T, hasEagerState: !1, eagerState: null, next: null }, um(p)) Vv(y, T); else if (T = rm(p, y, T, k), T !== null) { var U = Vs(); wc(T, p, k, U), Hv(T, y, k) } } function Id(p, y, T) { var k = ch(p), U = { lane: k, action: T, hasEagerState: !1, eagerState: null, next: null }; if (um(p)) Vv(y, U); else { var W = p.alternate; if (p.lanes === 0 && (W === null || W.lanes === 0) && (W = y.lastRenderedReducer, W !== null)) try { var le = y.lastRenderedState, we = W(le, T); if (U.hasEagerState = !0, U.eagerState = we, Os(we, le)) { var Pe = y.interleaved; Pe === null ? (U.next = U, jb(y)) : (U.next = Pe.next, Pe.next = U), y.interleaved = U; return } } catch { } finally { } T = rm(p, y, U, k), T !== null && (U = Vs(), wc(T, p, k, U), Hv(T, y, k)) } } function um(p) { var y = p.alternate; return p === Qr || y !== null && y === Qr } function Vv(p, y) { za = Zo = !0; var T = p.pending; T === null ? y.next = y : (y.next = T.next, T.next = y), p.pending = y } function Hv(p, y, T) { if ((T & 4194240) !== 0) { var k = y.lanes; k &= p.pendingLanes, T |= k, y.lanes = T, yl(p, T) } } var Wv = { readContext: Fs, useCallback: Sa, useContext: Sa, useEffect: Sa, useImperativeHandle: Sa, useInsertionEffect: Sa, useLayoutEffect: Sa, useMemo: Sa, useReducer: Sa, useRef: Sa, useState: Sa, useDebugValue: Sa, useDeferredValue: Sa, useTransition: Sa, useMutableSource: Sa, useSyncExternalStore: Sa, useId: Sa, unstable_isNewReconciler: !1 }, dE = { readContext: Fs, useCallback: function (p, y) { return _a().memoizedState = [p, y === void 0 ? null : y], p }, useContext: Fs, useEffect: is, useImperativeHandle: function (p, y, T) { return T = T != null ? T.concat([p]) : null, Tl(4194308, 4, cE.bind(null, y, p), T) }, useLayoutEffect: function (p, y) { return Tl(4194308, 4, p, y) }, useInsertionEffect: function (p, y) { return Tl(4, 2, p, y) }, useMemo: function (p, y) { var T = _a(); return y = y === void 0 ? null : y, p = p(), T.memoizedState = [p, y], p }, useReducer: function (p, y, T) { var k = _a(); return y = T !== void 0 ? T(y) : y, k.memoizedState = k.baseState = y, p = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: p, lastRenderedState: y }, k.queue = p, p = p.dispatch = zv.bind(null, Qr, p), [k.memoizedState, p] }, useRef: function (p) { var y = _a(); return p = { current: p }, y.memoizedState = p }, useState: Db, useDebugValue: Bv, useDeferredValue: function (p) { return _a().memoizedState = p }, useTransition: function () { var p = Db(!1), y = p[0]; return p = YP.bind(null, p[1]), _a().memoizedState = p, [y, p] }, useMutableSource: function () { }, useSyncExternalStore: function (p, y, T) { var k = Qr, U = _a(); if (ii) { if (T === void 0) throw Error(n(407)); T = T() } else { if (T = y(), Va === null) throw Error(n(349)); (mc & 30) !== 0 || Uv(k, y, T) } U.memoizedState = T; var W = { value: T, getSnapshot: y }; return U.queue = W, is(aE.bind(null, k, W, p), [p]), k.flags |= 2048, Qo(9, lm.bind(null, k, W, T, y), void 0, null), T }, useId: function () { var p = _a(), y = Va.identifierPrefix; if (ii) { var T = wo, k = zt; T = (k & ~(1 << 32 - tn(k) - 1)).toString(32) + T, y = ":" + y + "R" + T, T = du++, 0 < T && (y += "H" + T.toString(32)), y += ":" } else T = vs++, y = ":" + y + "r" + T.toString(32) + ":"; return p.memoizedState = y }, unstable_isNewReconciler: !1 }, fE = { readContext: Fs, useCallback: uE, useContext: Fs, useEffect: Lb, useImperativeHandle: Ub, useInsertionEffect: Fb, useLayoutEffect: lE, useMemo: $s, useReducer: om, useRef: oE, useState: function () { return om(ah) }, useDebugValue: Bv, useDeferredValue: function (p) { var y = Bs(); return $v(y, Pi.memoizedState, p) }, useTransition: function () { var p = om(ah)[0], y = Bs().memoizedState; return [p, y] }, useMutableSource: kb, useSyncExternalStore: Ib, useId: vc, unstable_isNewReconciler: !1 }, hE = { readContext: Fs, useCallback: uE, useContext: Fs, useEffect: Lb, useImperativeHandle: Ub, useInsertionEffect: Fb, useLayoutEffect: lE, useMemo: $s, useReducer: gc, useRef: oE, useState: function () { return gc(ah) }, useDebugValue: Bv, useDeferredValue: function (p) { var y = Bs(); return Pi === null ? y.memoizedState = p : $v(y, Pi.memoizedState, p) }, useTransition: function () { var p = gc(ah)[0], y = Bs().memoizedState; return [p, y] }, useMutableSource: kb, useSyncExternalStore: Ib, useId: vc, unstable_isNewReconciler: !1 }; function _o(p, y) { if (p && p.defaultProps) { y = K({}, y), p = p.defaultProps; for (var T in p) y[T] === void 0 && (y[T] = p[T]); return y } return y } function dm(p, y, T, k) { y = p.memoizedState, T = T(k, y), T = T == null ? y : K({}, y, T), p.memoizedState = T, p.lanes === 0 && (p.updateQueue.baseState = T) } var Gv = { isMounted: function (p) { return (p = p._reactInternals) ? ue(p) === p : !1 }, enqueueSetState: function (p, y, T) { p = p._reactInternals; var k = Vs(), U = ch(p), W = Br(k, U); W.payload = y, T != null && (W.callback = T), y = hi(p, W, U), y !== null && (wc(y, p, U, k), $a(y, p, U)) }, enqueueReplaceState: function (p, y, T) { p = p._reactInternals; var k = Vs(), U = ch(p), W = Br(k, U); W.tag = 1, W.payload = y, T != null && (W.callback = T), y = hi(p, W, U), y !== null && (wc(y, p, U, k), $a(y, p, U)) }, enqueueForceUpdate: function (p, y) { p = p._reactInternals; var T = Vs(), k = ch(p), U = Br(T, k); U.tag = 2, y != null && (U.callback = y), y = hi(p, U, k), y !== null && (wc(y, p, k, T), $a(y, p, k)) } }; function pE(p, y, T, k, U, W, le) { return p = p.stateNode, typeof p.shouldComponentUpdate == "function" ? p.shouldComponentUpdate(k, W, le) : y.prototype && y.prototype.isPureReactComponent ? !md(T, k) || !md(U, W) : !0 } function w(p, y, T) { var k = !1, U = lc, W = y.contextType; return typeof W == "object" && W !== null ? W = Fs(W) : (U = Ba(y) ? cc : ba.current, k = y.contextTypes, W = (k = k != null) ? wd(p, U) : lc), y = new y(T, W), p.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, y.updater = Gv, p.stateNode = y, y._reactInternals = p, k && (p = p.stateNode, p.__reactInternalMemoizedUnmaskedChildContext = U, p.__reactInternalMemoizedMaskedChildContext = W), y } function _(p, y, T, k) { p = y.state, typeof y.componentWillReceiveProps == "function" && y.componentWillReceiveProps(T, k), typeof y.UNSAFE_componentWillReceiveProps == "function" && y.UNSAFE_componentWillReceiveProps(T, k), y.state !== p && Gv.enqueueReplaceState(y, y.state, null) } function R(p, y, T, k) { var U = p.stateNode; U.props = T, U.state = p.memoizedState, U.refs = {}, Zn(p); var W = y.contextType; typeof W == "object" && W !== null ? U.context = Fs(W) : (W = Ba(y) ? cc : ba.current, U.context = wd(p, W)), U.state = p.memoizedState, W = y.getDerivedStateFromProps, typeof W == "function" && (dm(p, y, W, T), U.state = p.memoizedState), typeof y.getDerivedStateFromProps == "function" || typeof U.getSnapshotBeforeUpdate == "function" || typeof U.UNSAFE_componentWillMount != "function" && typeof U.componentWillMount != "function" || (y = U.state, typeof U.componentWillMount == "function" && U.componentWillMount(), typeof U.UNSAFE_componentWillMount == "function" && U.UNSAFE_componentWillMount(), y !== U.state && Gv.enqueueReplaceState(U, U.state, null), Ai(p, T, U, k), U.state = p.memoizedState), typeof U.componentDidMount == "function" && (p.flags |= 4194308) } function L(p, y) {
		try { var T = "", k = y; do T += be(k), k = k.return; while (k); var U = T } catch (W) {
			U = `
Error generating stack: `+ W.message + `
`+ W.stack
		} return { value: p, source: y, stack: U, digest: null }
	} function H(p, y, T) { return { value: p, source: null, stack: T ?? null, digest: y ?? null } } function J(p, y) { try { console.error(y.value) } catch (T) { setTimeout(function () { throw T }) } } var ve = typeof WeakMap == "function" ? WeakMap : Map; function Oe(p, y, T) { T = Br(-1, T), T.tag = 3, T.payload = { element: null }; var k = y.value; return T.callback = function () { wE || (wE = !0, aj = k), J(p, y) }, T } function tt(p, y, T) { T = Br(-1, T), T.tag = 3; var k = p.type.getDerivedStateFromError; if (typeof k == "function") { var U = y.value; T.payload = function () { return k(U) }, T.callback = function () { J(p, y) } } var W = p.stateNode; return W !== null && typeof W.componentDidCatch == "function" && (T.callback = function () { J(p, y), typeof k != "function" && (oh === null ? oh = new Set([this]) : oh.add(this)); var le = y.stack; this.componentDidCatch(y.value, { componentStack: le !== null ? le : "" }) }), T } function Ot(p, y, T) { var k = p.pingCache; if (k === null) { k = p.pingCache = new ve; var U = new Set; k.set(y, U) } else U = k.get(y), U === void 0 && (U = new Set, k.set(y, U)); U.has(T) || (U.add(T), p = Jme.bind(null, p, y, T), y.then(p, p)) } function an(p) { do { var y; if ((y = p.tag === 13) && (y = p.memoizedState, y = y !== null ? y.dehydrated !== null : !0), y) return p; p = p.return } while (p !== null); return null } function Bn(p, y, T, k, U) { return (p.mode & 1) === 0 ? (p === y ? p.flags |= 65536 : (p.flags |= 128, T.flags |= 131072, T.flags &= -52805, T.tag === 1 && (T.alternate === null ? T.tag = 17 : (y = Br(-1, 1), y.tag = 2, hi(T, y, 1))), T.lanes |= 1), p) : (p.flags |= 65536, p.lanes = U, p) } var En = C.ReactCurrentOwner, rr = !1; function Qt(p, y, T, k) { y.child = p === null ? em(y, null, T, k) : Md(y, p.child, T, k) } function Ea(p, y, T, k, U) { T = T.render; var W = y.ref; return cu(y, U), k = sm(p, y, T, k, W, U), T = Rb(), p !== null && !rr ? (y.updateQueue = p.updateQueue, y.flags &= -2053, p.lanes &= ~U, Od(p, y, U)) : (ii && T && Mb(y), y.flags |= 1, Qt(p, y, k, U), y.child) } function zs(p, y, T, k, U) { if (p === null) { var W = T.type; return typeof W == "function" && !fj(W) && W.defaultProps === void 0 && T.compare === null && T.defaultProps === void 0 ? (y.tag = 15, y.type = W, Ve(p, y, W, k, U)) : (p = CE(T.type, null, k, y, y.mode, U), p.ref = y.ref, p.return = y, y.child = p) } if (W = p.child, (p.lanes & U) === 0) { var le = W.memoizedProps; if (T = T.compare, T = T !== null ? T : md, T(le, k) && p.ref === y.ref) return Od(p, y, U) } return y.flags |= 1, p = dh(W, k), p.ref = y.ref, p.return = y, y.child = p } function Ve(p, y, T, k, U) { if (p !== null) { var W = p.memoizedProps; if (md(W, k) && p.ref === y.ref) if (rr = !1, y.pendingProps = k = W, (p.lanes & U) !== 0) (p.flags & 131072) !== 0 && (rr = !0); else return y.lanes = p.lanes, Od(p, y, U) } return Ht(p, y, T, k, U) } function Le(p, y, T) { var k = y.pendingProps, U = k.children, W = p !== null ? p.memoizedState : null; if (k.mode === "hidden") if ((y.mode & 1) === 0) y.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Hr(Xv, Jo), Jo |= T; else { if ((T & 1073741824) === 0) return p = W !== null ? W.baseLanes | T : T, y.lanes = y.childLanes = 1073741824, y.memoizedState = { baseLanes: p, cachePool: null, transitions: null }, y.updateQueue = null, Hr(Xv, Jo), Jo |= p, null; y.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, k = W !== null ? W.baseLanes : T, Hr(Xv, Jo), Jo |= k } else W !== null ? (k = W.baseLanes | T, y.memoizedState = null) : k = T, Hr(Xv, Jo), Jo |= k; return Qt(p, y, U, T), y.child } function Ye(p, y) { var T = y.ref; (p === null && T !== null || p !== null && p.ref !== T) && (y.flags |= 512, y.flags |= 2097152) } function Ht(p, y, T, k, U) { var W = Ba(T) ? cc : ba.current; return W = wd(y, W), cu(y, U), T = sm(p, y, T, k, W, U), k = Rb(), p !== null && !rr ? (y.updateQueue = p.updateQueue, y.flags &= -2053, p.lanes &= ~U, Od(p, y, U)) : (ii && k && Mb(y), y.flags |= 1, Qt(p, y, T, U), y.child) } function gn(p, y, T, k, U) { if (Ba(T)) { var W = !0; Sd(y) } else W = !1; if (cu(y, U), y.stateNode === null) gE(p, y), w(y, T, k), R(y, T, k, U), k = !0; else if (p === null) { var le = y.stateNode, we = y.memoizedProps; le.props = we; var Pe = le.context, qe = T.contextType; typeof qe == "object" && qe !== null ? qe = Fs(qe) : (qe = Ba(T) ? cc : ba.current, qe = wd(y, qe)); var wt = T.getDerivedStateFromProps, Ct = typeof wt == "function" || typeof le.getSnapshotBeforeUpdate == "function"; Ct || typeof le.UNSAFE_componentWillReceiveProps != "function" && typeof le.componentWillReceiveProps != "function" || (we !== k || Pe !== qe) && _(y, le, k, qe), Ur = !1; var xt = y.memoizedState; le.state = xt, Ai(y, k, le, U), Pe = y.memoizedState, we !== k || xt !== Pe || ts.current || Ur ? (typeof wt == "function" && (dm(y, T, wt, k), Pe = y.memoizedState), (we = Ur || pE(y, T, we, k, xt, Pe, qe)) ? (Ct || typeof le.UNSAFE_componentWillMount != "function" && typeof le.componentWillMount != "function" || (typeof le.componentWillMount == "function" && le.componentWillMount(), typeof le.UNSAFE_componentWillMount == "function" && le.UNSAFE_componentWillMount()), typeof le.componentDidMount == "function" && (y.flags |= 4194308)) : (typeof le.componentDidMount == "function" && (y.flags |= 4194308), y.memoizedProps = k, y.memoizedState = Pe), le.props = k, le.state = Pe, le.context = qe, k = we) : (typeof le.componentDidMount == "function" && (y.flags |= 4194308), k = !1) } else { le = y.stateNode, Oi(p, y), we = y.memoizedProps, qe = y.type === y.elementType ? we : _o(y.type, we), le.props = qe, Ct = y.pendingProps, xt = le.context, Pe = T.contextType, typeof Pe == "object" && Pe !== null ? Pe = Fs(Pe) : (Pe = Ba(T) ? cc : ba.current, Pe = wd(y, Pe)); var rn = T.getDerivedStateFromProps; (wt = typeof rn == "function" || typeof le.getSnapshotBeforeUpdate == "function") || typeof le.UNSAFE_componentWillReceiveProps != "function" && typeof le.componentWillReceiveProps != "function" || (we !== Ct || xt !== Pe) && _(y, le, k, Pe), Ur = !1, xt = y.memoizedState, le.state = xt, Ai(y, k, le, U); var dn = y.memoizedState; we !== Ct || xt !== dn || ts.current || Ur ? (typeof rn == "function" && (dm(y, T, rn, k), dn = y.memoizedState), (qe = Ur || pE(y, T, qe, k, xt, dn, Pe) || !1) ? (wt || typeof le.UNSAFE_componentWillUpdate != "function" && typeof le.componentWillUpdate != "function" || (typeof le.componentWillUpdate == "function" && le.componentWillUpdate(k, dn, Pe), typeof le.UNSAFE_componentWillUpdate == "function" && le.UNSAFE_componentWillUpdate(k, dn, Pe)), typeof le.componentDidUpdate == "function" && (y.flags |= 4), typeof le.getSnapshotBeforeUpdate == "function" && (y.flags |= 1024)) : (typeof le.componentDidUpdate != "function" || we === p.memoizedProps && xt === p.memoizedState || (y.flags |= 4), typeof le.getSnapshotBeforeUpdate != "function" || we === p.memoizedProps && xt === p.memoizedState || (y.flags |= 1024), y.memoizedProps = k, y.memoizedState = dn), le.props = k, le.state = dn, le.context = Pe, k = qe) : (typeof le.componentDidUpdate != "function" || we === p.memoizedProps && xt === p.memoizedState || (y.flags |= 4), typeof le.getSnapshotBeforeUpdate != "function" || we === p.memoizedProps && xt === p.memoizedState || (y.flags |= 1024), k = !1) } return Wn(p, y, T, k, W, U) } function Wn(p, y, T, k, U, W) { Ye(p, y); var le = (y.flags & 128) !== 0; if (!k && !le) return U && _b(y, T, !1), Od(p, y, W); k = y.stateNode, En.current = y; var we = le && typeof T.getDerivedStateFromError != "function" ? null : k.render(); return y.flags |= 1, p !== null && le ? (y.child = Md(y, p.child, null, W), y.child = Md(y, null, we, W)) : Qt(p, y, we, W), y.memoizedState = k.state, U && _b(y, T, !0), y.child } function $n(p) { var y = p.stateNode; y.pendingContext ? Sb(p, y.pendingContext, y.pendingContext !== y.context) : y.context && Sb(p, y.context, !1), im(p, y.containerInfo) } function _r(p, y, T, k, U) { return lu(), eh(U), y.flags |= 256, Qt(p, y, T, k), y.child } var Hi = { dehydrated: null, treeContext: null, retryLane: 0 }; function br(p) { return { baseLanes: p, cachePool: null, transitions: null } } function yc(p, y, T) { var k = y.pendingProps, U = ai.current, W = !1, le = (y.flags & 128) !== 0, we; if ((we = le) || (we = p !== null && p.memoizedState === null ? !1 : (U & 2) !== 0), we ? (W = !0, y.flags &= -129) : (p === null || p.memoizedState !== null) && (U |= 1), Hr(ai, U & 1), p === null) return Lv(y), p = y.memoizedState, p !== null && (p = p.dehydrated, p !== null) ? ((y.mode & 1) === 0 ? y.lanes = 1 : p.data === "$!" ? y.lanes = 8 : y.lanes = 1073741824, null) : (le = k.children, p = k.fallback, W ? (k = y.mode, W = y.child, le = { mode: "hidden", children: le }, (k & 1) === 0 && W !== null ? (W.childLanes = 0, W.pendingProps = le) : W = NE(le, k, 0, null), p = gm(p, k, T, null), W.return = y, p.return = y, W.sibling = p, y.child = W, y.child.memoizedState = br(T), y.memoizedState = Hi, p) : Bb(y, le)); if (U = p.memoizedState, U !== null && (we = U.dehydrated, we !== null)) return $me(p, y, le, k, we, U, T); if (W) { W = k.fallback, le = y.mode, U = p.child, we = U.sibling; var Pe = { mode: "hidden", children: k.children }; return (le & 1) === 0 && y.child !== U ? (k = y.child, k.childLanes = 0, k.pendingProps = Pe, y.deletions = null) : (k = dh(U, Pe), k.subtreeFlags = U.subtreeFlags & 14680064), we !== null ? W = dh(we, W) : (W = gm(W, le, T, null), W.flags |= 2), W.return = y, k.return = y, k.sibling = W, y.child = k, k = W, W = y.child, le = p.child.memoizedState, le = le === null ? br(T) : { baseLanes: le.baseLanes | T, cachePool: null, transitions: le.transitions }, W.memoizedState = le, W.childLanes = p.childLanes & ~T, y.memoizedState = Hi, k } return W = p.child, p = W.sibling, k = dh(W, { mode: "visible", children: k.children }), (y.mode & 1) === 0 && (k.lanes = T), k.return = y, k.sibling = null, p !== null && (T = y.deletions, T === null ? (y.deletions = [p], y.flags |= 16) : T.push(p)), y.child = k, y.memoizedState = null, k } function Bb(p, y) { return y = NE({ mode: "visible", children: y }, p.mode, 0, null), y.return = p, p.child = y } function mE(p, y, T, k) { return k !== null && eh(k), Md(y, p.child, null, T), p = Bb(y, y.pendingProps.children), p.flags |= 2, y.memoizedState = null, p } function $me(p, y, T, k, U, W, le) { if (T) return y.flags & 256 ? (y.flags &= -257, k = H(Error(n(422))), mE(p, y, le, k)) : y.memoizedState !== null ? (y.child = p.child, y.flags |= 128, null) : (W = k.fallback, U = y.mode, k = NE({ mode: "visible", children: k.children }, U, 0, null), W = gm(W, U, le, null), W.flags |= 2, k.return = y, W.return = y, k.sibling = W, y.child = k, (y.mode & 1) !== 0 && Md(y, p.child, null, le), y.child.memoizedState = br(le), y.memoizedState = Hi, W); if ((y.mode & 1) === 0) return mE(p, y, le, null); if (U.data === "$!") { if (k = U.nextSibling && U.nextSibling.dataset, k) var we = k.dgst; return k = we, W = Error(n(419)), k = H(W, k, void 0), mE(p, y, le, k) } if (we = (le & p.childLanes) !== 0, rr || we) { if (k = Va, k !== null) { switch (le & -le) { case 4: U = 2; break; case 16: U = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: U = 32; break; case 536870912: U = 268435456; break; default: U = 0 }U = (U & (k.suspendedLanes | le)) !== 0 ? 0 : U, U !== 0 && U !== W.retryLane && (W.retryLane = U, Yo(p, U), wc(k, p, U, -1)) } return dj(), k = H(Error(n(421))), mE(p, y, le, k) } return U.data === "$?" ? (y.flags |= 128, y.child = p.child, y = ege.bind(null, p), U._reactRetry = y, null) : (p = W.treeContext, rs = sc(U.nextSibling), wa = y, ii = !0, So = null, p !== null && (ns[fa++] = zt, ns[fa++] = wo, ns[fa++] = Ed, zt = p.id, wo = p.overflow, Ed = y), y = Bb(y, k.children), y.flags |= 4096, y) } function E6(p, y, T) { p.lanes |= y; var k = p.alternate; k !== null && (k.lanes |= y), nm(p.return, y, T) } function KP(p, y, T, k, U) { var W = p.memoizedState; W === null ? p.memoizedState = { isBackwards: y, rendering: null, renderingStartTime: 0, last: k, tail: T, tailMode: U } : (W.isBackwards = y, W.rendering = null, W.renderingStartTime = 0, W.last = k, W.tail = T, W.tailMode = U) } function M6(p, y, T) { var k = y.pendingProps, U = k.revealOrder, W = k.tail; if (Qt(p, y, k.children, T), k = ai.current, (k & 2) !== 0) k = k & 1 | 2, y.flags |= 128; else { if (p !== null && (p.flags & 128) !== 0) e: for (p = y.child; p !== null;) { if (p.tag === 13) p.memoizedState !== null && E6(p, T, y); else if (p.tag === 19) E6(p, T, y); else if (p.child !== null) { p.child.return = p, p = p.child; continue } if (p === y) break e; for (; p.sibling === null;) { if (p.return === null || p.return === y) break e; p = p.return } p.sibling.return = p.return, p = p.sibling } k &= 1 } if (Hr(ai, k), (y.mode & 1) === 0) y.memoizedState = null; else switch (U) { case "forwards": for (T = y.child, U = null; T !== null;)p = T.alternate, p !== null && Ko(p) === null && (U = T), T = T.sibling; T = U, T === null ? (U = y.child, y.child = null) : (U = T.sibling, T.sibling = null), KP(y, !1, U, T, W); break; case "backwards": for (T = null, U = y.child, y.child = null; U !== null;) { if (p = U.alternate, p !== null && Ko(p) === null) { y.child = U; break } p = U.sibling, U.sibling = T, T = U, U = p } KP(y, !0, T, null, W); break; case "together": KP(y, !1, null, null, void 0); break; default: y.memoizedState = null }return y.child } function gE(p, y) { (y.mode & 1) === 0 && p !== null && (p.alternate = null, y.alternate = null, y.flags |= 2) } function Od(p, y, T) { if (p !== null && (y.dependencies = p.dependencies), fm |= y.lanes, (T & y.childLanes) === 0) return null; if (p !== null && y.child !== p.child) throw Error(n(153)); if (y.child !== null) { for (p = y.child, T = dh(p, p.pendingProps), y.child = T, T.return = y; p.sibling !== null;)p = p.sibling, T = T.sibling = dh(p, p.pendingProps), T.return = y; T.sibling = null } return y.child } function zme(p, y, T) { switch (y.tag) { case 3: $n(y), lu(); break; case 5: jd(y); break; case 1: Ba(y.type) && Sd(y); break; case 4: im(y, y.stateNode.containerInfo); break; case 10: var k = y.type._context, U = y.memoizedProps.value; Hr(Td, k._currentValue), k._currentValue = U; break; case 13: if (k = y.memoizedState, k !== null) return k.dehydrated !== null ? (Hr(ai, ai.current & 1), y.flags |= 128, null) : (T & y.child.childLanes) !== 0 ? yc(p, y, T) : (Hr(ai, ai.current & 1), p = Od(p, y, T), p !== null ? p.sibling : null); Hr(ai, ai.current & 1); break; case 19: if (k = (T & y.childLanes) !== 0, (p.flags & 128) !== 0) { if (k) return M6(p, y, T); y.flags |= 128 } if (U = y.memoizedState, U !== null && (U.rendering = null, U.tail = null, U.lastEffect = null), Hr(ai, ai.current), k) break; return null; case 22: case 23: return y.lanes = 0, Le(p, y, T) }return Od(p, y, T) } var T6, ZP, C6, N6; T6 = function (p, y) { for (var T = y.child; T !== null;) { if (T.tag === 5 || T.tag === 6) p.appendChild(T.stateNode); else if (T.tag !== 4 && T.child !== null) { T.child.return = T, T = T.child; continue } if (T === y) break; for (; T.sibling === null;) { if (T.return === null || T.return === y) return; T = T.return } T.sibling.return = T.return, T = T.sibling } }, ZP = function () { }, C6 = function (p, y, T, k) { var U = p.memoizedProps; if (U !== k) { p = y.stateNode, Vi(Us.current); var W = null; switch (T) { case "input": U = xe(p, U), k = xe(p, k), W = []; break; case "select": U = K({}, U, { value: void 0 }), k = K({}, k, { value: void 0 }), W = []; break; case "textarea": U = St(p, U), k = St(p, k), W = []; break; default: typeof U.onClick != "function" && typeof k.onClick == "function" && (p.onclick = qp) }Se(T, k); var le; T = null; for (qe in U) if (!k.hasOwnProperty(qe) && U.hasOwnProperty(qe) && U[qe] != null) if (qe === "style") { var we = U[qe]; for (le in we) we.hasOwnProperty(le) && (T || (T = {}), T[le] = "") } else qe !== "dangerouslySetInnerHTML" && qe !== "children" && qe !== "suppressContentEditableWarning" && qe !== "suppressHydrationWarning" && qe !== "autoFocus" && (i.hasOwnProperty(qe) ? W || (W = []) : (W = W || []).push(qe, null)); for (qe in k) { var Pe = k[qe]; if (we = U?.[qe], k.hasOwnProperty(qe) && Pe !== we && (Pe != null || we != null)) if (qe === "style") if (we) { for (le in we) !we.hasOwnProperty(le) || Pe && Pe.hasOwnProperty(le) || (T || (T = {}), T[le] = ""); for (le in Pe) Pe.hasOwnProperty(le) && we[le] !== Pe[le] && (T || (T = {}), T[le] = Pe[le]) } else T || (W || (W = []), W.push(qe, T)), T = Pe; else qe === "dangerouslySetInnerHTML" ? (Pe = Pe ? Pe.__html : void 0, we = we ? we.__html : void 0, Pe != null && we !== Pe && (W = W || []).push(qe, Pe)) : qe === "children" ? typeof Pe != "string" && typeof Pe != "number" || (W = W || []).push(qe, "" + Pe) : qe !== "suppressContentEditableWarning" && qe !== "suppressHydrationWarning" && (i.hasOwnProperty(qe) ? (Pe != null && qe === "onScroll" && Kr("scroll", p), W || we === Pe || (W = [])) : (W = W || []).push(qe, Pe)) } T && (W = W || []).push("style", T); var qe = W; (y.updateQueue = qe) && (y.flags |= 4) } }, N6 = function (p, y, T, k) { T !== k && (y.flags |= 4) }; function $b(p, y) { if (!ii) switch (p.tailMode) { case "hidden": y = p.tail; for (var T = null; y !== null;)y.alternate !== null && (T = y), y = y.sibling; T === null ? p.tail = null : T.sibling = null; break; case "collapsed": T = p.tail; for (var k = null; T !== null;)T.alternate !== null && (k = T), T = T.sibling; k === null ? y || p.tail === null ? p.tail = null : p.tail.sibling = null : k.sibling = null } } function ys(p) { var y = p.alternate !== null && p.alternate.child === p.child, T = 0, k = 0; if (y) for (var U = p.child; U !== null;)T |= U.lanes | U.childLanes, k |= U.subtreeFlags & 14680064, k |= U.flags & 14680064, U.return = p, U = U.sibling; else for (U = p.child; U !== null;)T |= U.lanes | U.childLanes, k |= U.subtreeFlags, k |= U.flags, U.return = p, U = U.sibling; return p.subtreeFlags |= k, p.childLanes = T, y } function Vme(p, y, T) { var k = y.pendingProps; switch (dc(y), y.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ys(y), null; case 1: return Ba(y.type) && Xp(), ys(y), null; case 3: return k = y.stateNode, uu(), Zr(ts), Zr(ba), Ml(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (p === null || p.child === null) && (Jf(y) ? y.flags |= 4 : p === null || p.memoizedState.isDehydrated && (y.flags & 256) === 0 || (y.flags |= 1024, So !== null && (lj(So), So = null))), ZP(p, y), ys(y), null; case 5: rh(y); var U = Vi(pc.current); if (T = y.type, p !== null && y.stateNode != null) C6(p, y, T, k, U), p.ref !== y.ref && (y.flags |= 512, y.flags |= 2097152); else { if (!k) { if (y.stateNode === null) throw Error(n(166)); return ys(y), null } if (p = Vi(Us.current), Jf(y)) { k = y.stateNode, T = y.type; var W = y.memoizedProps; switch (k[Ji] = y, k[Qf] = W, p = (y.mode & 1) !== 0, T) { case "dialog": Kr("cancel", k), Kr("close", k); break; case "iframe": case "object": case "embed": Kr("load", k); break; case "video": case "audio": for (U = 0; U < su.length; U++)Kr(su[U], k); break; case "source": Kr("error", k); break; case "img": case "image": case "link": Kr("error", k), Kr("load", k); break; case "details": Kr("toggle", k); break; case "input": _e(k, W), Kr("invalid", k); break; case "select": k._wrapperState = { wasMultiple: !!W.multiple }, Kr("invalid", k); break; case "textarea": ee(k, W), Kr("invalid", k) }Se(T, W), U = null; for (var le in W) if (W.hasOwnProperty(le)) { var we = W[le]; le === "children" ? typeof we == "string" ? k.textContent !== we && (W.suppressHydrationWarning !== !0 && Gp(k.textContent, we, p), U = ["children", we]) : typeof we == "number" && k.textContent !== "" + we && (W.suppressHydrationWarning !== !0 && Gp(k.textContent, we, p), U = ["children", "" + we]) : i.hasOwnProperty(le) && we != null && le === "onScroll" && Kr("scroll", k) } switch (T) { case "input": Ce(k), Ze(k, W, !0); break; case "textarea": Ce(k), Re(k); break; case "select": case "option": break; default: typeof W.onClick == "function" && (k.onclick = qp) }k = U, y.updateQueue = k, k !== null && (y.flags |= 4) } else { le = U.nodeType === 9 ? U : U.ownerDocument, p === "http://www.w3.org/1999/xhtml" && (p = Ue(T)), p === "http://www.w3.org/1999/xhtml" ? T === "script" ? (p = le.createElement("div"), p.innerHTML = "<script><\/script>", p = p.removeChild(p.firstChild)) : typeof k.is == "string" ? p = le.createElement(T, { is: k.is }) : (p = le.createElement(T), T === "select" && (le = p, k.multiple ? le.multiple = !0 : k.size && (le.size = k.size))) : p = le.createElementNS(p, T), p[Ji] = y, p[Qf] = k, T6(p, y, !1, !1), y.stateNode = p; e: { switch (le = Fe(T, k), T) { case "dialog": Kr("cancel", p), Kr("close", p), U = k; break; case "iframe": case "object": case "embed": Kr("load", p), U = k; break; case "video": case "audio": for (U = 0; U < su.length; U++)Kr(su[U], p); U = k; break; case "source": Kr("error", p), U = k; break; case "img": case "image": case "link": Kr("error", p), Kr("load", p), U = k; break; case "details": Kr("toggle", p), U = k; break; case "input": _e(p, k), U = xe(p, k), Kr("invalid", p); break; case "option": U = k; break; case "select": p._wrapperState = { wasMultiple: !!k.multiple }, U = K({}, k, { value: void 0 }), Kr("invalid", p); break; case "textarea": ee(p, k), U = St(p, k), Kr("invalid", p); break; default: U = k }Se(T, U), we = U; for (W in we) if (we.hasOwnProperty(W)) { var Pe = we[W]; W === "style" ? bt(p, Pe) : W === "dangerouslySetInnerHTML" ? (Pe = Pe ? Pe.__html : void 0, Pe != null && Xt(p, Pe)) : W === "children" ? typeof Pe == "string" ? (T !== "textarea" || Pe !== "") && yt(p, Pe) : typeof Pe == "number" && yt(p, "" + Pe) : W !== "suppressContentEditableWarning" && W !== "suppressHydrationWarning" && W !== "autoFocus" && (i.hasOwnProperty(W) ? Pe != null && W === "onScroll" && Kr("scroll", p) : Pe != null && M(p, W, Pe, le)) } switch (T) { case "input": Ce(p), Ze(p, k, !1); break; case "textarea": Ce(p), Re(p); break; case "option": k.value != null && p.setAttribute("value", "" + se(k.value)); break; case "select": p.multiple = !!k.multiple, W = k.value, W != null ? Tt(p, !!k.multiple, W, !1) : k.defaultValue != null && Tt(p, !!k.multiple, k.defaultValue, !0); break; default: typeof U.onClick == "function" && (p.onclick = qp) }switch (T) { case "button": case "input": case "select": case "textarea": k = !!k.autoFocus; break e; case "img": k = !0; break e; default: k = !1 } } k && (y.flags |= 4) } y.ref !== null && (y.flags |= 512, y.flags |= 2097152) } return ys(y), null; case 6: if (p && y.stateNode != null) N6(p, y, p.memoizedProps, k); else { if (typeof k != "string" && y.stateNode === null) throw Error(n(166)); if (T = Vi(pc.current), Vi(Us.current), Jf(y)) { if (k = y.stateNode, T = y.memoizedProps, k[Ji] = y, (W = k.nodeValue !== T) && (p = wa, p !== null)) switch (p.tag) { case 3: Gp(k.nodeValue, T, (p.mode & 1) !== 0); break; case 5: p.memoizedProps.suppressHydrationWarning !== !0 && Gp(k.nodeValue, T, (p.mode & 1) !== 0) }W && (y.flags |= 4) } else k = (T.nodeType === 9 ? T : T.ownerDocument).createTextNode(k), k[Ji] = y, y.stateNode = k } return ys(y), null; case 13: if (Zr(ai), k = y.memoizedState, p === null || p.memoizedState !== null && p.memoizedState.dehydrated !== null) { if (ii && rs !== null && (y.mode & 1) !== 0 && (y.flags & 128) === 0) Nb(), lu(), y.flags |= 98560, W = !1; else if (W = Jf(y), k !== null && k.dehydrated !== null) { if (p === null) { if (!W) throw Error(n(318)); if (W = y.memoizedState, W = W !== null ? W.dehydrated : null, !W) throw Error(n(317)); W[Ji] = y } else lu(), (y.flags & 128) === 0 && (y.memoizedState = null), y.flags |= 4; ys(y), W = !1 } else So !== null && (lj(So), So = null), W = !0; if (!W) return y.flags & 65536 ? y : null } return (y.flags & 128) !== 0 ? (y.lanes = T, y) : (k = k !== null, k !== (p !== null && p.memoizedState !== null) && k && (y.child.flags |= 8192, (y.mode & 1) !== 0 && (p === null || (ai.current & 1) !== 0 ? Ma === 0 && (Ma = 3) : dj())), y.updateQueue !== null && (y.flags |= 4), ys(y), null); case 4: return uu(), ZP(p, y), p === null && Yf(y.stateNode.containerInfo), ys(y), null; case 10: return tm(y.type._context), ys(y), null; case 17: return Ba(y.type) && Xp(), ys(y), null; case 19: if (Zr(ai), W = y.memoizedState, W === null) return ys(y), null; if (k = (y.flags & 128) !== 0, le = W.rendering, le === null) if (k) $b(W, !1); else { if (Ma !== 0 || p !== null && (p.flags & 128) !== 0) for (p = y.child; p !== null;) { if (le = Ko(p), le !== null) { for (y.flags |= 128, $b(W, !1), k = le.updateQueue, k !== null && (y.updateQueue = k, y.flags |= 4), y.subtreeFlags = 0, k = T, T = y.child; T !== null;)W = T, p = k, W.flags &= 14680066, le = W.alternate, le === null ? (W.childLanes = 0, W.lanes = p, W.child = null, W.subtreeFlags = 0, W.memoizedProps = null, W.memoizedState = null, W.updateQueue = null, W.dependencies = null, W.stateNode = null) : (W.childLanes = le.childLanes, W.lanes = le.lanes, W.child = le.child, W.subtreeFlags = 0, W.deletions = null, W.memoizedProps = le.memoizedProps, W.memoizedState = le.memoizedState, W.updateQueue = le.updateQueue, W.type = le.type, p = le.dependencies, W.dependencies = p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }), T = T.sibling; return Hr(ai, ai.current & 1 | 2), y.child } p = p.sibling } W.tail !== null && ge() > Yv && (y.flags |= 128, k = !0, $b(W, !1), y.lanes = 4194304) } else { if (!k) if (p = Ko(le), p !== null) { if (y.flags |= 128, k = !0, T = p.updateQueue, T !== null && (y.updateQueue = T, y.flags |= 4), $b(W, !0), W.tail === null && W.tailMode === "hidden" && !le.alternate && !ii) return ys(y), null } else 2 * ge() - W.renderingStartTime > Yv && T !== 1073741824 && (y.flags |= 128, k = !0, $b(W, !1), y.lanes = 4194304); W.isBackwards ? (le.sibling = y.child, y.child = le) : (T = W.last, T !== null ? T.sibling = le : y.child = le, W.last = le) } return W.tail !== null ? (y = W.tail, W.rendering = y, W.tail = y.sibling, W.renderingStartTime = ge(), y.sibling = null, T = ai.current, Hr(ai, k ? T & 1 | 2 : T & 1), y) : (ys(y), null); case 22: case 23: return uj(), k = y.memoizedState !== null, p !== null && p.memoizedState !== null !== k && (y.flags |= 8192), k && (y.mode & 1) !== 0 ? (Jo & 1073741824) !== 0 && (ys(y), y.subtreeFlags & 6 && (y.flags |= 8192)) : ys(y), null; case 24: return null; case 25: return null }throw Error(n(156, y.tag)) } function Hme(p, y) { switch (dc(y), y.tag) { case 1: return Ba(y.type) && Xp(), p = y.flags, p & 65536 ? (y.flags = p & -65537 | 128, y) : null; case 3: return uu(), Zr(ts), Zr(ba), Ml(), p = y.flags, (p & 65536) !== 0 && (p & 128) === 0 ? (y.flags = p & -65537 | 128, y) : null; case 5: return rh(y), null; case 13: if (Zr(ai), p = y.memoizedState, p !== null && p.dehydrated !== null) { if (y.alternate === null) throw Error(n(340)); lu() } return p = y.flags, p & 65536 ? (y.flags = p & -65537 | 128, y) : null; case 19: return Zr(ai), null; case 4: return uu(), null; case 10: return tm(y.type._context), null; case 22: case 23: return uj(), null; case 24: return null; default: return null } } var vE = !1, xs = !1, Wme = typeof WeakSet == "function" ? WeakSet : Set, ln = null; function qv(p, y) { var T = p.ref; if (T !== null) if (typeof T == "function") try { T(null) } catch (k) { Wi(p, y, k) } else T.current = null } function QP(p, y, T) { try { T() } catch (k) { Wi(p, y, k) } } var A6 = !1; function Gme(p, y) { if (Zf = mo, p = _i(), la(p)) { if ("selectionStart" in p) var T = { start: p.selectionStart, end: p.selectionEnd }; else e: { T = (T = p.ownerDocument) && T.defaultView || window; var k = T.getSelection && T.getSelection(); if (k && k.rangeCount !== 0) { T = k.anchorNode; var U = k.anchorOffset, W = k.focusNode; k = k.focusOffset; try { T.nodeType, W.nodeType } catch { T = null; break e } var le = 0, we = -1, Pe = -1, qe = 0, wt = 0, Ct = p, xt = null; t: for (; ;) { for (var rn; Ct !== T || U !== 0 && Ct.nodeType !== 3 || (we = le + U), Ct !== W || k !== 0 && Ct.nodeType !== 3 || (Pe = le + k), Ct.nodeType === 3 && (le += Ct.nodeValue.length), (rn = Ct.firstChild) !== null;)xt = Ct, Ct = rn; for (; ;) { if (Ct === p) break t; if (xt === T && ++qe === U && (we = le), xt === W && ++wt === k && (Pe = le), (rn = Ct.nextSibling) !== null) break; Ct = xt, xt = Ct.parentNode } Ct = rn } T = we === -1 || Pe === -1 ? null : { start: we, end: Pe } } else T = null } T = T || { start: 0, end: 0 } } else T = null; for (gb = { focusedElem: p, selectionRange: T }, mo = !1, ln = y; ln !== null;)if (y = ln, p = y.child, (y.subtreeFlags & 1028) !== 0 && p !== null) p.return = y, ln = p; else for (; ln !== null;) { y = ln; try { var dn = y.alternate; if ((y.flags & 1024) !== 0) switch (y.tag) { case 0: case 11: case 15: break; case 1: if (dn !== null) { var mn = dn.memoizedProps, ea = dn.memoizedState, Be = y.stateNode, Ie = Be.getSnapshotBeforeUpdate(y.elementType === y.type ? mn : _o(y.type, mn), ea); Be.__reactInternalSnapshotBeforeUpdate = Ie } break; case 3: var ze = y.stateNode.containerInfo; ze.nodeType === 1 ? ze.textContent = "" : ze.nodeType === 9 && ze.documentElement && ze.removeChild(ze.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(n(163)) } } catch (Ut) { Wi(y, y.return, Ut) } if (p = y.sibling, p !== null) { p.return = y.return, ln = p; break } ln = y.return } return dn = A6, A6 = !1, dn } function zb(p, y, T) { var k = y.updateQueue; if (k = k !== null ? k.lastEffect : null, k !== null) { var U = k = k.next; do { if ((U.tag & p) === p) { var W = U.destroy; U.destroy = void 0, W !== void 0 && QP(y, T, W) } U = U.next } while (U !== k) } } function yE(p, y) { if (y = y.updateQueue, y = y !== null ? y.lastEffect : null, y !== null) { var T = y = y.next; do { if ((T.tag & p) === p) { var k = T.create; T.destroy = k() } T = T.next } while (T !== y) } } function JP(p) { var y = p.ref; if (y !== null) { var T = p.stateNode; switch (p.tag) { case 5: p = T; break; default: p = T }typeof y == "function" ? y(p) : y.current = p } } function P6(p) { var y = p.alternate; y !== null && (p.alternate = null, P6(y)), p.child = null, p.deletions = null, p.sibling = null, p.tag === 5 && (y = p.stateNode, y !== null && (delete y[Ji], delete y[Qf], delete y[bd], delete y[Pv], delete y[jv])), p.stateNode = null, p.return = null, p.dependencies = null, p.memoizedProps = null, p.memoizedState = null, p.pendingProps = null, p.stateNode = null, p.updateQueue = null } function j6(p) { return p.tag === 5 || p.tag === 3 || p.tag === 4 } function R6(p) { e: for (; ;) { for (; p.sibling === null;) { if (p.return === null || j6(p.return)) return null; p = p.return } for (p.sibling.return = p.return, p = p.sibling; p.tag !== 5 && p.tag !== 6 && p.tag !== 18;) { if (p.flags & 2 || p.child === null || p.tag === 4) continue e; p.child.return = p, p = p.child } if (!(p.flags & 2)) return p.stateNode } } function ej(p, y, T) { var k = p.tag; if (k === 5 || k === 6) p = p.stateNode, y ? T.nodeType === 8 ? T.parentNode.insertBefore(p, y) : T.insertBefore(p, y) : (T.nodeType === 8 ? (y = T.parentNode, y.insertBefore(p, T)) : (y = T, y.appendChild(p)), T = T._reactRootContainer, T != null || y.onclick !== null || (y.onclick = qp)); else if (k !== 4 && (p = p.child, p !== null)) for (ej(p, y, T), p = p.sibling; p !== null;)ej(p, y, T), p = p.sibling } function tj(p, y, T) { var k = p.tag; if (k === 5 || k === 6) p = p.stateNode, y ? T.insertBefore(p, y) : T.appendChild(p); else if (k !== 4 && (p = p.child, p !== null)) for (tj(p, y, T), p = p.sibling; p !== null;)tj(p, y, T), p = p.sibling } var as = null, xc = !1; function sh(p, y, T) { for (T = T.child; T !== null;)k6(p, y, T), T = T.sibling } function k6(p, y, T) { if (kt && typeof kt.onCommitFiberUnmount == "function") try { kt.onCommitFiberUnmount(Pt, T) } catch { } switch (T.tag) { case 5: xs || qv(T, y); case 6: var k = as, U = xc; as = null, sh(p, y, T), as = k, xc = U, as !== null && (xc ? (p = as, T = T.stateNode, p.nodeType === 8 ? p.parentNode.removeChild(T) : p.removeChild(T)) : as.removeChild(T.stateNode)); break; case 18: as !== null && (xc ? (p = as, T = T.stateNode, p.nodeType === 8 ? Av(p.parentNode, T) : p.nodeType === 1 && Av(p, T), Op(p)) : Av(as, T.stateNode)); break; case 4: k = as, U = xc, as = T.stateNode.containerInfo, xc = !0, sh(p, y, T), as = k, xc = U; break; case 0: case 11: case 14: case 15: if (!xs && (k = T.updateQueue, k !== null && (k = k.lastEffect, k !== null))) { U = k = k.next; do { var W = U, le = W.destroy; W = W.tag, le !== void 0 && ((W & 2) !== 0 || (W & 4) !== 0) && QP(T, y, le), U = U.next } while (U !== k) } sh(p, y, T); break; case 1: if (!xs && (qv(T, y), k = T.stateNode, typeof k.componentWillUnmount == "function")) try { k.props = T.memoizedProps, k.state = T.memoizedState, k.componentWillUnmount() } catch (we) { Wi(T, y, we) } sh(p, y, T); break; case 21: sh(p, y, T); break; case 22: T.mode & 1 ? (xs = (k = xs) || T.memoizedState !== null, sh(p, y, T), xs = k) : sh(p, y, T); break; default: sh(p, y, T) } } function I6(p) { var y = p.updateQueue; if (y !== null) { p.updateQueue = null; var T = p.stateNode; T === null && (T = p.stateNode = new Wme), y.forEach(function (k) { var U = tge.bind(null, p, k); T.has(k) || (T.add(k), k.then(U, U)) }) } } function bc(p, y) { var T = y.deletions; if (T !== null) for (var k = 0; k < T.length; k++) { var U = T[k]; try { var W = p, le = y, we = le; e: for (; we !== null;) { switch (we.tag) { case 5: as = we.stateNode, xc = !1; break e; case 3: as = we.stateNode.containerInfo, xc = !0; break e; case 4: as = we.stateNode.containerInfo, xc = !0; break e }we = we.return } if (as === null) throw Error(n(160)); k6(W, le, U), as = null, xc = !1; var Pe = U.alternate; Pe !== null && (Pe.return = null), U.return = null } catch (qe) { Wi(U, y, qe) } } if (y.subtreeFlags & 12854) for (y = y.child; y !== null;)O6(y, p), y = y.sibling } function O6(p, y) { var T = p.alternate, k = p.flags; switch (p.tag) { case 0: case 11: case 14: case 15: if (bc(y, p), fu(p), k & 4) { try { zb(3, p, p.return), yE(3, p) } catch (mn) { Wi(p, p.return, mn) } try { zb(5, p, p.return) } catch (mn) { Wi(p, p.return, mn) } } break; case 1: bc(y, p), fu(p), k & 512 && T !== null && qv(T, T.return); break; case 5: if (bc(y, p), fu(p), k & 512 && T !== null && qv(T, T.return), p.flags & 32) { var U = p.stateNode; try { yt(U, "") } catch (mn) { Wi(p, p.return, mn) } } if (k & 4 && (U = p.stateNode, U != null)) { var W = p.memoizedProps, le = T !== null ? T.memoizedProps : W, we = p.type, Pe = p.updateQueue; if (p.updateQueue = null, Pe !== null) try { we === "input" && W.type === "radio" && W.name != null && je(U, W), Fe(we, le); var qe = Fe(we, W); for (le = 0; le < Pe.length; le += 2) { var wt = Pe[le], Ct = Pe[le + 1]; wt === "style" ? bt(U, Ct) : wt === "dangerouslySetInnerHTML" ? Xt(U, Ct) : wt === "children" ? yt(U, Ct) : M(U, wt, Ct, qe) } switch (we) { case "input": ke(U, W); break; case "textarea": ne(U, W); break; case "select": var xt = U._wrapperState.wasMultiple; U._wrapperState.wasMultiple = !!W.multiple; var rn = W.value; rn != null ? Tt(U, !!W.multiple, rn, !1) : xt !== !!W.multiple && (W.defaultValue != null ? Tt(U, !!W.multiple, W.defaultValue, !0) : Tt(U, !!W.multiple, W.multiple ? [] : "", !1)) }U[Qf] = W } catch (mn) { Wi(p, p.return, mn) } } break; case 6: if (bc(y, p), fu(p), k & 4) { if (p.stateNode === null) throw Error(n(162)); U = p.stateNode, W = p.memoizedProps; try { U.nodeValue = W } catch (mn) { Wi(p, p.return, mn) } } break; case 3: if (bc(y, p), fu(p), k & 4 && T !== null && T.memoizedState.isDehydrated) try { Op(y.containerInfo) } catch (mn) { Wi(p, p.return, mn) } break; case 4: bc(y, p), fu(p); break; case 13: bc(y, p), fu(p), U = p.child, U.flags & 8192 && (W = U.memoizedState !== null, U.stateNode.isHidden = W, !W || U.alternate !== null && U.alternate.memoizedState !== null || (ij = ge())), k & 4 && I6(p); break; case 22: if (wt = T !== null && T.memoizedState !== null, p.mode & 1 ? (xs = (qe = xs) || wt, bc(y, p), xs = qe) : bc(y, p), fu(p), k & 8192) { if (qe = p.memoizedState !== null, (p.stateNode.isHidden = qe) && !wt && (p.mode & 1) !== 0) for (ln = p, wt = p.child; wt !== null;) { for (Ct = ln = wt; ln !== null;) { switch (xt = ln, rn = xt.child, xt.tag) { case 0: case 11: case 14: case 15: zb(4, xt, xt.return); break; case 1: qv(xt, xt.return); var dn = xt.stateNode; if (typeof dn.componentWillUnmount == "function") { k = xt, T = xt.return; try { y = k, dn.props = y.memoizedProps, dn.state = y.memoizedState, dn.componentWillUnmount() } catch (mn) { Wi(k, T, mn) } } break; case 5: qv(xt, xt.return); break; case 22: if (xt.memoizedState !== null) { F6(Ct); continue } }rn !== null ? (rn.return = xt, ln = rn) : F6(Ct) } wt = wt.sibling } e: for (wt = null, Ct = p; ;) { if (Ct.tag === 5) { if (wt === null) { wt = Ct; try { U = Ct.stateNode, qe ? (W = U.style, typeof W.setProperty == "function" ? W.setProperty("display", "none", "important") : W.display = "none") : (we = Ct.stateNode, Pe = Ct.memoizedProps.style, le = Pe != null && Pe.hasOwnProperty("display") ? Pe.display : null, we.style.display = pt("display", le)) } catch (mn) { Wi(p, p.return, mn) } } } else if (Ct.tag === 6) { if (wt === null) try { Ct.stateNode.nodeValue = qe ? "" : Ct.memoizedProps } catch (mn) { Wi(p, p.return, mn) } } else if ((Ct.tag !== 22 && Ct.tag !== 23 || Ct.memoizedState === null || Ct === p) && Ct.child !== null) { Ct.child.return = Ct, Ct = Ct.child; continue } if (Ct === p) break e; for (; Ct.sibling === null;) { if (Ct.return === null || Ct.return === p) break e; wt === Ct && (wt = null), Ct = Ct.return } wt === Ct && (wt = null), Ct.sibling.return = Ct.return, Ct = Ct.sibling } } break; case 19: bc(y, p), fu(p), k & 4 && I6(p); break; case 21: break; default: bc(y, p), fu(p) } } function fu(p) { var y = p.flags; if (y & 2) { try { e: { for (var T = p.return; T !== null;) { if (j6(T)) { var k = T; break e } T = T.return } throw Error(n(160)) } switch (k.tag) { case 5: var U = k.stateNode; k.flags & 32 && (yt(U, ""), k.flags &= -33); var W = R6(p); tj(p, W, U); break; case 3: case 4: var le = k.stateNode.containerInfo, we = R6(p); ej(p, we, le); break; default: throw Error(n(161)) } } catch (Pe) { Wi(p, p.return, Pe) } p.flags &= -3 } y & 4096 && (p.flags &= -4097) } function qme(p, y, T) { ln = p, D6(p) } function D6(p, y, T) { for (var k = (p.mode & 1) !== 0; ln !== null;) { var U = ln, W = U.child; if (U.tag === 22 && k) { var le = U.memoizedState !== null || vE; if (!le) { var we = U.alternate, Pe = we !== null && we.memoizedState !== null || xs; we = vE; var qe = xs; if (vE = le, (xs = Pe) && !qe) for (ln = U; ln !== null;)le = ln, Pe = le.child, le.tag === 22 && le.memoizedState !== null ? U6(U) : Pe !== null ? (Pe.return = le, ln = Pe) : U6(U); for (; W !== null;)ln = W, D6(W), W = W.sibling; ln = U, vE = we, xs = qe } L6(p) } else (U.subtreeFlags & 8772) !== 0 && W !== null ? (W.return = U, ln = W) : L6(p) } } function L6(p) { for (; ln !== null;) { var y = ln; if ((y.flags & 8772) !== 0) { var T = y.alternate; try { if ((y.flags & 8772) !== 0) switch (y.tag) { case 0: case 11: case 15: xs || yE(5, y); break; case 1: var k = y.stateNode; if (y.flags & 4 && !xs) if (T === null) k.componentDidMount(); else { var U = y.elementType === y.type ? T.memoizedProps : _o(y.type, T.memoizedProps); k.componentDidUpdate(U, T.memoizedState, k.__reactInternalSnapshotBeforeUpdate) } var W = y.updateQueue; W !== null && nh(y, W, k); break; case 3: var le = y.updateQueue; if (le !== null) { if (T = null, y.child !== null) switch (y.child.tag) { case 5: T = y.child.stateNode; break; case 1: T = y.child.stateNode }nh(y, le, T) } break; case 5: var we = y.stateNode; if (T === null && y.flags & 4) { T = we; var Pe = y.memoizedProps; switch (y.type) { case "button": case "input": case "select": case "textarea": Pe.autoFocus && T.focus(); break; case "img": Pe.src && (T.src = Pe.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (y.memoizedState === null) { var qe = y.alternate; if (qe !== null) { var wt = qe.memoizedState; if (wt !== null) { var Ct = wt.dehydrated; Ct !== null && Op(Ct) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(n(163)) }xs || y.flags & 512 && JP(y) } catch (xt) { Wi(y, y.return, xt) } } if (y === p) { ln = null; break } if (T = y.sibling, T !== null) { T.return = y.return, ln = T; break } ln = y.return } } function F6(p) { for (; ln !== null;) { var y = ln; if (y === p) { ln = null; break } var T = y.sibling; if (T !== null) { T.return = y.return, ln = T; break } ln = y.return } } function U6(p) { for (; ln !== null;) { var y = ln; try { switch (y.tag) { case 0: case 11: case 15: var T = y.return; try { yE(4, y) } catch (Pe) { Wi(y, T, Pe) } break; case 1: var k = y.stateNode; if (typeof k.componentDidMount == "function") { var U = y.return; try { k.componentDidMount() } catch (Pe) { Wi(y, U, Pe) } } var W = y.return; try { JP(y) } catch (Pe) { Wi(y, W, Pe) } break; case 5: var le = y.return; try { JP(y) } catch (Pe) { Wi(y, le, Pe) } } } catch (Pe) { Wi(y, y.return, Pe) } if (y === p) { ln = null; break } var we = y.sibling; if (we !== null) { we.return = y.return, ln = we; break } ln = y.return } } var Xme = Math.ceil, xE = C.ReactCurrentDispatcher, nj = C.ReactCurrentOwner, Cl = C.ReactCurrentBatchConfig, Ar = 0, Va = null, ha = null, ss = 0, Jo = 0, Xv = Ni(0), Ma = 0, Vb = null, fm = 0, bE = 0, rj = 0, Hb = null, Eo = null, ij = 0, Yv = 1 / 0, Dd = null, wE = !1, aj = null, oh = null, SE = !1, lh = null, _E = 0, Wb = 0, sj = null, EE = -1, ME = 0; function Vs() { return (Ar & 6) !== 0 ? ge() : EE !== -1 ? EE : EE = ge() } function ch(p) { return (p.mode & 1) === 0 ? 1 : (Ar & 2) !== 0 && ss !== 0 ? ss & -ss : XP.transition !== null ? (ME === 0 && (ME = ur()), ME) : (p = nr, p !== 0 || (p = window.event, p = p === void 0 ? 16 : H_(p.type)), p) } function wc(p, y, T, k) { if (50 < Wb) throw Wb = 0, sj = null, Error(n(185)); yr(p, T, k), ((Ar & 2) === 0 || p !== Va) && (p === Va && ((Ar & 2) === 0 && (bE |= T), Ma === 4 && uh(p, ss)), Mo(p, k), T === 1 && Ar === 0 && (y.mode & 1) === 0 && (Yv = ge() + 500, Kp && _l())) } function Mo(p, y) { var T = p.callbackNode; vr(p, y); var k = tr(p, p === Va ? ss : 0); if (k === 0) T !== null && ye(T), p.callbackNode = null, p.callbackPriority = 0; else if (y = k & -k, p.callbackPriority !== y) { if (T != null && ye(T), y === 1) p.tag === 0 ? iE($6.bind(null, p)) : Zp($6.bind(null, p)), qP(function () { (Ar & 6) === 0 && _l() }), T = null; else { switch (Df(k)) { case 1: T = Ke; break; case 4: T = st; break; case 16: T = ft; break; case 536870912: T = $t; break; default: T = ft }T = Y6(T, B6.bind(null, p)) } p.callbackPriority = y, p.callbackNode = T } } function B6(p, y) { if (EE = -1, ME = 0, (Ar & 6) !== 0) throw Error(n(327)); var T = p.callbackNode; if (Kv() && p.callbackNode !== T) return null; var k = tr(p, p === Va ? ss : 0); if (k === 0) return null; if ((k & 30) !== 0 || (k & p.expiredLanes) !== 0 || y) y = TE(p, k); else { y = k; var U = Ar; Ar |= 2; var W = V6(); (Va !== p || ss !== y) && (Dd = null, Yv = ge() + 500, pm(p, y)); do try { Zme(); break } catch (we) { z6(p, we) } while (!0); Nd(), xE.current = W, Ar = U, ha !== null ? y = 0 : (Va = null, ss = 0, y = Ma) } if (y !== 0) { if (y === 2 && (U = yn(p), U !== 0 && (k = U, y = oj(p, U))), y === 1) throw T = Vb, pm(p, 0), uh(p, k), Mo(p, ge()), T; if (y === 6) uh(p, k); else { if (U = p.current.alternate, (k & 30) === 0 && !Yme(U) && (y = TE(p, k), y === 2 && (W = yn(p), W !== 0 && (k = W, y = oj(p, W))), y === 1)) throw T = Vb, pm(p, 0), uh(p, k), Mo(p, ge()), T; switch (p.finishedWork = U, p.finishedLanes = k, y) { case 0: case 1: throw Error(n(345)); case 2: mm(p, Eo, Dd); break; case 3: if (uh(p, k), (k & 130023424) === k && (y = ij + 500 - ge(), 10 < y)) { if (tr(p, 0) !== 0) break; if (U = p.suspendedLanes, (U & k) !== k) { Vs(), p.pingedLanes |= p.suspendedLanes & U; break } p.timeoutHandle = yb(mm.bind(null, p, Eo, Dd), y); break } mm(p, Eo, Dd); break; case 4: if (uh(p, k), (k & 4194240) === k) break; for (y = p.eventTimes, U = -1; 0 < k;) { var le = 31 - tn(k); W = 1 << le, le = y[le], le > U && (U = le), k &= ~W } if (k = U, k = ge() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * Xme(k / 1960)) - k, 10 < k) { p.timeoutHandle = yb(mm.bind(null, p, Eo, Dd), k); break } mm(p, Eo, Dd); break; case 5: mm(p, Eo, Dd); break; default: throw Error(n(329)) } } } return Mo(p, ge()), p.callbackNode === T ? B6.bind(null, p) : null } function oj(p, y) { var T = Hb; return p.current.memoizedState.isDehydrated && (pm(p, y).flags |= 256), p = TE(p, y), p !== 2 && (y = Eo, Eo = T, y !== null && lj(y)), p } function lj(p) { Eo === null ? Eo = p : Eo.push.apply(Eo, p) } function Yme(p) { for (var y = p; ;) { if (y.flags & 16384) { var T = y.updateQueue; if (T !== null && (T = T.stores, T !== null)) for (var k = 0; k < T.length; k++) { var U = T[k], W = U.getSnapshot; U = U.value; try { if (!Os(W(), U)) return !1 } catch { return !1 } } } if (T = y.child, y.subtreeFlags & 16384 && T !== null) T.return = y, y = T; else { if (y === p) break; for (; y.sibling === null;) { if (y.return === null || y.return === p) return !0; y = y.return } y.sibling.return = y.return, y = y.sibling } } return !0 } function uh(p, y) { for (y &= ~rj, y &= ~bE, p.suspendedLanes |= y, p.pingedLanes &= ~y, p = p.expirationTimes; 0 < y;) { var T = 31 - tn(y), k = 1 << T; p[T] = -1, y &= ~k } } function $6(p) { if ((Ar & 6) !== 0) throw Error(n(327)); Kv(); var y = tr(p, 0); if ((y & 1) === 0) return Mo(p, ge()), null; var T = TE(p, y); if (p.tag !== 0 && T === 2) { var k = yn(p); k !== 0 && (y = k, T = oj(p, k)) } if (T === 1) throw T = Vb, pm(p, 0), uh(p, y), Mo(p, ge()), T; if (T === 6) throw Error(n(345)); return p.finishedWork = p.current.alternate, p.finishedLanes = y, mm(p, Eo, Dd), Mo(p, ge()), null } function cj(p, y) { var T = Ar; Ar |= 1; try { return p(y) } finally { Ar = T, Ar === 0 && (Yv = ge() + 500, Kp && _l()) } } function hm(p) { lh !== null && lh.tag === 0 && (Ar & 6) === 0 && Kv(); var y = Ar; Ar |= 1; var T = Cl.transition, k = nr; try { if (Cl.transition = null, nr = 1, p) return p() } finally { nr = k, Cl.transition = T, Ar = y, (Ar & 6) === 0 && _l() } } function uj() { Jo = Xv.current, Zr(Xv) } function pm(p, y) { p.finishedWork = null, p.finishedLanes = 0; var T = p.timeoutHandle; if (T !== -1 && (p.timeoutHandle = -1, xb(T)), ha !== null) for (T = ha.return; T !== null;) { var k = T; switch (dc(k), k.tag) { case 1: k = k.type.childContextTypes, k != null && Xp(); break; case 3: uu(), Zr(ts), Zr(ba), Ml(); break; case 5: rh(k); break; case 4: uu(); break; case 13: Zr(ai); break; case 19: Zr(ai); break; case 10: tm(k.type._context); break; case 22: case 23: uj() }T = T.return } if (Va = p, ha = p = dh(p.current, null), ss = Jo = y, Ma = 0, Vb = null, rj = bE = fm = 0, Eo = Hb = null, hc !== null) { for (y = 0; y < hc.length; y++)if (T = hc[y], k = T.interleaved, k !== null) { T.interleaved = null; var U = k.next, W = T.pending; if (W !== null) { var le = W.next; W.next = U, k.next = le } T.pending = k } hc = null } return p } function z6(p, y) { do { var T = ha; try { if (Nd(), Rd.current = Wv, Zo) { for (var k = Qr.memoizedState; k !== null;) { var U = k.queue; U !== null && (U.pending = null), k = k.next } Zo = !1 } if (mc = 0, Cr = Pi = Qr = null, za = !1, du = 0, nj.current = null, T === null || T.return === null) { Ma = 1, Vb = y, ha = null; break } e: { var W = p, le = T.return, we = T, Pe = y; if (y = ss, we.flags |= 32768, Pe !== null && typeof Pe == "object" && typeof Pe.then == "function") { var qe = Pe, wt = we, Ct = wt.tag; if ((wt.mode & 1) === 0 && (Ct === 0 || Ct === 11 || Ct === 15)) { var xt = wt.alternate; xt ? (wt.updateQueue = xt.updateQueue, wt.memoizedState = xt.memoizedState, wt.lanes = xt.lanes) : (wt.updateQueue = null, wt.memoizedState = null) } var rn = an(le); if (rn !== null) { rn.flags &= -257, Bn(rn, le, we, W, y), rn.mode & 1 && Ot(W, qe, y), y = rn, Pe = qe; var dn = y.updateQueue; if (dn === null) { var mn = new Set; mn.add(Pe), y.updateQueue = mn } else dn.add(Pe); break e } else { if ((y & 1) === 0) { Ot(W, qe, y), dj(); break e } Pe = Error(n(426)) } } else if (ii && we.mode & 1) { var ea = an(le); if (ea !== null) { (ea.flags & 65536) === 0 && (ea.flags |= 256), Bn(ea, le, we, W, y), eh(L(Pe, we)); break e } } W = Pe = L(Pe, we), Ma !== 4 && (Ma = 2), Hb === null ? Hb = [W] : Hb.push(W), W = le; do { switch (W.tag) { case 3: W.flags |= 65536, y &= -y, W.lanes |= y; var Be = Oe(W, Pe, y); Ad(W, Be); break e; case 1: we = Pe; var Ie = W.type, ze = W.stateNode; if ((W.flags & 128) === 0 && (typeof Ie.getDerivedStateFromError == "function" || ze !== null && typeof ze.componentDidCatch == "function" && (oh === null || !oh.has(ze)))) { W.flags |= 65536, y &= -y, W.lanes |= y; var Ut = tt(W, we, y); Ad(W, Ut); break e } }W = W.return } while (W !== null) } W6(T) } catch (xn) { y = xn, ha === T && T !== null && (ha = T = T.return); continue } break } while (!0) } function V6() { var p = xE.current; return xE.current = Wv, p === null ? Wv : p } function dj() { (Ma === 0 || Ma === 3 || Ma === 2) && (Ma = 4), Va === null || (fm & 268435455) === 0 && (bE & 268435455) === 0 || uh(Va, ss) } function TE(p, y) { var T = Ar; Ar |= 2; var k = V6(); (Va !== p || ss !== y) && (Dd = null, pm(p, y)); do try { Kme(); break } catch (U) { z6(p, U) } while (!0); if (Nd(), Ar = T, xE.current = k, ha !== null) throw Error(n(261)); return Va = null, ss = 0, Ma } function Kme() { for (; ha !== null;)H6(ha) } function Zme() { for (; ha !== null && !Me();)H6(ha) } function H6(p) { var y = X6(p.alternate, p, Jo); p.memoizedProps = p.pendingProps, y === null ? W6(p) : ha = y, nj.current = null } function W6(p) { var y = p; do { var T = y.alternate; if (p = y.return, (y.flags & 32768) === 0) { if (T = Vme(T, y, Jo), T !== null) { ha = T; return } } else { if (T = Hme(T, y), T !== null) { T.flags &= 32767, ha = T; return } if (p !== null) p.flags |= 32768, p.subtreeFlags = 0, p.deletions = null; else { Ma = 6, ha = null; return } } if (y = y.sibling, y !== null) { ha = y; return } ha = y = p } while (y !== null); Ma === 0 && (Ma = 5) } function mm(p, y, T) { var k = nr, U = Cl.transition; try { Cl.transition = null, nr = 1, Qme(p, y, T, k) } finally { Cl.transition = U, nr = k } return null } function Qme(p, y, T, k) { do Kv(); while (lh !== null); if ((Ar & 6) !== 0) throw Error(n(327)); T = p.finishedWork; var U = p.finishedLanes; if (T === null) return null; if (p.finishedWork = null, p.finishedLanes = 0, T === p.current) throw Error(n(177)); p.callbackNode = null, p.callbackPriority = 0; var W = T.lanes | T.childLanes; if (ri(p, W), p === Va && (ha = Va = null, ss = 0), (T.subtreeFlags & 2064) === 0 && (T.flags & 2064) === 0 || SE || (SE = !0, Y6(ft, function () { return Kv(), null })), W = (T.flags & 15990) !== 0, (T.subtreeFlags & 15990) !== 0 || W) { W = Cl.transition, Cl.transition = null; var le = nr; nr = 1; var we = Ar; Ar |= 4, nj.current = null, Gme(p, T), O6(T, p), ca(gb), mo = !!Zf, gb = Zf = null, p.current = T, qme(T), Te(), Ar = we, nr = le, Cl.transition = W } else p.current = T; if (SE && (SE = !1, lh = p, _E = U), W = p.pendingLanes, W === 0 && (oh = null), Zt(T.stateNode), Mo(p, ge()), y !== null) for (k = p.onRecoverableError, T = 0; T < y.length; T++)U = y[T], k(U.value, { componentStack: U.stack, digest: U.digest }); if (wE) throw wE = !1, p = aj, aj = null, p; return (_E & 1) !== 0 && p.tag !== 0 && Kv(), W = p.pendingLanes, (W & 1) !== 0 ? p === sj ? Wb++ : (Wb = 0, sj = p) : Wb = 0, _l(), null } function Kv() { if (lh !== null) { var p = Df(_E), y = Cl.transition, T = nr; try { if (Cl.transition = null, nr = 16 > p ? 16 : p, lh === null) var k = !1; else { if (p = lh, lh = null, _E = 0, (Ar & 6) !== 0) throw Error(n(331)); var U = Ar; for (Ar |= 4, ln = p.current; ln !== null;) { var W = ln, le = W.child; if ((ln.flags & 16) !== 0) { var we = W.deletions; if (we !== null) { for (var Pe = 0; Pe < we.length; Pe++) { var qe = we[Pe]; for (ln = qe; ln !== null;) { var wt = ln; switch (wt.tag) { case 0: case 11: case 15: zb(8, wt, W) }var Ct = wt.child; if (Ct !== null) Ct.return = wt, ln = Ct; else for (; ln !== null;) { wt = ln; var xt = wt.sibling, rn = wt.return; if (P6(wt), wt === qe) { ln = null; break } if (xt !== null) { xt.return = rn, ln = xt; break } ln = rn } } } var dn = W.alternate; if (dn !== null) { var mn = dn.child; if (mn !== null) { dn.child = null; do { var ea = mn.sibling; mn.sibling = null, mn = ea } while (mn !== null) } } ln = W } } if ((W.subtreeFlags & 2064) !== 0 && le !== null) le.return = W, ln = le; else e: for (; ln !== null;) { if (W = ln, (W.flags & 2048) !== 0) switch (W.tag) { case 0: case 11: case 15: zb(9, W, W.return) }var Be = W.sibling; if (Be !== null) { Be.return = W.return, ln = Be; break e } ln = W.return } } var Ie = p.current; for (ln = Ie; ln !== null;) { le = ln; var ze = le.child; if ((le.subtreeFlags & 2064) !== 0 && ze !== null) ze.return = le, ln = ze; else e: for (le = Ie; ln !== null;) { if (we = ln, (we.flags & 2048) !== 0) try { switch (we.tag) { case 0: case 11: case 15: yE(9, we) } } catch (xn) { Wi(we, we.return, xn) } if (we === le) { ln = null; break e } var Ut = we.sibling; if (Ut !== null) { Ut.return = we.return, ln = Ut; break e } ln = we.return } } if (Ar = U, _l(), kt && typeof kt.onPostCommitFiberRoot == "function") try { kt.onPostCommitFiberRoot(Pt, p) } catch { } k = !0 } return k } finally { nr = T, Cl.transition = y } } return !1 } function G6(p, y, T) { y = L(T, y), y = Oe(p, y, 1), p = hi(p, y, 1), y = Vs(), p !== null && (yr(p, 1, y), Mo(p, y)) } function Wi(p, y, T) { if (p.tag === 3) G6(p, p, T); else for (; y !== null;) { if (y.tag === 3) { G6(y, p, T); break } else if (y.tag === 1) { var k = y.stateNode; if (typeof y.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (oh === null || !oh.has(k))) { p = L(T, p), p = tt(y, p, 1), y = hi(y, p, 1), p = Vs(), y !== null && (yr(y, 1, p), Mo(y, p)); break } } y = y.return } } function Jme(p, y, T) { var k = p.pingCache; k !== null && k.delete(y), y = Vs(), p.pingedLanes |= p.suspendedLanes & T, Va === p && (ss & T) === T && (Ma === 4 || Ma === 3 && (ss & 130023424) === ss && 500 > ge() - ij ? pm(p, 0) : rj |= T), Mo(p, y) } function q6(p, y) { y === 0 && ((p.mode & 1) === 0 ? y = 1 : (y = bn, bn <<= 1, (bn & 130023424) === 0 && (bn = 4194304))); var T = Vs(); p = Yo(p, y), p !== null && (yr(p, y, T), Mo(p, T)) } function ege(p) { var y = p.memoizedState, T = 0; y !== null && (T = y.retryLane), q6(p, T) } function tge(p, y) { var T = 0; switch (p.tag) { case 13: var k = p.stateNode, U = p.memoizedState; U !== null && (T = U.retryLane); break; case 19: k = p.stateNode; break; default: throw Error(n(314)) }k !== null && k.delete(y), q6(p, T) } var X6; X6 = function (p, y, T) { if (p !== null) if (p.memoizedProps !== y.pendingProps || ts.current) rr = !0; else { if ((p.lanes & T) === 0 && (y.flags & 128) === 0) return rr = !1, zme(p, y, T); rr = (p.flags & 131072) !== 0 } else rr = !1, ii && (y.flags & 1048576) !== 0 && Eb(y, Ov, y.index); switch (y.lanes = 0, y.tag) { case 2: var k = y.type; gE(p, y), p = y.pendingProps; var U = wd(y, ba.current); cu(y, T), U = sm(null, y, k, p, U, T); var W = Rb(); return y.flags |= 1, typeof U == "object" && U !== null && typeof U.render == "function" && U.$$typeof === void 0 ? (y.tag = 1, y.memoizedState = null, y.updateQueue = null, Ba(k) ? (W = !0, Sd(y)) : W = !1, y.memoizedState = U.state !== null && U.state !== void 0 ? U.state : null, Zn(y), U.updater = Gv, y.stateNode = U, U._reactInternals = y, R(y, k, p, T), y = Wn(null, y, k, !0, W, T)) : (y.tag = 0, ii && W && Mb(y), Qt(null, y, U, T), y = y.child), y; case 16: k = y.elementType; e: { switch (gE(p, y), p = y.pendingProps, U = k._init, k = U(k._payload), y.type = k, U = y.tag = rge(k), p = _o(k, p), U) { case 0: y = Ht(null, y, k, p, T); break e; case 1: y = gn(null, y, k, p, T); break e; case 11: y = Ea(null, y, k, p, T); break e; case 14: y = zs(null, y, k, _o(k.type, p), T); break e }throw Error(n(306, k, "")) } return y; case 0: return k = y.type, U = y.pendingProps, U = y.elementType === k ? U : _o(k, U), Ht(p, y, k, U, T); case 1: return k = y.type, U = y.pendingProps, U = y.elementType === k ? U : _o(k, U), gn(p, y, k, U, T); case 3: e: { if ($n(y), p === null) throw Error(n(387)); k = y.pendingProps, W = y.memoizedState, U = W.element, Oi(p, y), Ai(y, k, null, T); var le = y.memoizedState; if (k = le.element, W.isDehydrated) if (W = { element: k, isDehydrated: !1, cache: le.cache, pendingSuspenseBoundaries: le.pendingSuspenseBoundaries, transitions: le.transitions }, y.updateQueue.baseState = W, y.memoizedState = W, y.flags & 256) { U = L(Error(n(423)), y), y = _r(p, y, k, T, U); break e } else if (k !== U) { U = L(Error(n(424)), y), y = _r(p, y, k, T, U); break e } else for (rs = sc(y.stateNode.containerInfo.firstChild), wa = y, ii = !0, So = null, T = em(y, null, k, T), y.child = T; T;)T.flags = T.flags & -3 | 4096, T = T.sibling; else { if (lu(), k === U) { y = Od(p, y, T); break e } Qt(p, y, k, T) } y = y.child } return y; case 5: return jd(y), p === null && Lv(y), k = y.type, U = y.pendingProps, W = p !== null ? p.memoizedProps : null, le = U.children, vb(k, U) ? le = null : W !== null && vb(k, W) && (y.flags |= 32), Ye(p, y), Qt(p, y, le, T), y.child; case 6: return p === null && Lv(y), null; case 13: return yc(p, y, T); case 4: return im(y, y.stateNode.containerInfo), k = y.pendingProps, p === null ? y.child = Md(y, null, k, T) : Qt(p, y, k, T), y.child; case 11: return k = y.type, U = y.pendingProps, U = y.elementType === k ? U : _o(k, U), Ea(p, y, k, U, T); case 7: return Qt(p, y, y.pendingProps, T), y.child; case 8: return Qt(p, y, y.pendingProps.children, T), y.child; case 12: return Qt(p, y, y.pendingProps.children, T), y.child; case 10: e: { if (k = y.type._context, U = y.pendingProps, W = y.memoizedProps, le = U.value, Hr(Td, k._currentValue), k._currentValue = le, W !== null) if (Os(W.value, le)) { if (W.children === U.children && !ts.current) { y = Od(p, y, T); break e } } else for (W = y.child, W !== null && (W.return = y); W !== null;) { var we = W.dependencies; if (we !== null) { le = W.child; for (var Pe = we.firstContext; Pe !== null;) { if (Pe.context === k) { if (W.tag === 1) { Pe = Br(-1, T & -T), Pe.tag = 2; var qe = W.updateQueue; if (qe !== null) { qe = qe.shared; var wt = qe.pending; wt === null ? Pe.next = Pe : (Pe.next = wt.next, wt.next = Pe), qe.pending = Pe } } W.lanes |= T, Pe = W.alternate, Pe !== null && (Pe.lanes |= T), nm(W.return, T, y), we.lanes |= T; break } Pe = Pe.next } } else if (W.tag === 10) le = W.type === y.type ? null : W.child; else if (W.tag === 18) { if (le = W.return, le === null) throw Error(n(341)); le.lanes |= T, we = le.alternate, we !== null && (we.lanes |= T), nm(le, T, y), le = W.sibling } else le = W.child; if (le !== null) le.return = W; else for (le = W; le !== null;) { if (le === y) { le = null; break } if (W = le.sibling, W !== null) { W.return = le.return, le = W; break } le = le.return } W = le } Qt(p, y, U.children, T), y = y.child } return y; case 9: return U = y.type, k = y.pendingProps.children, cu(y, T), U = Fs(U), k = k(U), y.flags |= 1, Qt(p, y, k, T), y.child; case 14: return k = y.type, U = _o(k, y.pendingProps), U = _o(k.type, U), zs(p, y, k, U, T); case 15: return Ve(p, y, y.type, y.pendingProps, T); case 17: return k = y.type, U = y.pendingProps, U = y.elementType === k ? U : _o(k, U), gE(p, y), y.tag = 1, Ba(k) ? (p = !0, Sd(y)) : p = !1, cu(y, T), w(y, k, U), R(y, k, U, T), Wn(null, y, k, !0, p, T); case 19: return M6(p, y, T); case 22: return Le(p, y, T) }throw Error(n(156, y.tag)) }; function Y6(p, y) { return te(p, y) } function nge(p, y, T, k) { this.tag = p, this.key = T, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = y, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Nl(p, y, T, k) { return new nge(p, y, T, k) } function fj(p) { return p = p.prototype, !(!p || !p.isReactComponent) } function rge(p) { if (typeof p == "function") return fj(p) ? 1 : 0; if (p != null) { if (p = p.$$typeof, p === B) return 11; if (p === q) return 14 } return 2 } function dh(p, y) { var T = p.alternate; return T === null ? (T = Nl(p.tag, y, p.key, p.mode), T.elementType = p.elementType, T.type = p.type, T.stateNode = p.stateNode, T.alternate = p, p.alternate = T) : (T.pendingProps = y, T.type = p.type, T.flags = 0, T.subtreeFlags = 0, T.deletions = null), T.flags = p.flags & 14680064, T.childLanes = p.childLanes, T.lanes = p.lanes, T.child = p.child, T.memoizedProps = p.memoizedProps, T.memoizedState = p.memoizedState, T.updateQueue = p.updateQueue, y = p.dependencies, T.dependencies = y === null ? null : { lanes: y.lanes, firstContext: y.firstContext }, T.sibling = p.sibling, T.index = p.index, T.ref = p.ref, T } function CE(p, y, T, k, U, W) { var le = 2; if (k = p, typeof p == "function") fj(p) && (le = 1); else if (typeof p == "string") le = 5; else e: switch (p) { case j: return gm(T.children, U, W, y); case O: le = 8, U |= 8; break; case I: return p = Nl(12, T, y, U | 2), p.elementType = I, p.lanes = W, p; case G: return p = Nl(13, T, y, U), p.elementType = G, p.lanes = W, p; case z: return p = Nl(19, T, y, U), p.elementType = z, p.lanes = W, p; case Z: return NE(T, U, W, y); default: if (typeof p == "object" && p !== null) switch (p.$$typeof) { case D: le = 10; break e; case F: le = 9; break e; case B: le = 11; break e; case q: le = 14; break e; case Y: le = 16, k = null; break e }throw Error(n(130, p == null ? p : typeof p, "")) }return y = Nl(le, T, y, U), y.elementType = p, y.type = k, y.lanes = W, y } function gm(p, y, T, k) { return p = Nl(7, p, k, y), p.lanes = T, p } function NE(p, y, T, k) { return p = Nl(22, p, k, y), p.elementType = Z, p.lanes = T, p.stateNode = { isHidden: !1 }, p } function hj(p, y, T) { return p = Nl(6, p, null, y), p.lanes = T, p } function pj(p, y, T) { return y = Nl(4, p.children !== null ? p.children : [], p.key, y), y.lanes = T, y.stateNode = { containerInfo: p.containerInfo, pendingChildren: null, implementation: p.implementation }, y } function ige(p, y, T, k, U) { this.tag = y, this.containerInfo = p, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = di(0), this.expirationTimes = di(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = di(0), this.identifierPrefix = k, this.onRecoverableError = U, this.mutableSourceEagerHydrationData = null } function mj(p, y, T, k, U, W, le, we, Pe) { return p = new ige(p, y, T, we, Pe), y === 1 ? (y = 1, W === !0 && (y |= 8)) : y = 0, W = Nl(3, null, null, y), p.current = W, W.stateNode = p, W.memoizedState = { element: k, isDehydrated: T, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Zn(W), p } function age(p, y, T) { var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: A, key: k == null ? null : "" + k, children: p, containerInfo: y, implementation: T } } function K6(p) { if (!p) return lc; p = p._reactInternals; e: { if (ue(p) !== p || p.tag !== 1) throw Error(n(170)); var y = p; do { switch (y.tag) { case 3: y = y.stateNode.context; break e; case 1: if (Ba(y.type)) { y = y.stateNode.__reactInternalMemoizedMergedChildContext; break e } }y = y.return } while (y !== null); throw Error(n(171)) } if (p.tag === 1) { var T = p.type; if (Ba(T)) return Yp(p, T, y) } return y } function Z6(p, y, T, k, U, W, le, we, Pe) { return p = mj(T, k, !0, p, U, W, le, we, Pe), p.context = K6(null), T = p.current, k = Vs(), U = ch(T), W = Br(k, U), W.callback = y ?? null, hi(T, W, U), p.current.lanes = U, yr(p, U, k), Mo(p, k), p } function AE(p, y, T, k) { var U = y.current, W = Vs(), le = ch(U); return T = K6(T), y.context === null ? y.context = T : y.pendingContext = T, y = Br(W, le), y.payload = { element: p }, k = k === void 0 ? null : k, k !== null && (y.callback = k), p = hi(U, y, le), p !== null && (wc(p, U, le, W), $a(p, U, le)), le } function PE(p) { if (p = p.current, !p.child) return null; switch (p.child.tag) { case 5: return p.child.stateNode; default: return p.child.stateNode } } function Q6(p, y) { if (p = p.memoizedState, p !== null && p.dehydrated !== null) { var T = p.retryLane; p.retryLane = T !== 0 && T < y ? T : y } } function gj(p, y) { Q6(p, y), (p = p.alternate) && Q6(p, y) } function sge() { return null } var J6 = typeof reportError == "function" ? reportError : function (p) { console.error(p) }; function vj(p) { this._internalRoot = p } jE.prototype.render = vj.prototype.render = function (p) { var y = this._internalRoot; if (y === null) throw Error(n(409)); AE(p, y, null, null) }, jE.prototype.unmount = vj.prototype.unmount = function () { var p = this._internalRoot; if (p !== null) { this._internalRoot = null; var y = p.containerInfo; hm(function () { AE(null, p, null, null) }), y[Ls] = null } }; function jE(p) { this._internalRoot = p } jE.prototype.unstable_scheduleHydration = function (p) { if (p) { var y = ev(); p = { blockedOn: null, target: p, priority: y }; for (var T = 0; T < eu.length && y !== 0 && y < eu[T].priority; T++); eu.splice(T, 0, p), T === 0 && rv(p) } }; function yj(p) { return !(!p || p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11) } function RE(p) { return !(!p || p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11 && (p.nodeType !== 8 || p.nodeValue !== " react-mount-point-unstable ")) } function e8() { } function oge(p, y, T, k, U) { if (U) { if (typeof k == "function") { var W = k; k = function () { var qe = PE(le); W.call(qe) } } var le = Z6(y, k, p, 0, null, !1, !1, "", e8); return p._reactRootContainer = le, p[Ls] = le.current, Yf(p.nodeType === 8 ? p.parentNode : p), hm(), le } for (; U = p.lastChild;)p.removeChild(U); if (typeof k == "function") { var we = k; k = function () { var qe = PE(Pe); we.call(qe) } } var Pe = mj(p, 0, !1, null, null, !1, !1, "", e8); return p._reactRootContainer = Pe, p[Ls] = Pe.current, Yf(p.nodeType === 8 ? p.parentNode : p), hm(function () { AE(y, Pe, T, k) }), Pe } function kE(p, y, T, k, U) { var W = T._reactRootContainer; if (W) { var le = W; if (typeof U == "function") { var we = U; U = function () { var Pe = PE(le); we.call(Pe) } } AE(y, le, p, U) } else le = oge(T, y, p, U, k); return PE(le) } Rp = function (p) { switch (p.tag) { case 3: var y = p.stateNode; if (y.current.memoizedState.isDehydrated) { var T = gr(y.pendingLanes); T !== 0 && (yl(y, T | 1), Mo(y, ge()), (Ar & 6) === 0 && (Yv = ge() + 500, _l())) } break; case 13: hm(function () { var k = Yo(p, 1); if (k !== null) { var U = Vs(); wc(k, p, 1, U) } }), gj(p, 1) } }, J0 = function (p) { if (p.tag === 13) { var y = Yo(p, 134217728); if (y !== null) { var T = Vs(); wc(y, p, 134217728, T) } gj(p, 134217728) } }, V_ = function (p) { if (p.tag === 13) { var y = ch(p), T = Yo(p, y); if (T !== null) { var k = Vs(); wc(T, p, y, k) } gj(p, y) } }, ev = function () { return nr }, tv = function (p, y) { var T = nr; try { return nr = p, y() } finally { nr = T } }, De = function (p, y, T) { switch (y) { case "input": if (ke(p, T), y = T.name, T.type === "radio" && y != null) { for (T = p; T.parentNode;)T = T.parentNode; for (T = T.querySelectorAll("input[name=" + JSON.stringify("" + y) + '][type="radio"]'), y = 0; y < T.length; y++) { var k = T[y]; if (k !== p && k.form === p.form) { var U = Rv(k); if (!U) throw Error(n(90)); fe(k), ke(k, U) } } } break; case "textarea": ne(p, T); break; case "select": y = T.value, y != null && Tt(p, !!T.multiple, y, !1) } }, Ft = cj, un = hm; var lge = { usingClientEntryPoint: !1, Events: [oc, Ii, Rv, ot, it, cj] }, Gb = { findFiberByHostInstance: ou, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, cge = { bundleType: Gb.bundleType, version: Gb.version, rendererPackageName: Gb.rendererPackageName, rendererConfig: Gb.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: C.ReactCurrentDispatcher, findHostInstanceByFiber: function (p) { return p = Je(p), p === null ? null : p.stateNode }, findFiberByHostInstance: Gb.findFiberByHostInstance || sge, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var IE = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!IE.isDisabled && IE.supportsFiber) try { Pt = IE.inject(cge), kt = IE } catch { } } return To.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lge, To.createPortal = function (p, y) { var T = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!yj(y)) throw Error(n(200)); return age(p, y, null, T) }, To.createRoot = function (p, y) { if (!yj(p)) throw Error(n(299)); var T = !1, k = "", U = J6; return y != null && (y.unstable_strictMode === !0 && (T = !0), y.identifierPrefix !== void 0 && (k = y.identifierPrefix), y.onRecoverableError !== void 0 && (U = y.onRecoverableError)), y = mj(p, 1, !1, null, null, T, !1, k, U), p[Ls] = y.current, Yf(p.nodeType === 8 ? p.parentNode : p), new vj(y) }, To.findDOMNode = function (p) { if (p == null) return null; if (p.nodeType === 1) return p; var y = p._reactInternals; if (y === void 0) throw typeof p.render == "function" ? Error(n(188)) : (p = Object.keys(p).join(","), Error(n(268, p))); return p = Je(y), p = p === null ? null : p.stateNode, p }, To.flushSync = function (p) { return hm(p) }, To.hydrate = function (p, y, T) { if (!RE(y)) throw Error(n(200)); return kE(null, p, y, !0, T) }, To.hydrateRoot = function (p, y, T) { if (!yj(p)) throw Error(n(405)); var k = T != null && T.hydratedSources || null, U = !1, W = "", le = J6; if (T != null && (T.unstable_strictMode === !0 && (U = !0), T.identifierPrefix !== void 0 && (W = T.identifierPrefix), T.onRecoverableError !== void 0 && (le = T.onRecoverableError)), y = Z6(y, null, p, 1, T ?? null, U, !1, W, le), p[Ls] = y.current, Yf(p), k) for (p = 0; p < k.length; p++)T = k[p], U = T._getVersion, U = U(T._source), y.mutableSourceEagerHydrationData == null ? y.mutableSourceEagerHydrationData = [T, U] : y.mutableSourceEagerHydrationData.push(T, U); return new jE(y) }, To.render = function (p, y, T) { if (!RE(y)) throw Error(n(200)); return kE(null, p, y, !1, T) }, To.unmountComponentAtNode = function (p) { if (!RE(p)) throw Error(n(40)); return p._reactRootContainer ? (hm(function () { kE(null, null, p, !1, function () { p._reactRootContainer = null, p[Ls] = null }) }), !0) : !1 }, To.unstable_batchedUpdates = cj, To.unstable_renderSubtreeIntoContainer = function (p, y, T, k) { if (!RE(T)) throw Error(n(200)); if (p == null || p._reactInternals === void 0) throw Error(n(38)); return kE(p, y, T, !1, k) }, To.version = "18.3.1-next-f1338f8080-20240426", To
} var l8; function nJ() { if (l8) return wj.exports; l8 = 1; function t() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t) } catch (e) { console.error(e) } } return t(), wj.exports = vge(), wj.exports } var c8; function yge() { if (c8) return DE; c8 = 1; var t = nJ(); return DE.createRoot = t.createRoot, DE.hydrateRoot = t.hydrateRoot, DE } var xge = yge(), S = IS(); const P = Fr(S), Yh = dge({ __proto__: null, default: P }, [S]); var xi = nJ(); const rJ = Fr(xi);/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function m1() { return m1 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, m1.apply(this, arguments) } var Ih; (function (t) { t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE" })(Ih || (Ih = {})); const u8 = "popstate"; function bge(t) { t === void 0 && (t = {}); function e(r, i) { let { pathname: a, search: s, hash: o } = r.location; return z3("", { pathname: a, search: s, hash: o }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : $T(i) } return Sge(e, n, null, t) } function aa(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } function iJ(t, e) { if (!t) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function wge() { return Math.random().toString(36).substr(2, 8) } function d8(t, e) { return { usr: t.state, key: t.key, idx: e } } function z3(t, e, n, r) { return n === void 0 && (n = null), m1({ pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" }, typeof e == "string" ? u0(e) : e, { state: n, key: e && e.key || r || wge() }) } function $T(t) { let { pathname: e = "/", search: n = "", hash: r = "" } = t; return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e } function u0(t) { let e = {}; if (t) { let n = t.indexOf("#"); n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n)); let r = t.indexOf("?"); r >= 0 && (e.search = t.substr(r), t = t.substr(0, r)), t && (e.pathname = t) } return e } function Sge(t, e, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: a = !1 } = r, s = i.history, o = Ih.Pop, c = null, u = d(); u == null && (u = 0, s.replaceState(m1({}, s.state, { idx: u }), "")); function d() { return (s.state || { idx: null }).idx } function f() { o = Ih.Pop; let v = d(), b = v == null ? null : v - u; u = v, c && c({ action: o, location: x.location, delta: b }) } function h(v, b) { o = Ih.Push; let E = z3(x.location, v, b); u = d() + 1; let M = d8(E, u), C = x.createHref(E); try { s.pushState(M, "", C) } catch (N) { if (N instanceof DOMException && N.name === "DataCloneError") throw N; i.location.assign(C) } a && c && c({ action: o, location: x.location, delta: 1 }) } function m(v, b) { o = Ih.Replace; let E = z3(x.location, v, b); u = d(); let M = d8(E, u), C = x.createHref(E); s.replaceState(M, "", C), a && c && c({ action: o, location: x.location, delta: 0 }) } function g(v) { let b = i.location.origin !== "null" ? i.location.origin : i.location.href, E = typeof v == "string" ? v : $T(v); return E = E.replace(/ $/, "%20"), aa(b, "No window.location.(origin|href) available to create URL for href: " + E), new URL(E, b) } let x = { get action() { return o }, get location() { return t(i, s) }, listen(v) { if (c) throw new Error("A history only accepts one active listener"); return i.addEventListener(u8, f), c = v, () => { i.removeEventListener(u8, f), c = null } }, createHref(v) { return e(i, v) }, createURL: g, encodeLocation(v) { let b = g(v); return { pathname: b.pathname, search: b.search, hash: b.hash } }, push: h, replace: m, go(v) { return s.go(v) } }; return x } var f8; (function (t) { t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error" })(f8 || (f8 = {})); function _ge(t, e, n) { return n === void 0 && (n = "/"), Ege(t, e, n) } function Ege(t, e, n, r) { let i = typeof e == "string" ? u0(e) : e, a = n5(i.pathname || "/", n); if (a == null) return null; let s = aJ(t); Mge(s); let o = null; for (let c = 0; o == null && c < s.length; ++c) { let u = Lge(a); o = Ige(s[c], u) } return o } function aJ(t, e, n, r) { e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (a, s, o) => { let c = { relativePath: o === void 0 ? a.path || "" : o, caseSensitive: a.caseSensitive === !0, childrenIndex: s, route: a }; c.relativePath.startsWith("/") && (aa(c.relativePath.startsWith(r), 'Absolute route path "' + c.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), c.relativePath = c.relativePath.slice(r.length)); let u = Vh([r, c.relativePath]), d = n.concat(c); a.children && a.children.length > 0 && (aa(a.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), aJ(a.children, e, d, u)), !(a.path == null && !a.index) && e.push({ path: u, score: Rge(u, a.index), routesMeta: d }) }; return t.forEach((a, s) => { var o; if (a.path === "" || !((o = a.path) != null && o.includes("?"))) i(a, s); else for (let c of sJ(a.path)) i(a, s, c) }), e } function sJ(t) { let e = t.split("/"); if (e.length === 0) return []; let [n, ...r] = e, i = n.endsWith("?"), a = n.replace(/\?$/, ""); if (r.length === 0) return i ? [a, ""] : [a]; let s = sJ(r.join("/")), o = []; return o.push(...s.map(c => c === "" ? a : [a, c].join("/"))), i && o.push(...s), o.map(c => t.startsWith("/") && c === "" ? "/" : c) } function Mge(t) { t.sort((e, n) => e.score !== n.score ? n.score - e.score : kge(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const Tge = /^:[\w-]+$/, Cge = 3, Nge = 2, Age = 1, Pge = 10, jge = -2, h8 = t => t === "*"; function Rge(t, e) { let n = t.split("/"), r = n.length; return n.some(h8) && (r += jge), e && (r += Nge), n.filter(i => !h8(i)).reduce((i, a) => i + (Tge.test(a) ? Cge : a === "" ? Age : Pge), r) } function kge(t, e) { return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0 } function Ige(t, e, n) { let { routesMeta: r } = t, i = {}, a = "/", s = []; for (let o = 0; o < r.length; ++o) { let c = r[o], u = o === r.length - 1, d = a === "/" ? e : e.slice(a.length) || "/", f = Oge({ path: c.relativePath, caseSensitive: c.caseSensitive, end: u }, d), h = c.route; if (!f) return null; Object.assign(i, f.params), s.push({ params: i, pathname: Vh([a, f.pathname]), pathnameBase: $ge(Vh([a, f.pathnameBase])), route: h }), f.pathnameBase !== "/" && (a = Vh([a, f.pathnameBase])) } return s } function Oge(t, e) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [n, r] = Dge(t.path, t.caseSensitive, t.end), i = e.match(n); if (!i) return null; let a = i[0], s = a.replace(/(.)\/+$/, "$1"), o = i.slice(1); return { params: r.reduce((u, d, f) => { let { paramName: h, isOptional: m } = d; if (h === "*") { let x = o[f] || ""; s = a.slice(0, a.length - x.length).replace(/(.)\/+$/, "$1") } const g = o[f]; return m && !g ? u[h] = void 0 : u[h] = (g || "").replace(/%2F/g, "/"), u }, {}), pathname: a, pathnameBase: s, pattern: t } } function Dge(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !0), iJ(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, o, c) => (r.push({ paramName: o, isOptional: c != null }), c ? "/?([^\\/]+)?" : "/([^\\/]+)")); return t.endsWith("*") ? (r.push({ paramName: "*" }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), r] } function Lge(t) { try { return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (e) { return iJ(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t } } function n5(t, e) { if (e === "/") return t; if (!t.toLowerCase().startsWith(e.toLowerCase())) return null; let n = e.endsWith("/") ? e.length - 1 : e.length, r = t.charAt(n); return r && r !== "/" ? null : t.slice(n) || "/" } function Fge(t, e) { e === void 0 && (e = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? u0(t) : t; return { pathname: n ? n.startsWith("/") ? n : Uge(n, e) : e, search: zge(r), hash: Vge(i) } } function Uge(t, e) { let n = e.replace(/\/+$/, "").split("/"); return t.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function Ej(t, e, n, r) { return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function Bge(t) { return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0) } function r5(t, e) { let n = Bge(t); return e ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function i5(t, e, n, r) { r === void 0 && (r = !1); let i; typeof t == "string" ? i = u0(t) : (i = m1({}, t), aa(!i.pathname || !i.pathname.includes("?"), Ej("?", "pathname", "search", i)), aa(!i.pathname || !i.pathname.includes("#"), Ej("#", "pathname", "hash", i)), aa(!i.search || !i.search.includes("#"), Ej("#", "search", "hash", i))); let a = t === "" || i.pathname === "", s = a ? "/" : i.pathname, o; if (s == null) o = n; else { let f = e.length - 1; if (!r && s.startsWith("..")) { let h = s.split("/"); for (; h[0] === "..";)h.shift(), f -= 1; i.pathname = h.join("/") } o = f >= 0 ? e[f] : "/" } let c = Fge(i, o), u = s && s !== "/" && s.endsWith("/"), d = (a || s === ".") && n.endsWith("/"); return !c.pathname.endsWith("/") && (u || d) && (c.pathname += "/"), c } const Vh = t => t.join("/").replace(/\/\/+/g, "/"), $ge = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), zge = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, Vge = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t; function Hge(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } const oJ = ["post", "put", "patch", "delete"]; new Set(oJ); const Wge = ["get", ...oJ]; new Set(Wge);/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function g1() { return g1 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, g1.apply(this, arguments) } const a5 = S.createContext(null), Gge = S.createContext(null), fp = S.createContext(null), pA = S.createContext(null), Yu = S.createContext({ outlet: null, matches: [], isDataRoute: !1 }), lJ = S.createContext(null); function qge(t, e) { let { relative: n } = e === void 0 ? {} : e; d0() || aa(!1); let { basename: r, navigator: i } = S.useContext(fp), { hash: a, pathname: s, search: o } = uJ(t, { relative: n }), c = s; return r !== "/" && (c = s === "/" ? r : Vh([r, s])), i.createHref({ pathname: c, search: o, hash: a }) } function d0() { return S.useContext(pA) != null } function fs() { return d0() || aa(!1), S.useContext(pA).location } function cJ(t) { S.useContext(fp).static || S.useLayoutEffect(t) } function ui() { let { isDataRoute: t } = S.useContext(Yu); return t ? cve() : Xge() } function Xge() { d0() || aa(!1); let t = S.useContext(a5), { basename: e, future: n, navigator: r } = S.useContext(fp), { matches: i } = S.useContext(Yu), { pathname: a } = fs(), s = JSON.stringify(r5(i, n.v7_relativeSplatPath)), o = S.useRef(!1); return cJ(() => { o.current = !0 }), S.useCallback(function (u, d) { if (d === void 0 && (d = {}), !o.current) return; if (typeof u == "number") { r.go(u); return } let f = i5(u, JSON.parse(s), a, d.relative === "path"); t == null && e !== "/" && (f.pathname = f.pathname === "/" ? e : Vh([e, f.pathname])), (d.replace ? r.replace : r.push)(f, d.state, d) }, [e, r, s, a, t]) } const Yge = S.createContext(null); function Kge(t) { let e = S.useContext(Yu).outlet; return e && S.createElement(Yge.Provider, { value: t }, e) } function Zge() { let { matches: t } = S.useContext(Yu), e = t[t.length - 1]; return e ? e.params : {} } function uJ(t, e) { let { relative: n } = e === void 0 ? {} : e, { future: r } = S.useContext(fp), { matches: i } = S.useContext(Yu), { pathname: a } = fs(), s = JSON.stringify(r5(i, r.v7_relativeSplatPath)); return S.useMemo(() => i5(t, JSON.parse(s), a, n === "path"), [t, s, a, n]) } function Qge(t, e) { return Jge(t, e) } function Jge(t, e, n, r) { d0() || aa(!1); let { navigator: i } = S.useContext(fp), { matches: a } = S.useContext(Yu), s = a[a.length - 1], o = s ? s.params : {}; s && s.pathname; let c = s ? s.pathnameBase : "/"; s && s.route; let u = fs(), d; if (e) { var f; let v = typeof e == "string" ? u0(e) : e; c === "/" || (f = v.pathname) != null && f.startsWith(c) || aa(!1), d = v } else d = u; let h = d.pathname || "/", m = h; if (c !== "/") { let v = c.replace(/^\//, "").split("/"); m = "/" + h.replace(/^\//, "").split("/").slice(v.length).join("/") } let g = _ge(t, { pathname: m }), x = ive(g && g.map(v => Object.assign({}, v, { params: Object.assign({}, o, v.params), pathname: Vh([c, i.encodeLocation ? i.encodeLocation(v.pathname).pathname : v.pathname]), pathnameBase: v.pathnameBase === "/" ? c : Vh([c, i.encodeLocation ? i.encodeLocation(v.pathnameBase).pathname : v.pathnameBase]) })), a, n, r); return e && x ? S.createElement(pA.Provider, { value: { location: g1({ pathname: "/", search: "", hash: "", state: null, key: "default" }, d), navigationType: Ih.Pop } }, x) : x } function eve() { let t = lve(), e = Hge(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return S.createElement(S.Fragment, null, S.createElement("h2", null, "Unexpected Application Error!"), S.createElement("h3", { style: { fontStyle: "italic" } }, e), n ? S.createElement("pre", { style: i }, n) : null, null) } const tve = S.createElement(eve, null); class nve extends S.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, n) { return n.location !== e.location || n.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : n.error, location: n.location, revalidation: e.revalidation || n.revalidation } } componentDidCatch(e, n) { console.error("React Router caught the following error during render", e, n) } render() { return this.state.error !== void 0 ? S.createElement(Yu.Provider, { value: this.props.routeContext }, S.createElement(lJ.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function rve(t) { let { routeContext: e, match: n, children: r } = t, i = S.useContext(a5); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), S.createElement(Yu.Provider, { value: e }, r) } function ive(t, e, n, r) { var i; if (e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null) { var a; if (!n) return null; if (n.errors) t = n.matches; else if ((a = r) != null && a.v7_partialHydration && e.length === 0 && !n.initialized && n.matches.length > 0) t = n.matches; else return null } let s = t, o = (i = n) == null ? void 0 : i.errors; if (o != null) { let d = s.findIndex(f => f.route.id && o?.[f.route.id] !== void 0); d >= 0 || aa(!1), s = s.slice(0, Math.min(s.length, d + 1)) } let c = !1, u = -1; if (n && r && r.v7_partialHydration) for (let d = 0; d < s.length; d++) { let f = s[d]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (u = d), f.route.id) { let { loaderData: h, errors: m } = n, g = f.route.loader && h[f.route.id] === void 0 && (!m || m[f.route.id] === void 0); if (f.route.lazy || g) { c = !0, u >= 0 ? s = s.slice(0, u + 1) : s = [s[0]]; break } } } return s.reduceRight((d, f, h) => { let m, g = !1, x = null, v = null; n && (m = o && f.route.id ? o[f.route.id] : void 0, x = f.route.errorElement || tve, c && (u < 0 && h === 0 ? (uve("route-fallback"), g = !0, v = null) : u === h && (g = !0, v = f.route.hydrateFallbackElement || null))); let b = e.concat(s.slice(0, h + 1)), E = () => { let M; return m ? M = x : g ? M = v : f.route.Component ? M = S.createElement(f.route.Component, null) : f.route.element ? M = f.route.element : M = d, S.createElement(rve, { match: f, routeContext: { outlet: d, matches: b, isDataRoute: n != null }, children: M }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? S.createElement(nve, { location: n.location, revalidation: n.revalidation, component: x, error: m, children: E(), routeContext: { outlet: null, matches: b, isDataRoute: !0 } }) : E() }, null) } var dJ = (function (t) { return t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t })(dJ || {}), fJ = (function (t) { return t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t.UseRouteId = "useRouteId", t })(fJ || {}); function ave(t) { let e = S.useContext(a5); return e || aa(!1), e } function sve(t) { let e = S.useContext(Gge); return e || aa(!1), e } function ove(t) { let e = S.useContext(Yu); return e || aa(!1), e } function hJ(t) { let e = ove(), n = e.matches[e.matches.length - 1]; return n.route.id || aa(!1), n.route.id } function lve() { var t; let e = S.useContext(lJ), n = sve(), r = hJ(); return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r] } function cve() { let { router: t } = ave(dJ.UseNavigateStable), e = hJ(fJ.UseNavigateStable), n = S.useRef(!1); return cJ(() => { n.current = !0 }), S.useCallback(function (i, a) { a === void 0 && (a = {}), n.current && (typeof i == "number" ? t.navigate(i) : t.navigate(i, g1({ fromRouteId: e }, a))) }, [t, e]) } const p8 = {}; function uve(t, e, n) { p8[t] || (p8[t] = !0) } function dve(t, e) { t?.v7_startTransition, t?.v7_relativeSplatPath } function Ay(t) { let { to: e, replace: n, state: r, relative: i } = t; d0() || aa(!1); let { future: a, static: s } = S.useContext(fp), { matches: o } = S.useContext(Yu), { pathname: c } = fs(), u = ui(), d = i5(e, r5(o, a.v7_relativeSplatPath), c, i === "path"), f = JSON.stringify(d); return S.useEffect(() => u(JSON.parse(f), { replace: n, state: r, relative: i }), [u, f, i, n, r]), null } function fve(t) { return Kge(t.context) } function Gn(t) { aa(!1) } function hve(t) { let { basename: e = "/", children: n = null, location: r, navigationType: i = Ih.Pop, navigator: a, static: s = !1, future: o } = t; d0() && aa(!1); let c = e.replace(/^\/*/, "/"), u = S.useMemo(() => ({ basename: c, navigator: a, static: s, future: g1({ v7_relativeSplatPath: !1 }, o) }), [c, o, a, s]); typeof r == "string" && (r = u0(r)); let { pathname: d = "/", search: f = "", hash: h = "", state: m = null, key: g = "default" } = r, x = S.useMemo(() => { let v = n5(d, c); return v == null ? null : { location: { pathname: v, search: f, hash: h, state: m, key: g }, navigationType: i } }, [c, d, f, h, m, g, i]); return x == null ? null : S.createElement(fp.Provider, { value: u }, S.createElement(pA.Provider, { children: n, value: x })) } function pve(t) { let { children: e, location: n } = t; return Qge(V3(e), n) } new Promise(() => { }); function V3(t, e) { e === void 0 && (e = []); let n = []; return S.Children.forEach(t, (r, i) => { if (!S.isValidElement(r)) return; let a = [...e, i]; if (r.type === S.Fragment) { n.push.apply(n, V3(r.props.children, a)); return } r.type !== Gn && aa(!1), !r.props.index || !r.props.children || aa(!1); let s = { id: r.props.id || a.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (s.children = V3(r.props.children, a)), n.push(s) }), n }/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function H3() { return H3 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, H3.apply(this, arguments) } function mve(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, a; for (a = 0; a < r.length; a++)i = r[a], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } function gve(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function vve(t, e) { return t.button === 0 && (!e || e === "_self") && !gve(t) } function W3(t) { return t === void 0 && (t = ""), new URLSearchParams(typeof t == "string" || Array.isArray(t) || t instanceof URLSearchParams ? t : Object.keys(t).reduce((e, n) => { let r = t[n]; return e.concat(Array.isArray(r) ? r.map(i => [n, i]) : [[n, r]]) }, [])) } function yve(t, e) { let n = W3(t); return e && e.forEach((r, i) => { n.has(i) || e.getAll(i).forEach(a => { n.append(i, a) }) }), n } const xve = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], bve = "6"; try { window.__reactRouterVersion = bve } catch { } const wve = "startTransition", m8 = Yh[wve]; function Sve(t) { let { basename: e, children: n, future: r, window: i } = t, a = S.useRef(); a.current == null && (a.current = bge({ window: i, v5Compat: !0 })); let s = a.current, [o, c] = S.useState({ action: s.action, location: s.location }), { v7_startTransition: u } = r || {}, d = S.useCallback(f => { u && m8 ? m8(() => c(f)) : c(f) }, [c, u]); return S.useLayoutEffect(() => s.listen(d), [s, d]), S.useEffect(() => dve(r), [r]), S.createElement(hve, { basename: e, children: n, location: o.location, navigationType: o.action, navigator: s, future: r }) } const _ve = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Eve = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, yi = S.forwardRef(function (e, n) { let { onClick: r, relative: i, reloadDocument: a, replace: s, state: o, target: c, to: u, preventScrollReset: d, viewTransition: f } = e, h = mve(e, xve), { basename: m } = S.useContext(fp), g, x = !1; if (typeof u == "string" && Eve.test(u) && (g = u, _ve)) try { let M = new URL(window.location.href), C = u.startsWith("//") ? new URL(M.protocol + u) : new URL(u), N = n5(C.pathname, m); C.origin === M.origin && N != null ? u = N + C.search + C.hash : x = !0 } catch { } let v = qge(u, { relative: i }), b = Mve(u, { replace: s, state: o, target: c, preventScrollReset: d, relative: i, viewTransition: f }); function E(M) { r && r(M), M.defaultPrevented || b(M) } return S.createElement("a", H3({}, h, { href: g || v, onClick: x || a ? r : E, ref: n, target: c })) }); var g8; (function (t) { t.UseScrollRestoration = "useScrollRestoration", t.UseSubmit = "useSubmit", t.UseSubmitFetcher = "useSubmitFetcher", t.UseFetcher = "useFetcher", t.useViewTransitionState = "useViewTransitionState" })(g8 || (g8 = {})); var v8; (function (t) { t.UseFetcher = "useFetcher", t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration" })(v8 || (v8 = {})); function Mve(t, e) { let { target: n, replace: r, state: i, preventScrollReset: a, relative: s, viewTransition: o } = e === void 0 ? {} : e, c = ui(), u = fs(), d = uJ(t, { relative: s }); return S.useCallback(f => { if (vve(f, n)) { f.preventDefault(); let h = r !== void 0 ? r : $T(u) === $T(d); c(t, { replace: h, state: i, preventScrollReset: a, relative: s, viewTransition: o }) } }, [u, c, d, r, i, n, t, a, s, o]) } function pJ(t) { let e = S.useRef(W3(t)), n = S.useRef(!1), r = fs(), i = S.useMemo(() => yve(r.search, n.current ? null : e.current), [r.search]), a = ui(), s = S.useCallback((o, c) => { const u = W3(typeof o == "function" ? o(i) : o); n.current = !0, a("?" + u, c) }, [a, i]); return [i, s] } const Tve = { apiUrl: "http://localhost:5000" }; class Cve { baseURL; constructor(e) { this.baseURL = e } async request(e, n = {}) { const r = `${this.baseURL}${e}`, a = { ...n, headers: { ...{ "Content-Type": "application/json" }, ...n.headers }, credentials: "include" }; try { const s = await fetch(r, a); if (!s.headers.get("content-type")?.includes("application/json")) { if (!s.ok) throw new Error(`HTTP error! status: ${s.status}`); return {} } const c = await s.json(); if (!s.ok) { s.status; const u = new Error(c.message || c.error || "An error occurred"); throw u.responseData = c, u.statusCode = s.status, u } return c } catch (s) { throw s instanceof Error ? s : new Error("An unexpected error occurred") } } async get(e, n) { return this.request(e, { ...n, method: "GET" }) } async post(e, n, r) { return this.request(e, { ...r, method: "POST", body: n ? JSON.stringify(n) : void 0 }) } async put(e, n, r) { return this.request(e, { ...r, method: "PUT", body: n ? JSON.stringify(n) : void 0 }) } async delete(e, n) { return this.request(e, { ...n, method: "DELETE" }) } async patch(e, n, r) { return this.request(e, { ...r, method: "PATCH", body: n ? JSON.stringify(n) : void 0 }) } } const Yn = new Cve(Tve.apiUrl), jn = { auth: { register: "/api/auth/register", login: "/api/auth/login", logout: "/api/auth/logout", me: "/api/auth/me", google: "/api/auth/google", github: "/api/auth/github", assignRole: "/api/auth/assign-role", forgotPassword: "/api/auth/forgot-password", resetPassword: t => `/api/auth/reset-password/${t}` }, dashboard: { trainee: "/api/dashboard/trainee", interviewer: "/api/dashboard/interviewer", admin: "/api/dashboard/admin" }, interviewers: { pending: "/api/interviewers/pending", approve: t => `/api/interviewers/${t}/approve`, reject: t => `/api/interviewers/${t}/reject` }, upload: { resume: "/api/upload/resume", getResume: t => `/api/uploads/resumes/${t}` }, notifications: { getAll: "/api/notifications", markAsRead: t => `/api/notifications/${t}/read`, markAllAsRead: "/api/notifications/read-all", delete: t => `/api/notifications/${t}` }, users: { getAll: "/api/users", getById: t => `/api/users/${t}`, create: "/api/users", update: t => `/api/users/${t}`, delete: t => `/api/users/${t}`, changeRole: t => `/api/users/${t}/role`, sendEmail: t => `/api/users/${t}/send-email`, export: "/api/users/export" }, resources: { getAll: "/api/resources", getById: t => `/api/resources/${t}`, create: "/api/resources", update: t => `/api/resources/${t}`, delete: t => `/api/resources/${t}`, incrementViews: t => `/api/resources/${t}/view` }, bookings: { getSlots: "/api/bookings/slots", getAll: "/api/bookings", create: "/api/bookings/create", reschedule: t => `/api/bookings/${t}/reschedule` }, interviewer: { availability: "/api/interviewer/availability", addAvailability: "/api/interviewer/availability/add", deleteAvailability: t => `/api/interviewer/availability/delete/${t}` }, interviewerInterviews: { getAll: "/api/interviewer/interviews", getById: t => `/api/interviewer/interviews/${t}`, updateStatus: t => `/api/interviewer/interviews/${t}/status` }, admin: { interviews: { getAll: "/api/admin/interviews", update: t => `/api/admin/interviews/${t}`, cancel: t => `/api/admin/interviews/${t}/cancel` } } }, Lc = { async register(t) { return Yn.post(jn.auth.register, t) }, async login(t) { return Yn.post(jn.auth.login, t) }, async getMe() { return Yn.get(jn.auth.me) }, async logout() { return Yn.post(jn.auth.logout) }, getOAuthUrl(t, e) { const n = "http://localhost:5000", r = t === "google" ? jn.auth.google : jn.auth.github; return e ? `${n}${r}?role=${e}` : `${n}${r}` }, async assignRole(t) { return Yn.post(jn.auth.assignRole, t) }, async forgotPassword(t) { return Yn.post(jn.auth.forgotPassword, { email: t }) }, async validateResetToken(t) { return Yn.get(jn.auth.resetPassword(t)) }, async resetPassword(t, e) { return Yn.post(jn.auth.resetPassword(t), { password: e }) } }, mJ = S.createContext(void 0), Nve = ["/", "/login", "/forgot-password", "/reset-password", "/pricing", "/resources", "/help", "/faq", "/style-guide"], Ave = t => Nve.includes(t) || t.startsWith("/reset-password/"), Pve = t => !!(t.startsWith("/dashboard") || t.startsWith("/pending-verification") || t.startsWith("/rejected-notice") || t.startsWith("/oauth")); function jve({ children: t }) { const [e, n] = S.useState(null), [r, i] = S.useState(!1), a = fs(), s = S.useRef(!1), o = async () => { if (a.pathname !== "/" && !r) { i(!0); try { const h = await Lc.getMe(); h.success && h.data ? n({ id: h.data._id || h.data.id, name: h.data.name, email: h.data.email, role: h.data.role, status: h.data.status, permissions: h.data.permissions || [], isApproved: h.data.isApproved, oauthRolePending: h.data.oauthRolePending }) : n(null) } catch (h) { h.statusCode, n(null) } finally { i(!1) } } }; S.useEffect(() => { const h = a.pathname; if (h === "/") { i(!1), s.current = !1; return } if (Ave(h)) { i(!1); return } Pve(h) && !s.current && (s.current = !0, o()) }, [a.pathname]); const c = async (h, m) => { const g = await Lc.login({ email: h, password: m }); return g.user && (s.current = !0, await o()), g.redirect }, u = async h => { const m = await Lc.register(h); return m.user && (s.current = !0, await o()), m.redirect }, d = async () => { try { await Lc.logout() } catch { } finally { n(null) } }, f = h => e ? h.includes(e.role) : !1; return l.jsx(mJ.Provider, { value: { user: e, loading: r, login: c, register: u, logout: d, isAuthorized: f, fetchUser: o }, children: t }) } const La = () => { const t = S.useContext(mJ); if (!t) throw new Error("useAuth must be used within AuthProvider"); return t }; class Rve { async getNotifications(e) { const n = new URLSearchParams; e?.limit && n.append("limit", e.limit.toString()), e?.skip && n.append("skip", e.skip.toString()), e?.unreadOnly && n.append("unreadOnly", "true"); const r = n.toString() ? `?${n.toString()}` : ""; return Yn.get(`${jn.notifications.getAll}${r}`) } async markAsRead(e) { return Yn.put(jn.notifications.markAsRead(e), {}) } async markAllAsRead() { return Yn.put(jn.notifications.markAllAsRead, {}) } async deleteNotification(e) { return Yn.delete(jn.notifications.delete(e)) } } const Jd = new Rve, gJ = S.createContext(void 0), kve = t => ({ id: t._id, title: t.title, message: t.message, timestamp: new Date(t.createdAt), isRead: t.isRead, type: t.type }); function Ive({ children: t }) { const [e, n] = S.useState([]), [r, i] = S.useState(!1), { user: a, loading: s } = La(), o = S.useCallback(async () => { if (s || !a) { n([]); return } try { i(!0); const x = (await Jd.getNotifications({ limit: 50 })).data.map(kve); n(x) } catch { } finally { i(!1) } }, [a]); S.useEffect(() => { if (s || !a) return; o(); const g = setInterval(() => { a && o() }, 3e4); return () => clearInterval(g) }, [o, s, a]); const c = S.useCallback(g => { const x = { ...g, id: `client-${Date.now()}-${Math.random()}`, timestamp: new Date, isRead: !1 }; n(v => [x, ...v]), g.type === "success" && setTimeout(() => { n(v => v.filter(b => b.id !== x.id)) }, 5e3) }, []), u = S.useCallback(async g => { if (n(x => x.map(v => v.id === g ? { ...v, isRead: !0 } : v)), !g.startsWith("client-")) try { await Jd.markAsRead(g), o() } catch { o() } }, [o]), d = S.useCallback(async () => { n(g => g.map(x => ({ ...x, isRead: !0 }))); try { await Jd.markAllAsRead(), o() } catch { o() } }, [o]), f = S.useCallback(async g => { if (n(x => x.filter(v => v.id !== g)), !g.startsWith("client-")) try { await Jd.deleteNotification(g) } catch { o() } }, [o]), h = S.useCallback(() => { n([]) }, []), m = e.filter(g => !g.isRead).length; return l.jsx(gJ.Provider, { value: { notifications: e, addNotification: c, markAsRead: u, markAllAsRead: d, removeNotification: f, clearNotifications: h, unreadCount: m, loading: r, refreshNotifications: o }, children: t }) } const OS = () => { const t = S.useContext(gJ); if (!t) throw new Error("useNotifications must be used within NotificationProvider"); return t };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ove = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), vJ = (...t) => t.filter((e, n, r) => !!e && e.trim() !== "" && r.indexOf(e) === n).join(" ").trim();/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var Dve = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Lve = S.forwardRef(({ color: t = "currentColor", size: e = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: i = "", children: a, iconNode: s, ...o }, c) => S.createElement("svg", { ref: c, ...Dve, width: e, height: e, stroke: t, strokeWidth: r ? Number(n) * 24 / Number(e) : n, className: vJ("lucide", i), ...o }, [...s.map(([u, d]) => S.createElement(u, d)), ...Array.isArray(a) ? a : [a]]));/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Rt = (t, e) => { const n = S.forwardRef(({ className: r, ...i }, a) => S.createElement(Lve, { ref: a, iconNode: e, className: vJ(`lucide-${Ove(t)}`, r), ...i })); return n.displayName = `${t}`, n };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const s5 = Rt("Activity", [["path", { d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2", key: "169zse" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const f0 = Rt("ArrowLeft", [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const o5 = Rt("ArrowRight", [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mA = Rt("Award", [["path", { d: "m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526", key: "1yiouv" }], ["circle", { cx: "12", cy: "8", r: "6", key: "1vp47v" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lx = Rt("Bell", [["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }], ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Kh = Rt("BookOpen", [["path", { d: "M12 7v14", key: "1akyts" }], ["path", { d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z", key: "ruj8y" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yJ = Rt("Book", [["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20", key: "k3hazp" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fve = Rt("Bookmark", [["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z", key: "1fy3hk" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ro = Rt("Brain", [["path", { d: "M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z", key: "l5xja" }], ["path", { d: "M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z", key: "ep3f8r" }], ["path", { d: "M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4", key: "1p4c4q" }], ["path", { d: "M17.599 6.5a3 3 0 0 0 .399-1.375", key: "tmeiqw" }], ["path", { d: "M6.003 5.125A3 3 0 0 0 6.401 6.5", key: "105sqy" }], ["path", { d: "M3.477 10.896a4 4 0 0 1 .585-.396", key: "ql3yin" }], ["path", { d: "M19.938 10.5a4 4 0 0 1 .585.396", key: "1qfode" }], ["path", { d: "M6 18a4 4 0 0 1-1.967-.516", key: "2e4loj" }], ["path", { d: "M19.967 17.484A4 4 0 0 1 18 18", key: "159ez6" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const G3 = Rt("Briefcase", [["path", { d: "M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16", key: "jecpp" }], ["rect", { width: "20", height: "14", x: "2", y: "6", rx: "2", key: "i6l2r4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Uve = Rt("Building", [["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2", key: "76otgf" }], ["path", { d: "M9 22v-4h6v4", key: "r93iot" }], ["path", { d: "M8 6h.01", key: "1dz90k" }], ["path", { d: "M16 6h.01", key: "1x0f13" }], ["path", { d: "M12 6h.01", key: "1vi96p" }], ["path", { d: "M12 10h.01", key: "1nrarc" }], ["path", { d: "M12 14h.01", key: "1etili" }], ["path", { d: "M16 10h.01", key: "1m94wz" }], ["path", { d: "M16 14h.01", key: "1gbofw" }], ["path", { d: "M8 10h.01", key: "19clt8" }], ["path", { d: "M8 14h.01", key: "6423bh" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Bve = Rt("CalendarClock", [["path", { d: "M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5", key: "1osxxc" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M3 10h5", key: "r794hk" }], ["path", { d: "M17.5 17.5 16 16.3V14", key: "akvzfd" }], ["circle", { cx: "16", cy: "16", r: "6", key: "qoo3c4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const li = Rt("Calendar", [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const v1 = Rt("ChartColumn", [["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }], ["path", { d: "M18 17V9", key: "2bz60n" }], ["path", { d: "M13 17V5", key: "1frdt8" }], ["path", { d: "M8 17v-3", key: "17ska0" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const l5 = Rt("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gA = Rt("ChevronDown", [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const c5 = Rt("ChevronLeft", [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const DS = Rt("ChevronRight", [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $ve = Rt("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ji = Rt("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xJ = Rt("CircleCheckBig", [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oi = Rt("CircleCheck", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bJ = Rt("CircleHelp", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }], ["path", { d: "M12 17h.01", key: "p32p05" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const LS = Rt("CircleX", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "m15 9-6 6", key: "1uzhvr" }], ["path", { d: "m9 9 6 6", key: "z0biqf" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wJ = Rt("Circle", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ni = Rt("Clock", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zve = Rt("Cog", [["path", { d: "M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z", key: "sobvz5" }], ["path", { d: "M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", key: "11i496" }], ["path", { d: "M12 2v2", key: "tus03m" }], ["path", { d: "M12 22v-2", key: "1osdcq" }], ["path", { d: "m17 20.66-1-1.73", key: "eq3orb" }], ["path", { d: "M11 10.27 7 3.34", key: "16pf9h" }], ["path", { d: "m20.66 17-1.73-1", key: "sg0v6f" }], ["path", { d: "m3.34 7 1.73 1", key: "1ulond" }], ["path", { d: "M14 12h8", key: "4f43i9" }], ["path", { d: "M2 12h2", key: "1t8f8n" }], ["path", { d: "m20.66 7-1.73 1", key: "1ow05n" }], ["path", { d: "m3.34 17 1.73-1", key: "nuk764" }], ["path", { d: "m17 3.34-1 1.73", key: "2wel8s" }], ["path", { d: "m11 13.73-4 6.93", key: "794ttg" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vve = Rt("CreditCard", [["rect", { width: "20", height: "14", x: "2", y: "5", rx: "2", key: "ynyp8z" }], ["line", { x1: "2", x2: "22", y1: "10", y2: "10", key: "1b3vmo" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Hve = Rt("Crown", [["path", { d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z", key: "1vdc57" }], ["path", { d: "M5 21h14", key: "11awu3" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const y8 = Rt("Database", [["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }], ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }], ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const FS = Rt("Download", [["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }], ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }], ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const u5 = Rt("EllipsisVertical", [["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }], ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }], ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const SJ = Rt("ExternalLink", [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zT = Rt("EyeOff", [["path", { d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49", key: "ct8e1f" }], ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242", key: "151rxh" }], ["path", { d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143", key: "13bj9a" }], ["path", { d: "m2 2 20 20", key: "1ooewy" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Du = Rt("Eye", [["path", { d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0", key: "1nclc0" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const d5 = Rt("Facebook", [["path", { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z", key: "1jg4f8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const df = Rt("FileText", [["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }], ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }], ["path", { d: "M10 9H8", key: "b1mrlr" }], ["path", { d: "M16 13H8", key: "t4e002" }], ["path", { d: "M16 17H8", key: "z1uh3a" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _J = Rt("Filter", [["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Wve = Rt("Github", [["path", { d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4", key: "tonef" }], ["path", { d: "M9 18c-4.51 2-5-2-7-2", key: "9comsn" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const EJ = Rt("Globe", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }], ["path", { d: "M2 12h20", key: "9i4pu4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const MJ = Rt("GraduationCap", [["path", { d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z", key: "j76jl0" }], ["path", { d: "M22 10v6", key: "1lu8f3" }], ["path", { d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5", key: "1r8lef" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const US = Rt("Heart", [["path", { d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z", key: "c3ymky" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const f5 = Rt("House", [["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }], ["path", { d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z", key: "1d0kgt" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const h5 = Rt("Info", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const p5 = Rt("Instagram", [["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5", key: "2e1cvw" }], ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" }], ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Gve = Rt("Key", [["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }], ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }], ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qve = Rt("LayoutDashboard", [["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }], ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }], ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }], ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const TJ = Rt("Library", [["path", { d: "m16 6 4 14", key: "ji33uf" }], ["path", { d: "M12 6v14", key: "1n7gus" }], ["path", { d: "M8 8v12", key: "1gg7y9" }], ["path", { d: "M4 4v16", key: "6qkkli" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Xve = Rt("Link", [["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }], ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const BS = Rt("Linkedin", [["path", { d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z", key: "c2jq9f" }], ["rect", { width: "4", height: "12", x: "2", y: "9", key: "mk3on5" }], ["circle", { cx: "4", cy: "4", r: "2", key: "bt5ra8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sa = Rt("LoaderCircle", [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zh = Rt("Lock", [["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }], ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const CJ = Rt("LogOut", [["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }], ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }], ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Lu = Rt("Mail", [["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }], ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Yve = Rt("MapPin", [["path", { d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0", key: "1r0f0z" }], ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Kve = Rt("Menu", [["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }], ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }], ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ff = Rt("MessageSquare", [["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const NJ = Rt("MicOff", [["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }], ["path", { d: "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2", key: "80xlxr" }], ["path", { d: "M5 10v2a7 7 0 0 0 12 5", key: "p2k8kg" }], ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }], ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }], ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const VT = Rt("Mic", [["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }], ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }], ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zve = Rt("Moon", [["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z", key: "a7tn18" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Qve = Rt("Palette", [["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }], ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }], ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }], ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }], ["path", { d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z", key: "12rzf8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const x8 = Rt("PanelsTopLeft", [["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }], ["path", { d: "M3 9h18", key: "1pudct" }], ["path", { d: "M9 21V9", key: "1oto5p" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Jve = Rt("Pause", [["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }], ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const eye = Rt("PhoneOff", [["path", { d: "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91", key: "z86iuo" }], ["line", { x1: "22", x2: "2", y1: "2", y2: "22", key: "11kh81" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const AJ = Rt("Phone", [["path", { d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z", key: "foiqr5" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yg = Rt("Play", [["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const HT = Rt("Plus", [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "M12 5v14", key: "s699le" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xT = Rt("RefreshCw", [["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }], ["path", { d: "M21 3v5h-5", key: "1q7to0" }], ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }], ["path", { d: "M8 16H3v5", key: "1cv678" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const PJ = Rt("Save", [["path", { d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z", key: "1c8476" }], ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7", key: "1ydtos" }], ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7", key: "t51u73" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lg = Rt("Search", [["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }], ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const h0 = Rt("Settings", [["path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z", key: "1qme2f" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cx = Rt("Shield", [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ia = Rt("Sparkles", [["path", { d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z", key: "4pj2yx" }], ["path", { d: "M20 3v4", key: "1olli1" }], ["path", { d: "M22 5h-4", key: "1gvqau" }], ["path", { d: "M4 17v2", key: "vumght" }], ["path", { d: "M5 18H3", key: "zchphs" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const m5 = Rt("SquarePen", [["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }], ["path", { d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z", key: "ohrbg2" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ug = Rt("Star", [["path", { d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z", key: "r04s7s" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tye = Rt("Sun", [["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }], ["path", { d: "M12 2v2", key: "tus03m" }], ["path", { d: "M12 20v2", key: "1lh1kg" }], ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }], ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }], ["path", { d: "M2 12h2", key: "1t8f8n" }], ["path", { d: "M20 12h2", key: "1q8mjw" }], ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }], ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Qh = Rt("Target", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }], ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const nye = Rt("ThumbsDown", [["path", { d: "M17 14V2", key: "8ymqnk" }], ["path", { d: "M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z", key: "m61m77" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rye = Rt("ThumbsUp", [["path", { d: "M7 10v12", key: "1qc93n" }], ["path", { d: "M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z", key: "emmmcr" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Bg = Rt("Trash2", [["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }], ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }], ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }], ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fu = Rt("TrendingUp", [["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }], ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const p0 = Rt("TriangleAlert", [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3", key: "wmoenq" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const g5 = Rt("Twitter", [["path", { d: "M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z", key: "pff0z6" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const iye = Rt("Type", [["polyline", { points: "4 7 4 4 20 4 20 7", key: "1nosan" }], ["line", { x1: "9", x2: "15", y1: "20", y2: "20", key: "swin9y" }], ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $S = Rt("Upload", [["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }], ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }], ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const aye = Rt("UserCheck", [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["polyline", { points: "16 11 18 13 22 9", key: "1pwet4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bT = Rt("UserPlus", [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["line", { x1: "19", x2: "19", y1: "8", y2: "14", key: "1bvyxn" }], ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hf = Rt("User", [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qc = Rt("Users", [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }], ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const b8 = Rt("VideoOff", [["path", { d: "M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196", key: "w8jjjt" }], ["path", { d: "M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2", key: "1xawa7" }], ["path", { d: "m2 2 20 20", key: "1ooewy" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fo = Rt("Video", [["path", { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5", key: "ftymec" }], ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sye = Rt("Volume2", [["path", { d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z", key: "uqj9uw" }], ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }], ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Pa = Rt("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vA = Rt("Zap", [["path", { d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z", key: "1xq2db" }]]); let oye = class extends S.Component { state = { hasError: !1, error: null }; static getDerivedStateFromError(e) { return { hasError: !0, error: e } } componentDidCatch(e, n) { console.error("[ErrorBoundary] Unhandled error:", e.message) } render() { return this.state.hasError ? this.props.fallback || l.jsx("div", { className: "min-h-screen flex items-center justify-center", children: l.jsxs("div", { className: "text-center space-y-4", children: [l.jsx(p0, { className: "h-12 w-12 text-warning mx-auto" }), l.jsx("h2", { className: "text-2xl font-bold", children: "Something went wrong" }), l.jsx("p", { className: "text-muted-foreground", children: "Please try refreshing the page or contact support if the problem persists." }), l.jsx("button", { onClick: () => window.location.reload(), className: "bg-primary text-white px-4 py-2 rounded-md hover:bg-primary/90", children: "Refresh Page" })] }) }) : this.props.children } }; function lye() { const { user: t, loading: e } = La(), n = ui(), r = fs(); return S.useEffect(() => { if (["/", "/login", "/pricing", "/resources", "/faq", "/forgot-password"].includes(r.pathname) || r.pathname.startsWith("/reset-password/") || e || !t) return; const a = r.pathname, s = ["/rejected-notice", "/pending-verification", "/login", "/oauth/select-role"]; if (!a.startsWith("/dashboard") && !s.includes(a)) { if (t.oauthRolePending) { n("/oauth/select-role", { replace: !0 }); return } if (t.role === "interviewer" && t.status === "rejected") { n("/rejected-notice", { replace: !0 }); return } if (t.role === "interviewer" && t.status === "pending_verification") { n("/pending-verification", { replace: !0 }); return } } }, [t, e, n, r.pathname]), null } const cye = 1, uye = 1e6; let Mj = 0; function dye() { return Mj = (Mj + 1) % Number.MAX_SAFE_INTEGER, Mj.toString() } const Tj = new Map, w8 = t => { if (Tj.has(t)) return; const e = setTimeout(() => { Tj.delete(t), Uw({ type: "REMOVE_TOAST", toastId: t }) }, uye); Tj.set(t, e) }, fye = (t, e) => { switch (e.type) { case "ADD_TOAST": return { ...t, toasts: [e.toast, ...t.toasts].slice(0, cye) }; case "UPDATE_TOAST": return { ...t, toasts: t.toasts.map(n => n.id === e.toast.id ? { ...n, ...e.toast } : n) }; case "DISMISS_TOAST": { const { toastId: n } = e; return n ? w8(n) : t.toasts.forEach(r => { w8(r.id) }), { ...t, toasts: t.toasts.map(r => r.id === n || n === void 0 ? { ...r, open: !1 } : r) } } case "REMOVE_TOAST": return e.toastId === void 0 ? { ...t, toasts: [] } : { ...t, toasts: t.toasts.filter(n => n.id !== e.toastId) } } }, wT = []; let ST = { toasts: [] }; function Uw(t) { ST = fye(ST, t), wT.forEach(e => { e(ST) }) } function hye({ ...t }) { const e = dye(), n = i => Uw({ type: "UPDATE_TOAST", toast: { ...i, id: e } }), r = () => Uw({ type: "DISMISS_TOAST", toastId: e }); return Uw({ type: "ADD_TOAST", toast: { ...t, id: e, open: !0, onOpenChange: i => { i || r() } } }), { id: e, dismiss: r, update: n } } function pye() { const [t, e] = S.useState(ST); return S.useEffect(() => (wT.push(e), () => { const n = wT.indexOf(e); n > -1 && wT.splice(n, 1) }), [t]), { ...t, toast: hye, dismiss: n => Uw({ type: "DISMISS_TOAST", toastId: n }) } } function Mt(t, e, { checkForDefaultPrevented: n = !0 } = {}) { return function (i) { if (t?.(i), n === !1 || !i.defaultPrevented) return e?.(i) } } function S8(t, e) { if (typeof t == "function") return t(e); t != null && (t.current = e) } function yA(...t) { return e => { let n = !1; const r = t.map(i => { const a = S8(i, e); return !n && typeof a == "function" && (n = !0), a }); if (n) return () => { for (let i = 0; i < r.length; i++) { const a = r[i]; typeof a == "function" ? a() : S8(t[i], null) } } } } function Mn(...t) { return S.useCallback(yA(...t), t) } function mye(t, e) { const n = S.createContext(e), r = a => { const { children: s, ...o } = a, c = S.useMemo(() => o, Object.values(o)); return l.jsx(n.Provider, { value: c, children: s }) }; r.displayName = t + "Provider"; function i(a) { const s = S.useContext(n); if (s) return s; if (e !== void 0) return e; throw new Error(`\`${a}\` must be used within \`${t}\``) } return [r, i] } function oa(t, e = []) { let n = []; function r(a, s) { const o = S.createContext(s), c = n.length; n = [...n, s]; const u = f => { const { scope: h, children: m, ...g } = f, x = h?.[t]?.[c] || o, v = S.useMemo(() => g, Object.values(g)); return l.jsx(x.Provider, { value: v, children: m }) }; u.displayName = a + "Provider"; function d(f, h) { const m = h?.[t]?.[c] || o, g = S.useContext(m); if (g) return g; if (s !== void 0) return s; throw new Error(`\`${f}\` must be used within \`${a}\``) } return [u, d] } const i = () => { const a = n.map(s => S.createContext(s)); return function (o) { const c = o?.[t] || a; return S.useMemo(() => ({ [`__scope${t}`]: { ...o, [t]: c } }), [o, c]) } }; return i.scopeName = t, [r, gye(i, ...e)] } function gye(...t) { const e = t[0]; if (t.length === 1) return e; const n = () => { const r = t.map(i => ({ useScope: i(), scopeName: i.scopeName })); return function (a) { const s = r.reduce((o, { useScope: c, scopeName: u }) => { const f = c(a)[`__scope${u}`]; return { ...o, ...f } }, {}); return S.useMemo(() => ({ [`__scope${e.scopeName}`]: s }), [s]) } }; return n.scopeName = e.scopeName, n } function xg(t) { const e = vye(t), n = S.forwardRef((r, i) => { const { children: a, ...s } = r, o = S.Children.toArray(a), c = o.find(yye); if (c) { const u = c.props.children, d = o.map(f => f === c ? S.Children.count(u) > 1 ? S.Children.only(null) : S.isValidElement(u) ? u.props.children : null : f); return l.jsx(e, { ...s, ref: i, children: S.isValidElement(u) ? S.cloneElement(u, void 0, d) : null }) } return l.jsx(e, { ...s, ref: i, children: a }) }); return n.displayName = `${t}.Slot`, n } var jJ = xg("Slot"); function vye(t) { const e = S.forwardRef((n, r) => { const { children: i, ...a } = n; if (S.isValidElement(i)) { const s = bye(i), o = xye(a, i.props); return i.type !== S.Fragment && (o.ref = r ? yA(r, s) : s), S.cloneElement(i, o) } return S.Children.count(i) > 1 ? S.Children.only(null) : null }); return e.displayName = `${t}.SlotClone`, e } var RJ = Symbol("radix.slottable"); function kJ(t) { const e = ({ children: n }) => l.jsx(l.Fragment, { children: n }); return e.displayName = `${t}.Slottable`, e.__radixId = RJ, e } function yye(t) { return S.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === RJ } function xye(t, e) { const n = { ...e }; for (const r in e) { const i = t[r], a = e[r]; /^on[A-Z]/.test(r) ? i && a ? n[r] = (...o) => { const c = a(...o); return i(...o), c } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...a } : r === "className" && (n[r] = [i, a].filter(Boolean).join(" ")) } return { ...t, ...n } } function bye(t) { let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning; return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref) } function m0(t) { const e = t + "CollectionProvider", [n, r] = oa(e), [i, a] = n(e, { collectionRef: { current: null }, itemMap: new Map }), s = x => { const { scope: v, children: b } = x, E = P.useRef(null), M = P.useRef(new Map).current; return l.jsx(i, { scope: v, itemMap: M, collectionRef: E, children: b }) }; s.displayName = e; const o = t + "CollectionSlot", c = xg(o), u = P.forwardRef((x, v) => { const { scope: b, children: E } = x, M = a(o, b), C = Mn(v, M.collectionRef); return l.jsx(c, { ref: C, children: E }) }); u.displayName = o; const d = t + "CollectionItemSlot", f = "data-radix-collection-item", h = xg(d), m = P.forwardRef((x, v) => { const { scope: b, children: E, ...M } = x, C = P.useRef(null), N = Mn(v, C), A = a(d, b); return P.useEffect(() => (A.itemMap.set(C, { ref: C, ...M }), () => void A.itemMap.delete(C))), l.jsx(h, { [f]: "", ref: N, children: E }) }); m.displayName = d; function g(x) { const v = a(t + "CollectionConsumer", x); return P.useCallback(() => { const E = v.collectionRef.current; if (!E) return []; const M = Array.from(E.querySelectorAll(`[${f}]`)); return Array.from(v.itemMap.values()).sort((A, j) => M.indexOf(A.ref.current) - M.indexOf(j.ref.current)) }, [v.collectionRef, v.itemMap]) } return [{ Provider: s, Slot: u, ItemSlot: m }, g, r] } var wye = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], qt = wye.reduce((t, e) => { const n = xg(`Primitive.${e}`), r = S.forwardRef((i, a) => { const { asChild: s, ...o } = i, c = s ? n : e; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), l.jsx(c, { ...o, ref: a }) }); return r.displayName = `Primitive.${e}`, { ...t, [e]: r } }, {}); function v5(t, e) { t && xi.flushSync(() => t.dispatchEvent(e)) } function Yi(t) { const e = S.useRef(t); return S.useEffect(() => { e.current = t }), S.useMemo(() => (...n) => e.current?.(...n), []) } function Sye(t, e = globalThis?.document) { const n = Yi(t); S.useEffect(() => { const r = i => { i.key === "Escape" && n(i) }; return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 }) }, [n, e]) } var _ye = "DismissableLayer", q3 = "dismissableLayer.update", Eye = "dismissableLayer.pointerDownOutside", Mye = "dismissableLayer.focusOutside", _8, IJ = S.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), g0 = S.forwardRef((t, e) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: i, onFocusOutside: a, onInteractOutside: s, onDismiss: o, ...c } = t, u = S.useContext(IJ), [d, f] = S.useState(null), h = d?.ownerDocument ?? globalThis?.document, [, m] = S.useState({}), g = Mn(e, j => f(j)), x = Array.from(u.layers), [v] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), b = x.indexOf(v), E = d ? x.indexOf(d) : -1, M = u.layersWithOutsidePointerEventsDisabled.size > 0, C = E >= b, N = Cye(j => { const O = j.target, I = [...u.branches].some(D => D.contains(O)); !C || I || (i?.(j), s?.(j), j.defaultPrevented || o?.()) }, h), A = Nye(j => { const O = j.target;[...u.branches].some(D => D.contains(O)) || (a?.(j), s?.(j), j.defaultPrevented || o?.()) }, h); return Sye(j => { E === u.layers.size - 1 && (r?.(j), !j.defaultPrevented && o && (j.preventDefault(), o())) }, h), S.useEffect(() => { if (d) return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (_8 = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), E8(), () => { n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = _8) } }, [d, h, n, u]), S.useEffect(() => () => { d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), E8()) }, [d, u]), S.useEffect(() => { const j = () => m({}); return document.addEventListener(q3, j), () => document.removeEventListener(q3, j) }, []), l.jsx(qt.div, { ...c, ref: g, style: { pointerEvents: M ? C ? "auto" : "none" : void 0, ...t.style }, onFocusCapture: Mt(t.onFocusCapture, A.onFocusCapture), onBlurCapture: Mt(t.onBlurCapture, A.onBlurCapture), onPointerDownCapture: Mt(t.onPointerDownCapture, N.onPointerDownCapture) }) }); g0.displayName = _ye; var Tye = "DismissableLayerBranch", OJ = S.forwardRef((t, e) => { const n = S.useContext(IJ), r = S.useRef(null), i = Mn(e, r); return S.useEffect(() => { const a = r.current; if (a) return n.branches.add(a), () => { n.branches.delete(a) } }, [n.branches]), l.jsx(qt.div, { ...t, ref: i }) }); OJ.displayName = Tye; function Cye(t, e = globalThis?.document) { const n = Yi(t), r = S.useRef(!1), i = S.useRef(() => { }); return S.useEffect(() => { const a = o => { if (o.target && !r.current) { let c = function () { DJ(Eye, n, u, { discrete: !0 }) }; const u = { originalEvent: o }; o.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = c, e.addEventListener("click", i.current, { once: !0 })) : c() } else e.removeEventListener("click", i.current); r.current = !1 }, s = window.setTimeout(() => { e.addEventListener("pointerdown", a) }, 0); return () => { window.clearTimeout(s), e.removeEventListener("pointerdown", a), e.removeEventListener("click", i.current) } }, [e, n]), { onPointerDownCapture: () => r.current = !0 } } function Nye(t, e = globalThis?.document) { const n = Yi(t), r = S.useRef(!1); return S.useEffect(() => { const i = a => { a.target && !r.current && DJ(Mye, n, { originalEvent: a }, { discrete: !1 }) }; return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i) }, [e, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function E8() { const t = new CustomEvent(q3); document.dispatchEvent(t) } function DJ(t, e, n, { discrete: r }) { const i = n.originalEvent.target, a = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n }); e && i.addEventListener(t, e, { once: !0 }), r ? v5(i, a) : i.dispatchEvent(a) } var Aye = g0, Pye = OJ, Ki = globalThis?.document ? S.useLayoutEffect : () => { }, jye = "Portal", zS = S.forwardRef((t, e) => { const { container: n, ...r } = t, [i, a] = S.useState(!1); Ki(() => a(!0), []); const s = n || i && globalThis?.document?.body; return s ? rJ.createPortal(l.jsx(qt.div, { ...r, ref: e }), s) : null }); zS.displayName = jye; function Rye(t, e) { return S.useReducer((n, r) => e[n][r] ?? n, t) } var Ka = t => { const { present: e, children: n } = t, r = kye(e), i = typeof n == "function" ? n({ present: r.isPresent }) : S.Children.only(n), a = Mn(r.ref, Iye(i)); return typeof n == "function" || r.isPresent ? S.cloneElement(i, { ref: a }) : null }; Ka.displayName = "Presence"; function kye(t) { const [e, n] = S.useState(), r = S.useRef(null), i = S.useRef(t), a = S.useRef("none"), s = t ? "mounted" : "unmounted", [o, c] = Rye(s, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return S.useEffect(() => { const u = LE(r.current); a.current = o === "mounted" ? u : "none" }, [o]), Ki(() => { const u = r.current, d = i.current; if (d !== t) { const h = a.current, m = LE(u); t ? c("MOUNT") : m === "none" || u?.display === "none" ? c("UNMOUNT") : c(d && h !== m ? "ANIMATION_OUT" : "UNMOUNT"), i.current = t } }, [t, c]), Ki(() => { if (e) { let u; const d = e.ownerDocument.defaultView ?? window, f = m => { const x = LE(r.current).includes(m.animationName); if (m.target === e && x && (c("ANIMATION_END"), !i.current)) { const v = e.style.animationFillMode; e.style.animationFillMode = "forwards", u = d.setTimeout(() => { e.style.animationFillMode === "forwards" && (e.style.animationFillMode = v) }) } }, h = m => { m.target === e && (a.current = LE(r.current)) }; return e.addEventListener("animationstart", h), e.addEventListener("animationcancel", f), e.addEventListener("animationend", f), () => { d.clearTimeout(u), e.removeEventListener("animationstart", h), e.removeEventListener("animationcancel", f), e.removeEventListener("animationend", f) } } else c("ANIMATION_END") }, [e, c]), { isPresent: ["mounted", "unmountSuspended"].includes(o), ref: S.useCallback(u => { r.current = u ? getComputedStyle(u) : null, n(u) }, []) } } function LE(t) { return t?.animationName || "none" } function Iye(t) { let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning; return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref) } var Oye = Yh[" useInsertionEffect ".trim().toString()] || Ki; function Uo({ prop: t, defaultProp: e, onChange: n = () => { }, caller: r }) { const [i, a, s] = Dye({ defaultProp: e, onChange: n }), o = t !== void 0, c = o ? t : i; { const d = S.useRef(t !== void 0); S.useEffect(() => { const f = d.current; f !== o && console.warn(`${r} is changing from ${f ? "controlled" : "uncontrolled"} to ${o ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), d.current = o }, [o, r]) } const u = S.useCallback(d => { if (o) { const f = Lye(d) ? d(t) : d; f !== t && s.current?.(f) } else a(d) }, [o, t, a, s]); return [c, u] } function Dye({ defaultProp: t, onChange: e }) { const [n, r] = S.useState(t), i = S.useRef(n), a = S.useRef(e); return Oye(() => { a.current = e }, [e]), S.useEffect(() => { i.current !== n && (a.current?.(n), i.current = n) }, [n, i]), [n, r, a] } function Lye(t) { return typeof t == "function" } var LJ = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), Fye = "VisuallyHidden", xA = S.forwardRef((t, e) => l.jsx(qt.span, { ...t, ref: e, style: { ...LJ, ...t.style } })); xA.displayName = Fye; var Uye = xA, y5 = "ToastProvider", [x5, Bye, $ye] = m0("Toast"), [FJ] = oa("Toast", [$ye]), [zye, bA] = FJ(y5), UJ = t => { const { __scopeToast: e, label: n = "Notification", duration: r = 5e3, swipeDirection: i = "right", swipeThreshold: a = 50, children: s } = t, [o, c] = S.useState(null), [u, d] = S.useState(0), f = S.useRef(!1), h = S.useRef(!1); return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${y5}\`. Expected non-empty \`string\`.`), l.jsx(x5.Provider, { scope: e, children: l.jsx(zye, { scope: e, label: n, duration: r, swipeDirection: i, swipeThreshold: a, toastCount: u, viewport: o, onViewportChange: c, onToastAdd: S.useCallback(() => d(m => m + 1), []), onToastRemove: S.useCallback(() => d(m => m - 1), []), isFocusedToastEscapeKeyDownRef: f, isClosePausedRef: h, children: s }) }) }; UJ.displayName = y5; var BJ = "ToastViewport", Vye = ["F8"], X3 = "toast.viewportPause", Y3 = "toast.viewportResume", $J = S.forwardRef((t, e) => { const { __scopeToast: n, hotkey: r = Vye, label: i = "Notifications ({hotkey})", ...a } = t, s = bA(BJ, n), o = Bye(n), c = S.useRef(null), u = S.useRef(null), d = S.useRef(null), f = S.useRef(null), h = Mn(e, f, s.onViewportChange), m = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), g = s.toastCount > 0; S.useEffect(() => { const v = b => { r.length !== 0 && r.every(M => b[M] || b.code === M) && f.current?.focus() }; return document.addEventListener("keydown", v), () => document.removeEventListener("keydown", v) }, [r]), S.useEffect(() => { const v = c.current, b = f.current; if (g && v && b) { const E = () => { if (!s.isClosePausedRef.current) { const A = new CustomEvent(X3); b.dispatchEvent(A), s.isClosePausedRef.current = !0 } }, M = () => { if (s.isClosePausedRef.current) { const A = new CustomEvent(Y3); b.dispatchEvent(A), s.isClosePausedRef.current = !1 } }, C = A => { !v.contains(A.relatedTarget) && M() }, N = () => { v.contains(document.activeElement) || M() }; return v.addEventListener("focusin", E), v.addEventListener("focusout", C), v.addEventListener("pointermove", E), v.addEventListener("pointerleave", N), window.addEventListener("blur", E), window.addEventListener("focus", M), () => { v.removeEventListener("focusin", E), v.removeEventListener("focusout", C), v.removeEventListener("pointermove", E), v.removeEventListener("pointerleave", N), window.removeEventListener("blur", E), window.removeEventListener("focus", M) } } }, [g, s.isClosePausedRef]); const x = S.useCallback(({ tabbingDirection: v }) => { const E = o().map(M => { const C = M.ref.current, N = [C, ...nxe(C)]; return v === "forwards" ? N : N.reverse() }); return (v === "forwards" ? E.reverse() : E).flat() }, [o]); return S.useEffect(() => { const v = f.current; if (v) { const b = E => { const M = E.altKey || E.ctrlKey || E.metaKey; if (E.key === "Tab" && !M) { const N = document.activeElement, A = E.shiftKey; if (E.target === v && A) { u.current?.focus(); return } const I = x({ tabbingDirection: A ? "backwards" : "forwards" }), D = I.findIndex(F => F === N); Cj(I.slice(D + 1)) ? E.preventDefault() : A ? u.current?.focus() : d.current?.focus() } }; return v.addEventListener("keydown", b), () => v.removeEventListener("keydown", b) } }, [o, x]), l.jsxs(Pye, { ref: c, role: "region", "aria-label": i.replace("{hotkey}", m), tabIndex: -1, style: { pointerEvents: g ? void 0 : "none" }, children: [g && l.jsx(K3, { ref: u, onFocusFromOutsideViewport: () => { const v = x({ tabbingDirection: "forwards" }); Cj(v) } }), l.jsx(x5.Slot, { scope: n, children: l.jsx(qt.ol, { tabIndex: -1, ...a, ref: h }) }), g && l.jsx(K3, { ref: d, onFocusFromOutsideViewport: () => { const v = x({ tabbingDirection: "backwards" }); Cj(v) } })] }) }); $J.displayName = BJ; var zJ = "ToastFocusProxy", K3 = S.forwardRef((t, e) => { const { __scopeToast: n, onFocusFromOutsideViewport: r, ...i } = t, a = bA(zJ, n); return l.jsx(xA, { "aria-hidden": !0, tabIndex: 0, ...i, ref: e, style: { position: "fixed" }, onFocus: s => { const o = s.relatedTarget; !a.viewport?.contains(o) && r() } }) }); K3.displayName = zJ; var VS = "Toast", Hye = "toast.swipeStart", Wye = "toast.swipeMove", Gye = "toast.swipeCancel", qye = "toast.swipeEnd", VJ = S.forwardRef((t, e) => { const { forceMount: n, open: r, defaultOpen: i, onOpenChange: a, ...s } = t, [o, c] = Uo({ prop: r, defaultProp: i ?? !0, onChange: a, caller: VS }); return l.jsx(Ka, { present: n || o, children: l.jsx(Kye, { open: o, ...s, ref: e, onClose: () => c(!1), onPause: Yi(t.onPause), onResume: Yi(t.onResume), onSwipeStart: Mt(t.onSwipeStart, u => { u.currentTarget.setAttribute("data-swipe", "start") }), onSwipeMove: Mt(t.onSwipeMove, u => { const { x: d, y: f } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${f}px`) }), onSwipeCancel: Mt(t.onSwipeCancel, u => { u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y") }), onSwipeEnd: Mt(t.onSwipeEnd, u => { const { x: d, y: f } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${f}px`), c(!1) }) }) }) }); VJ.displayName = VS; var [Xye, Yye] = FJ(VS, { onClose() { } }), Kye = S.forwardRef((t, e) => { const { __scopeToast: n, type: r = "foreground", duration: i, open: a, onClose: s, onEscapeKeyDown: o, onPause: c, onResume: u, onSwipeStart: d, onSwipeMove: f, onSwipeCancel: h, onSwipeEnd: m, ...g } = t, x = bA(VS, n), [v, b] = S.useState(null), E = Mn(e, z => b(z)), M = S.useRef(null), C = S.useRef(null), N = i || x.duration, A = S.useRef(0), j = S.useRef(N), O = S.useRef(0), { onToastAdd: I, onToastRemove: D } = x, F = Yi(() => { v?.contains(document.activeElement) && x.viewport?.focus(), s() }), B = S.useCallback(z => { !z || z === 1 / 0 || (window.clearTimeout(O.current), A.current = new Date().getTime(), O.current = window.setTimeout(F, z)) }, [F]); S.useEffect(() => { const z = x.viewport; if (z) { const q = () => { B(j.current), u?.() }, Y = () => { const Z = new Date().getTime() - A.current; j.current = j.current - Z, window.clearTimeout(O.current), c?.() }; return z.addEventListener(X3, Y), z.addEventListener(Y3, q), () => { z.removeEventListener(X3, Y), z.removeEventListener(Y3, q) } } }, [x.viewport, N, c, u, B]), S.useEffect(() => { a && !x.isClosePausedRef.current && B(N) }, [a, N, x.isClosePausedRef, B]), S.useEffect(() => (I(), () => D()), [I, D]); const G = S.useMemo(() => v ? KJ(v) : null, [v]); return x.viewport ? l.jsxs(l.Fragment, { children: [G && l.jsx(Zye, { __scopeToast: n, role: "status", "aria-live": r === "foreground" ? "assertive" : "polite", "aria-atomic": !0, children: G }), l.jsx(Xye, { scope: n, onClose: F, children: xi.createPortal(l.jsx(x5.ItemSlot, { scope: n, children: l.jsx(Aye, { asChild: !0, onEscapeKeyDown: Mt(o, () => { x.isFocusedToastEscapeKeyDownRef.current || F(), x.isFocusedToastEscapeKeyDownRef.current = !1 }), children: l.jsx(qt.li, { role: "status", "aria-live": "off", "aria-atomic": !0, tabIndex: 0, "data-state": a ? "open" : "closed", "data-swipe-direction": x.swipeDirection, ...g, ref: E, style: { userSelect: "none", touchAction: "none", ...t.style }, onKeyDown: Mt(t.onKeyDown, z => { z.key === "Escape" && (o?.(z.nativeEvent), z.nativeEvent.defaultPrevented || (x.isFocusedToastEscapeKeyDownRef.current = !0, F())) }), onPointerDown: Mt(t.onPointerDown, z => { z.button === 0 && (M.current = { x: z.clientX, y: z.clientY }) }), onPointerMove: Mt(t.onPointerMove, z => { if (!M.current) return; const q = z.clientX - M.current.x, Y = z.clientY - M.current.y, Z = !!C.current, $ = ["left", "right"].includes(x.swipeDirection), V = ["left", "up"].includes(x.swipeDirection) ? Math.min : Math.max, K = $ ? V(0, q) : 0, X = $ ? 0 : V(0, Y), Q = z.pointerType === "touch" ? 10 : 2, re = { x: K, y: X }, ce = { originalEvent: z, delta: re }; Z ? (C.current = re, FE(Wye, f, ce, { discrete: !1 })) : M8(re, x.swipeDirection, Q) ? (C.current = re, FE(Hye, d, ce, { discrete: !1 }), z.target.setPointerCapture(z.pointerId)) : (Math.abs(q) > Q || Math.abs(Y) > Q) && (M.current = null) }), onPointerUp: Mt(t.onPointerUp, z => { const q = C.current, Y = z.target; if (Y.hasPointerCapture(z.pointerId) && Y.releasePointerCapture(z.pointerId), C.current = null, M.current = null, q) { const Z = z.currentTarget, $ = { originalEvent: z, delta: q }; M8(q, x.swipeDirection, x.swipeThreshold) ? FE(qye, m, $, { discrete: !0 }) : FE(Gye, h, $, { discrete: !0 }), Z.addEventListener("click", V => V.preventDefault(), { once: !0 }) } }) }) }) }), x.viewport) })] }) : null }), Zye = t => { const { __scopeToast: e, children: n, ...r } = t, i = bA(VS, e), [a, s] = S.useState(!1), [o, c] = S.useState(!1); return exe(() => s(!0)), S.useEffect(() => { const u = window.setTimeout(() => c(!0), 1e3); return () => window.clearTimeout(u) }, []), o ? null : l.jsx(zS, { asChild: !0, children: l.jsx(xA, { ...r, children: a && l.jsxs(l.Fragment, { children: [i.label, " ", n] }) }) }) }, Qye = "ToastTitle", HJ = S.forwardRef((t, e) => { const { __scopeToast: n, ...r } = t; return l.jsx(qt.div, { ...r, ref: e }) }); HJ.displayName = Qye; var Jye = "ToastDescription", WJ = S.forwardRef((t, e) => { const { __scopeToast: n, ...r } = t; return l.jsx(qt.div, { ...r, ref: e }) }); WJ.displayName = Jye; var GJ = "ToastAction", qJ = S.forwardRef((t, e) => { const { altText: n, ...r } = t; return n.trim() ? l.jsx(YJ, { altText: n, asChild: !0, children: l.jsx(b5, { ...r, ref: e }) }) : (console.error(`Invalid prop \`altText\` supplied to \`${GJ}\`. Expected non-empty \`string\`.`), null) }); qJ.displayName = GJ; var XJ = "ToastClose", b5 = S.forwardRef((t, e) => { const { __scopeToast: n, ...r } = t, i = Yye(XJ, n); return l.jsx(YJ, { asChild: !0, children: l.jsx(qt.button, { type: "button", ...r, ref: e, onClick: Mt(t.onClick, i.onClose) }) }) }); b5.displayName = XJ; var YJ = S.forwardRef((t, e) => { const { __scopeToast: n, altText: r, ...i } = t; return l.jsx(qt.div, { "data-radix-toast-announce-exclude": "", "data-radix-toast-announce-alt": r || void 0, ...i, ref: e }) }); function KJ(t) { const e = []; return Array.from(t.childNodes).forEach(r => { if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), txe(r)) { const i = r.ariaHidden || r.hidden || r.style.display === "none", a = r.dataset.radixToastAnnounceExclude === ""; if (!i) if (a) { const s = r.dataset.radixToastAnnounceAlt; s && e.push(s) } else e.push(...KJ(r)) } }), e } function FE(t, e, n, { discrete: r }) { const i = n.originalEvent.currentTarget, a = new CustomEvent(t, { bubbles: !0, cancelable: !0, detail: n }); e && i.addEventListener(t, e, { once: !0 }), r ? v5(i, a) : i.dispatchEvent(a) } var M8 = (t, e, n = 0) => { const r = Math.abs(t.x), i = Math.abs(t.y), a = r > i; return e === "left" || e === "right" ? a && r > n : !a && i > n }; function exe(t = () => { }) { const e = Yi(t); Ki(() => { let n = 0, r = 0; return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(e)), () => { window.cancelAnimationFrame(n), window.cancelAnimationFrame(r) } }, [e]) } function txe(t) { return t.nodeType === t.ELEMENT_NODE } function nxe(t) { const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const i = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)e.push(n.currentNode); return e } function Cj(t) { const e = document.activeElement; return t.some(n => n === e ? !0 : (n.focus(), document.activeElement !== e)) } var rxe = UJ, ZJ = $J, QJ = VJ, JJ = HJ, eee = WJ, tee = qJ, nee = b5; function ree(t) { var e, n, r = ""; if (typeof t == "string" || typeof t == "number") r += t; else if (typeof t == "object") if (Array.isArray(t)) { var i = t.length; for (e = 0; e < i; e++)t[e] && (n = ree(t[e])) && (r && (r += " "), r += n) } else for (n in t) t[n] && (r && (r += " "), r += n); return r } function zn() { for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)(t = arguments[n]) && (e = ree(t)) && (r && (r += " "), r += e); return r } const T8 = t => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, C8 = zn, $g = (t, e) => n => { var r; if (e?.variants == null) return C8(t, n?.class, n?.className); const { variants: i, defaultVariants: a } = e, s = Object.keys(i).map(u => { const d = n?.[u], f = a?.[u]; if (d === null) return null; const h = T8(d) || T8(f); return i[u][h] }), o = n && Object.entries(n).reduce((u, d) => { let [f, h] = d; return h === void 0 || (u[f] = h), u }, {}), c = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, d) => { let { class: f, className: h, ...m } = d; return Object.entries(m).every(g => { let [x, v] = g; return Array.isArray(v) ? v.includes({ ...a, ...o }[x]) : { ...a, ...o }[x] === v }) ? [...u, f, h] : u }, []); return C8(t, s, c, n?.class, n?.className) }, w5 = "-", ixe = t => { const e = sxe(t), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = t; return { getClassGroupId: s => { const o = s.split(w5); return o[0] === "" && o.length !== 1 && o.shift(), iee(o, e) || axe(s) }, getConflictingClassGroupIds: (s, o) => { const c = n[s] || []; return o && r[s] ? [...c, ...r[s]] : c } } }, iee = (t, e) => { if (t.length === 0) return e.classGroupId; const n = t[0], r = e.nextPart.get(n), i = r ? iee(t.slice(1), r) : void 0; if (i) return i; if (e.validators.length === 0) return; const a = t.join(w5); return e.validators.find(({ validator: s }) => s(a))?.classGroupId }, N8 = /^\[(.+)\]$/, axe = t => { if (N8.test(t)) { const e = N8.exec(t)[1], n = e?.substring(0, e.indexOf(":")); if (n) return "arbitrary.." + n } }, sxe = t => { const { theme: e, prefix: n } = t, r = { nextPart: new Map, validators: [] }; return lxe(Object.entries(t.classGroups), n).forEach(([a, s]) => { Z3(s, r, a, e) }), r }, Z3 = (t, e, n, r) => { t.forEach(i => { if (typeof i == "string") { const a = i === "" ? e : A8(e, i); a.classGroupId = n; return } if (typeof i == "function") { if (oxe(i)) { Z3(i(r), e, n, r); return } e.validators.push({ validator: i, classGroupId: n }); return } Object.entries(i).forEach(([a, s]) => { Z3(s, A8(e, a), n, r) }) }) }, A8 = (t, e) => { let n = t; return e.split(w5).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, oxe = t => t.isThemeGetter, lxe = (t, e) => e ? t.map(([n, r]) => { const i = r.map(a => typeof a == "string" ? e + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([s, o]) => [e + s, o])) : a); return [n, i] }) : t, cxe = t => { if (t < 1) return { get: () => { }, set: () => { } }; let e = 0, n = new Map, r = new Map; const i = (a, s) => { n.set(a, s), e++, e > t && (e = 0, r = n, n = new Map) }; return { get(a) { let s = n.get(a); if (s !== void 0) return s; if ((s = r.get(a)) !== void 0) return i(a, s), s }, set(a, s) { n.has(a) ? n.set(a, s) : i(a, s) } } }, aee = "!", uxe = t => { const { separator: e, experimentalParseClassName: n } = t, r = e.length === 1, i = e[0], a = e.length, s = o => { const c = []; let u = 0, d = 0, f; for (let v = 0; v < o.length; v++) { let b = o[v]; if (u === 0) { if (b === i && (r || o.slice(v, v + a) === e)) { c.push(o.slice(d, v)), d = v + a; continue } if (b === "/") { f = v; continue } } b === "[" ? u++ : b === "]" && u-- } const h = c.length === 0 ? o : o.substring(d), m = h.startsWith(aee), g = m ? h.substring(1) : h, x = f && f > d ? f - d : void 0; return { modifiers: c, hasImportantModifier: m, baseClassName: g, maybePostfixModifierPosition: x } }; return n ? o => n({ className: o, parseClassName: s }) : s }, dxe = t => { if (t.length <= 1) return t; const e = []; let n = []; return t.forEach(r => { r[0] === "[" ? (e.push(...n.sort(), r), n = []) : n.push(r) }), e.push(...n.sort()), e }, fxe = t => ({ cache: cxe(t.cacheSize), parseClassName: uxe(t), ...ixe(t) }), hxe = /\s+/, pxe = (t, e) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: i } = e, a = [], s = t.trim().split(hxe); let o = ""; for (let c = s.length - 1; c >= 0; c -= 1) { const u = s[c], { modifiers: d, hasImportantModifier: f, baseClassName: h, maybePostfixModifierPosition: m } = n(u); let g = !!m, x = r(g ? h.substring(0, m) : h); if (!x) { if (!g) { o = u + (o.length > 0 ? " " + o : o); continue } if (x = r(h), !x) { o = u + (o.length > 0 ? " " + o : o); continue } g = !1 } const v = dxe(d).join(":"), b = f ? v + aee : v, E = b + x; if (a.includes(E)) continue; a.push(E); const M = i(x, g); for (let C = 0; C < M.length; ++C) { const N = M[C]; a.push(b + N) } o = u + (o.length > 0 ? " " + o : o) } return o }; function mxe() { let t = 0, e, n, r = ""; for (; t < arguments.length;)(e = arguments[t++]) && (n = see(e)) && (r && (r += " "), r += n); return r } const see = t => { if (typeof t == "string") return t; let e, n = ""; for (let r = 0; r < t.length; r++)t[r] && (e = see(t[r])) && (n && (n += " "), n += e); return n }; function Q3(t, ...e) { let n, r, i, a = s; function s(c) { const u = e.reduce((d, f) => f(d), t()); return n = fxe(u), r = n.cache.get, i = n.cache.set, a = o, o(c) } function o(c) { const u = r(c); if (u) return u; const d = pxe(c, n); return i(c, d), d } return function () { return a(mxe.apply(null, arguments)) } } const Ei = t => { const e = n => n[t] || []; return e.isThemeGetter = !0, e }, oee = /^\[(?:([a-z-]+):)?(.+)\]$/i, gxe = /^\d+\/\d+$/, vxe = new Set(["px", "full", "screen"]), yxe = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, xxe = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, bxe = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, wxe = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Sxe = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Ld = t => Yy(t) || vxe.has(t) || gxe.test(t), hh = t => v0(t, "length", Pxe), Yy = t => !!t && !Number.isNaN(Number(t)), Nj = t => v0(t, "number", Yy), Xb = t => !!t && Number.isInteger(Number(t)), _xe = t => t.endsWith("%") && Yy(t.slice(0, -1)), or = t => oee.test(t), ph = t => yxe.test(t), Exe = new Set(["length", "size", "percentage"]), Mxe = t => v0(t, Exe, lee), Txe = t => v0(t, "position", lee), Cxe = new Set(["image", "url"]), Nxe = t => v0(t, Cxe, Rxe), Axe = t => v0(t, "", jxe), Yb = () => !0, v0 = (t, e, n) => { const r = oee.exec(t); return r ? r[1] ? typeof e == "string" ? r[1] === e : e.has(r[1]) : n(r[2]) : !1 }, Pxe = t => xxe.test(t) && !bxe.test(t), lee = () => !1, jxe = t => wxe.test(t), Rxe = t => Sxe.test(t), J3 = () => { const t = Ei("colors"), e = Ei("spacing"), n = Ei("blur"), r = Ei("brightness"), i = Ei("borderColor"), a = Ei("borderRadius"), s = Ei("borderSpacing"), o = Ei("borderWidth"), c = Ei("contrast"), u = Ei("grayscale"), d = Ei("hueRotate"), f = Ei("invert"), h = Ei("gap"), m = Ei("gradientColorStops"), g = Ei("gradientColorStopPositions"), x = Ei("inset"), v = Ei("margin"), b = Ei("opacity"), E = Ei("padding"), M = Ei("saturate"), C = Ei("scale"), N = Ei("sepia"), A = Ei("skew"), j = Ei("space"), O = Ei("translate"), I = () => ["auto", "contain", "none"], D = () => ["auto", "hidden", "clip", "visible", "scroll"], F = () => ["auto", or, e], B = () => [or, e], G = () => ["", Ld, hh], z = () => ["auto", Yy, or], q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Y = () => ["solid", "dashed", "dotted", "double", "none"], Z = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], $ = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], V = () => ["", "0", or], K = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], X = () => [Yy, or]; return { cacheSize: 500, separator: ":", theme: { colors: [Yb], spacing: [Ld, hh], blur: ["none", "", ph, or], brightness: X(), borderColor: [t], borderRadius: ["none", "", "full", ph, or], borderSpacing: B(), borderWidth: G(), contrast: X(), grayscale: V(), hueRotate: X(), invert: V(), gap: B(), gradientColorStops: [t], gradientColorStopPositions: [_xe, hh], inset: F(), margin: F(), opacity: X(), padding: B(), saturate: X(), scale: X(), sepia: V(), skew: X(), space: B(), translate: B() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", or] }], container: ["container"], columns: [{ columns: [ph] }], "break-after": [{ "break-after": K() }], "break-before": [{ "break-before": K() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...q(), or] }], overflow: [{ overflow: D() }], "overflow-x": [{ "overflow-x": D() }], "overflow-y": [{ "overflow-y": D() }], overscroll: [{ overscroll: I() }], "overscroll-x": [{ "overscroll-x": I() }], "overscroll-y": [{ "overscroll-y": I() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [x] }], "inset-x": [{ "inset-x": [x] }], "inset-y": [{ "inset-y": [x] }], start: [{ start: [x] }], end: [{ end: [x] }], top: [{ top: [x] }], right: [{ right: [x] }], bottom: [{ bottom: [x] }], left: [{ left: [x] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Xb, or] }], basis: [{ basis: F() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", or] }], grow: [{ grow: V() }], shrink: [{ shrink: V() }], order: [{ order: ["first", "last", "none", Xb, or] }], "grid-cols": [{ "grid-cols": [Yb] }], "col-start-end": [{ col: ["auto", { span: ["full", Xb, or] }, or] }], "col-start": [{ "col-start": z() }], "col-end": [{ "col-end": z() }], "grid-rows": [{ "grid-rows": [Yb] }], "row-start-end": [{ row: ["auto", { span: [Xb, or] }, or] }], "row-start": [{ "row-start": z() }], "row-end": [{ "row-end": z() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", or] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", or] }], gap: [{ gap: [h] }], "gap-x": [{ "gap-x": [h] }], "gap-y": [{ "gap-y": [h] }], "justify-content": [{ justify: ["normal", ...$()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...$(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...$(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [E] }], px: [{ px: [E] }], py: [{ py: [E] }], ps: [{ ps: [E] }], pe: [{ pe: [E] }], pt: [{ pt: [E] }], pr: [{ pr: [E] }], pb: [{ pb: [E] }], pl: [{ pl: [E] }], m: [{ m: [v] }], mx: [{ mx: [v] }], my: [{ my: [v] }], ms: [{ ms: [v] }], me: [{ me: [v] }], mt: [{ mt: [v] }], mr: [{ mr: [v] }], mb: [{ mb: [v] }], ml: [{ ml: [v] }], "space-x": [{ "space-x": [j] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [j] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", or, e] }], "min-w": [{ "min-w": [or, e, "min", "max", "fit"] }], "max-w": [{ "max-w": [or, e, "none", "full", "min", "max", "fit", "prose", { screen: [ph] }, ph] }], h: [{ h: [or, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [or, e, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [or, e, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [or, e, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", ph, hh] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Nj] }], "font-family": [{ font: [Yb] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", or] }], "line-clamp": [{ "line-clamp": ["none", Yy, Nj] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Ld, or] }], "list-image": [{ "list-image": ["none", or] }], "list-style-type": [{ list: ["none", "disc", "decimal", or] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [t] }], "placeholder-opacity": [{ "placeholder-opacity": [b] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [t] }], "text-opacity": [{ "text-opacity": [b] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...Y(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", Ld, hh] }], "underline-offset": [{ "underline-offset": ["auto", Ld, or] }], "text-decoration-color": [{ decoration: [t] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: B() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", or] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", or] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [b] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...q(), Txe] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Mxe] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Nxe] }], "bg-color": [{ bg: [t] }], "gradient-from-pos": [{ from: [g] }], "gradient-via-pos": [{ via: [g] }], "gradient-to-pos": [{ to: [g] }], "gradient-from": [{ from: [m] }], "gradient-via": [{ via: [m] }], "gradient-to": [{ to: [m] }], rounded: [{ rounded: [a] }], "rounded-s": [{ "rounded-s": [a] }], "rounded-e": [{ "rounded-e": [a] }], "rounded-t": [{ "rounded-t": [a] }], "rounded-r": [{ "rounded-r": [a] }], "rounded-b": [{ "rounded-b": [a] }], "rounded-l": [{ "rounded-l": [a] }], "rounded-ss": [{ "rounded-ss": [a] }], "rounded-se": [{ "rounded-se": [a] }], "rounded-ee": [{ "rounded-ee": [a] }], "rounded-es": [{ "rounded-es": [a] }], "rounded-tl": [{ "rounded-tl": [a] }], "rounded-tr": [{ "rounded-tr": [a] }], "rounded-br": [{ "rounded-br": [a] }], "rounded-bl": [{ "rounded-bl": [a] }], "border-w": [{ border: [o] }], "border-w-x": [{ "border-x": [o] }], "border-w-y": [{ "border-y": [o] }], "border-w-s": [{ "border-s": [o] }], "border-w-e": [{ "border-e": [o] }], "border-w-t": [{ "border-t": [o] }], "border-w-r": [{ "border-r": [o] }], "border-w-b": [{ "border-b": [o] }], "border-w-l": [{ "border-l": [o] }], "border-opacity": [{ "border-opacity": [b] }], "border-style": [{ border: [...Y(), "hidden"] }], "divide-x": [{ "divide-x": [o] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [o] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [b] }], "divide-style": [{ divide: Y() }], "border-color": [{ border: [i] }], "border-color-x": [{ "border-x": [i] }], "border-color-y": [{ "border-y": [i] }], "border-color-s": [{ "border-s": [i] }], "border-color-e": [{ "border-e": [i] }], "border-color-t": [{ "border-t": [i] }], "border-color-r": [{ "border-r": [i] }], "border-color-b": [{ "border-b": [i] }], "border-color-l": [{ "border-l": [i] }], "divide-color": [{ divide: [i] }], "outline-style": [{ outline: ["", ...Y()] }], "outline-offset": [{ "outline-offset": [Ld, or] }], "outline-w": [{ outline: [Ld, hh] }], "outline-color": [{ outline: [t] }], "ring-w": [{ ring: G() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [t] }], "ring-opacity": [{ "ring-opacity": [b] }], "ring-offset-w": [{ "ring-offset": [Ld, hh] }], "ring-offset-color": [{ "ring-offset": [t] }], shadow: [{ shadow: ["", "inner", "none", ph, Axe] }], "shadow-color": [{ shadow: [Yb] }], opacity: [{ opacity: [b] }], "mix-blend": [{ "mix-blend": [...Z(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": Z() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [c] }], "drop-shadow": [{ "drop-shadow": ["", "none", ph, or] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [d] }], invert: [{ invert: [f] }], saturate: [{ saturate: [M] }], sepia: [{ sepia: [N] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [c] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [d] }], "backdrop-invert": [{ "backdrop-invert": [f] }], "backdrop-opacity": [{ "backdrop-opacity": [b] }], "backdrop-saturate": [{ "backdrop-saturate": [M] }], "backdrop-sepia": [{ "backdrop-sepia": [N] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [s] }], "border-spacing-x": [{ "border-spacing-x": [s] }], "border-spacing-y": [{ "border-spacing-y": [s] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", or] }], duration: [{ duration: X() }], ease: [{ ease: ["linear", "in", "out", "in-out", or] }], delay: [{ delay: X() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", or] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [C] }], "scale-x": [{ "scale-x": [C] }], "scale-y": [{ "scale-y": [C] }], rotate: [{ rotate: [Xb, or] }], "translate-x": [{ "translate-x": [O] }], "translate-y": [{ "translate-y": [O] }], "skew-x": [{ "skew-x": [A] }], "skew-y": [{ "skew-y": [A] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", or] }], accent: [{ accent: ["auto", t] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", or] }], "caret-color": [{ caret: [t] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": B() }], "scroll-mx": [{ "scroll-mx": B() }], "scroll-my": [{ "scroll-my": B() }], "scroll-ms": [{ "scroll-ms": B() }], "scroll-me": [{ "scroll-me": B() }], "scroll-mt": [{ "scroll-mt": B() }], "scroll-mr": [{ "scroll-mr": B() }], "scroll-mb": [{ "scroll-mb": B() }], "scroll-ml": [{ "scroll-ml": B() }], "scroll-p": [{ "scroll-p": B() }], "scroll-px": [{ "scroll-px": B() }], "scroll-py": [{ "scroll-py": B() }], "scroll-ps": [{ "scroll-ps": B() }], "scroll-pe": [{ "scroll-pe": B() }], "scroll-pt": [{ "scroll-pt": B() }], "scroll-pr": [{ "scroll-pr": B() }], "scroll-pb": [{ "scroll-pb": B() }], "scroll-pl": [{ "scroll-pl": B() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", or] }], fill: [{ fill: [t, "none"] }], "stroke-w": [{ stroke: [Ld, hh, Nj] }], stroke: [{ stroke: [t, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, kxe = (t, { cacheSize: e, prefix: n, separator: r, experimentalParseClassName: i, extend: a = {}, override: s = {} }) => { Aw(t, "cacheSize", e), Aw(t, "prefix", n), Aw(t, "separator", r), Aw(t, "experimentalParseClassName", i); for (const o in s) Ixe(t[o], s[o]); for (const o in a) Oxe(t[o], a[o]); return t }, Aw = (t, e, n) => { n !== void 0 && (t[e] = n) }, Ixe = (t, e) => { if (e) for (const n in e) Aw(t, n, e[n]) }, Oxe = (t, e) => { if (e) for (const n in e) { const r = e[n]; r !== void 0 && (t[n] = (t[n] || []).concat(r)) } }, Dxe = (t, ...e) => typeof t == "function" ? Q3(J3, t, ...e) : Q3(() => kxe(J3(), t), ...e), Lxe = Q3(J3); function _t(...t) { return Lxe(zn(t)) } const Fxe = rxe, cee = S.forwardRef(({ className: t, ...e }, n) => l.jsx(ZJ, { ref: n, className: _t("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", t), ...e })); cee.displayName = ZJ.displayName; const Uxe = $g("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground" } }, defaultVariants: { variant: "default" } }), uee = S.forwardRef(({ className: t, variant: e, ...n }, r) => l.jsx(QJ, { ref: r, className: _t(Uxe({ variant: e }), t), ...n })); uee.displayName = QJ.displayName; const Bxe = S.forwardRef(({ className: t, ...e }, n) => l.jsx(tee, { ref: n, className: _t("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50", t), ...e })); Bxe.displayName = tee.displayName; const dee = S.forwardRef(({ className: t, ...e }, n) => l.jsx(nee, { ref: n, className: _t("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", t), "toast-close": "", ...e, children: l.jsx(Pa, { className: "h-4 w-4" }) })); dee.displayName = nee.displayName; const fee = S.forwardRef(({ className: t, ...e }, n) => l.jsx(JJ, { ref: n, className: _t("text-sm font-semibold", t), ...e })); fee.displayName = JJ.displayName; const hee = S.forwardRef(({ className: t, ...e }, n) => l.jsx(eee, { ref: n, className: _t("text-sm opacity-90", t), ...e })); hee.displayName = eee.displayName; function $xe() { const { toasts: t } = pye(); return l.jsxs(Fxe, { children: [t.map(function ({ id: e, title: n, description: r, action: i, ...a }) { return l.jsxs(uee, { ...a, children: [l.jsxs("div", { className: "grid gap-1", children: [n && l.jsx(fee, { children: n }), r && l.jsx(hee, { children: r })] }), i, l.jsx(dee, {})] }, e) }), l.jsx(cee, {})] }) } var P8 = ["light", "dark"], zxe = "(prefers-color-scheme: dark)", Vxe = S.createContext(void 0), Hxe = { setTheme: t => { }, themes: [] }, Wxe = () => { var t; return (t = S.useContext(Vxe)) != null ? t : Hxe }; S.memo(({ forcedTheme: t, storageKey: e, attribute: n, enableSystem: r, enableColorScheme: i, defaultTheme: a, value: s, attrs: o, nonce: c }) => { let u = a === "system", d = n === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${o.map(g => `'${g}'`).join(",")})`};` : `var d=document.documentElement,n='${n}',s='setAttribute';`, f = i ? P8.includes(a) && a ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${a}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", h = (g, x = !1, v = !0) => { let b = s ? s[g] : g, E = x ? g + "|| ''" : `'${b}'`, M = ""; return i && v && !x && P8.includes(g) && (M += `d.style.colorScheme = '${g}';`), n === "class" ? x || b ? M += `c.add(${E})` : M += "null" : b && (M += `d[s](n,${E})`), M }, m = t ? `!function(){${d}${h(t)}}()` : r ? `!function(){try{${d}var e=localStorage.getItem('${e}');if('system'===e||(!e&&${u})){var t='${zxe}',m=window.matchMedia(t);if(m.media!==t||m.matches){${h("dark")}}else{${h("light")}}}else if(e){${s ? `var x=${JSON.stringify(s)};` : ""}${h(s ? "x[e]" : "e", !0)}}${u ? "" : "else{" + h(a, !1, !1) + "}"}${f}}catch(e){}}()` : `!function(){try{${d}var e=localStorage.getItem('${e}');if(e){${s ? `var x=${JSON.stringify(s)};` : ""}${h(s ? "x[e]" : "e", !0)}}else{${h(a, !1, !1)};}${f}}catch(t){}}();`; return S.createElement("script", { nonce: c, dangerouslySetInnerHTML: { __html: m } }) }); var Gxe = t => { switch (t) { case "success": return Yxe; case "info": return Zxe; case "warning": return Kxe; case "error": return Qxe; default: return null } }, qxe = Array(12).fill(0), Xxe = ({ visible: t, className: e }) => P.createElement("div", { className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "), "data-visible": t }, P.createElement("div", { className: "sonner-spinner" }, qxe.map((n, r) => P.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${r}` })))), Yxe = P.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, P.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), Kxe = P.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, P.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), Zxe = P.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, P.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), Qxe = P.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, P.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), Jxe = P.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, P.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), P.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), e0e = () => { let [t, e] = P.useState(document.hidden); return P.useEffect(() => { let n = () => { e(document.hidden) }; return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n) }, []), t }, eL = 1, t0e = class { constructor() { this.subscribe = e => (this.subscribers.push(e), () => { let n = this.subscribers.indexOf(e); this.subscribers.splice(n, 1) }), this.publish = e => { this.subscribers.forEach(n => n(e)) }, this.addToast = e => { this.publish(e), this.toasts = [...this.toasts, e] }, this.create = e => { var n; let { message: r, ...i } = e, a = typeof e?.id == "number" || ((n = e.id) == null ? void 0 : n.length) > 0 ? e.id : eL++, s = this.toasts.find(c => c.id === a), o = e.dismissible === void 0 ? !0 : e.dismissible; return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), s ? this.toasts = this.toasts.map(c => c.id === a ? (this.publish({ ...c, ...e, id: a, title: r }), { ...c, ...e, id: a, dismissible: o, title: r }) : c) : this.addToast({ title: r, ...i, dismissible: o, id: a }), a }, this.dismiss = e => (this.dismissedToasts.add(e), e || this.toasts.forEach(n => { this.subscribers.forEach(r => r({ id: n.id, dismiss: !0 })) }), this.subscribers.forEach(n => n({ id: e, dismiss: !0 })), e), this.message = (e, n) => this.create({ ...n, message: e }), this.error = (e, n) => this.create({ ...n, message: e, type: "error" }), this.success = (e, n) => this.create({ ...n, type: "success", message: e }), this.info = (e, n) => this.create({ ...n, type: "info", message: e }), this.warning = (e, n) => this.create({ ...n, type: "warning", message: e }), this.loading = (e, n) => this.create({ ...n, type: "loading", message: e }), this.promise = (e, n) => { if (!n) return; let r; n.loading !== void 0 && (r = this.create({ ...n, promise: e, type: "loading", message: n.loading, description: typeof n.description != "function" ? n.description : void 0 })); let i = e instanceof Promise ? e : e(), a = r !== void 0, s, o = i.then(async u => { if (s = ["resolve", u], P.isValidElement(u)) a = !1, this.create({ id: r, type: "default", message: u }); else if (r0e(u) && !u.ok) { a = !1; let d = typeof n.error == "function" ? await n.error(`HTTP error! status: ${u.status}`) : n.error, f = typeof n.description == "function" ? await n.description(`HTTP error! status: ${u.status}`) : n.description; this.create({ id: r, type: "error", message: d, description: f }) } else if (n.success !== void 0) { a = !1; let d = typeof n.success == "function" ? await n.success(u) : n.success, f = typeof n.description == "function" ? await n.description(u) : n.description; this.create({ id: r, type: "success", message: d, description: f }) } }).catch(async u => { if (s = ["reject", u], n.error !== void 0) { a = !1; let d = typeof n.error == "function" ? await n.error(u) : n.error, f = typeof n.description == "function" ? await n.description(u) : n.description; this.create({ id: r, type: "error", message: d, description: f }) } }).finally(() => { var u; a && (this.dismiss(r), r = void 0), (u = n.finally) == null || u.call(n) }), c = () => new Promise((u, d) => o.then(() => s[0] === "reject" ? d(s[1]) : u(s[1])).catch(d)); return typeof r != "string" && typeof r != "number" ? { unwrap: c } : Object.assign(r, { unwrap: c }) }, this.custom = (e, n) => { let r = n?.id || eL++; return this.create({ jsx: e(r), id: r, ...n }), r }, this.getActiveToasts = () => this.toasts.filter(e => !this.dismissedToasts.has(e.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } }, Ao = new t0e, n0e = (t, e) => { let n = e?.id || eL++; return Ao.addToast({ title: t, ...e, id: n }), n }, r0e = t => t && typeof t == "object" && "ok" in t && typeof t.ok == "boolean" && "status" in t && typeof t.status == "number", i0e = n0e, a0e = () => Ao.toasts, s0e = () => Ao.getActiveToasts(), dt = Object.assign(i0e, { success: Ao.success, info: Ao.info, warning: Ao.warning, error: Ao.error, custom: Ao.custom, message: Ao.message, promise: Ao.promise, dismiss: Ao.dismiss, loading: Ao.loading }, { getHistory: a0e, getToasts: s0e }); function o0e(t, { insertAt: e } = {}) { if (typeof document > "u") return; let n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style"); r.type = "text/css", e === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = t : r.appendChild(document.createTextNode(t)) } o0e(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`); function UE(t) { return t.label !== void 0 } var l0e = 3, c0e = "32px", u0e = "16px", j8 = 4e3, d0e = 356, f0e = 14, h0e = 20, p0e = 200; function Sc(...t) { return t.filter(Boolean).join(" ") } function m0e(t) { let [e, n] = t.split("-"), r = []; return e && r.push(e), n && r.push(n), r } var g0e = t => { var e, n, r, i, a, s, o, c, u, d, f; let { invert: h, toast: m, unstyled: g, interacting: x, setHeights: v, visibleToasts: b, heights: E, index: M, toasts: C, expanded: N, removeToast: A, defaultRichColors: j, closeButton: O, style: I, cancelButtonStyle: D, actionButtonStyle: F, className: B = "", descriptionClassName: G = "", duration: z, position: q, gap: Y, loadingIcon: Z, expandByDefault: $, classNames: V, icons: K, closeButtonAriaLabel: X = "Close toast", pauseWhenPageIsHidden: Q } = t, [re, ce] = P.useState(null), [be, de] = P.useState(null), [ae, se] = P.useState(!1), [he, Ae] = P.useState(!1), [Ce, fe] = P.useState(!1), [oe, xe] = P.useState(!1), [_e, je] = P.useState(!1), [ke, Ze] = P.useState(0), [Xe, nt] = P.useState(0), Tt = P.useRef(m.duration || z || j8), St = P.useRef(null), ee = P.useRef(null), ne = M === 0, Re = M + 1 <= b, Ue = m.type, et = m.dismissible !== !1, Ge = m.className || "", Xt = m.descriptionClassName || "", yt = P.useMemo(() => E.findIndex(it => it.toastId === m.id) || 0, [E, m.id]), Yt = P.useMemo(() => { var it; return (it = m.closeButton) != null ? it : O }, [m.closeButton, O]), en = P.useMemo(() => m.duration || z || j8, [m.duration, z]), pt = P.useRef(0), bt = P.useRef(0), pn = P.useRef(0), Se = P.useRef(null), [Fe, ht] = q.split("-"), Ee = P.useMemo(() => E.reduce((it, Ft, un) => un >= yt ? it : it + Ft.height, 0), [E, yt]), De = e0e(), gt = m.invert || h, Bt = Ue === "loading"; bt.current = P.useMemo(() => yt * Y + Ee, [yt, Ee]), P.useEffect(() => { Tt.current = en }, [en]), P.useEffect(() => { se(!0) }, []), P.useEffect(() => { let it = ee.current; if (it) { let Ft = it.getBoundingClientRect().height; return nt(Ft), v(un => [{ toastId: m.id, height: Ft, position: m.position }, ...un]), () => v(un => un.filter(wn => wn.toastId !== m.id)) } }, [v, m.id]), P.useLayoutEffect(() => { if (!ae) return; let it = ee.current, Ft = it.style.height; it.style.height = "auto"; let un = it.getBoundingClientRect().height; it.style.height = Ft, nt(un), v(wn => wn.find(wr => wr.toastId === m.id) ? wn.map(wr => wr.toastId === m.id ? { ...wr, height: un } : wr) : [{ toastId: m.id, height: un, position: m.position }, ...wn]) }, [ae, m.title, m.description, v, m.id]); let mt = P.useCallback(() => { Ae(!0), Ze(bt.current), v(it => it.filter(Ft => Ft.toastId !== m.id)), setTimeout(() => { A(m) }, p0e) }, [m, A, v, bt]); P.useEffect(() => { if (m.promise && Ue === "loading" || m.duration === 1 / 0 || m.type === "loading") return; let it; return N || x || Q && De ? (() => { if (pn.current < pt.current) { let Ft = new Date().getTime() - pt.current; Tt.current = Tt.current - Ft } pn.current = new Date().getTime() })() : Tt.current !== 1 / 0 && (pt.current = new Date().getTime(), it = setTimeout(() => { var Ft; (Ft = m.onAutoClose) == null || Ft.call(m, m), mt() }, Tt.current)), () => clearTimeout(it) }, [N, x, m, Ue, Q, De, mt]), P.useEffect(() => { m.delete && mt() }, [mt, m.delete]); function ot() { var it, Ft, un; return K != null && K.loading ? P.createElement("div", { className: Sc(V?.loader, (it = m?.classNames) == null ? void 0 : it.loader, "sonner-loader"), "data-visible": Ue === "loading" }, K.loading) : Z ? P.createElement("div", { className: Sc(V?.loader, (Ft = m?.classNames) == null ? void 0 : Ft.loader, "sonner-loader"), "data-visible": Ue === "loading" }, Z) : P.createElement(Xxe, { className: Sc(V?.loader, (un = m?.classNames) == null ? void 0 : un.loader), visible: Ue === "loading" }) } return P.createElement("li", { tabIndex: 0, ref: ee, className: Sc(B, Ge, V?.toast, (e = m?.classNames) == null ? void 0 : e.toast, V?.default, V?.[Ue], (n = m?.classNames) == null ? void 0 : n[Ue]), "data-sonner-toast": "", "data-rich-colors": (r = m.richColors) != null ? r : j, "data-styled": !(m.jsx || m.unstyled || g), "data-mounted": ae, "data-promise": !!m.promise, "data-swiped": _e, "data-removed": he, "data-visible": Re, "data-y-position": Fe, "data-x-position": ht, "data-index": M, "data-front": ne, "data-swiping": Ce, "data-dismissible": et, "data-type": Ue, "data-invert": gt, "data-swipe-out": oe, "data-swipe-direction": be, "data-expanded": !!(N || $ && ae), style: { "--index": M, "--toasts-before": M, "--z-index": C.length - M, "--offset": `${he ? ke : bt.current}px`, "--initial-height": $ ? "auto" : `${Xe}px`, ...I, ...m.style }, onDragEnd: () => { fe(!1), ce(null), Se.current = null }, onPointerDown: it => { Bt || !et || (St.current = new Date, Ze(bt.current), it.target.setPointerCapture(it.pointerId), it.target.tagName !== "BUTTON" && (fe(!0), Se.current = { x: it.clientX, y: it.clientY })) }, onPointerUp: () => { var it, Ft, un, wn; if (oe || !et) return; Se.current = null; let wr = Number(((it = ee.current) == null ? void 0 : it.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), Tr = Number(((Ft = ee.current) == null ? void 0 : Ft.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), Ua = new Date().getTime() - ((un = St.current) == null ? void 0 : un.getTime()), Vr = re === "x" ? wr : Tr, zi = Math.abs(Vr) / Ua; if (Math.abs(Vr) >= h0e || zi > .11) { Ze(bt.current), (wn = m.onDismiss) == null || wn.call(m, m), de(re === "x" ? wr > 0 ? "right" : "left" : Tr > 0 ? "down" : "up"), mt(), xe(!0), je(!1); return } fe(!1), ce(null) }, onPointerMove: it => { var Ft, un, wn, wr; if (!Se.current || !et || ((Ft = window.getSelection()) == null ? void 0 : Ft.toString().length) > 0) return; let Tr = it.clientY - Se.current.y, Ua = it.clientX - Se.current.x, Vr = (un = t.swipeDirections) != null ? un : m0e(q); !re && (Math.abs(Ua) > 1 || Math.abs(Tr) > 1) && ce(Math.abs(Ua) > Math.abs(Tr) ? "x" : "y"); let zi = { x: 0, y: 0 }; re === "y" ? (Vr.includes("top") || Vr.includes("bottom")) && (Vr.includes("top") && Tr < 0 || Vr.includes("bottom") && Tr > 0) && (zi.y = Tr) : re === "x" && (Vr.includes("left") || Vr.includes("right")) && (Vr.includes("left") && Ua < 0 || Vr.includes("right") && Ua > 0) && (zi.x = Ua), (Math.abs(zi.x) > 0 || Math.abs(zi.y) > 0) && je(!0), (wn = ee.current) == null || wn.style.setProperty("--swipe-amount-x", `${zi.x}px`), (wr = ee.current) == null || wr.style.setProperty("--swipe-amount-y", `${zi.y}px`) } }, Yt && !m.jsx ? P.createElement("button", { "aria-label": X, "data-disabled": Bt, "data-close-button": !0, onClick: Bt || !et ? () => { } : () => { var it; mt(), (it = m.onDismiss) == null || it.call(m, m) }, className: Sc(V?.closeButton, (i = m?.classNames) == null ? void 0 : i.closeButton) }, (a = K?.close) != null ? a : Jxe) : null, m.jsx || S.isValidElement(m.title) ? m.jsx ? m.jsx : typeof m.title == "function" ? m.title() : m.title : P.createElement(P.Fragment, null, Ue || m.icon || m.promise ? P.createElement("div", { "data-icon": "", className: Sc(V?.icon, (s = m?.classNames) == null ? void 0 : s.icon) }, m.promise || m.type === "loading" && !m.icon ? m.icon || ot() : null, m.type !== "loading" ? m.icon || K?.[Ue] || Gxe(Ue) : null) : null, P.createElement("div", { "data-content": "", className: Sc(V?.content, (o = m?.classNames) == null ? void 0 : o.content) }, P.createElement("div", { "data-title": "", className: Sc(V?.title, (c = m?.classNames) == null ? void 0 : c.title) }, typeof m.title == "function" ? m.title() : m.title), m.description ? P.createElement("div", { "data-description": "", className: Sc(G, Xt, V?.description, (u = m?.classNames) == null ? void 0 : u.description) }, typeof m.description == "function" ? m.description() : m.description) : null), S.isValidElement(m.cancel) ? m.cancel : m.cancel && UE(m.cancel) ? P.createElement("button", { "data-button": !0, "data-cancel": !0, style: m.cancelButtonStyle || D, onClick: it => { var Ft, un; UE(m.cancel) && et && ((un = (Ft = m.cancel).onClick) == null || un.call(Ft, it), mt()) }, className: Sc(V?.cancelButton, (d = m?.classNames) == null ? void 0 : d.cancelButton) }, m.cancel.label) : null, S.isValidElement(m.action) ? m.action : m.action && UE(m.action) ? P.createElement("button", { "data-button": !0, "data-action": !0, style: m.actionButtonStyle || F, onClick: it => { var Ft, un; UE(m.action) && ((un = (Ft = m.action).onClick) == null || un.call(Ft, it), !it.defaultPrevented && mt()) }, className: Sc(V?.actionButton, (f = m?.classNames) == null ? void 0 : f.actionButton) }, m.action.label) : null)) }; function R8() { if (typeof window > "u" || typeof document > "u") return "ltr"; let t = document.documentElement.getAttribute("dir"); return t === "auto" || !t ? window.getComputedStyle(document.documentElement).direction : t } function v0e(t, e) { let n = {}; return [t, e].forEach((r, i) => { let a = i === 1, s = a ? "--mobile-offset" : "--offset", o = a ? u0e : c0e; function c(u) { ["top", "right", "bottom", "left"].forEach(d => { n[`${s}-${d}`] = typeof u == "number" ? `${u}px` : u }) } typeof r == "number" || typeof r == "string" ? c(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach(u => { r[u] === void 0 ? n[`${s}-${u}`] = o : n[`${s}-${u}`] = typeof r[u] == "number" ? `${r[u]}px` : r[u] }) : c(o) }), n } var y0e = S.forwardRef(function (t, e) { let { invert: n, position: r = "bottom-right", hotkey: i = ["altKey", "KeyT"], expand: a, closeButton: s, className: o, offset: c, mobileOffset: u, theme: d = "light", richColors: f, duration: h, style: m, visibleToasts: g = l0e, toastOptions: x, dir: v = R8(), gap: b = f0e, loadingIcon: E, icons: M, containerAriaLabel: C = "Notifications", pauseWhenPageIsHidden: N } = t, [A, j] = P.useState([]), O = P.useMemo(() => Array.from(new Set([r].concat(A.filter(Q => Q.position).map(Q => Q.position)))), [A, r]), [I, D] = P.useState([]), [F, B] = P.useState(!1), [G, z] = P.useState(!1), [q, Y] = P.useState(d !== "system" ? d : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), Z = P.useRef(null), $ = i.join("+").replace(/Key/g, "").replace(/Digit/g, ""), V = P.useRef(null), K = P.useRef(!1), X = P.useCallback(Q => { j(re => { var ce; return (ce = re.find(be => be.id === Q.id)) != null && ce.delete || Ao.dismiss(Q.id), re.filter(({ id: be }) => be !== Q.id) }) }, []); return P.useEffect(() => Ao.subscribe(Q => { if (Q.dismiss) { j(re => re.map(ce => ce.id === Q.id ? { ...ce, delete: !0 } : ce)); return } setTimeout(() => { rJ.flushSync(() => { j(re => { let ce = re.findIndex(be => be.id === Q.id); return ce !== -1 ? [...re.slice(0, ce), { ...re[ce], ...Q }, ...re.slice(ce + 1)] : [Q, ...re] }) }) }) }), []), P.useEffect(() => { if (d !== "system") { Y(d); return } if (d === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? Y("dark") : Y("light")), typeof window > "u") return; let Q = window.matchMedia("(prefers-color-scheme: dark)"); try { Q.addEventListener("change", ({ matches: re }) => { Y(re ? "dark" : "light") }) } catch { Q.addListener(({ matches: ce }) => { try { Y(ce ? "dark" : "light") } catch (be) { console.error(be) } }) } }, [d]), P.useEffect(() => { A.length <= 1 && B(!1) }, [A]), P.useEffect(() => { let Q = re => { var ce, be; i.every(de => re[de] || re.code === de) && (B(!0), (ce = Z.current) == null || ce.focus()), re.code === "Escape" && (document.activeElement === Z.current || (be = Z.current) != null && be.contains(document.activeElement)) && B(!1) }; return document.addEventListener("keydown", Q), () => document.removeEventListener("keydown", Q) }, [i]), P.useEffect(() => { if (Z.current) return () => { V.current && (V.current.focus({ preventScroll: !0 }), V.current = null, K.current = !1) } }, [Z.current]), P.createElement("section", { ref: e, "aria-label": `${C} ${$}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, O.map((Q, re) => { var ce; let [be, de] = Q.split("-"); return A.length ? P.createElement("ol", { key: Q, dir: v === "auto" ? R8() : v, tabIndex: -1, ref: Z, className: o, "data-sonner-toaster": !0, "data-theme": q, "data-y-position": be, "data-lifted": F && A.length > 1 && !a, "data-x-position": de, style: { "--front-toast-height": `${((ce = I[0]) == null ? void 0 : ce.height) || 0}px`, "--width": `${d0e}px`, "--gap": `${b}px`, ...m, ...v0e(c, u) }, onBlur: ae => { K.current && !ae.currentTarget.contains(ae.relatedTarget) && (K.current = !1, V.current && (V.current.focus({ preventScroll: !0 }), V.current = null)) }, onFocus: ae => { ae.target instanceof HTMLElement && ae.target.dataset.dismissible === "false" || K.current || (K.current = !0, V.current = ae.relatedTarget) }, onMouseEnter: () => B(!0), onMouseMove: () => B(!0), onMouseLeave: () => { G || B(!1) }, onDragEnd: () => B(!1), onPointerDown: ae => { ae.target instanceof HTMLElement && ae.target.dataset.dismissible === "false" || z(!0) }, onPointerUp: () => z(!1) }, A.filter(ae => !ae.position && re === 0 || ae.position === Q).map((ae, se) => { var he, Ae; return P.createElement(g0e, { key: ae.id, icons: M, index: se, toast: ae, defaultRichColors: f, duration: (he = x?.duration) != null ? he : h, className: x?.className, descriptionClassName: x?.descriptionClassName, invert: n, visibleToasts: g, closeButton: (Ae = x?.closeButton) != null ? Ae : s, interacting: G, position: Q, style: x?.style, unstyled: x?.unstyled, classNames: x?.classNames, cancelButtonStyle: x?.cancelButtonStyle, actionButtonStyle: x?.actionButtonStyle, removeToast: X, toasts: A.filter(Ce => Ce.position == ae.position), heights: I.filter(Ce => Ce.position == ae.position), setHeights: D, expandByDefault: a, gap: b, loadingIcon: E, expanded: F, pauseWhenPageIsHidden: N, swipeDirections: t.swipeDirections }) })) : null })) }); const x0e = ({ ...t }) => { const { theme: e = "system" } = Wxe(); return l.jsx(y0e, { theme: e, className: "toaster group", toastOptions: { classNames: { toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg", description: "group-[.toast]:text-muted-foreground", actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground", cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground" } }, ...t }) }; var b0e = Yh[" useId ".trim().toString()] || (() => { }), w0e = 0; function $l(t) { const [e, n] = S.useState(b0e()); return Ki(() => { n(r => r ?? String(w0e++)) }, [t]), e ? `radix-${e}` : "" } const S0e = ["top", "right", "bottom", "left"], pf = Math.min, Ms = Math.max, y1 = Math.round, BE = Math.floor, Cu = t => ({ x: t, y: t }), _0e = { left: "right", right: "left", bottom: "top", top: "bottom" }, E0e = { start: "end", end: "start" }; function tL(t, e, n) { return Ms(t, pf(e, n)) } function Uu(t, e) { return typeof t == "function" ? t(e) : t } function mf(t) { return t.split("-")[0] } function y0(t) { return t.split("-")[1] } function S5(t) { return t === "x" ? "y" : "x" } function _5(t) { return t === "y" ? "height" : "width" } const M0e = new Set(["top", "bottom"]); function xu(t) { return M0e.has(mf(t)) ? "y" : "x" } function E5(t) { return S5(xu(t)) } function T0e(t, e, n) { n === void 0 && (n = !1); const r = y0(t), i = E5(t), a = _5(i); let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return e.reference[a] > e.floating[a] && (s = WT(s)), [s, WT(s)] } function C0e(t) { const e = WT(t); return [nL(t), e, nL(e)] } function nL(t) { return t.replace(/start|end/g, e => E0e[e]) } const k8 = ["left", "right"], I8 = ["right", "left"], N0e = ["top", "bottom"], A0e = ["bottom", "top"]; function P0e(t, e, n) { switch (t) { case "top": case "bottom": return n ? e ? I8 : k8 : e ? k8 : I8; case "left": case "right": return e ? N0e : A0e; default: return [] } } function j0e(t, e, n, r) { const i = y0(t); let a = P0e(mf(t), n === "start", r); return i && (a = a.map(s => s + "-" + i), e && (a = a.concat(a.map(nL)))), a } function WT(t) { return t.replace(/left|right|bottom|top/g, e => _0e[e]) } function R0e(t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t } } function pee(t) { return typeof t != "number" ? R0e(t) : { top: t, right: t, bottom: t, left: t } } function GT(t) { const { x: e, y: n, width: r, height: i } = t; return { width: r, height: i, top: n, left: e, right: e + r, bottom: n + i, x: e, y: n } } function O8(t, e, n) { let { reference: r, floating: i } = t; const a = xu(e), s = E5(e), o = _5(s), c = mf(e), u = a === "y", d = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, h = r[o] / 2 - i[o] / 2; let m; switch (c) { case "top": m = { x: d, y: r.y - i.height }; break; case "bottom": m = { x: d, y: r.y + r.height }; break; case "right": m = { x: r.x + r.width, y: f }; break; case "left": m = { x: r.x - i.width, y: f }; break; default: m = { x: r.x, y: r.y } }switch (y0(e)) { case "start": m[s] -= h * (n && u ? -1 : 1); break; case "end": m[s] += h * (n && u ? -1 : 1); break }return m } const k0e = async (t, e, n) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: a = [], platform: s } = n, o = a.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(e)); let u = await s.getElementRects({ reference: t, floating: e, strategy: i }), { x: d, y: f } = O8(u, r, c), h = r, m = {}, g = 0; for (let x = 0; x < o.length; x++) { const { name: v, fn: b } = o[x], { x: E, y: M, data: C, reset: N } = await b({ x: d, y: f, initialPlacement: r, placement: h, strategy: i, middlewareData: m, rects: u, platform: s, elements: { reference: t, floating: e } }); d = E ?? d, f = M ?? f, m = { ...m, [v]: { ...m[v], ...C } }, N && g <= 50 && (g++, typeof N == "object" && (N.placement && (h = N.placement), N.rects && (u = N.rects === !0 ? await s.getElementRects({ reference: t, floating: e, strategy: i }) : N.rects), { x: d, y: f } = O8(u, h, c)), x = -1) } return { x: d, y: f, placement: h, strategy: i, middlewareData: m } }; async function ux(t, e) { var n; e === void 0 && (e = {}); const { x: r, y: i, platform: a, rects: s, elements: o, strategy: c } = t, { boundary: u = "clippingAncestors", rootBoundary: d = "viewport", elementContext: f = "floating", altBoundary: h = !1, padding: m = 0 } = Uu(e, t), g = pee(m), v = o[h ? f === "floating" ? "reference" : "floating" : f], b = GT(await a.getClippingRect({ element: (n = await (a.isElement == null ? void 0 : a.isElement(v))) == null || n ? v : v.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(o.floating)), boundary: u, rootBoundary: d, strategy: c })), E = f === "floating" ? { x: r, y: i, width: s.floating.width, height: s.floating.height } : s.reference, M = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(o.floating)), C = await (a.isElement == null ? void 0 : a.isElement(M)) ? await (a.getScale == null ? void 0 : a.getScale(M)) || { x: 1, y: 1 } : { x: 1, y: 1 }, N = GT(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: o, rect: E, offsetParent: M, strategy: c }) : E); return { top: (b.top - N.top + g.top) / C.y, bottom: (N.bottom - b.bottom + g.bottom) / C.y, left: (b.left - N.left + g.left) / C.x, right: (N.right - b.right + g.right) / C.x } } const I0e = t => ({ name: "arrow", options: t, async fn(e) { const { x: n, y: r, placement: i, rects: a, platform: s, elements: o, middlewareData: c } = e, { element: u, padding: d = 0 } = Uu(t, e) || {}; if (u == null) return {}; const f = pee(d), h = { x: n, y: r }, m = E5(i), g = _5(m), x = await s.getDimensions(u), v = m === "y", b = v ? "top" : "left", E = v ? "bottom" : "right", M = v ? "clientHeight" : "clientWidth", C = a.reference[g] + a.reference[m] - h[m] - a.floating[g], N = h[m] - a.reference[m], A = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u)); let j = A ? A[M] : 0; (!j || !await (s.isElement == null ? void 0 : s.isElement(A))) && (j = o.floating[M] || a.floating[g]); const O = C / 2 - N / 2, I = j / 2 - x[g] / 2 - 1, D = pf(f[b], I), F = pf(f[E], I), B = D, G = j - x[g] - F, z = j / 2 - x[g] / 2 + O, q = tL(B, z, G), Y = !c.arrow && y0(i) != null && z !== q && a.reference[g] / 2 - (z < B ? D : F) - x[g] / 2 < 0, Z = Y ? z < B ? z - B : z - G : 0; return { [m]: h[m] + Z, data: { [m]: q, centerOffset: z - q - Z, ...Y && { alignmentOffset: Z } }, reset: Y } } }), O0e = function (t) { return t === void 0 && (t = {}), { name: "flip", options: t, async fn(e) { var n, r; const { placement: i, middlewareData: a, rects: s, initialPlacement: o, platform: c, elements: u } = e, { mainAxis: d = !0, crossAxis: f = !0, fallbackPlacements: h, fallbackStrategy: m = "bestFit", fallbackAxisSideDirection: g = "none", flipAlignment: x = !0, ...v } = Uu(t, e); if ((n = a.arrow) != null && n.alignmentOffset) return {}; const b = mf(i), E = xu(o), M = mf(o) === o, C = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), N = h || (M || !x ? [WT(o)] : C0e(o)), A = g !== "none"; !h && A && N.push(...j0e(o, x, g, C)); const j = [o, ...N], O = await ux(e, v), I = []; let D = ((r = a.flip) == null ? void 0 : r.overflows) || []; if (d && I.push(O[b]), f) { const z = T0e(i, s, C); I.push(O[z[0]], O[z[1]]) } if (D = [...D, { placement: i, overflows: I }], !I.every(z => z <= 0)) { var F, B; const z = (((F = a.flip) == null ? void 0 : F.index) || 0) + 1, q = j[z]; if (q && (!(f === "alignment" ? E !== xu(q) : !1) || D.every($ => $.overflows[0] > 0 && xu($.placement) === E))) return { data: { index: z, overflows: D }, reset: { placement: q } }; let Y = (B = D.filter(Z => Z.overflows[0] <= 0).sort((Z, $) => Z.overflows[1] - $.overflows[1])[0]) == null ? void 0 : B.placement; if (!Y) switch (m) { case "bestFit": { var G; const Z = (G = D.filter($ => { if (A) { const V = xu($.placement); return V === E || V === "y" } return !0 }).map($ => [$.placement, $.overflows.filter(V => V > 0).reduce((V, K) => V + K, 0)]).sort(($, V) => $[1] - V[1])[0]) == null ? void 0 : G[0]; Z && (Y = Z); break } case "initialPlacement": Y = o; break }if (i !== Y) return { reset: { placement: Y } } } return {} } } }; function D8(t, e) { return { top: t.top - e.height, right: t.right - e.width, bottom: t.bottom - e.height, left: t.left - e.width } } function L8(t) { return S0e.some(e => t[e] >= 0) } const D0e = function (t) { return t === void 0 && (t = {}), { name: "hide", options: t, async fn(e) { const { rects: n } = e, { strategy: r = "referenceHidden", ...i } = Uu(t, e); switch (r) { case "referenceHidden": { const a = await ux(e, { ...i, elementContext: "reference" }), s = D8(a, n.reference); return { data: { referenceHiddenOffsets: s, referenceHidden: L8(s) } } } case "escaped": { const a = await ux(e, { ...i, altBoundary: !0 }), s = D8(a, n.floating); return { data: { escapedOffsets: s, escaped: L8(s) } } } default: return {} } } } }, mee = new Set(["left", "top"]); async function L0e(t, e) { const { placement: n, platform: r, elements: i } = t, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = mf(n), o = y0(n), c = xu(n) === "y", u = mee.has(s) ? -1 : 1, d = a && c ? -1 : 1, f = Uu(e, t); let { mainAxis: h, crossAxis: m, alignmentAxis: g } = typeof f == "number" ? { mainAxis: f, crossAxis: 0, alignmentAxis: null } : { mainAxis: f.mainAxis || 0, crossAxis: f.crossAxis || 0, alignmentAxis: f.alignmentAxis }; return o && typeof g == "number" && (m = o === "end" ? g * -1 : g), c ? { x: m * d, y: h * u } : { x: h * u, y: m * d } } const F0e = function (t) { return t === void 0 && (t = 0), { name: "offset", options: t, async fn(e) { var n, r; const { x: i, y: a, placement: s, middlewareData: o } = e, c = await L0e(e, t); return s === ((n = o.offset) == null ? void 0 : n.placement) && (r = o.arrow) != null && r.alignmentOffset ? {} : { x: i + c.x, y: a + c.y, data: { ...c, placement: s } } } } }, U0e = function (t) { return t === void 0 && (t = {}), { name: "shift", options: t, async fn(e) { const { x: n, y: r, placement: i } = e, { mainAxis: a = !0, crossAxis: s = !1, limiter: o = { fn: v => { let { x: b, y: E } = v; return { x: b, y: E } } }, ...c } = Uu(t, e), u = { x: n, y: r }, d = await ux(e, c), f = xu(mf(i)), h = S5(f); let m = u[h], g = u[f]; if (a) { const v = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", E = m + d[v], M = m - d[b]; m = tL(E, m, M) } if (s) { const v = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", E = g + d[v], M = g - d[b]; g = tL(E, g, M) } const x = o.fn({ ...e, [h]: m, [f]: g }); return { ...x, data: { x: x.x - n, y: x.y - r, enabled: { [h]: a, [f]: s } } } } } }, B0e = function (t) { return t === void 0 && (t = {}), { options: t, fn(e) { const { x: n, y: r, placement: i, rects: a, middlewareData: s } = e, { offset: o = 0, mainAxis: c = !0, crossAxis: u = !0 } = Uu(t, e), d = { x: n, y: r }, f = xu(i), h = S5(f); let m = d[h], g = d[f]; const x = Uu(o, e), v = typeof x == "number" ? { mainAxis: x, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...x }; if (c) { const M = h === "y" ? "height" : "width", C = a.reference[h] - a.floating[M] + v.mainAxis, N = a.reference[h] + a.reference[M] - v.mainAxis; m < C ? m = C : m > N && (m = N) } if (u) { var b, E; const M = h === "y" ? "width" : "height", C = mee.has(mf(i)), N = a.reference[f] - a.floating[M] + (C && ((b = s.offset) == null ? void 0 : b[f]) || 0) + (C ? 0 : v.crossAxis), A = a.reference[f] + a.reference[M] + (C ? 0 : ((E = s.offset) == null ? void 0 : E[f]) || 0) - (C ? v.crossAxis : 0); g < N ? g = N : g > A && (g = A) } return { [h]: m, [f]: g } } } }, $0e = function (t) { return t === void 0 && (t = {}), { name: "size", options: t, async fn(e) { var n, r; const { placement: i, rects: a, platform: s, elements: o } = e, { apply: c = () => { }, ...u } = Uu(t, e), d = await ux(e, u), f = mf(i), h = y0(i), m = xu(i) === "y", { width: g, height: x } = a.floating; let v, b; f === "top" || f === "bottom" ? (v = f, b = h === (await (s.isRTL == null ? void 0 : s.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (b = f, v = h === "end" ? "top" : "bottom"); const E = x - d.top - d.bottom, M = g - d.left - d.right, C = pf(x - d[v], E), N = pf(g - d[b], M), A = !e.middlewareData.shift; let j = C, O = N; if ((n = e.middlewareData.shift) != null && n.enabled.x && (O = M), (r = e.middlewareData.shift) != null && r.enabled.y && (j = E), A && !h) { const D = Ms(d.left, 0), F = Ms(d.right, 0), B = Ms(d.top, 0), G = Ms(d.bottom, 0); m ? O = g - 2 * (D !== 0 || F !== 0 ? D + F : Ms(d.left, d.right)) : j = x - 2 * (B !== 0 || G !== 0 ? B + G : Ms(d.top, d.bottom)) } await c({ ...e, availableWidth: O, availableHeight: j }); const I = await s.getDimensions(o.floating); return g !== I.width || x !== I.height ? { reset: { rects: !0 } } : {} } } }; function wA() { return typeof window < "u" } function x0(t) { return gee(t) ? (t.nodeName || "").toLowerCase() : "#document" } function dl(t) { var e; return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window } function Ku(t) { var e; return (e = (gee(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement } function gee(t) { return wA() ? t instanceof Node || t instanceof dl(t).Node : !1 } function Zs(t) { return wA() ? t instanceof Element || t instanceof dl(t).Element : !1 } function Bu(t) { return wA() ? t instanceof HTMLElement || t instanceof dl(t).HTMLElement : !1 } function F8(t) { return !wA() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof dl(t).ShadowRoot } const z0e = new Set(["inline", "contents"]); function HS(t) { const { overflow: e, overflowX: n, overflowY: r, display: i } = zc(t); return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !z0e.has(i) } const V0e = new Set(["table", "td", "th"]); function H0e(t) { return V0e.has(x0(t)) } const W0e = [":popover-open", ":modal"]; function SA(t) { return W0e.some(e => { try { return t.matches(e) } catch { return !1 } }) } const G0e = ["transform", "translate", "scale", "rotate", "perspective"], q0e = ["transform", "translate", "scale", "rotate", "perspective", "filter"], X0e = ["paint", "layout", "strict", "content"]; function M5(t) { const e = T5(), n = Zs(t) ? zc(t) : t; return G0e.some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || q0e.some(r => (n.willChange || "").includes(r)) || X0e.some(r => (n.contain || "").includes(r)) } function Y0e(t) { let e = Jh(t); for (; Bu(e) && !dx(e);) { if (M5(e)) return e; if (SA(e)) return null; e = Jh(e) } return null } function T5() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const K0e = new Set(["html", "body", "#document"]); function dx(t) { return K0e.has(x0(t)) } function zc(t) { return dl(t).getComputedStyle(t) } function _A(t) { return Zs(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.scrollX, scrollTop: t.scrollY } } function Jh(t) { if (x0(t) === "html") return t; const e = t.assignedSlot || t.parentNode || F8(t) && t.host || Ku(t); return F8(e) ? e.host : e } function vee(t) { const e = Jh(t); return dx(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Bu(e) && HS(e) ? e : vee(e) } function Hh(t, e, n) { var r; e === void 0 && (e = []), n === void 0 && (n = !0); const i = vee(t), a = i === ((r = t.ownerDocument) == null ? void 0 : r.body), s = dl(i); if (a) { const o = rL(s); return e.concat(s, s.visualViewport || [], HS(i) ? i : [], o && n ? Hh(o) : []) } return e.concat(i, Hh(i, [], n)) } function rL(t) { return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null } function yee(t) { const e = zc(t); let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0; const i = Bu(t), a = i ? t.offsetWidth : n, s = i ? t.offsetHeight : r, o = y1(n) !== a || y1(r) !== s; return o && (n = a, r = s), { width: n, height: r, $: o } } function C5(t) { return Zs(t) ? t : t.contextElement } function Ky(t) { const e = C5(t); if (!Bu(e)) return Cu(1); const n = e.getBoundingClientRect(), { width: r, height: i, $: a } = yee(e); let s = (a ? y1(n.width) : n.width) / r, o = (a ? y1(n.height) : n.height) / i; return (!s || !Number.isFinite(s)) && (s = 1), (!o || !Number.isFinite(o)) && (o = 1), { x: s, y: o } } const Z0e = Cu(0); function xee(t) { const e = dl(t); return !T5() || !e.visualViewport ? Z0e : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop } } function Q0e(t, e, n) { return e === void 0 && (e = !1), !n || e && n !== dl(t) ? !1 : e } function bg(t, e, n, r) { e === void 0 && (e = !1), n === void 0 && (n = !1); const i = t.getBoundingClientRect(), a = C5(t); let s = Cu(1); e && (r ? Zs(r) && (s = Ky(r)) : s = Ky(t)); const o = Q0e(a, n, r) ? xee(a) : Cu(0); let c = (i.left + o.x) / s.x, u = (i.top + o.y) / s.y, d = i.width / s.x, f = i.height / s.y; if (a) { const h = dl(a), m = r && Zs(r) ? dl(r) : r; let g = h, x = rL(g); for (; x && r && m !== g;) { const v = Ky(x), b = x.getBoundingClientRect(), E = zc(x), M = b.left + (x.clientLeft + parseFloat(E.paddingLeft)) * v.x, C = b.top + (x.clientTop + parseFloat(E.paddingTop)) * v.y; c *= v.x, u *= v.y, d *= v.x, f *= v.y, c += M, u += C, g = dl(x), x = rL(g) } } return GT({ width: d, height: f, x: c, y: u }) } function N5(t, e) { const n = _A(t).scrollLeft; return e ? e.left + n : bg(Ku(t)).left + n } function bee(t, e, n) { n === void 0 && (n = !1); const r = t.getBoundingClientRect(), i = r.left + e.scrollLeft - (n ? 0 : N5(t, r)), a = r.top + e.scrollTop; return { x: i, y: a } } function J0e(t) { let { elements: e, rect: n, offsetParent: r, strategy: i } = t; const a = i === "fixed", s = Ku(r), o = e ? SA(e.floating) : !1; if (r === s || o && a) return n; let c = { scrollLeft: 0, scrollTop: 0 }, u = Cu(1); const d = Cu(0), f = Bu(r); if ((f || !f && !a) && ((x0(r) !== "body" || HS(s)) && (c = _A(r)), Bu(r))) { const m = bg(r); u = Ky(r), d.x = m.x + r.clientLeft, d.y = m.y + r.clientTop } const h = s && !f && !a ? bee(s, c, !0) : Cu(0); return { width: n.width * u.x, height: n.height * u.y, x: n.x * u.x - c.scrollLeft * u.x + d.x + h.x, y: n.y * u.y - c.scrollTop * u.y + d.y + h.y } } function ebe(t) { return Array.from(t.getClientRects()) } function tbe(t) { const e = Ku(t), n = _A(t), r = t.ownerDocument.body, i = Ms(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), a = Ms(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight); let s = -n.scrollLeft + N5(t); const o = -n.scrollTop; return zc(r).direction === "rtl" && (s += Ms(e.clientWidth, r.clientWidth) - i), { width: i, height: a, x: s, y: o } } function nbe(t, e) { const n = dl(t), r = Ku(t), i = n.visualViewport; let a = r.clientWidth, s = r.clientHeight, o = 0, c = 0; if (i) { a = i.width, s = i.height; const u = T5(); (!u || u && e === "fixed") && (o = i.offsetLeft, c = i.offsetTop) } return { width: a, height: s, x: o, y: c } } const rbe = new Set(["absolute", "fixed"]); function ibe(t, e) { const n = bg(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, a = Bu(t) ? Ky(t) : Cu(1), s = t.clientWidth * a.x, o = t.clientHeight * a.y, c = i * a.x, u = r * a.y; return { width: s, height: o, x: c, y: u } } function U8(t, e, n) { let r; if (e === "viewport") r = nbe(t, n); else if (e === "document") r = tbe(Ku(t)); else if (Zs(e)) r = ibe(e, n); else { const i = xee(t); r = { x: e.x - i.x, y: e.y - i.y, width: e.width, height: e.height } } return GT(r) } function wee(t, e) { const n = Jh(t); return n === e || !Zs(n) || dx(n) ? !1 : zc(n).position === "fixed" || wee(n, e) } function abe(t, e) { const n = e.get(t); if (n) return n; let r = Hh(t, [], !1).filter(o => Zs(o) && x0(o) !== "body"), i = null; const a = zc(t).position === "fixed"; let s = a ? Jh(t) : t; for (; Zs(s) && !dx(s);) { const o = zc(s), c = M5(s); !c && o.position === "fixed" && (i = null), (a ? !c && !i : !c && o.position === "static" && !!i && rbe.has(i.position) || HS(s) && !c && wee(t, s)) ? r = r.filter(d => d !== s) : i = o, s = Jh(s) } return e.set(t, r), r } function sbe(t) { let { element: e, boundary: n, rootBoundary: r, strategy: i } = t; const s = [...n === "clippingAncestors" ? SA(e) ? [] : abe(e, this._c) : [].concat(n), r], o = s[0], c = s.reduce((u, d) => { const f = U8(e, d, i); return u.top = Ms(f.top, u.top), u.right = pf(f.right, u.right), u.bottom = pf(f.bottom, u.bottom), u.left = Ms(f.left, u.left), u }, U8(e, o, i)); return { width: c.right - c.left, height: c.bottom - c.top, x: c.left, y: c.top } } function obe(t) { const { width: e, height: n } = yee(t); return { width: e, height: n } } function lbe(t, e, n) { const r = Bu(e), i = Ku(e), a = n === "fixed", s = bg(t, !0, a, e); let o = { scrollLeft: 0, scrollTop: 0 }; const c = Cu(0); function u() { c.x = N5(i) } if (r || !r && !a) if ((x0(e) !== "body" || HS(i)) && (o = _A(e)), r) { const m = bg(e, !0, a, e); c.x = m.x + e.clientLeft, c.y = m.y + e.clientTop } else i && u(); a && !r && i && u(); const d = i && !r && !a ? bee(i, o) : Cu(0), f = s.left + o.scrollLeft - c.x - d.x, h = s.top + o.scrollTop - c.y - d.y; return { x: f, y: h, width: s.width, height: s.height } } function Aj(t) { return zc(t).position === "static" } function B8(t, e) { if (!Bu(t) || zc(t).position === "fixed") return null; if (e) return e(t); let n = t.offsetParent; return Ku(t) === n && (n = n.ownerDocument.body), n } function See(t, e) { const n = dl(t); if (SA(t)) return n; if (!Bu(t)) { let i = Jh(t); for (; i && !dx(i);) { if (Zs(i) && !Aj(i)) return i; i = Jh(i) } return n } let r = B8(t, e); for (; r && H0e(r) && Aj(r);)r = B8(r, e); return r && dx(r) && Aj(r) && !M5(r) ? n : r || Y0e(t) || n } const cbe = async function (t) { const e = this.getOffsetParent || See, n = this.getDimensions, r = await n(t.floating); return { reference: lbe(t.reference, await e(t.floating), t.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }; function ube(t) { return zc(t).direction === "rtl" } const dbe = { convertOffsetParentRelativeRectToViewportRelativeRect: J0e, getDocumentElement: Ku, getClippingRect: sbe, getOffsetParent: See, getElementRects: cbe, getClientRects: ebe, getDimensions: obe, getScale: Ky, isElement: Zs, isRTL: ube }; function _ee(t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height } function fbe(t, e) { let n = null, r; const i = Ku(t); function a() { var o; clearTimeout(r), (o = n) == null || o.disconnect(), n = null } function s(o, c) { o === void 0 && (o = !1), c === void 0 && (c = 1), a(); const u = t.getBoundingClientRect(), { left: d, top: f, width: h, height: m } = u; if (o || e(), !h || !m) return; const g = BE(f), x = BE(i.clientWidth - (d + h)), v = BE(i.clientHeight - (f + m)), b = BE(d), M = { rootMargin: -g + "px " + -x + "px " + -v + "px " + -b + "px", threshold: Ms(0, pf(1, c)) || 1 }; let C = !0; function N(A) { const j = A[0].intersectionRatio; if (j !== c) { if (!C) return s(); j ? s(!1, j) : r = setTimeout(() => { s(!1, 1e-7) }, 1e3) } j === 1 && !_ee(u, t.getBoundingClientRect()) && s(), C = !1 } try { n = new IntersectionObserver(N, { ...M, root: i.ownerDocument }) } catch { n = new IntersectionObserver(N, M) } n.observe(t) } return s(!0), a } function A5(t, e, n, r) { r === void 0 && (r = {}); const { ancestorScroll: i = !0, ancestorResize: a = !0, elementResize: s = typeof ResizeObserver == "function", layoutShift: o = typeof IntersectionObserver == "function", animationFrame: c = !1 } = r, u = C5(t), d = i || a ? [...u ? Hh(u) : [], ...Hh(e)] : []; d.forEach(b => { i && b.addEventListener("scroll", n, { passive: !0 }), a && b.addEventListener("resize", n) }); const f = u && o ? fbe(u, n) : null; let h = -1, m = null; s && (m = new ResizeObserver(b => { let [E] = b; E && E.target === u && m && (m.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => { var M; (M = m) == null || M.observe(e) })), n() }), u && !c && m.observe(u), m.observe(e)); let g, x = c ? bg(t) : null; c && v(); function v() { const b = bg(t); x && !_ee(x, b) && n(), x = b, g = requestAnimationFrame(v) } return n(), () => { var b; d.forEach(E => { i && E.removeEventListener("scroll", n), a && E.removeEventListener("resize", n) }), f?.(), (b = m) == null || b.disconnect(), m = null, c && cancelAnimationFrame(g) } } const Pj = ux, Eee = F0e, Mee = U0e, Tee = O0e, hbe = $0e, pbe = D0e, $8 = I0e, mbe = B0e, Cee = (t, e, n) => { const r = new Map, i = { platform: dbe, ...n }, a = { ...i.platform, _c: r }; return k0e(t, e, { ...i, platform: a }) }; var gbe = typeof document < "u", vbe = function () { }, _T = gbe ? S.useLayoutEffect : vbe; function qT(t, e) { if (t === e) return !0; if (typeof t != typeof e) return !1; if (typeof t == "function" && t.toString() === e.toString()) return !0; let n, r, i; if (t && e && typeof t == "object") { if (Array.isArray(t)) { if (n = t.length, n !== e.length) return !1; for (r = n; r-- !== 0;)if (!qT(t[r], e[r])) return !1; return !0 } if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length) return !1; for (r = n; r-- !== 0;)if (!{}.hasOwnProperty.call(e, i[r])) return !1; for (r = n; r-- !== 0;) { const a = i[r]; if (!(a === "_owner" && t.$$typeof) && !qT(t[a], e[a])) return !1 } return !0 } return t !== t && e !== e } function Nee(t) { return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1 } function z8(t, e) { const n = Nee(t); return Math.round(e * n) / n } function jj(t) { const e = S.useRef(t); return _T(() => { e.current = t }), e } function Aee(t) { t === void 0 && (t = {}); const { placement: e = "bottom", strategy: n = "absolute", middleware: r = [], platform: i, elements: { reference: a, floating: s } = {}, transform: o = !0, whileElementsMounted: c, open: u } = t, [d, f] = S.useState({ x: 0, y: 0, strategy: n, placement: e, middlewareData: {}, isPositioned: !1 }), [h, m] = S.useState(r); qT(h, r) || m(r); const [g, x] = S.useState(null), [v, b] = S.useState(null), E = S.useCallback($ => { $ !== A.current && (A.current = $, x($)) }, []), M = S.useCallback($ => { $ !== j.current && (j.current = $, b($)) }, []), C = a || g, N = s || v, A = S.useRef(null), j = S.useRef(null), O = S.useRef(d), I = c != null, D = jj(c), F = jj(i), B = jj(u), G = S.useCallback(() => { if (!A.current || !j.current) return; const $ = { placement: e, strategy: n, middleware: h }; F.current && ($.platform = F.current), Cee(A.current, j.current, $).then(V => { const K = { ...V, isPositioned: B.current !== !1 }; z.current && !qT(O.current, K) && (O.current = K, xi.flushSync(() => { f(K) })) }) }, [h, e, n, F, B]); _T(() => { u === !1 && O.current.isPositioned && (O.current.isPositioned = !1, f($ => ({ ...$, isPositioned: !1 }))) }, [u]); const z = S.useRef(!1); _T(() => (z.current = !0, () => { z.current = !1 }), []), _T(() => { if (C && (A.current = C), N && (j.current = N), C && N) { if (D.current) return D.current(C, N, G); G() } }, [C, N, G, D, I]); const q = S.useMemo(() => ({ reference: A, floating: j, setReference: E, setFloating: M }), [E, M]), Y = S.useMemo(() => ({ reference: C, floating: N }), [C, N]), Z = S.useMemo(() => { const $ = { position: n, left: 0, top: 0 }; if (!Y.floating) return $; const V = z8(Y.floating, d.x), K = z8(Y.floating, d.y); return o ? { ...$, transform: "translate(" + V + "px, " + K + "px)", ...Nee(Y.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: V, top: K } }, [n, o, Y.floating, d.x, d.y]); return S.useMemo(() => ({ ...d, update: G, refs: q, elements: Y, floatingStyles: Z }), [d, G, q, Y, Z]) } const ybe = t => { function e(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: t, fn(n) { const { element: r, padding: i } = typeof t == "function" ? t(n) : t; return r && e(r) ? r.current != null ? $8({ element: r.current, padding: i }).fn(n) : {} : r ? $8({ element: r, padding: i }).fn(n) : {} } } }, P5 = (t, e) => ({ ...Eee(t), options: [t, e] }), Pee = (t, e) => ({ ...Mee(t), options: [t, e] }), xbe = (t, e) => ({ ...mbe(t), options: [t, e] }), jee = (t, e) => ({ ...Tee(t), options: [t, e] }), Ree = (t, e) => ({ ...hbe(t), options: [t, e] }), bbe = (t, e) => ({ ...pbe(t), options: [t, e] }), wbe = (t, e) => ({ ...ybe(t), options: [t, e] }); var Sbe = "Arrow", kee = S.forwardRef((t, e) => { const { children: n, width: r = 10, height: i = 5, ...a } = t; return l.jsx(qt.svg, { ...a, ref: e, width: r, height: i, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: t.asChild ? n : l.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); kee.displayName = Sbe; var _be = kee; function WS(t) { const [e, n] = S.useState(void 0); return Ki(() => { if (t) { n({ width: t.offsetWidth, height: t.offsetHeight }); const r = new ResizeObserver(i => { if (!Array.isArray(i) || !i.length) return; const a = i[0]; let s, o; if ("borderBoxSize" in a) { const c = a.borderBoxSize, u = Array.isArray(c) ? c[0] : c; s = u.inlineSize, o = u.blockSize } else s = t.offsetWidth, o = t.offsetHeight; n({ width: s, height: o }) }); return r.observe(t, { box: "border-box" }), () => r.unobserve(t) } else n(void 0) }, [t]), e } var j5 = "Popper", [Iee, b0] = oa(j5), [Ebe, Oee] = Iee(j5), Dee = t => { const { __scopePopper: e, children: n } = t, [r, i] = S.useState(null); return l.jsx(Ebe, { scope: e, anchor: r, onAnchorChange: i, children: n }) }; Dee.displayName = j5; var Lee = "PopperAnchor", Fee = S.forwardRef((t, e) => { const { __scopePopper: n, virtualRef: r, ...i } = t, a = Oee(Lee, n), s = S.useRef(null), o = Mn(e, s); return S.useEffect(() => { a.onAnchorChange(r?.current || s.current) }), r ? null : l.jsx(qt.div, { ...i, ref: o }) }); Fee.displayName = Lee; var R5 = "PopperContent", [Mbe, Tbe] = Iee(R5), Uee = S.forwardRef((t, e) => { const { __scopePopper: n, side: r = "bottom", sideOffset: i = 0, align: a = "center", alignOffset: s = 0, arrowPadding: o = 0, avoidCollisions: c = !0, collisionBoundary: u = [], collisionPadding: d = 0, sticky: f = "partial", hideWhenDetached: h = !1, updatePositionStrategy: m = "optimized", onPlaced: g, ...x } = t, v = Oee(R5, n), [b, E] = S.useState(null), M = Mn(e, ae => E(ae)), [C, N] = S.useState(null), A = WS(C), j = A?.width ?? 0, O = A?.height ?? 0, I = r + (a !== "center" ? "-" + a : ""), D = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, F = Array.isArray(u) ? u : [u], B = F.length > 0, G = { padding: D, boundary: F.filter(Nbe), altBoundary: B }, { refs: z, floatingStyles: q, placement: Y, isPositioned: Z, middlewareData: $ } = Aee({ strategy: "fixed", placement: I, whileElementsMounted: (...ae) => A5(...ae, { animationFrame: m === "always" }), elements: { reference: v.anchor }, middleware: [P5({ mainAxis: i + O, alignmentAxis: s }), c && Pee({ mainAxis: !0, crossAxis: !1, limiter: f === "partial" ? xbe() : void 0, ...G }), c && jee({ ...G }), Ree({ ...G, apply: ({ elements: ae, rects: se, availableWidth: he, availableHeight: Ae }) => { const { width: Ce, height: fe } = se.reference, oe = ae.floating.style; oe.setProperty("--radix-popper-available-width", `${he}px`), oe.setProperty("--radix-popper-available-height", `${Ae}px`), oe.setProperty("--radix-popper-anchor-width", `${Ce}px`), oe.setProperty("--radix-popper-anchor-height", `${fe}px`) } }), C && wbe({ element: C, padding: o }), Abe({ arrowWidth: j, arrowHeight: O }), h && bbe({ strategy: "referenceHidden", ...G })] }), [V, K] = zee(Y), X = Yi(g); Ki(() => { Z && X?.() }, [Z, X]); const Q = $.arrow?.x, re = $.arrow?.y, ce = $.arrow?.centerOffset !== 0, [be, de] = S.useState(); return Ki(() => { b && de(window.getComputedStyle(b).zIndex) }, [b]), l.jsx("div", { ref: z.setFloating, "data-radix-popper-content-wrapper": "", style: { ...q, transform: Z ? q.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: be, "--radix-popper-transform-origin": [$.transformOrigin?.x, $.transformOrigin?.y].join(" "), ...$.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: t.dir, children: l.jsx(Mbe, { scope: n, placedSide: V, onArrowChange: N, arrowX: Q, arrowY: re, shouldHideArrow: ce, children: l.jsx(qt.div, { "data-side": V, "data-align": K, ...x, ref: M, style: { ...x.style, animation: Z ? void 0 : "none" } }) }) }) }); Uee.displayName = R5; var Bee = "PopperArrow", Cbe = { top: "bottom", right: "left", bottom: "top", left: "right" }, $ee = S.forwardRef(function (e, n) { const { __scopePopper: r, ...i } = e, a = Tbe(Bee, r), s = Cbe[a.placedSide]; return l.jsx("span", { ref: a.onArrowChange, style: { position: "absolute", left: a.arrowX, top: a.arrowY, [s]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[a.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[a.placedSide], visibility: a.shouldHideArrow ? "hidden" : void 0 }, children: l.jsx(_be, { ...i, ref: n, style: { ...i.style, display: "block" } }) }) }); $ee.displayName = Bee; function Nbe(t) { return t !== null } var Abe = t => ({ name: "transformOrigin", options: t, fn(e) { const { placement: n, rects: r, middlewareData: i } = e, s = i.arrow?.centerOffset !== 0, o = s ? 0 : t.arrowWidth, c = s ? 0 : t.arrowHeight, [u, d] = zee(n), f = { start: "0%", center: "50%", end: "100%" }[d], h = (i.arrow?.x ?? 0) + o / 2, m = (i.arrow?.y ?? 0) + c / 2; let g = "", x = ""; return u === "bottom" ? (g = s ? f : `${h}px`, x = `${-c}px`) : u === "top" ? (g = s ? f : `${h}px`, x = `${r.floating.height + c}px`) : u === "right" ? (g = `${-c}px`, x = s ? f : `${m}px`) : u === "left" && (g = `${r.floating.width + c}px`, x = s ? f : `${m}px`), { data: { x: g, y: x } } } }); function zee(t) { const [e, n = "center"] = t.split("-"); return [e, n] } var Vee = Dee, k5 = Fee, I5 = Uee, O5 = $ee, [EA] = oa("Tooltip", [b0]), D5 = b0(), Hee = "TooltipProvider", Pbe = 700, V8 = "tooltip.open", [jbe, Wee] = EA(Hee), Gee = t => { const { __scopeTooltip: e, delayDuration: n = Pbe, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: a } = t, s = S.useRef(!0), o = S.useRef(!1), c = S.useRef(0); return S.useEffect(() => { const u = c.current; return () => window.clearTimeout(u) }, []), l.jsx(jbe, { scope: e, isOpenDelayedRef: s, delayDuration: n, onOpen: S.useCallback(() => { window.clearTimeout(c.current), s.current = !1 }, []), onClose: S.useCallback(() => { window.clearTimeout(c.current), c.current = window.setTimeout(() => s.current = !0, r) }, [r]), isPointerInTransitRef: o, onPointerInTransitChange: S.useCallback(u => { o.current = u }, []), disableHoverableContent: i, children: a }) }; Gee.displayName = Hee; var qee = "Tooltip", [gct, MA] = EA(qee), iL = "TooltipTrigger", Rbe = S.forwardRef((t, e) => { const { __scopeTooltip: n, ...r } = t, i = MA(iL, n), a = Wee(iL, n), s = D5(n), o = S.useRef(null), c = Mn(e, o, i.onTriggerChange), u = S.useRef(!1), d = S.useRef(!1), f = S.useCallback(() => u.current = !1, []); return S.useEffect(() => () => document.removeEventListener("pointerup", f), [f]), l.jsx(k5, { asChild: !0, ...s, children: l.jsx(qt.button, { "aria-describedby": i.open ? i.contentId : void 0, "data-state": i.stateAttribute, ...r, ref: c, onPointerMove: Mt(t.onPointerMove, h => { h.pointerType !== "touch" && !d.current && !a.isPointerInTransitRef.current && (i.onTriggerEnter(), d.current = !0) }), onPointerLeave: Mt(t.onPointerLeave, () => { i.onTriggerLeave(), d.current = !1 }), onPointerDown: Mt(t.onPointerDown, () => { i.open && i.onClose(), u.current = !0, document.addEventListener("pointerup", f, { once: !0 }) }), onFocus: Mt(t.onFocus, () => { u.current || i.onOpen() }), onBlur: Mt(t.onBlur, i.onClose), onClick: Mt(t.onClick, i.onClose) }) }) }); Rbe.displayName = iL; var kbe = "TooltipPortal", [vct, Ibe] = EA(kbe, { forceMount: void 0 }), fx = "TooltipContent", Xee = S.forwardRef((t, e) => { const n = Ibe(fx, t.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...a } = t, s = MA(fx, t.__scopeTooltip); return l.jsx(Ka, { present: r || s.open, children: s.disableHoverableContent ? l.jsx(Yee, { side: i, ...a, ref: e }) : l.jsx(Obe, { side: i, ...a, ref: e }) }) }), Obe = S.forwardRef((t, e) => { const n = MA(fx, t.__scopeTooltip), r = Wee(fx, t.__scopeTooltip), i = S.useRef(null), a = Mn(e, i), [s, o] = S.useState(null), { trigger: c, onClose: u } = n, d = i.current, { onPointerInTransitChange: f } = r, h = S.useCallback(() => { o(null), f(!1) }, [f]), m = S.useCallback((g, x) => { const v = g.currentTarget, b = { x: g.clientX, y: g.clientY }, E = Bbe(b, v.getBoundingClientRect()), M = $be(b, E), C = zbe(x.getBoundingClientRect()), N = Hbe([...M, ...C]); o(N), f(!0) }, [f]); return S.useEffect(() => () => h(), [h]), S.useEffect(() => { if (c && d) { const g = v => m(v, d), x = v => m(v, c); return c.addEventListener("pointerleave", g), d.addEventListener("pointerleave", x), () => { c.removeEventListener("pointerleave", g), d.removeEventListener("pointerleave", x) } } }, [c, d, m, h]), S.useEffect(() => { if (s) { const g = x => { const v = x.target, b = { x: x.clientX, y: x.clientY }, E = c?.contains(v) || d?.contains(v), M = !Vbe(b, s); E ? h() : M && (h(), u()) }; return document.addEventListener("pointermove", g), () => document.removeEventListener("pointermove", g) } }, [c, d, s, u, h]), l.jsx(Yee, { ...t, ref: a }) }), [Dbe, Lbe] = EA(qee, { isInside: !1 }), Fbe = kJ("TooltipContent"), Yee = S.forwardRef((t, e) => { const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: a, onPointerDownOutside: s, ...o } = t, c = MA(fx, n), u = D5(n), { onClose: d } = c; return S.useEffect(() => (document.addEventListener(V8, d), () => document.removeEventListener(V8, d)), [d]), S.useEffect(() => { if (c.trigger) { const f = h => { h.target?.contains(c.trigger) && d() }; return window.addEventListener("scroll", f, { capture: !0 }), () => window.removeEventListener("scroll", f, { capture: !0 }) } }, [c.trigger, d]), l.jsx(g0, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: a, onPointerDownOutside: s, onFocusOutside: f => f.preventDefault(), onDismiss: d, children: l.jsxs(I5, { "data-state": c.stateAttribute, ...u, ...o, ref: e, style: { ...o.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [l.jsx(Fbe, { children: r }), l.jsx(Dbe, { scope: n, isInside: !0, children: l.jsx(Uye, { id: c.contentId, role: "tooltip", children: i || r }) })] }) }) }); Xee.displayName = fx; var Kee = "TooltipArrow", Ube = S.forwardRef((t, e) => { const { __scopeTooltip: n, ...r } = t, i = D5(n); return Lbe(Kee, n).isInside ? null : l.jsx(O5, { ...i, ...r, ref: e }) }); Ube.displayName = Kee; function Bbe(t, e) { const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), i = Math.abs(e.right - t.x), a = Math.abs(e.left - t.x); switch (Math.min(n, r, i, a)) { case a: return "left"; case i: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function $be(t, e, n = 5) { const r = []; switch (e) { case "top": r.push({ x: t.x - n, y: t.y + n }, { x: t.x + n, y: t.y + n }); break; case "bottom": r.push({ x: t.x - n, y: t.y - n }, { x: t.x + n, y: t.y - n }); break; case "left": r.push({ x: t.x + n, y: t.y - n }, { x: t.x + n, y: t.y + n }); break; case "right": r.push({ x: t.x - n, y: t.y - n }, { x: t.x - n, y: t.y + n }); break }return r } function zbe(t) { const { top: e, right: n, bottom: r, left: i } = t; return [{ x: i, y: e }, { x: n, y: e }, { x: n, y: r }, { x: i, y: r }] } function Vbe(t, e) { const { x: n, y: r } = t; let i = !1; for (let a = 0, s = e.length - 1; a < e.length; s = a++) { const o = e[a], c = e[s], u = o.x, d = o.y, f = c.x, h = c.y; d > r != h > r && n < (f - u) * (r - d) / (h - d) + u && (i = !i) } return i } function Hbe(t) { const e = t.slice(); return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), Wbe(e) } function Wbe(t) { if (t.length <= 1) return t.slice(); const e = []; for (let r = 0; r < t.length; r++) { const i = t[r]; for (; e.length >= 2;) { const a = e[e.length - 1], s = e[e.length - 2]; if ((a.x - s.x) * (i.y - s.y) >= (a.y - s.y) * (i.x - s.x)) e.pop(); else break } e.push(i) } e.pop(); const n = []; for (let r = t.length - 1; r >= 0; r--) { const i = t[r]; for (; n.length >= 2;) { const a = n[n.length - 1], s = n[n.length - 2]; if ((a.x - s.x) * (i.y - s.y) >= (a.y - s.y) * (i.x - s.x)) n.pop(); else break } n.push(i) } return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n) } var Gbe = Gee, Zee = Xee; const qbe = Gbe, Xbe = S.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => l.jsx(Zee, { ref: r, sideOffset: e, className: _t("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", t), ...n })); Xbe.displayName = Zee.displayName; var w0 = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(t) { return this.listeners.add(t), this.onSubscribe(), () => { this.listeners.delete(t), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, wg = typeof window > "u" || "Deno" in globalThis; function Gs() { } function Ybe(t, e) { return typeof t == "function" ? t(e) : t } function aL(t) { return typeof t == "number" && t >= 0 && t !== 1 / 0 } function Qee(t, e) { return Math.max(t + (e || 0) - Date.now(), 0) } function Wh(t, e) { return typeof t == "function" ? t(e) : t } function Dl(t, e) { return typeof t == "function" ? t(e) : t } function H8(t, e) { const { type: n = "all", exact: r, fetchStatus: i, predicate: a, queryKey: s, stale: o } = t; if (s) { if (r) { if (e.queryHash !== L5(s, e.options)) return !1 } else if (!x1(e.queryKey, s)) return !1 } if (n !== "all") { const c = e.isActive(); if (n === "active" && !c || n === "inactive" && c) return !1 } return !(typeof o == "boolean" && e.isStale() !== o || i && i !== e.state.fetchStatus || a && !a(e)) } function W8(t, e) { const { exact: n, status: r, predicate: i, mutationKey: a } = t; if (a) { if (!e.options.mutationKey) return !1; if (n) { if (Sg(e.options.mutationKey) !== Sg(a)) return !1 } else if (!x1(e.options.mutationKey, a)) return !1 } return !(r && e.state.status !== r || i && !i(e)) } function L5(t, e) { return (e?.queryKeyHashFn || Sg)(t) } function Sg(t) { return JSON.stringify(t, (e, n) => sL(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : n) } function x1(t, e) { return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every(n => x1(t[n], e[n])) : !1 } function Jee(t, e) { if (t === e) return t; const n = G8(t) && G8(e); if (n || sL(t) && sL(e)) { const r = n ? t : Object.keys(t), i = r.length, a = n ? e : Object.keys(e), s = a.length, o = n ? [] : {}, c = new Set(r); let u = 0; for (let d = 0; d < s; d++) { const f = n ? d : a[d]; (!n && c.has(f) || n) && t[f] === void 0 && e[f] === void 0 ? (o[f] = void 0, u++) : (o[f] = Jee(t[f], e[f]), o[f] === t[f] && t[f] !== void 0 && u++) } return i === s && u === i ? t : o } return e } function XT(t, e) { if (!e || Object.keys(t).length !== Object.keys(e).length) return !1; for (const n in t) if (t[n] !== e[n]) return !1; return !0 } function G8(t) { return Array.isArray(t) && t.length === Object.keys(t).length } function sL(t) { if (!q8(t)) return !1; const e = t.constructor; if (e === void 0) return !0; const n = e.prototype; return !(!q8(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype) } function q8(t) { return Object.prototype.toString.call(t) === "[object Object]" } function Kbe(t) { return new Promise(e => { setTimeout(e, t) }) } function oL(t, e, n) { return typeof n.structuralSharing == "function" ? n.structuralSharing(t, e) : n.structuralSharing !== !1 ? Jee(t, e) : e } function Zbe(t, e, n = 0) { const r = [...t, e]; return n && r.length > n ? r.slice(1) : r } function Qbe(t, e, n = 0) { const r = [e, ...t]; return n && r.length > n ? r.slice(0, -1) : r } var F5 = Symbol(); function ete(t, e) { return !t.queryFn && e?.initialPromise ? () => e.initialPromise : !t.queryFn || t.queryFn === F5 ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn } function tte(t, e) { return typeof t == "function" ? t(...e) : !!t } var Jbe = class extends w0 { #t; #e; #n; constructor() { super(), this.#n = t => { if (!wg && window.addEventListener) { const e = () => t(); return window.addEventListener("visibilitychange", e, !1), () => { window.removeEventListener("visibilitychange", e) } } } } onSubscribe() { this.#e || this.setEventListener(this.#n) } onUnsubscribe() { this.hasListeners() || (this.#e?.(), this.#e = void 0) } setEventListener(t) { this.#n = t, this.#e?.(), this.#e = t(e => { typeof e == "boolean" ? this.setFocused(e) : this.onFocus() }) } setFocused(t) { this.#t !== t && (this.#t = t, this.onFocus()) } onFocus() { const t = this.isFocused(); this.listeners.forEach(e => { e(t) }) } isFocused() { return typeof this.#t == "boolean" ? this.#t : globalThis.document?.visibilityState !== "hidden" } }, U5 = new Jbe, ewe = class extends w0 { #t = !0; #e; #n; constructor() { super(), this.#n = t => { if (!wg && window.addEventListener) { const e = () => t(!0), n = () => t(!1); return window.addEventListener("online", e, !1), window.addEventListener("offline", n, !1), () => { window.removeEventListener("online", e), window.removeEventListener("offline", n) } } } } onSubscribe() { this.#e || this.setEventListener(this.#n) } onUnsubscribe() { this.hasListeners() || (this.#e?.(), this.#e = void 0) } setEventListener(t) { this.#n = t, this.#e?.(), this.#e = t(this.setOnline.bind(this)) } setOnline(t) { this.#t !== t && (this.#t = t, this.listeners.forEach(n => { n(t) })) } isOnline() { return this.#t } }, YT = new ewe; function lL() { let t, e; const n = new Promise((i, a) => { t = i, e = a }); n.status = "pending", n.catch(() => { }); function r(i) { Object.assign(n, i), delete n.resolve, delete n.reject } return n.resolve = i => { r({ status: "fulfilled", value: i }), t(i) }, n.reject = i => { r({ status: "rejected", reason: i }), e(i) }, n } function twe(t) { return Math.min(1e3 * 2 ** t, 3e4) } function nte(t) { return (t ?? "online") === "online" ? YT.isOnline() : !0 } var rte = class extends Error { constructor(t) { super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent } }; function Rj(t) { return t instanceof rte } function ite(t) { let e = !1, n = 0, r = !1, i; const a = lL(), s = x => { r || (h(new rte(x)), t.abort?.()) }, o = () => { e = !0 }, c = () => { e = !1 }, u = () => U5.isFocused() && (t.networkMode === "always" || YT.isOnline()) && t.canRun(), d = () => nte(t.networkMode) && t.canRun(), f = x => { r || (r = !0, t.onSuccess?.(x), i?.(), a.resolve(x)) }, h = x => { r || (r = !0, t.onError?.(x), i?.(), a.reject(x)) }, m = () => new Promise(x => { i = v => { (r || u()) && x(v) }, t.onPause?.() }).then(() => { i = void 0, r || t.onContinue?.() }), g = () => { if (r) return; let x; const v = n === 0 ? t.initialPromise : void 0; try { x = v ?? t.fn() } catch (b) { x = Promise.reject(b) } Promise.resolve(x).then(f).catch(b => { if (r) return; const E = t.retry ?? (wg ? 0 : 3), M = t.retryDelay ?? twe, C = typeof M == "function" ? M(n, b) : M, N = E === !0 || typeof E == "number" && n < E || typeof E == "function" && E(n, b); if (e || !N) { h(b); return } n++, t.onFail?.(n, b), Kbe(C).then(() => u() ? void 0 : m()).then(() => { e ? h(b) : g() }) }) }; return { promise: a, cancel: s, continue: () => (i?.(), a), cancelRetry: o, continueRetry: c, canStart: d, start: () => (d() ? g() : m().then(g), a) } } var nwe = t => setTimeout(t, 0); function rwe() { let t = [], e = 0, n = o => { o() }, r = o => { o() }, i = nwe; const a = o => { e ? t.push(o) : i(() => { n(o) }) }, s = () => { const o = t; t = [], o.length && i(() => { r(() => { o.forEach(c => { n(c) }) }) }) }; return { batch: o => { let c; e++; try { c = o() } finally { e--, e || s() } return c }, batchCalls: o => (...c) => { a(() => { o(...c) }) }, schedule: a, setNotifyFunction: o => { n = o }, setBatchNotifyFunction: o => { r = o }, setScheduler: o => { i = o } } } var ja = rwe(), ate = class { #t; destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), aL(this.gcTime) && (this.#t = setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(t) { this.gcTime = Math.max(this.gcTime || 0, t ?? (wg ? 1 / 0 : 300 * 1e3)) } clearGcTimeout() { this.#t && (clearTimeout(this.#t), this.#t = void 0) } }, iwe = class extends ate { #t; #e; #n; #r; #i; #s; #o; constructor(t) { super(), this.#o = !1, this.#s = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.#r = t.client, this.#n = this.#r.getQueryCache(), this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.#t = awe(this.options), this.state = t.state ?? this.#t, this.scheduleGc() } get meta() { return this.options.meta } get promise() { return this.#i?.promise } setOptions(t) { this.options = { ...this.#s, ...t }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && this.#n.remove(this) } setData(t, e) { const n = oL(this.state.data, t, this.options); return this.#a({ data: n, type: "success", dataUpdatedAt: e?.updatedAt, manual: e?.manual }), n } setState(t, e) { this.#a({ type: "setState", state: t, setStateOptions: e }) } cancel(t) { const e = this.#i?.promise; return this.#i?.cancel(t), e ? e.then(Gs).catch(Gs) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(this.#t) } isActive() { return this.observers.some(t => Dl(t.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === F5 || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStatic() { return this.getObserversCount() > 0 ? this.observers.some(t => Wh(t.options.staleTime, this) === "static") : !1 } isStale() { return this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated } isStaleByTime(t = 0) { return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !Qee(this.state.dataUpdatedAt, t) } onFocus() { this.observers.find(e => e.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#i?.continue() } onOnline() { this.observers.find(e => e.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#i?.continue() } addObserver(t) { this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.#n.notify({ type: "observerAdded", query: this, observer: t })) } removeObserver(t) { this.observers.includes(t) && (this.observers = this.observers.filter(e => e !== t), this.observers.length || (this.#i && (this.#o ? this.#i.cancel({ revert: !0 }) : this.#i.cancelRetry()), this.scheduleGc()), this.#n.notify({ type: "observerRemoved", query: this, observer: t })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || this.#a({ type: "invalidate" }) } fetch(t, e) { if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && e?.cancelRefetch) this.cancel({ silent: !0 }); else if (this.#i) return this.#i.continueRetry(), this.#i.promise } if (t && this.setOptions(t), !this.options.queryFn) { const c = this.observers.find(u => u.options.queryFn); c && this.setOptions(c.options) } const n = new AbortController, r = c => { Object.defineProperty(c, "signal", { enumerable: !0, get: () => (this.#o = !0, n.signal) }) }, i = () => { const c = ete(this.options, e), d = (() => { const f = { client: this.#r, queryKey: this.queryKey, meta: this.meta }; return r(f), f })(); return this.#o = !1, this.options.persister ? this.options.persister(c, d, this) : c(d) }, s = (() => { const c = { fetchOptions: e, options: this.options, queryKey: this.queryKey, client: this.#r, state: this.state, fetchFn: i }; return r(c), c })(); this.options.behavior?.onFetch(s, this), this.#e = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== s.fetchOptions?.meta) && this.#a({ type: "fetch", meta: s.fetchOptions?.meta }); const o = c => { Rj(c) && c.silent || this.#a({ type: "error", error: c }), Rj(c) || (this.#n.config.onError?.(c, this), this.#n.config.onSettled?.(this.state.data, c, this)), this.scheduleGc() }; return this.#i = ite({ initialPromise: e?.initialPromise, fn: s.fetchFn, abort: n.abort.bind(n), onSuccess: c => { if (c === void 0) { o(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(c) } catch (u) { o(u); return } this.#n.config.onSuccess?.(c, this), this.#n.config.onSettled?.(c, this.state.error, this), this.scheduleGc() }, onError: o, onFail: (c, u) => { this.#a({ type: "failed", failureCount: c, error: u }) }, onPause: () => { this.#a({ type: "pause" }) }, onContinue: () => { this.#a({ type: "continue" }) }, retry: s.options.retry, retryDelay: s.options.retryDelay, networkMode: s.options.networkMode, canRun: () => !0 }), this.#i.start() } #a(t) { const e = n => { switch (t.type) { case "failed": return { ...n, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }; case "pause": return { ...n, fetchStatus: "paused" }; case "continue": return { ...n, fetchStatus: "fetching" }; case "fetch": return { ...n, ...ste(n.data, this.options), fetchMeta: t.meta ?? null }; case "success": return this.#e = void 0, { ...n, data: t.data, dataUpdateCount: n.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const r = t.error; return Rj(r) && r.revert && this.#e ? { ...this.#e, fetchStatus: "idle" } : { ...n, error: r, errorUpdateCount: n.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: n.fetchFailureCount + 1, fetchFailureReason: r, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...n, isInvalidated: !0 }; case "setState": return { ...n, ...t.state } } }; this.state = e(this.state), ja.batch(() => { this.observers.forEach(n => { n.onQueryUpdate() }), this.#n.notify({ query: this, type: "updated", action: t }) }) } }; function ste(t, e) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: nte(e.networkMode) ? "fetching" : "paused", ...t === void 0 && { error: null, status: "pending" } } } function awe(t) { const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, n = e !== void 0, r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0; return { data: e, dataUpdateCount: 0, dataUpdatedAt: n ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: n ? "success" : "pending", fetchStatus: "idle" } } var swe = class extends w0 { constructor(t = {}) { super(), this.config = t, this.#t = new Map } #t; build(t, e, n) { const r = e.queryKey, i = e.queryHash ?? L5(r, e); let a = this.get(i); return a || (a = new iwe({ client: t, queryKey: r, queryHash: i, options: t.defaultQueryOptions(e), state: n, defaultOptions: t.getQueryDefaults(r) }), this.add(a)), a } add(t) { this.#t.has(t.queryHash) || (this.#t.set(t.queryHash, t), this.notify({ type: "added", query: t })) } remove(t) { const e = this.#t.get(t.queryHash); e && (t.destroy(), e === t && this.#t.delete(t.queryHash), this.notify({ type: "removed", query: t })) } clear() { ja.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } get(t) { return this.#t.get(t) } getAll() { return [...this.#t.values()] } find(t) { const e = { exact: !0, ...t }; return this.getAll().find(n => H8(e, n)) } findAll(t = {}) { const e = this.getAll(); return Object.keys(t).length > 0 ? e.filter(n => H8(t, n)) : e } notify(t) { ja.batch(() => { this.listeners.forEach(e => { e(t) }) }) } onFocus() { ja.batch(() => { this.getAll().forEach(t => { t.onFocus() }) }) } onOnline() { ja.batch(() => { this.getAll().forEach(t => { t.onOnline() }) }) } }, owe = class extends ate { #t; #e; #n; constructor(t) { super(), this.mutationId = t.mutationId, this.#e = t.mutationCache, this.#t = [], this.state = t.state || ote(), this.setOptions(t.options), this.scheduleGc() } setOptions(t) { this.options = t, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(t) { this.#t.includes(t) || (this.#t.push(t), this.clearGcTimeout(), this.#e.notify({ type: "observerAdded", mutation: this, observer: t })) } removeObserver(t) { this.#t = this.#t.filter(e => e !== t), this.scheduleGc(), this.#e.notify({ type: "observerRemoved", mutation: this, observer: t }) } optionalRemove() { this.#t.length || (this.state.status === "pending" ? this.scheduleGc() : this.#e.remove(this)) } continue() { return this.#n?.continue() ?? this.execute(this.state.variables) } async execute(t) { const e = () => { this.#r({ type: "continue" }) }; this.#n = ite({ fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), onFail: (i, a) => { this.#r({ type: "failed", failureCount: i, error: a }) }, onPause: () => { this.#r({ type: "pause" }) }, onContinue: e, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => this.#e.canRun(this) }); const n = this.state.status === "pending", r = !this.#n.canStart(); try { if (n) e(); else { this.#r({ type: "pending", variables: t, isPaused: r }), await this.#e.config.onMutate?.(t, this); const a = await this.options.onMutate?.(t); a !== this.state.context && this.#r({ type: "pending", context: a, variables: t, isPaused: r }) } const i = await this.#n.start(); return await this.#e.config.onSuccess?.(i, t, this.state.context, this), await this.options.onSuccess?.(i, t, this.state.context), await this.#e.config.onSettled?.(i, null, this.state.variables, this.state.context, this), await this.options.onSettled?.(i, null, t, this.state.context), this.#r({ type: "success", data: i }), i } catch (i) { try { throw await this.#e.config.onError?.(i, t, this.state.context, this), await this.options.onError?.(i, t, this.state.context), await this.#e.config.onSettled?.(void 0, i, this.state.variables, this.state.context, this), await this.options.onSettled?.(void 0, i, t, this.state.context), i } finally { this.#r({ type: "error", error: i }) } } finally { this.#e.runNext(this) } } #r(t) { const e = n => { switch (t.type) { case "failed": return { ...n, failureCount: t.failureCount, failureReason: t.error }; case "pause": return { ...n, isPaused: !0 }; case "continue": return { ...n, isPaused: !1 }; case "pending": return { ...n, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now() }; case "success": return { ...n, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...n, data: void 0, error: t.error, failureCount: n.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error" } } }; this.state = e(this.state), ja.batch(() => { this.#t.forEach(n => { n.onMutationUpdate(t) }), this.#e.notify({ mutation: this, type: "updated", action: t }) }) } }; function ote() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var lwe = class extends w0 { constructor(t = {}) { super(), this.config = t, this.#t = new Set, this.#e = new Map, this.#n = 0 } #t; #e; #n; build(t, e, n) { const r = new owe({ mutationCache: this, mutationId: ++this.#n, options: t.defaultMutationOptions(e), state: n }); return this.add(r), r } add(t) { this.#t.add(t); const e = $E(t); if (typeof e == "string") { const n = this.#e.get(e); n ? n.push(t) : this.#e.set(e, [t]) } this.notify({ type: "added", mutation: t }) } remove(t) { if (this.#t.delete(t)) { const e = $E(t); if (typeof e == "string") { const n = this.#e.get(e); if (n) if (n.length > 1) { const r = n.indexOf(t); r !== -1 && n.splice(r, 1) } else n[0] === t && this.#e.delete(e) } } this.notify({ type: "removed", mutation: t }) } canRun(t) { const e = $E(t); if (typeof e == "string") { const r = this.#e.get(e)?.find(i => i.state.status === "pending"); return !r || r === t } else return !0 } runNext(t) { const e = $E(t); return typeof e == "string" ? this.#e.get(e)?.find(r => r !== t && r.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve() } clear() { ja.batch(() => { this.#t.forEach(t => { this.notify({ type: "removed", mutation: t }) }), this.#t.clear(), this.#e.clear() }) } getAll() { return Array.from(this.#t) } find(t) { const e = { exact: !0, ...t }; return this.getAll().find(n => W8(e, n)) } findAll(t = {}) { return this.getAll().filter(e => W8(t, e)) } notify(t) { ja.batch(() => { this.listeners.forEach(e => { e(t) }) }) } resumePausedMutations() { const t = this.getAll().filter(e => e.state.isPaused); return ja.batch(() => Promise.all(t.map(e => e.continue().catch(Gs)))) } }; function $E(t) { return t.options.scope?.id } function X8(t) { return { onFetch: (e, n) => { const r = e.options, i = e.fetchOptions?.meta?.fetchMore?.direction, a = e.state.data?.pages || [], s = e.state.data?.pageParams || []; let o = { pages: [], pageParams: [] }, c = 0; const u = async () => { let d = !1; const f = g => { Object.defineProperty(g, "signal", { enumerable: !0, get: () => (e.signal.aborted ? d = !0 : e.signal.addEventListener("abort", () => { d = !0 }), e.signal) }) }, h = ete(e.options, e.fetchOptions), m = async (g, x, v) => { if (d) return Promise.reject(); if (x == null && g.pages.length) return Promise.resolve(g); const E = (() => { const A = { client: e.client, queryKey: e.queryKey, pageParam: x, direction: v ? "backward" : "forward", meta: e.options.meta }; return f(A), A })(), M = await h(E), { maxPages: C } = e.options, N = v ? Qbe : Zbe; return { pages: N(g.pages, M, C), pageParams: N(g.pageParams, x, C) } }; if (i && a.length) { const g = i === "backward", x = g ? cwe : Y8, v = { pages: a, pageParams: s }, b = x(r, v); o = await m(v, b, g) } else { const g = t ?? a.length; do { const x = c === 0 ? s[0] ?? r.initialPageParam : Y8(r, o); if (c > 0 && x == null) break; o = await m(o, x), c++ } while (c < g) } return o }; e.options.persister ? e.fetchFn = () => e.options.persister?.(u, { client: e.client, queryKey: e.queryKey, meta: e.options.meta, signal: e.signal }, n) : e.fetchFn = u } } } function Y8(t, { pages: e, pageParams: n }) { const r = e.length - 1; return e.length > 0 ? t.getNextPageParam(e[r], e, n[r], n) : void 0 } function cwe(t, { pages: e, pageParams: n }) { return e.length > 0 ? t.getPreviousPageParam?.(e[0], e, n[0], n) : void 0 } var uwe = class { #t; #e; #n; #r; #i; #s; #o; #a; constructor(t = {}) { this.#t = t.queryCache || new swe, this.#e = t.mutationCache || new lwe, this.#n = t.defaultOptions || {}, this.#r = new Map, this.#i = new Map, this.#s = 0 } mount() { this.#s++, this.#s === 1 && (this.#o = U5.subscribe(async t => { t && (await this.resumePausedMutations(), this.#t.onFocus()) }), this.#a = YT.subscribe(async t => { t && (await this.resumePausedMutations(), this.#t.onOnline()) })) } unmount() { this.#s--, this.#s === 0 && (this.#o?.(), this.#o = void 0, this.#a?.(), this.#a = void 0) } isFetching(t) { return this.#t.findAll({ ...t, fetchStatus: "fetching" }).length } isMutating(t) { return this.#e.findAll({ ...t, status: "pending" }).length } getQueryData(t) { const e = this.defaultQueryOptions({ queryKey: t }); return this.#t.get(e.queryHash)?.state.data } ensureQueryData(t) { const e = this.defaultQueryOptions(t), n = this.#t.build(this, e), r = n.state.data; return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && n.isStaleByTime(Wh(e.staleTime, n)) && this.prefetchQuery(e), Promise.resolve(r)) } getQueriesData(t) { return this.#t.findAll(t).map(({ queryKey: e, state: n }) => { const r = n.data; return [e, r] }) } setQueryData(t, e, n) { const r = this.defaultQueryOptions({ queryKey: t }), a = this.#t.get(r.queryHash)?.state.data, s = Ybe(e, a); if (s !== void 0) return this.#t.build(this, r).setData(s, { ...n, manual: !0 }) } setQueriesData(t, e, n) { return ja.batch(() => this.#t.findAll(t).map(({ queryKey: r }) => [r, this.setQueryData(r, e, n)])) } getQueryState(t) { const e = this.defaultQueryOptions({ queryKey: t }); return this.#t.get(e.queryHash)?.state } removeQueries(t) { const e = this.#t; ja.batch(() => { e.findAll(t).forEach(n => { e.remove(n) }) }) } resetQueries(t, e) { const n = this.#t; return ja.batch(() => (n.findAll(t).forEach(r => { r.reset() }), this.refetchQueries({ type: "active", ...t }, e))) } cancelQueries(t, e = {}) { const n = { revert: !0, ...e }, r = ja.batch(() => this.#t.findAll(t).map(i => i.cancel(n))); return Promise.all(r).then(Gs).catch(Gs) } invalidateQueries(t, e = {}) { return ja.batch(() => (this.#t.findAll(t).forEach(n => { n.invalidate() }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries({ ...t, type: t?.refetchType ?? t?.type ?? "active" }, e))) } refetchQueries(t, e = {}) { const n = { ...e, cancelRefetch: e.cancelRefetch ?? !0 }, r = ja.batch(() => this.#t.findAll(t).filter(i => !i.isDisabled() && !i.isStatic()).map(i => { let a = i.fetch(void 0, n); return n.throwOnError || (a = a.catch(Gs)), i.state.fetchStatus === "paused" ? Promise.resolve() : a })); return Promise.all(r).then(Gs) } fetchQuery(t) { const e = this.defaultQueryOptions(t); e.retry === void 0 && (e.retry = !1); const n = this.#t.build(this, e); return n.isStaleByTime(Wh(e.staleTime, n)) ? n.fetch(e) : Promise.resolve(n.state.data) } prefetchQuery(t) { return this.fetchQuery(t).then(Gs).catch(Gs) } fetchInfiniteQuery(t) { return t.behavior = X8(t.pages), this.fetchQuery(t) } prefetchInfiniteQuery(t) { return this.fetchInfiniteQuery(t).then(Gs).catch(Gs) } ensureInfiniteQueryData(t) { return t.behavior = X8(t.pages), this.ensureQueryData(t) } resumePausedMutations() { return YT.isOnline() ? this.#e.resumePausedMutations() : Promise.resolve() } getQueryCache() { return this.#t } getMutationCache() { return this.#e } getDefaultOptions() { return this.#n } setDefaultOptions(t) { this.#n = t } setQueryDefaults(t, e) { this.#r.set(Sg(t), { queryKey: t, defaultOptions: e }) } getQueryDefaults(t) { const e = [...this.#r.values()], n = {}; return e.forEach(r => { x1(t, r.queryKey) && Object.assign(n, r.defaultOptions) }), n } setMutationDefaults(t, e) { this.#i.set(Sg(t), { mutationKey: t, defaultOptions: e }) } getMutationDefaults(t) { const e = [...this.#i.values()], n = {}; return e.forEach(r => { x1(t, r.mutationKey) && Object.assign(n, r.defaultOptions) }), n } defaultQueryOptions(t) { if (t._defaulted) return t; const e = { ...this.#n.queries, ...this.getQueryDefaults(t.queryKey), ...t, _defaulted: !0 }; return e.queryHash || (e.queryHash = L5(e.queryKey, e)), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === F5 && (e.enabled = !1), e } defaultMutationOptions(t) { return t?._defaulted ? t : { ...this.#n.mutations, ...t?.mutationKey && this.getMutationDefaults(t.mutationKey), ...t, _defaulted: !0 } } clear() { this.#t.clear(), this.#e.clear() } }, dwe = class extends w0 { constructor(t, e) { super(), this.options = e, this.#t = t, this.#a = null, this.#o = lL(), this.options.experimental_prefetchInRender || this.#o.reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(e) } #t; #e = void 0; #n = void 0; #r = void 0; #i; #s; #o; #a; #m; #f; #h; #c; #u; #l; #p = new Set; bindMethods() { this.refetch = this.refetch.bind(this) } onSubscribe() { this.listeners.size === 1 && (this.#e.addObserver(this), K8(this.#e, this.options) ? this.#d() : this.updateResult(), this.#x()) } onUnsubscribe() { this.hasListeners() || this.destroy() } shouldFetchOnReconnect() { return cL(this.#e, this.options, this.options.refetchOnReconnect) } shouldFetchOnWindowFocus() { return cL(this.#e, this.options, this.options.refetchOnWindowFocus) } destroy() { this.listeners = new Set, this.#b(), this.#w(), this.#e.removeObserver(this) } setOptions(t) { const e = this.options, n = this.#e; if (this.options = this.#t.defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Dl(this.options.enabled, this.#e) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean"); this.#S(), this.#e.setOptions(this.options), e._defaulted && !XT(this.options, e) && this.#t.getQueryCache().notify({ type: "observerOptionsUpdated", query: this.#e, observer: this }); const r = this.hasListeners(); r && Z8(this.#e, n, this.options, e) && this.#d(), this.updateResult(), r && (this.#e !== n || Dl(this.options.enabled, this.#e) !== Dl(e.enabled, this.#e) || Wh(this.options.staleTime, this.#e) !== Wh(e.staleTime, this.#e)) && this.#g(); const i = this.#v(); r && (this.#e !== n || Dl(this.options.enabled, this.#e) !== Dl(e.enabled, this.#e) || i !== this.#l) && this.#y(i) } getOptimisticResult(t) { const e = this.#t.getQueryCache().build(this.#t, t), n = this.createResult(e, t); return hwe(this, n) && (this.#r = n, this.#s = this.options, this.#i = this.#e.state), n } getCurrentResult() { return this.#r } trackResult(t, e) { return new Proxy(t, { get: (n, r) => (this.trackProp(r), e?.(r), Reflect.get(n, r)) }) } trackProp(t) { this.#p.add(t) } getCurrentQuery() { return this.#e } refetch({ ...t } = {}) { return this.fetch({ ...t }) } fetchOptimistic(t) { const e = this.#t.defaultQueryOptions(t), n = this.#t.getQueryCache().build(this.#t, e); return n.fetch().then(() => this.createResult(n, e)) } fetch(t) { return this.#d({ ...t, cancelRefetch: t.cancelRefetch ?? !0 }).then(() => (this.updateResult(), this.#r)) } #d(t) { this.#S(); let e = this.#e.fetch(this.options, t); return t?.throwOnError || (e = e.catch(Gs)), e } #g() { this.#b(); const t = Wh(this.options.staleTime, this.#e); if (wg || this.#r.isStale || !aL(t)) return; const n = Qee(this.#r.dataUpdatedAt, t) + 1; this.#c = setTimeout(() => { this.#r.isStale || this.updateResult() }, n) } #v() { return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#e) : this.options.refetchInterval) ?? !1 } #y(t) { this.#w(), this.#l = t, !(wg || Dl(this.options.enabled, this.#e) === !1 || !aL(this.#l) || this.#l === 0) && (this.#u = setInterval(() => { (this.options.refetchIntervalInBackground || U5.isFocused()) && this.#d() }, this.#l)) } #x() { this.#g(), this.#y(this.#v()) } #b() { this.#c && (clearTimeout(this.#c), this.#c = void 0) } #w() { this.#u && (clearInterval(this.#u), this.#u = void 0) } createResult(t, e) { const n = this.#e, r = this.options, i = this.#r, a = this.#i, s = this.#s, c = t !== n ? t.state : this.#n, { state: u } = t; let d = { ...u }, f = !1, h; if (e._optimisticResults) { const O = this.hasListeners(), I = !O && K8(t, e), D = O && Z8(t, n, e, r); (I || D) && (d = { ...d, ...ste(u.data, t.options) }), e._optimisticResults === "isRestoring" && (d.fetchStatus = "idle") } let { error: m, errorUpdatedAt: g, status: x } = d; h = d.data; let v = !1; if (e.placeholderData !== void 0 && h === void 0 && x === "pending") { let O; i?.isPlaceholderData && e.placeholderData === s?.placeholderData ? (O = i.data, v = !0) : O = typeof e.placeholderData == "function" ? e.placeholderData(this.#h?.state.data, this.#h) : e.placeholderData, O !== void 0 && (x = "success", h = oL(i?.data, O, e), f = !0) } if (e.select && h !== void 0 && !v) if (i && h === a?.data && e.select === this.#m) h = this.#f; else try { this.#m = e.select, h = e.select(h), h = oL(i?.data, h, e), this.#f = h, this.#a = null } catch (O) { this.#a = O } this.#a && (m = this.#a, h = this.#f, g = Date.now(), x = "error"); const b = d.fetchStatus === "fetching", E = x === "pending", M = x === "error", C = E && b, N = h !== void 0, j = { status: x, fetchStatus: d.fetchStatus, isPending: E, isSuccess: x === "success", isError: M, isInitialLoading: C, isLoading: C, data: h, dataUpdatedAt: d.dataUpdatedAt, error: m, errorUpdatedAt: g, failureCount: d.fetchFailureCount, failureReason: d.fetchFailureReason, errorUpdateCount: d.errorUpdateCount, isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0, isFetchedAfterMount: d.dataUpdateCount > c.dataUpdateCount || d.errorUpdateCount > c.errorUpdateCount, isFetching: b, isRefetching: b && !E, isLoadingError: M && !N, isPaused: d.fetchStatus === "paused", isPlaceholderData: f, isRefetchError: M && N, isStale: B5(t, e), refetch: this.refetch, promise: this.#o, isEnabled: Dl(e.enabled, t) !== !1 }; if (this.options.experimental_prefetchInRender) { const O = F => { j.status === "error" ? F.reject(j.error) : j.data !== void 0 && F.resolve(j.data) }, I = () => { const F = this.#o = j.promise = lL(); O(F) }, D = this.#o; switch (D.status) { case "pending": t.queryHash === n.queryHash && O(D); break; case "fulfilled": (j.status === "error" || j.data !== D.value) && I(); break; case "rejected": (j.status !== "error" || j.error !== D.reason) && I(); break } } return j } updateResult() { const t = this.#r, e = this.createResult(this.#e, this.options); if (this.#i = this.#e.state, this.#s = this.options, this.#i.data !== void 0 && (this.#h = this.#e), XT(e, t)) return; this.#r = e; const n = () => { if (!t) return !0; const { notifyOnChangeProps: r } = this.options, i = typeof r == "function" ? r() : r; if (i === "all" || !i && !this.#p.size) return !0; const a = new Set(i ?? this.#p); return this.options.throwOnError && a.add("error"), Object.keys(this.#r).some(s => { const o = s; return this.#r[o] !== t[o] && a.has(o) }) }; this.#_({ listeners: n() }) } #S() { const t = this.#t.getQueryCache().build(this.#t, this.options); if (t === this.#e) return; const e = this.#e; this.#e = t, this.#n = t.state, this.hasListeners() && (e?.removeObserver(this), t.addObserver(this)) } onQueryUpdate() { this.updateResult(), this.hasListeners() && this.#x() } #_(t) { ja.batch(() => { t.listeners && this.listeners.forEach(e => { e(this.#r) }), this.#t.getQueryCache().notify({ query: this.#e, type: "observerResultsUpdated" }) }) } }; function fwe(t, e) { return Dl(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1) } function K8(t, e) { return fwe(t, e) || t.state.data !== void 0 && cL(t, e, e.refetchOnMount) } function cL(t, e, n) { if (Dl(e.enabled, t) !== !1 && Wh(e.staleTime, t) !== "static") { const r = typeof n == "function" ? n(t) : n; return r === "always" || r !== !1 && B5(t, e) } return !1 } function Z8(t, e, n, r) { return (t !== e || Dl(r.enabled, t) === !1) && (!n.suspense || t.state.status !== "error") && B5(t, n) } function B5(t, e) { return Dl(e.enabled, t) !== !1 && t.isStaleByTime(Wh(e.staleTime, t)) } function hwe(t, e) { return !XT(t.getCurrentResult(), e) } var pwe = class extends w0 { #t; #e = void 0; #n; #r; constructor(e, n) { super(), this.#t = e, this.setOptions(n), this.bindMethods(), this.#i() } bindMethods() { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this) } setOptions(e) { const n = this.options; this.options = this.#t.defaultMutationOptions(e), XT(this.options, n) || this.#t.getMutationCache().notify({ type: "observerOptionsUpdated", mutation: this.#n, observer: this }), n?.mutationKey && this.options.mutationKey && Sg(n.mutationKey) !== Sg(this.options.mutationKey) ? this.reset() : this.#n?.state.status === "pending" && this.#n.setOptions(this.options) } onUnsubscribe() { this.hasListeners() || this.#n?.removeObserver(this) } onMutationUpdate(e) { this.#i(), this.#s(e) } getCurrentResult() { return this.#e } reset() { this.#n?.removeObserver(this), this.#n = void 0, this.#i(), this.#s() } mutate(e, n) { return this.#r = n, this.#n?.removeObserver(this), this.#n = this.#t.getMutationCache().build(this.#t, this.options), this.#n.addObserver(this), this.#n.execute(e) } #i() { const e = this.#n?.state ?? ote(); this.#e = { ...e, isPending: e.status === "pending", isSuccess: e.status === "success", isError: e.status === "error", isIdle: e.status === "idle", mutate: this.mutate, reset: this.reset } } #s(e) { ja.batch(() => { if (this.#r && this.hasListeners()) { const n = this.#e.variables, r = this.#e.context; e?.type === "success" ? (this.#r.onSuccess?.(e.data, n, r), this.#r.onSettled?.(e.data, null, n, r)) : e?.type === "error" && (this.#r.onError?.(e.error, n, r), this.#r.onSettled?.(void 0, e.error, n, r)) } this.listeners.forEach(n => { n(this.#e) }) }) } }, lte = S.createContext(void 0), Xc = t => { const e = S.useContext(lte); if (!e) throw new Error("No QueryClient set, use QueryClientProvider to set one"); return e }, mwe = ({ client: t, children: e }) => (S.useEffect(() => (t.mount(), () => { t.unmount() }), [t]), l.jsx(lte.Provider, { value: t, children: e })), cte = S.createContext(!1), gwe = () => S.useContext(cte); cte.Provider; function vwe() { let t = !1; return { clearReset: () => { t = !1 }, reset: () => { t = !0 }, isReset: () => t } } var ywe = S.createContext(vwe()), xwe = () => S.useContext(ywe), bwe = (t, e) => { (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1)) }, wwe = t => { S.useEffect(() => { t.clearReset() }, [t]) }, Swe = ({ result: t, errorResetBoundary: e, throwOnError: n, query: r, suspense: i }) => t.isError && !e.isReset() && !t.isFetching && r && (i && t.data === void 0 || tte(n, [t.error, r])), _we = t => { if (t.suspense) { const e = r => r === "static" ? r : Math.max(r ?? 1e3, 1e3), n = t.staleTime; t.staleTime = typeof n == "function" ? (...r) => e(n(...r)) : e(n), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)) } }, Ewe = (t, e) => t.isLoading && t.isFetching && !e, Mwe = (t, e) => t?.suspense && e.isPending, Q8 = (t, e, n) => e.fetchOptimistic(t).catch(() => { n.clearReset() }); function Twe(t, e, n) { const r = gwe(), i = xwe(), a = Xc(), s = a.defaultQueryOptions(t); a.getDefaultOptions().queries?._experimental_beforeQuery?.(s), s._optimisticResults = r ? "isRestoring" : "optimistic", _we(s), bwe(s, i), wwe(i); const o = !a.getQueryCache().get(s.queryHash), [c] = S.useState(() => new e(a, s)), u = c.getOptimisticResult(s), d = !r && t.subscribed !== !1; if (S.useSyncExternalStore(S.useCallback(f => { const h = d ? c.subscribe(ja.batchCalls(f)) : Gs; return c.updateResult(), h }, [c, d]), () => c.getCurrentResult(), () => c.getCurrentResult()), S.useEffect(() => { c.setOptions(s) }, [s, c]), Mwe(s, u)) throw Q8(s, c, i); if (Swe({ result: u, errorResetBoundary: i, throwOnError: s.throwOnError, query: a.getQueryCache().get(s.queryHash), suspense: s.suspense })) throw u.error; return a.getDefaultOptions().queries?._experimental_afterQuery?.(s, u), s.experimental_prefetchInRender && !wg && Ewe(u, r) && (o ? Q8(s, c, i) : a.getQueryCache().get(s.queryHash)?.promise)?.catch(Gs).finally(() => { c.updateResult() }), s.notifyOnChangeProps ? u : c.trackResult(u) } function oo(t, e) { return Twe(t, dwe) } function Cs(t, e) { const n = Xc(), [r] = S.useState(() => new pwe(n, t)); S.useEffect(() => { r.setOptions(t) }, [r, t]); const i = S.useSyncExternalStore(S.useCallback(s => r.subscribe(ja.batchCalls(s)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult()), a = S.useCallback((s, o) => { r.mutate(s, o).catch(Gs) }, [r]); if (i.error && tte(r.options.throwOnError, [i.error])) throw i.error; return { ...i, mutate: a, mutateAsync: i.mutate } } const b1 = $g("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10" } }, defaultVariants: { variant: "default", size: "default" } }), vt = S.forwardRef(({ className: t, variant: e, size: n, asChild: r = !1, ...i }, a) => { const s = r ? jJ : "button"; return l.jsx(s, { className: _t(b1({ variant: e, size: n, className: t })), ref: a, ...i }) }); vt.displayName = "Button"; function uL() { const [t, e] = S.useState("light"); S.useEffect(() => { const i = window.document.documentElement.classList.contains("dark") ? "dark" : "light"; e(i) }, []); const n = () => { const r = window.document.documentElement, i = t === "light" ? "dark" : "light"; r.classList.remove(t), r.classList.add(i), e(i) }; return l.jsx(vt, { variant: "ghost", size: "icon", onClick: n, className: "hover:bg-muted transition-colors duration-0 hover:text-primary", children: t === "light" ? l.jsx(Zve, { className: "h-5 w-5" }) : l.jsx(tye, { className: "h-5 w-5" }) }) } const $5 = S.createContext({}); function z5(t) { const e = S.useRef(null); return e.current === null && (e.current = t()), e.current } const V5 = typeof window < "u", ute = V5 ? S.useLayoutEffect : S.useEffect, TA = S.createContext(null); function H5(t, e) { t.indexOf(e) === -1 && t.push(e) } function W5(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } const gf = (t, e, n) => n > e ? e : n < t ? t : n; let G5 = () => { }; const vf = {}, dte = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t); function fte(t) { return typeof t == "object" && t !== null } const hte = t => /^0[^.\s]+$/u.test(t); function q5(t) { let e; return () => (e === void 0 && (e = t()), e) } const zl = t => t, Cwe = (t, e) => n => e(t(n)), GS = (...t) => t.reduce(Cwe), w1 = (t, e, n) => { const r = e - t; return r === 0 ? 1 : (n - t) / r }; class X5 { constructor() { this.subscriptions = [] } add(e) { return H5(this.subscriptions, e), () => W5(this.subscriptions, e) } notify(e, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](e, n, r); else for (let a = 0; a < i; a++) { const s = this.subscriptions[a]; s && s(e, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Nu = t => t * 1e3, Ul = t => t / 1e3; function pte(t, e) { return e ? t * (1e3 / e) : 0 } const mte = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, Nwe = 1e-7, Awe = 12; function Pwe(t, e, n, r, i) { let a, s, o = 0; do s = e + (n - e) / 2, a = mte(s, r, i) - t, a > 0 ? n = s : e = s; while (Math.abs(a) > Nwe && ++o < Awe); return s } function qS(t, e, n, r) { if (t === e && n === r) return zl; const i = a => Pwe(a, 0, 1, t, n); return a => a === 0 || a === 1 ? a : mte(i(a), e, r) } const gte = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, vte = t => e => 1 - t(1 - e), yte = qS(.33, 1.53, .69, .99), Y5 = vte(yte), xte = gte(Y5), bte = t => (t *= 2) < 1 ? .5 * Y5(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), K5 = t => 1 - Math.sin(Math.acos(t)), wte = vte(K5), Ste = gte(K5), jwe = qS(.42, 0, 1, 1), Rwe = qS(0, 0, .58, 1), _te = qS(.42, 0, .58, 1), kwe = t => Array.isArray(t) && typeof t[0] != "number", Ete = t => Array.isArray(t) && typeof t[0] == "number", Iwe = { linear: zl, easeIn: jwe, easeInOut: _te, easeOut: Rwe, circIn: K5, circInOut: Ste, circOut: wte, backIn: Y5, backInOut: xte, backOut: yte, anticipate: bte }, Owe = t => typeof t == "string", J8 = t => { if (Ete(t)) { G5(t.length === 4); const [e, n, r, i] = t; return qS(e, n, r, i) } else if (Owe(t)) return Iwe[t]; return t }, zE = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function Dwe(t, e) { let n = new Set, r = new Set, i = !1, a = !1; const s = new WeakSet; let o = { delta: 0, timestamp: 0, isProcessing: !1 }; function c(d) { s.has(d) && (u.schedule(d), t()), d(o) } const u = { schedule: (d, f = !1, h = !1) => { const g = h && i ? n : r; return f && s.add(d), g.has(d) || g.add(d), d }, cancel: d => { r.delete(d), s.delete(d) }, process: d => { if (o = d, i) { a = !0; return } i = !0, [n, r] = [r, n], n.forEach(c), n.clear(), i = !1, a && (a = !1, u.process(d)) } }; return u } const Lwe = 40; function Mte(t, e) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, a = () => n = !0, s = zE.reduce((M, C) => (M[C] = Dwe(a), M), {}), { setup: o, read: c, resolveKeyframes: u, preUpdate: d, update: f, preRender: h, render: m, postRender: g } = s, x = () => { const M = vf.useManualTiming ? i.timestamp : performance.now(); n = !1, vf.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(M - i.timestamp, Lwe), 1)), i.timestamp = M, i.isProcessing = !0, o.process(i), c.process(i), u.process(i), d.process(i), f.process(i), h.process(i), m.process(i), g.process(i), i.isProcessing = !1, n && e && (r = !1, t(x)) }, v = () => { n = !0, r = !0, i.isProcessing || t(x) }; return { schedule: zE.reduce((M, C) => { const N = s[C]; return M[C] = (A, j = !1, O = !1) => (n || v(), N.schedule(A, j, O)), M }, {}), cancel: M => { for (let C = 0; C < zE.length; C++)s[zE[C]].cancel(M) }, state: i, steps: s } } const { schedule: Ri, cancel: ep, state: ls, steps: kj } = Mte(typeof requestAnimationFrame < "u" ? requestAnimationFrame : zl, !0); let ET; function Fwe() { ET = void 0 } const Do = { now: () => (ET === void 0 && Do.set(ls.isProcessing || vf.useManualTiming ? ls.timestamp : performance.now()), ET), set: t => { ET = t, queueMicrotask(Fwe) } }, Tte = t => e => typeof e == "string" && e.startsWith(t), Z5 = Tte("--"), Uwe = Tte("var(--"), Q5 = t => Uwe(t) ? Bwe.test(t.split("/*")[0].trim()) : !1, Bwe = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, S0 = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, S1 = { ...S0, transform: t => gf(0, 1, t) }, VE = { ...S0, default: 1 }, Bw = t => Math.round(t * 1e5) / 1e5, J5 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function $we(t) { return t == null } const zwe = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, eU = (t, e) => n => !!(typeof n == "string" && zwe.test(n) && n.startsWith(t) || e && !$we(n) && Object.prototype.hasOwnProperty.call(n, e)), Cte = (t, e, n) => r => { if (typeof r != "string") return r; const [i, a, s, o] = r.match(J5); return { [t]: parseFloat(i), [e]: parseFloat(a), [n]: parseFloat(s), alpha: o !== void 0 ? parseFloat(o) : 1 } }, Vwe = t => gf(0, 255, t), Ij = { ...S0, transform: t => Math.round(Vwe(t)) }, qm = { test: eU("rgb", "red"), parse: Cte("red", "green", "blue"), transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + Ij.transform(t) + ", " + Ij.transform(e) + ", " + Ij.transform(n) + ", " + Bw(S1.transform(r)) + ")" }; function Hwe(t) { let e = "", n = "", r = "", i = ""; return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, r += r, i += i), { red: parseInt(e, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const dL = { test: eU("#"), parse: Hwe, transform: qm.transform }, XS = t => ({ test: e => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${t}` }), Mh = XS("deg"), Au = XS("%"), Dn = XS("px"), Wwe = XS("vh"), Gwe = XS("vw"), eV = { ...Au, parse: t => Au.parse(t) / 100, transform: t => Au.transform(t * 100) }, ky = { test: eU("hsl", "hue"), parse: Cte("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + Au.transform(Bw(e)) + ", " + Au.transform(Bw(n)) + ", " + Bw(S1.transform(r)) + ")" }, ga = { test: t => qm.test(t) || dL.test(t) || ky.test(t), parse: t => qm.test(t) ? qm.parse(t) : ky.test(t) ? ky.parse(t) : dL.parse(t), transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? qm.transform(t) : ky.transform(t), getAnimatableNone: t => { const e = ga.parse(t); return e.alpha = 0, ga.transform(e) } }, qwe = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function Xwe(t) { return isNaN(t) && typeof t == "string" && (t.match(J5)?.length || 0) + (t.match(qwe)?.length || 0) > 0 } const Nte = "number", Ate = "color", Ywe = "var", Kwe = "var(", tV = "${}", Zwe = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function _1(t) { const e = t.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let a = 0; const o = e.replace(Zwe, c => (ga.test(c) ? (r.color.push(a), i.push(Ate), n.push(ga.parse(c))) : c.startsWith(Kwe) ? (r.var.push(a), i.push(Ywe), n.push(c)) : (r.number.push(a), i.push(Nte), n.push(parseFloat(c))), ++a, tV)).split(tV); return { values: n, split: o, indexes: r, types: i } } function Pte(t) { return _1(t).values } function jte(t) { const { split: e, types: n } = _1(t), r = e.length; return i => { let a = ""; for (let s = 0; s < r; s++)if (a += e[s], i[s] !== void 0) { const o = n[s]; o === Nte ? a += Bw(i[s]) : o === Ate ? a += ga.transform(i[s]) : a += i[s] } return a } } const Qwe = t => typeof t == "number" ? 0 : ga.test(t) ? ga.getAnimatableNone(t) : t; function Jwe(t) { const e = Pte(t); return jte(t)(e.map(Qwe)) } const tp = { test: Xwe, parse: Pte, createTransformer: jte, getAnimatableNone: Jwe }; function Oj(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function e1e({ hue: t, saturation: e, lightness: n, alpha: r }) { t /= 360, e /= 100, n /= 100; let i = 0, a = 0, s = 0; if (!e) i = a = s = n; else { const o = n < .5 ? n * (1 + e) : n + e - n * e, c = 2 * n - o; i = Oj(c, o, t + 1 / 3), a = Oj(c, o, t), s = Oj(c, o, t - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(a * 255), blue: Math.round(s * 255), alpha: r } } function KT(t, e) { return n => n > 0 ? e : t } const Li = (t, e, n) => t + (e - t) * n, Dj = (t, e, n) => { const r = t * t, i = n * (e * e - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, t1e = [dL, qm, ky], n1e = t => t1e.find(e => e.test(t)); function nV(t) { const e = n1e(t); if (!e) return !1; let n = e.parse(t); return e === ky && (n = e1e(n)), n } const rV = (t, e) => { const n = nV(t), r = nV(e); if (!n || !r) return KT(t, e); const i = { ...n }; return a => (i.red = Dj(n.red, r.red, a), i.green = Dj(n.green, r.green, a), i.blue = Dj(n.blue, r.blue, a), i.alpha = Li(n.alpha, r.alpha, a), qm.transform(i)) }, fL = new Set(["none", "hidden"]); function r1e(t, e) { return fL.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t } function i1e(t, e) { return n => Li(t, e, n) } function tU(t) { return typeof t == "number" ? i1e : typeof t == "string" ? Q5(t) ? KT : ga.test(t) ? rV : o1e : Array.isArray(t) ? Rte : typeof t == "object" ? ga.test(t) ? rV : a1e : KT } function Rte(t, e) { const n = [...t], r = n.length, i = t.map((a, s) => tU(a)(a, e[s])); return a => { for (let s = 0; s < r; s++)n[s] = i[s](a); return n } } function a1e(t, e) { const n = { ...t, ...e }, r = {}; for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = tU(t[i])(t[i], e[i])); return i => { for (const a in r) n[a] = r[a](i); return n } } function s1e(t, e) { const n = [], r = { color: 0, var: 0, number: 0 }; for (let i = 0; i < e.values.length; i++) { const a = e.types[i], s = t.indexes[a][r[a]], o = t.values[s] ?? 0; n[i] = o, r[a]++ } return n } const o1e = (t, e) => { const n = tp.createTransformer(e), r = _1(t), i = _1(e); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? fL.has(t) && !i.values.length || fL.has(e) && !r.values.length ? r1e(t, e) : GS(Rte(s1e(r, i), i.values), n) : KT(t, e) }; function kte(t, e, n) { return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Li(t, e, n) : tU(t)(t, e) } const l1e = t => { const e = ({ timestamp: n }) => t(n); return { start: (n = !0) => Ri.update(e, n), stop: () => ep(e), now: () => ls.isProcessing ? ls.timestamp : Do.now() } }, Ite = (t, e, n = 10) => { let r = ""; const i = Math.max(Math.round(e / n), 2); for (let a = 0; a < i; a++)r += Math.round(t(a / (i - 1)) * 1e4) / 1e4 + ", "; return `linear(${r.substring(0, r.length - 2)})` }, ZT = 2e4; function nU(t) { let e = 0; const n = 50; let r = t.next(e); for (; !r.done && e < ZT;)e += n, r = t.next(e); return e >= ZT ? 1 / 0 : e } function c1e(t, e = 100, n) { const r = n({ ...t, keyframes: [0, e] }), i = Math.min(nU(r), ZT); return { type: "keyframes", ease: a => r.next(i * a).value / e, duration: Ul(i) } } const u1e = 5; function Ote(t, e, n) { const r = Math.max(e - u1e, 0); return pte(n - t(r), e - r) } const qi = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Lj = .001; function d1e({ duration: t = qi.duration, bounce: e = qi.bounce, velocity: n = qi.velocity, mass: r = qi.mass }) { let i, a, s = 1 - e; s = gf(qi.minDamping, qi.maxDamping, s), t = gf(qi.minDuration, qi.maxDuration, Ul(t)), s < 1 ? (i = u => { const d = u * s, f = d * t, h = d - n, m = hL(u, s), g = Math.exp(-f); return Lj - h / m * g }, a = u => { const f = u * s * t, h = f * n + n, m = Math.pow(s, 2) * Math.pow(u, 2) * t, g = Math.exp(-f), x = hL(Math.pow(u, 2), s); return (-i(u) + Lj > 0 ? -1 : 1) * ((h - m) * g) / x }) : (i = u => { const d = Math.exp(-u * t), f = (u - n) * t + 1; return -Lj + d * f }, a = u => { const d = Math.exp(-u * t), f = (n - u) * (t * t); return d * f }); const o = 5 / t, c = h1e(i, a, o); if (t = Nu(t), isNaN(c)) return { stiffness: qi.stiffness, damping: qi.damping, duration: t }; { const u = Math.pow(c, 2) * r; return { stiffness: u, damping: s * 2 * Math.sqrt(r * u), duration: t } } } const f1e = 12; function h1e(t, e, n) { let r = n; for (let i = 1; i < f1e; i++)r = r - t(r) / e(r); return r } function hL(t, e) { return t * Math.sqrt(1 - e * e) } const p1e = ["duration", "bounce"], m1e = ["stiffness", "damping", "mass"]; function iV(t, e) { return e.some(n => t[n] !== void 0) } function g1e(t) { let e = { velocity: qi.velocity, stiffness: qi.stiffness, damping: qi.damping, mass: qi.mass, isResolvedFromDuration: !1, ...t }; if (!iV(t, m1e) && iV(t, p1e)) if (t.visualDuration) { const n = t.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, a = 2 * gf(.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(i); e = { ...e, mass: qi.mass, stiffness: i, damping: a } } else { const n = d1e(t); e = { ...e, ...n, mass: qi.mass }, e.isResolvedFromDuration = !0 } return e } function QT(t = qi.visualDuration, e = qi.bounce) { const n = typeof t != "object" ? { visualDuration: t, keyframes: [0, 1], bounce: e } : t; let { restSpeed: r, restDelta: i } = n; const a = n.keyframes[0], s = n.keyframes[n.keyframes.length - 1], o = { done: !1, value: a }, { stiffness: c, damping: u, mass: d, duration: f, velocity: h, isResolvedFromDuration: m } = g1e({ ...n, velocity: -Ul(n.velocity || 0) }), g = h || 0, x = u / (2 * Math.sqrt(c * d)), v = s - a, b = Ul(Math.sqrt(c / d)), E = Math.abs(v) < 5; r || (r = E ? qi.restSpeed.granular : qi.restSpeed.default), i || (i = E ? qi.restDelta.granular : qi.restDelta.default); let M; if (x < 1) { const N = hL(b, x); M = A => { const j = Math.exp(-x * b * A); return s - j * ((g + x * b * v) / N * Math.sin(N * A) + v * Math.cos(N * A)) } } else if (x === 1) M = N => s - Math.exp(-b * N) * (v + (g + b * v) * N); else { const N = b * Math.sqrt(x * x - 1); M = A => { const j = Math.exp(-x * b * A), O = Math.min(N * A, 300); return s - j * ((g + x * b * v) * Math.sinh(O) + N * v * Math.cosh(O)) / N } } const C = { calculatedDuration: m && f || null, next: N => { const A = M(N); if (m) o.done = N >= f; else { let j = N === 0 ? g : 0; x < 1 && (j = N === 0 ? Nu(g) : Ote(M, N, A)); const O = Math.abs(j) <= r, I = Math.abs(s - A) <= i; o.done = O && I } return o.value = o.done ? s : A, o }, toString: () => { const N = Math.min(nU(C), ZT), A = Ite(j => C.next(N * j).value, N, 30); return N + "ms " + A }, toTransition: () => { } }; return C } QT.applyToOptions = t => { const e = c1e(t, 100, QT); return t.ease = e.ease, t.duration = Nu(e.duration), t.type = "keyframes", t }; function pL({ keyframes: t, velocity: e = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: a = 500, modifyTarget: s, min: o, max: c, restDelta: u = .5, restSpeed: d }) { const f = t[0], h = { done: !1, value: f }, m = O => o !== void 0 && O < o || c !== void 0 && O > c, g = O => o === void 0 ? c : c === void 0 || Math.abs(o - O) < Math.abs(c - O) ? o : c; let x = n * e; const v = f + x, b = s === void 0 ? v : s(v); b !== v && (x = b - f); const E = O => -x * Math.exp(-O / r), M = O => b + E(O), C = O => { const I = E(O), D = M(O); h.done = Math.abs(I) <= u, h.value = h.done ? b : D }; let N, A; const j = O => { m(h.value) && (N = O, A = QT({ keyframes: [h.value, g(h.value)], velocity: Ote(M, O, h.value), damping: i, stiffness: a, restDelta: u, restSpeed: d })) }; return j(0), { calculatedDuration: null, next: O => { let I = !1; return !A && N === void 0 && (I = !0, C(O), j(O)), N !== void 0 && O >= N ? A.next(O - N) : (!I && C(O), h) } } } function v1e(t, e, n) { const r = [], i = n || vf.mix || kte, a = t.length - 1; for (let s = 0; s < a; s++) { let o = i(t[s], t[s + 1]); if (e) { const c = Array.isArray(e) ? e[s] || zl : e; o = GS(c, o) } r.push(o) } return r } function y1e(t, e, { clamp: n = !0, ease: r, mixer: i } = {}) { const a = t.length; if (G5(a === e.length), a === 1) return () => e[0]; if (a === 2 && e[0] === e[1]) return () => e[1]; const s = t[0] === t[1]; t[0] > t[a - 1] && (t = [...t].reverse(), e = [...e].reverse()); const o = v1e(e, r, i), c = o.length, u = d => { if (s && d < t[0]) return e[0]; let f = 0; if (c > 1) for (; f < t.length - 2 && !(d < t[f + 1]); f++); const h = w1(t[f], t[f + 1], d); return o[f](h) }; return n ? d => u(gf(t[0], t[a - 1], d)) : u } function x1e(t, e) { const n = t[t.length - 1]; for (let r = 1; r <= e; r++) { const i = w1(0, e, r); t.push(Li(n, 1, i)) } } function b1e(t) { const e = [0]; return x1e(e, t.length - 1), e } function w1e(t, e) { return t.map(n => n * e) } function S1e(t, e) { return t.map(() => e || _te).splice(0, t.length - 1) } function $w({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) { const i = kwe(r) ? r.map(J8) : J8(r), a = { done: !1, value: e[0] }, s = w1e(n && n.length === e.length ? n : b1e(e), t), o = y1e(s, e, { ease: Array.isArray(i) ? i : S1e(e, i) }); return { calculatedDuration: t, next: c => (a.value = o(c), a.done = c >= t, a) } } const _1e = t => t !== null; function rU(t, { repeat: e, repeatType: n = "loop" }, r, i = 1) { const a = t.filter(_1e), o = i < 0 || e && n !== "loop" && e % 2 === 1 ? 0 : a.length - 1; return !o || r === void 0 ? a[o] : r } const E1e = { decay: pL, inertia: pL, tween: $w, keyframes: $w, spring: QT }; function Dte(t) { typeof t.type == "string" && (t.type = E1e[t.type]) } class iU { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(e => { this.resolve = e }) } notifyFinished() { this.resolve() } then(e, n) { return this.finished.then(e, n) } } const M1e = t => t / 100; class aU extends iU { constructor(e) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: n } = this.options; n && n.updatedAt !== Do.now() && this.tick(Do.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = e, this.initAnimation(), this.play(), e.autoplay === !1 && this.pause() } initAnimation() { const { options: e } = this; Dte(e); const { type: n = $w, repeat: r = 0, repeatDelay: i = 0, repeatType: a, velocity: s = 0 } = e; let { keyframes: o } = e; const c = n || $w; c !== $w && typeof o[0] != "number" && (this.mixKeyframes = GS(M1e, kte(o[0], o[1])), o = [0, 100]); const u = c({ ...e, keyframes: o }); a === "mirror" && (this.mirroredGenerator = c({ ...e, keyframes: [...o].reverse(), velocity: -s })), u.calculatedDuration === null && (u.calculatedDuration = nU(u)); const { calculatedDuration: d } = u; this.calculatedDuration = d, this.resolvedDuration = d + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = u } updateTime(e) { const n = Math.round(e - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n } tick(e, n = !1) { const { generator: r, totalDuration: i, mixKeyframes: a, mirroredGenerator: s, resolvedDuration: o, calculatedDuration: c } = this; if (this.startTime === null) return r.next(0); const { delay: u = 0, keyframes: d, repeat: f, repeatType: h, repeatDelay: m, type: g, onUpdate: x, finalKeyframe: v } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - i / this.speed, this.startTime)), n ? this.currentTime = e : this.updateTime(e); const b = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), E = this.playbackSpeed >= 0 ? b < 0 : b > i; this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i); let M = this.currentTime, C = r; if (f) { const O = Math.min(this.currentTime, i) / o; let I = Math.floor(O), D = O % 1; !D && O >= 1 && (D = 1), D === 1 && I--, I = Math.min(I, f + 1), !!(I % 2) && (h === "reverse" ? (D = 1 - D, m && (D -= m / o)) : h === "mirror" && (C = s)), M = gf(0, 1, D) * o } const N = E ? { done: !1, value: d[0] } : C.next(M); a && (N.value = a(N.value)); let { done: A } = N; !E && c !== null && (A = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0); const j = this.holdTime === null && (this.state === "finished" || this.state === "running" && A); return j && g !== pL && (N.value = rU(d, this.options, v, this.speed)), x && x(N.value), j && this.finish(), N } then(e, n) { return this.finished.then(e, n) } get duration() { return Ul(this.calculatedDuration) } get iterationDuration() { const { delay: e = 0 } = this.options || {}; return this.duration + Ul(e) } get time() { return Ul(this.currentTime) } set time(e) { e = Nu(e), this.currentTime = e, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(e) { this.updateTime(Do.now()); const n = this.playbackSpeed !== e; this.playbackSpeed = e, n && (this.time = Ul(this.currentTime)) } play() { if (this.isStopped) return; const { driver: e = l1e, startTime: n } = this.options; this.driver || (this.driver = e(i => this.tick(i))), this.options.onPlay?.(); const r = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(Do.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } attachTimeline(e) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), e.observe(this) } } function T1e(t) { for (let e = 1; e < t.length; e++)t[e] ?? (t[e] = t[e - 1]) } const Xm = t => t * 180 / Math.PI, mL = t => { const e = Xm(Math.atan2(t[1], t[0])); return gL(e) }, C1e = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: t => (Math.abs(t[0]) + Math.abs(t[3])) / 2, rotate: mL, rotateZ: mL, skewX: t => Xm(Math.atan(t[1])), skewY: t => Xm(Math.atan(t[2])), skew: t => (Math.abs(t[1]) + Math.abs(t[2])) / 2 }, gL = t => (t = t % 360, t < 0 && (t += 360), t), aV = mL, sV = t => Math.sqrt(t[0] * t[0] + t[1] * t[1]), oV = t => Math.sqrt(t[4] * t[4] + t[5] * t[5]), N1e = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: sV, scaleY: oV, scale: t => (sV(t) + oV(t)) / 2, rotateX: t => gL(Xm(Math.atan2(t[6], t[5]))), rotateY: t => gL(Xm(Math.atan2(-t[2], t[0]))), rotateZ: aV, rotate: aV, skewX: t => Xm(Math.atan(t[4])), skewY: t => Xm(Math.atan(t[1])), skew: t => (Math.abs(t[1]) + Math.abs(t[4])) / 2 }; function vL(t) { return t.includes("scale") ? 1 : 0 } function yL(t, e) { if (!t || t === "none") return vL(e); const n = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let r, i; if (n) r = N1e, i = n; else { const o = t.match(/^matrix\(([-\d.e\s,]+)\)$/u); r = C1e, i = o } if (!i) return vL(e); const a = r[e], s = i[1].split(",").map(P1e); return typeof a == "function" ? a(s) : s[a] } const A1e = (t, e) => { const { transform: n = "none" } = getComputedStyle(t); return yL(n, e) }; function P1e(t) { return parseFloat(t.trim()) } const _0 = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], E0 = new Set(_0), lV = t => t === S0 || t === Dn, j1e = new Set(["x", "y", "z"]), R1e = _0.filter(t => !j1e.has(t)); function k1e(t) { const e = []; return R1e.forEach(n => { const r = t.getValue(n); r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), e } const cg = { width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), top: (t, { top: e }) => parseFloat(e), left: (t, { left: e }) => parseFloat(e), bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min), right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min), x: (t, { transform: e }) => yL(e, "x"), y: (t, { transform: e }) => yL(e, "y") }; cg.translateX = cg.x; cg.translateY = cg.y; const ug = new Set; let xL = !1, bL = !1, wL = !1; function Lte() { if (bL) { const t = Array.from(ug).filter(r => r.needsMeasurement), e = new Set(t.map(r => r.element)), n = new Map; e.forEach(r => { const i = k1e(r); i.length && (n.set(r, i), r.render()) }), t.forEach(r => r.measureInitialState()), e.forEach(r => { r.render(); const i = n.get(r); i && i.forEach(([a, s]) => { r.getValue(a)?.set(s) }) }), t.forEach(r => r.measureEndState()), t.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } bL = !1, xL = !1, ug.forEach(t => t.complete(wL)), ug.clear() } function Fte() { ug.forEach(t => { t.readKeyframes(), t.needsMeasurement && (bL = !0) }) } function I1e() { wL = !0, Fte(), Lte(), wL = !1 } class sU { constructor(e, n, r, i, a, s = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = i, this.element = a, this.isAsync = s } scheduleResolve() { this.state = "scheduled", this.isAsync ? (ug.add(this), xL || (xL = !0, Ri.read(Fte), Ri.resolveKeyframes(Lte))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: e, name: n, element: r, motionValue: i } = this; if (e[0] === null) { const a = i?.get(), s = e[e.length - 1]; if (a !== void 0) e[0] = a; else if (r && n) { const o = r.readValue(n, s); o != null && (e[0] = o) } e[0] === void 0 && (e[0] = s), i && a === void 0 && i.set(e[0]) } T1e(e) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(e = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e), ug.delete(this) } cancel() { this.state === "scheduled" && (ug.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const O1e = t => t.startsWith("--"); function D1e(t, e, n) { O1e(e) ? t.style.setProperty(e, n) : t.style[e] = n } const L1e = q5(() => window.ScrollTimeline !== void 0), F1e = {}; function U1e(t, e) { const n = q5(t); return () => F1e[e] ?? n() } const Ute = U1e(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), Pw = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, cV = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Pw([0, .65, .55, 1]), circOut: Pw([.55, 0, 1, .45]), backIn: Pw([.31, .01, .66, -.59]), backOut: Pw([.33, 1.53, .69, .99]) }; function Bte(t, e) { if (t) return typeof t == "function" ? Ute() ? Ite(t, e) : "ease-out" : Ete(t) ? Pw(t) : Array.isArray(t) ? t.map(n => Bte(n, e) || cV.easeOut) : cV[t] } function B1e(t, e, n, { delay: r = 0, duration: i = 300, repeat: a = 0, repeatType: s = "loop", ease: o = "easeOut", times: c } = {}, u = void 0) { const d = { [e]: n }; c && (d.offset = c); const f = Bte(o, i); Array.isArray(f) && (d.easing = f); const h = { delay: r, duration: i, easing: Array.isArray(f) ? "linear" : f, fill: "both", iterations: a + 1, direction: s === "reverse" ? "alternate" : "normal" }; return u && (h.pseudoElement = u), t.animate(d, h) } function $te(t) { return typeof t == "function" && "applyToOptions" in t } function $1e({ type: t, ...e }) { return $te(t) && Ute() ? t.applyToOptions(e) : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e) } class z1e extends iU { constructor(e) { if (super(), this.finishedTime = null, this.isStopped = !1, !e) return; const { element: n, name: r, keyframes: i, pseudoElement: a, allowFlatten: s = !1, finalKeyframe: o, onComplete: c } = e; this.isPseudoElement = !!a, this.allowFlatten = s, this.options = e, G5(typeof e.type != "string"); const u = $1e(e); this.animation = B1e(n, r, i, u, a), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !a) { const d = rU(i, this.options, o, this.speed); this.updateMotionValue ? this.updateMotionValue(d) : D1e(n, r, d), this.animation.cancel() } c?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: e } = this; e === "idle" || e === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { const e = this.animation.effect?.getComputedTiming?.().duration || 0; return Ul(Number(e)) } get iterationDuration() { const { delay: e = 0 } = this.options || {}; return this.duration + Ul(e) } get time() { return Ul(Number(this.animation.currentTime) || 0) } set time(e) { this.finishedTime = null, this.animation.currentTime = Nu(e) } get speed() { return this.animation.playbackRate } set speed(e) { e < 0 && (this.finishedTime = null), this.animation.playbackRate = e } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(e) { this.animation.startTime = e } attachTimeline({ timeline: e, observe: n }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, e && L1e() ? (this.animation.timeline = e, zl) : n(this) } } const zte = { anticipate: bte, backInOut: xte, circInOut: Ste }; function V1e(t) { return t in zte } function H1e(t) { typeof t.ease == "string" && V1e(t.ease) && (t.ease = zte[t.ease]) } const uV = 10; class W1e extends z1e { constructor(e) { H1e(e), Dte(e), super(e), e.startTime && (this.startTime = e.startTime), this.options = e } updateMotionValue(e) { const { motionValue: n, onUpdate: r, onComplete: i, element: a, ...s } = this.options; if (!n) return; if (e !== void 0) { n.set(e); return } const o = new aU({ ...s, autoplay: !1 }), c = Nu(this.finishedTime ?? this.time); n.setWithVelocity(o.sample(c - uV).value, o.sample(c).value, uV), o.stop() } } const dV = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (tp.test(t) || t === "0") && !t.startsWith("url(")); function G1e(t) { const e = t[0]; if (t.length === 1) return !0; for (let n = 0; n < t.length; n++)if (t[n] !== e) return !0 } function q1e(t, e, n, r) { const i = t[0]; if (i === null) return !1; if (e === "display" || e === "visibility") return !0; const a = t[t.length - 1], s = dV(i, e), o = dV(a, e); return !s || !o ? !1 : G1e(t) || (n === "spring" || $te(n)) && r } function SL(t) { t.duration = 0, t.type = "keyframes" } const X1e = new Set(["opacity", "clipPath", "filter", "transform"]), Y1e = q5(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function K1e(t) { const { motionValue: e, name: n, repeatDelay: r, repeatType: i, damping: a, type: s } = t; if (!(e?.owner?.current instanceof HTMLElement)) return !1; const { onUpdate: c, transformTemplate: u } = e.owner.getProps(); return Y1e() && n && X1e.has(n) && (n !== "transform" || !u) && !c && !r && i !== "mirror" && a !== 0 && s !== "inertia" } const Z1e = 40; class Q1e extends iU { constructor({ autoplay: e = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: a = 0, repeatType: s = "loop", keyframes: o, name: c, motionValue: u, element: d, ...f }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = Do.now(); const h = { autoplay: e, delay: n, type: r, repeat: i, repeatDelay: a, repeatType: s, name: c, motionValue: u, element: d, ...f }, m = d?.KeyframeResolver || sU; this.keyframeResolver = new m(o, (g, x, v) => this.onKeyframesResolved(g, x, h, !v), c, u, d), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(e, n, r, i) { this.keyframeResolver = void 0; const { name: a, type: s, velocity: o, delay: c, isHandoff: u, onUpdate: d } = r; this.resolvedAt = Do.now(), q1e(e, a, s, o) || ((vf.instantAnimations || !c) && d?.(rU(e, r, n)), e[0] = e[e.length - 1], SL(r), r.repeat = 0); const h = { startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > Z1e ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: n, ...r, keyframes: e }, m = !u && K1e(h) ? new W1e({ ...h, element: h.motionValue.owner.current }) : new aU(h); m.finished.then(() => this.notifyFinished()).catch(zl), this.pendingTimeline && (this.stopTimeline = m.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = m } get finished() { return this._animation ? this.animation.finished : this._finished } then(e, n) { return this.finished.finally(e).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), I1e()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(e) { this.animation.time = e } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(e) { this.animation.speed = e } get startTime() { return this.animation.startTime } attachTimeline(e) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } const J1e = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function eSe(t) { const e = J1e.exec(t); if (!e) return [,]; const [, n, r, i] = e; return [`--${n ?? r}`, i] } function Vte(t, e, n = 1) { const [r, i] = eSe(t); if (!r) return; const a = window.getComputedStyle(e).getPropertyValue(r); if (a) { const s = a.trim(); return dte(s) ? parseFloat(s) : s } return Q5(i) ? Vte(i, e, n + 1) : i } function oU(t, e) { return t?.[e] ?? t?.default ?? t } const Hte = new Set(["width", "height", "top", "left", "right", "bottom", ..._0]), tSe = { test: t => t === "auto", parse: t => t }, Wte = t => e => e.test(t), Gte = [S0, Dn, Au, Mh, Gwe, Wwe, tSe], fV = t => Gte.find(Wte(t)); function nSe(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || hte(t) : !0 } const rSe = new Set(["brightness", "contrast", "saturate", "opacity"]); function iSe(t) { const [e, n] = t.slice(0, -1).split("("); if (e === "drop-shadow") return t; const [r] = n.match(J5) || []; if (!r) return t; const i = n.replace(r, ""); let a = rSe.has(e) ? 1 : 0; return r !== n && (a *= 100), e + "(" + a + i + ")" } const aSe = /\b([a-z-]*)\(.*?\)/gu, _L = { ...tp, getAnimatableNone: t => { const e = t.match(aSe); return e ? e.map(iSe).join(" ") : t } }, hV = { ...S0, transform: Math.round }, sSe = { rotate: Mh, rotateX: Mh, rotateY: Mh, rotateZ: Mh, scale: VE, scaleX: VE, scaleY: VE, scaleZ: VE, skew: Mh, skewX: Mh, skewY: Mh, distance: Dn, translateX: Dn, translateY: Dn, translateZ: Dn, x: Dn, y: Dn, z: Dn, perspective: Dn, transformPerspective: Dn, opacity: S1, originX: eV, originY: eV, originZ: Dn }, lU = { borderWidth: Dn, borderTopWidth: Dn, borderRightWidth: Dn, borderBottomWidth: Dn, borderLeftWidth: Dn, borderRadius: Dn, radius: Dn, borderTopLeftRadius: Dn, borderTopRightRadius: Dn, borderBottomRightRadius: Dn, borderBottomLeftRadius: Dn, width: Dn, maxWidth: Dn, height: Dn, maxHeight: Dn, top: Dn, right: Dn, bottom: Dn, left: Dn, padding: Dn, paddingTop: Dn, paddingRight: Dn, paddingBottom: Dn, paddingLeft: Dn, margin: Dn, marginTop: Dn, marginRight: Dn, marginBottom: Dn, marginLeft: Dn, backgroundPositionX: Dn, backgroundPositionY: Dn, ...sSe, zIndex: hV, fillOpacity: S1, strokeOpacity: S1, numOctaves: hV }, oSe = { ...lU, color: ga, backgroundColor: ga, outlineColor: ga, fill: ga, stroke: ga, borderColor: ga, borderTopColor: ga, borderRightColor: ga, borderBottomColor: ga, borderLeftColor: ga, filter: _L, WebkitFilter: _L }, qte = t => oSe[t]; function Xte(t, e) { let n = qte(t); return n !== _L && (n = tp), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0 } const lSe = new Set(["auto", "none", "0"]); function cSe(t, e, n) { let r = 0, i; for (; r < t.length && !i;) { const a = t[r]; typeof a == "string" && !lSe.has(a) && _1(a).values.length && (i = t[r]), r++ } if (i && n) for (const a of e) t[a] = Xte(n, i) } class uSe extends sU { constructor(e, n, r, i, a) { super(e, n, r, i, a, !0) } readKeyframes() { const { unresolvedKeyframes: e, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let c = 0; c < e.length; c++) { let u = e[c]; if (typeof u == "string" && (u = u.trim(), Q5(u))) { const d = Vte(u, n.current); d !== void 0 && (e[c] = d), c === e.length - 1 && (this.finalKeyframe = u) } } if (this.resolveNoneKeyframes(), !Hte.has(r) || e.length !== 2) return; const [i, a] = e, s = fV(i), o = fV(a); if (s !== o) if (lV(s) && lV(o)) for (let c = 0; c < e.length; c++) { const u = e[c]; typeof u == "string" && (e[c] = parseFloat(u)) } else cg[r] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: e, name: n } = this, r = []; for (let i = 0; i < e.length; i++)(e[i] === null || nSe(e[i])) && r.push(i); r.length && cSe(e, r, n) } measureInitialState() { const { element: e, unresolvedKeyframes: n, name: r } = this; if (!e || !e.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = cg[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && e.getValue(r, i).jump(i, !1) } measureEndState() { const { element: e, name: n, unresolvedKeyframes: r } = this; if (!e || !e.current) return; const i = e.getValue(n); i && i.jump(this.measuredOrigin, !1); const a = r.length - 1, s = r[a]; r[a] = cg[n](e.measureViewportBox(), window.getComputedStyle(e.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), this.removedTransforms?.length && this.removedTransforms.forEach(([o, c]) => { e.getValue(o).set(c) }), this.resolveNoneKeyframes() } } function dSe(t, e, n) { if (t instanceof EventTarget) return [t]; if (typeof t == "string") { let r = document; const i = n?.[t] ?? r.querySelectorAll(t); return i ? Array.from(i) : [] } return Array.from(t) } const Yte = (t, e) => e && typeof t == "number" ? e.transform(t) : t; function Kte(t) { return fte(t) && "offsetHeight" in t } const pV = 30, fSe = t => !isNaN(parseFloat(t)); class hSe { constructor(e, n = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = r => { const i = Do.now(); if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const a of this.dependents) a.dirty() }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner } setCurrent(e) { this.current = e, this.updatedAt = Do.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = fSe(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, n) { this.events[e] || (this.events[e] = new X5); const r = this.events[e].add(n); return e === "change" ? () => { r(), Ri.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, n) { this.passiveEffect = e, this.stopPassiveEffect = n } set(e) { this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e) } setWithVelocity(e, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r } jump(e, n = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(e) { this.dependents || (this.dependents = new Set), this.dependents.add(e) } removeDependent(e) { this.dependents && this.dependents.delete(e) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const e = Do.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > pV) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, pV); return pte(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(e) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function hx(t, e) { return new hSe(t, e) } const { schedule: cU } = Mte(queueMicrotask, !1), Nc = { x: !1, y: !1 }; function Zte() { return Nc.x || Nc.y } function pSe(t) { return t === "x" || t === "y" ? Nc[t] ? null : (Nc[t] = !0, () => { Nc[t] = !1 }) : Nc.x || Nc.y ? null : (Nc.x = Nc.y = !0, () => { Nc.x = Nc.y = !1 }) } function Qte(t, e) { const n = dSe(t), r = new AbortController, i = { passive: !0, ...e, signal: r.signal }; return [n, i, () => r.abort()] } function mV(t) { return !(t.pointerType === "touch" || Zte()) } function mSe(t, e, n = {}) { const [r, i, a] = Qte(t, n), s = o => { if (!mV(o)) return; const { target: c } = o, u = e(c, o); if (typeof u != "function" || !c) return; const d = f => { mV(f) && (u(f), c.removeEventListener("pointerleave", d)) }; c.addEventListener("pointerleave", d, i) }; return r.forEach(o => { o.addEventListener("pointerenter", s, i) }), a } const Jte = (t, e) => e ? t === e ? !0 : Jte(t, e.parentElement) : !1, uU = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, gSe = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function vSe(t) { return gSe.has(t.tagName) || t.tabIndex !== -1 } const MT = new WeakSet; function gV(t) { return e => { e.key === "Enter" && t(e) } } function Fj(t, e) { t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })) } const ySe = (t, e) => { const n = t.currentTarget; if (!n) return; const r = gV(() => { if (MT.has(n)) return; Fj(n, "down"); const i = gV(() => { Fj(n, "up") }), a = () => Fj(n, "cancel"); n.addEventListener("keyup", i, e), n.addEventListener("blur", a, e) }); n.addEventListener("keydown", r, e), n.addEventListener("blur", () => n.removeEventListener("keydown", r), e) }; function vV(t) { return uU(t) && !Zte() } function xSe(t, e, n = {}) { const [r, i, a] = Qte(t, n), s = o => { const c = o.currentTarget; if (!vV(o)) return; MT.add(c); const u = e(c, o), d = (m, g) => { window.removeEventListener("pointerup", f), window.removeEventListener("pointercancel", h), MT.has(c) && MT.delete(c), vV(m) && typeof u == "function" && u(m, { success: g }) }, f = m => { d(m, c === window || c === document || n.useGlobalTarget || Jte(c, m.target)) }, h = m => { d(m, !1) }; window.addEventListener("pointerup", f, i), window.addEventListener("pointercancel", h, i) }; return r.forEach(o => { (n.useGlobalTarget ? window : o).addEventListener("pointerdown", s, i), Kte(o) && (o.addEventListener("focus", u => ySe(u, i)), !vSe(o) && !o.hasAttribute("tabindex") && (o.tabIndex = 0)) }), a } function ene(t) { return fte(t) && "ownerSVGElement" in t } function bSe(t) { return ene(t) && t.tagName === "svg" } const Ns = t => !!(t && t.getVelocity), wSe = [...Gte, ga, tp], SSe = t => wSe.find(Wte(t)), dU = S.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }); function yV(t, e) { if (typeof t == "function") return t(e); t != null && (t.current = e) } function _Se(...t) { return e => { let n = !1; const r = t.map(i => { const a = yV(i, e); return !n && typeof a == "function" && (n = !0), a }); if (n) return () => { for (let i = 0; i < r.length; i++) { const a = r[i]; typeof a == "function" ? a() : yV(t[i], null) } } } } function ESe(...t) { return S.useCallback(_Se(...t), t) } class MSe extends S.Component { getSnapshotBeforeUpdate(e) { const n = this.props.childRef.current; if (n && e.isPresent && !this.props.isPresent) { const r = n.offsetParent, i = Kte(r) && r.offsetWidth || 0, a = this.props.sizeRef.current; a.height = n.offsetHeight || 0, a.width = n.offsetWidth || 0, a.top = n.offsetTop, a.left = n.offsetLeft, a.right = i - a.width - a.left } return null } componentDidUpdate() { } render() { return this.props.children } } function TSe({ children: t, isPresent: e, anchorX: n, root: r }) {
	const i = S.useId(), a = S.useRef(null), s = S.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: o } = S.useContext(dU), c = ESe(a, t?.ref); return S.useInsertionEffect(() => {
		const { width: u, height: d, top: f, left: h, right: m } = s.current; if (e || !a.current || !u || !d) return; const g = n === "left" ? `left: ${h}` : `right: ${m}`; a.current.dataset.motionPopId = i; const x = document.createElement("style"); o && (x.nonce = o); const v = r ?? document.head; return v.appendChild(x), x.sheet && x.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${d}px !important;
            ${g}px !important;
            top: ${f}px !important;
          }
        `), () => { v.contains(x) && v.removeChild(x) }
	}, [e]), l.jsx(MSe, { isPresent: e, childRef: a, sizeRef: s, children: S.cloneElement(t, { ref: c }) })
} const CSe = ({ children: t, initial: e, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: a, mode: s, anchorX: o, root: c }) => { const u = z5(NSe), d = S.useId(); let f = !0, h = S.useMemo(() => (f = !1, { id: d, initial: e, isPresent: n, custom: i, onExitComplete: m => { u.set(m, !0); for (const g of u.values()) if (!g) return; r && r() }, register: m => (u.set(m, !1), () => u.delete(m)) }), [n, u, r]); return a && f && (h = { ...h }), S.useMemo(() => { u.forEach((m, g) => u.set(g, !1)) }, [n]), S.useEffect(() => { !n && !u.size && r && r() }, [n]), s === "popLayout" && (t = l.jsx(TSe, { isPresent: n, anchorX: o, root: c, children: t })), l.jsx(TA.Provider, { value: h, children: t }) }; function NSe() { return new Map } function tne(t = !0) { const e = S.useContext(TA); if (e === null) return [!0, null]; const { isPresent: n, onExitComplete: r, register: i } = e, a = S.useId(); S.useEffect(() => { if (t) return i(a) }, [t]); const s = S.useCallback(() => t && r && r(a), [a, r, t]); return !n && r ? [!1, s] : [!0] } const HE = t => t.key || ""; function xV(t) { const e = []; return S.Children.forEach(t, n => { S.isValidElement(n) && e.push(n) }), e } const YS = ({ children: t, custom: e, initial: n = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: a = "sync", propagate: s = !1, anchorX: o = "left", root: c }) => { const [u, d] = tne(s), f = S.useMemo(() => xV(t), [t]), h = s && !u ? [] : f.map(HE), m = S.useRef(!0), g = S.useRef(f), x = z5(() => new Map), [v, b] = S.useState(f), [E, M] = S.useState(f); ute(() => { m.current = !1, g.current = f; for (let A = 0; A < E.length; A++) { const j = HE(E[A]); h.includes(j) ? x.delete(j) : x.get(j) !== !0 && x.set(j, !1) } }, [E, h.length, h.join("-")]); const C = []; if (f !== v) { let A = [...f]; for (let j = 0; j < E.length; j++) { const O = E[j], I = HE(O); h.includes(I) || (A.splice(j, 0, O), C.push(O)) } return a === "wait" && C.length && (A = C), M(xV(A)), b(f), null } const { forceRender: N } = S.useContext($5); return l.jsx(l.Fragment, { children: E.map(A => { const j = HE(A), O = s && !u ? !1 : f === E || h.includes(j), I = () => { if (x.has(j)) x.set(j, !0); else return; let D = !0; x.forEach(F => { F || (D = !1) }), D && (N?.(), M(g.current), s && d?.(), r && r()) }; return l.jsx(CSe, { isPresent: O, initial: !m.current || n ? void 0 : !1, custom: e, presenceAffectsLayout: i, mode: a, root: c, onExitComplete: O ? void 0 : I, anchorX: o, children: A }, j) }) }) }, nne = S.createContext({ strict: !1 }), bV = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, px = {}; for (const t in bV) px[t] = { isEnabled: e => bV[t].some(n => !!e[n]) }; function ASe(t) { for (const e in t) px[e] = { ...px[e], ...t[e] } } const PSe = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function JT(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || PSe.has(t) } let rne = t => !JT(t); function jSe(t) { typeof t == "function" && (rne = e => e.startsWith("on") ? !JT(e) : t(e)) } try { jSe(require("@emotion/is-prop-valid").default) } catch { } function RSe(t, e, n) { const r = {}; for (const i in t) i === "values" && typeof t.values == "object" || (rne(i) || n === !0 && JT(i) || !e && !JT(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]); return r } const CA = S.createContext({}); function NA(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } function E1(t) { return typeof t == "string" || Array.isArray(t) } const fU = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], hU = ["initial", ...fU]; function AA(t) { return NA(t.animate) || hU.some(e => E1(t[e])) } function ine(t) { return !!(AA(t) || t.variants) } function kSe(t, e) { if (AA(t)) { const { initial: n, animate: r } = t; return { initial: n === !1 || E1(n) ? n : void 0, animate: E1(r) ? r : void 0 } } return t.inherit !== !1 ? e : {} } function ISe(t) { const { initial: e, animate: n } = kSe(t, S.useContext(CA)); return S.useMemo(() => ({ initial: e, animate: n }), [wV(e), wV(n)]) } function wV(t) { return Array.isArray(t) ? t.join(" ") : t } const M1 = {}; function OSe(t) { for (const e in t) M1[e] = t[e], Z5(e) && (M1[e].isCSSVariable = !0) } function ane(t, { layout: e, layoutId: n }) { return E0.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!M1[t] || t === "opacity") } const DSe = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, LSe = _0.length; function FSe(t, e, n) { let r = "", i = !0; for (let a = 0; a < LSe; a++) { const s = _0[a], o = t[s]; if (o === void 0) continue; let c = !0; if (typeof o == "number" ? c = o === (s.startsWith("scale") ? 1 : 0) : c = parseFloat(o) === 0, !c || n) { const u = Yte(o, lU[s]); if (!c) { i = !1; const d = DSe[s] || s; r += `${d}(${u}) ` } n && (e[s] = u) } } return r = r.trim(), n ? r = n(e, i ? "" : r) : i && (r = "none"), r } function pU(t, e, n) { const { style: r, vars: i, transformOrigin: a } = t; let s = !1, o = !1; for (const c in e) { const u = e[c]; if (E0.has(c)) { s = !0; continue } else if (Z5(c)) { i[c] = u; continue } else { const d = Yte(u, lU[c]); c.startsWith("origin") ? (o = !0, a[c] = d) : r[c] = d } } if (e.transform || (s || n ? r.transform = FSe(e, t.transform, n) : r.transform && (r.transform = "none")), o) { const { originX: c = "50%", originY: u = "50%", originZ: d = 0 } = a; r.transformOrigin = `${c} ${u} ${d}` } } const mU = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function sne(t, e, n) { for (const r in e) !Ns(e[r]) && !ane(r, n) && (t[r] = e[r]) } function USe({ transformTemplate: t }, e) { return S.useMemo(() => { const n = mU(); return pU(n, e, t), Object.assign({}, n.vars, n.style) }, [e]) } function BSe(t, e) { const n = t.style || {}, r = {}; return sne(r, n, t), Object.assign(r, USe(t, e)), r } function $Se(t, e) { const n = {}, r = BSe(t, e); return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n } const zSe = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, VSe = { offset: "strokeDashoffset", array: "strokeDasharray" }; function HSe(t, e, n = 1, r = 0, i = !0) { t.pathLength = 1; const a = i ? zSe : VSe; t[a.offset] = Dn.transform(-r); const s = Dn.transform(e), o = Dn.transform(n); t[a.array] = `${s} ${o}` } function one(t, { attrX: e, attrY: n, attrScale: r, pathLength: i, pathSpacing: a = 1, pathOffset: s = 0, ...o }, c, u, d) { if (pU(t, o, u), c) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: f, style: h } = t; f.transform && (h.transform = f.transform, delete f.transform), (h.transform || f.transformOrigin) && (h.transformOrigin = f.transformOrigin ?? "50% 50%", delete f.transformOrigin), h.transform && (h.transformBox = d?.transformBox ?? "fill-box", delete f.transformBox), e !== void 0 && (f.x = e), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), i !== void 0 && HSe(f, i, a, s, !1) } const lne = () => ({ ...mU(), attrs: {} }), cne = t => typeof t == "string" && t.toLowerCase() === "svg"; function WSe(t, e, n, r) { const i = S.useMemo(() => { const a = lne(); return one(a, e, cne(r), t.transformTemplate, t.style), { ...a.attrs, style: { ...a.style } } }, [e]); if (t.style) { const a = {}; sne(a, t.style, t), i.style = { ...a, ...i.style } } return i } const GSe = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function gU(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(GSe.indexOf(t) > -1 || /[A-Z]/u.test(t)) } function qSe(t, e, n, { latestValues: r }, i, a = !1) { const o = (gU(t) ? WSe : $Se)(e, r, i, t), c = RSe(e, typeof t == "string", a), u = t !== S.Fragment ? { ...c, ...o, ref: n } : {}, { children: d } = e, f = S.useMemo(() => Ns(d) ? d.get() : d, [d]); return S.createElement(t, { ...u, children: f }) } function SV(t) { const e = [{}, {}]; return t?.values.forEach((n, r) => { e[0][r] = n.get(), e[1][r] = n.getVelocity() }), e } function vU(t, e, n, r) { if (typeof e == "function") { const [i, a] = SV(r); e = e(n !== void 0 ? n : t.custom, i, a) } if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") { const [i, a] = SV(r); e = e(n !== void 0 ? n : t.custom, i, a) } return e } function TT(t) { return Ns(t) ? t.get() : t } function XSe({ scrapeMotionValuesFromProps: t, createRenderState: e }, n, r, i) { return { latestValues: YSe(n, r, i, t), renderState: e() } } function YSe(t, e, n, r) { const i = {}, a = r(t, {}); for (const h in a) i[h] = TT(a[h]); let { initial: s, animate: o } = t; const c = AA(t), u = ine(t); e && u && !c && t.inherit !== !1 && (s === void 0 && (s = e.initial), o === void 0 && (o = e.animate)); let d = n ? n.initial === !1 : !1; d = d || s === !1; const f = d ? o : s; if (f && typeof f != "boolean" && !NA(f)) { const h = Array.isArray(f) ? f : [f]; for (let m = 0; m < h.length; m++) { const g = vU(t, h[m]); if (g) { const { transitionEnd: x, transition: v, ...b } = g; for (const E in b) { let M = b[E]; if (Array.isArray(M)) { const C = d ? M.length - 1 : 0; M = M[C] } M !== null && (i[E] = M) } for (const E in x) i[E] = x[E] } } } return i } const une = t => (e, n) => { const r = S.useContext(CA), i = S.useContext(TA), a = () => XSe(t, e, r, i); return n ? a() : z5(a) }; function yU(t, e, n) { const { style: r } = t, i = {}; for (const a in r) (Ns(r[a]) || e.style && Ns(e.style[a]) || ane(a, t) || n?.getValue(a)?.liveStyle !== void 0) && (i[a] = r[a]); return i } const KSe = une({ scrapeMotionValuesFromProps: yU, createRenderState: mU }); function dne(t, e, n) { const r = yU(t, e, n); for (const i in t) if (Ns(t[i]) || Ns(e[i])) { const a = _0.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[a] = t[i] } return r } const ZSe = une({ scrapeMotionValuesFromProps: dne, createRenderState: lne }), QSe = Symbol.for("motionComponentSymbol"); function Iy(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } function JSe(t, e, n) { return S.useCallback(r => { r && t.onMount && t.onMount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Iy(n) && (n.current = r)) }, [e]) } const xU = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), e_e = "framerAppearId", fne = "data-" + xU(e_e), hne = S.createContext({}); function t_e(t, e, n, r, i) { const { visualElement: a } = S.useContext(CA), s = S.useContext(nne), o = S.useContext(TA), c = S.useContext(dU).reducedMotion, u = S.useRef(null); r = r || s.renderer, !u.current && r && (u.current = r(t, { visualState: e, parent: a, props: n, presenceContext: o, blockInitialAnimation: o ? o.initial === !1 : !1, reducedMotionConfig: c })); const d = u.current, f = S.useContext(hne); d && !d.projection && i && (d.type === "html" || d.type === "svg") && n_e(u.current, n, i, f); const h = S.useRef(!1); S.useInsertionEffect(() => { d && h.current && d.update(n, o) }); const m = n[fne], g = S.useRef(!!m && !window.MotionHandoffIsComplete?.(m) && window.MotionHasOptimisedAnimation?.(m)); return ute(() => { d && (h.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), d.scheduleRenderMicrotask(), g.current && d.animationState && d.animationState.animateChanges()) }), S.useEffect(() => { d && (!g.current && d.animationState && d.animationState.animateChanges(), g.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(m) }), g.current = !1), d.enteringChildren = void 0) }), d } function n_e(t, e, n, r) { const { layoutId: i, layout: a, drag: s, dragConstraints: o, layoutScroll: c, layoutRoot: u, layoutCrossfade: d } = e; t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : pne(t.parent)), t.projection.setOptions({ layoutId: i, layout: a, alwaysMeasureLayout: !!s || o && Iy(o), visualElement: t, animationType: typeof a == "string" ? a : "both", initialPromotionConfig: r, crossfade: d, layoutScroll: c, layoutRoot: u }) } function pne(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : pne(t.parent) } function Uj(t, { forwardMotionProps: e = !1 } = {}, n, r) { n && ASe(n); const i = gU(t) ? ZSe : KSe; function a(o, c) { let u; const d = { ...S.useContext(dU), ...o, layoutId: r_e(o) }, { isStatic: f } = d, h = ISe(o), m = i(o, f); if (!f && V5) { i_e(); const g = a_e(d); u = g.MeasureLayout, h.visualElement = t_e(t, m, d, r, g.ProjectionNode) } return l.jsxs(CA.Provider, { value: h, children: [u && h.visualElement ? l.jsx(u, { visualElement: h.visualElement, ...d }) : null, qSe(t, o, JSe(m, h.visualElement, c), m, f, e)] }) } a.displayName = `motion.${typeof t == "string" ? t : `create(${t.displayName ?? t.name ?? ""})`}`; const s = S.forwardRef(a); return s[QSe] = t, s } function r_e({ layoutId: t }) { const e = S.useContext($5).id; return e && t !== void 0 ? e + "-" + t : t } function i_e(t, e) { S.useContext(nne).strict } function a_e(t) { const { drag: e, layout: n } = px; if (!e && !n) return {}; const r = { ...e, ...n }; return { MeasureLayout: e?.isEnabled(t) || n?.isEnabled(t) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } function s_e(t, e) { if (typeof Proxy > "u") return Uj; const n = new Map, r = (a, s) => Uj(a, s, t, e), i = (a, s) => r(a, s); return new Proxy(i, { get: (a, s) => s === "create" ? r : (n.has(s) || n.set(s, Uj(s, void 0, t, e)), n.get(s)) }) } function mne({ top: t, left: e, right: n, bottom: r }) { return { x: { min: e, max: n }, y: { min: t, max: r } } } function o_e({ x: t, y: e }) { return { top: e.min, right: t.max, bottom: e.max, left: t.min } } function l_e(t, e) { if (!e) return t; const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function Bj(t) { return t === void 0 || t === 1 } function EL({ scale: t, scaleX: e, scaleY: n }) { return !Bj(t) || !Bj(e) || !Bj(n) } function Dm(t) { return EL(t) || gne(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function gne(t) { return _V(t.x) || _V(t.y) } function _V(t) { return t && t !== "0%" } function eC(t, e, n) { const r = t - n, i = e * r; return n + i } function EV(t, e, n, r, i) { return i !== void 0 && (t = eC(t, i, r)), eC(t, n, r) + e } function ML(t, e = 0, n = 1, r, i) { t.min = EV(t.min, e, n, r, i), t.max = EV(t.max, e, n, r, i) } function vne(t, { x: e, y: n }) { ML(t.x, e.translate, e.scale, e.originPoint), ML(t.y, n.translate, n.scale, n.originPoint) } const MV = .999999999999, TV = 1.0000000000001; function c_e(t, e, n, r = !1) { const i = n.length; if (!i) return; e.x = e.y = 1; let a, s; for (let o = 0; o < i; o++) { a = n[o], s = a.projectionDelta; const { visualElement: c } = a.options; c && c.props.style && c.props.style.display === "contents" || (r && a.options.layoutScroll && a.scroll && a !== a.root && Dy(t, { x: -a.scroll.offset.x, y: -a.scroll.offset.y }), s && (e.x *= s.x.scale, e.y *= s.y.scale, vne(t, s)), r && Dm(a.latestValues) && Dy(t, a.latestValues)) } e.x < TV && e.x > MV && (e.x = 1), e.y < TV && e.y > MV && (e.y = 1) } function Oy(t, e) { t.min = t.min + e, t.max = t.max + e } function CV(t, e, n, r, i = .5) { const a = Li(t.min, t.max, i); ML(t, e, n, a, r) } function Dy(t, e) { CV(t.x, e.x, e.scaleX, e.scale, e.originX), CV(t.y, e.y, e.scaleY, e.scale, e.originY) } function yne(t, e) { return mne(l_e(t.getBoundingClientRect(), e)) } function u_e(t, e, n) { const r = yne(t, n), { scroll: i } = e; return i && (Oy(r.x, i.offset.x), Oy(r.y, i.offset.y)), r } const NV = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Ly = () => ({ x: NV(), y: NV() }), AV = () => ({ min: 0, max: 0 }), na = () => ({ x: AV(), y: AV() }), TL = { current: null }, xne = { current: !1 }; function d_e() { if (xne.current = !0, !!V5) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), e = () => TL.current = t.matches; t.addEventListener("change", e), e() } else TL.current = !1 } const f_e = new WeakMap; function h_e(t, e, n) { for (const r in e) { const i = e[r], a = n[r]; if (Ns(i)) t.addValue(r, i); else if (Ns(a)) t.addValue(r, hx(i, { owner: t })); else if (a !== i) if (t.hasValue(r)) { const s = t.getValue(r); s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i) } else { const s = t.getStaticValue(r); t.addValue(r, hx(s !== void 0 ? s : i, { owner: t })) } } for (const r in n) e[r] === void 0 && t.removeValue(r); return e } const PV = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class p_e { scrapeMotionValuesFromProps(e, n, r) { return {} } constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: a, visualState: s }, o = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = sU, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const h = Do.now(); this.renderScheduledAt < h && (this.renderScheduledAt = h, Ri.render(this.render, !1, !0)) }; const { latestValues: c, renderState: u } = s; this.latestValues = c, this.baseTarget = { ...c }, this.initialValues = n.initial ? { ...c } : {}, this.renderState = u, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = o, this.blockInitialAnimation = !!a, this.isControllingVariants = AA(n), this.isVariantNode = ine(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); const { willChange: d, ...f } = this.scrapeMotionValuesFromProps(n, {}, this); for (const h in f) { const m = f[h]; c[h] !== void 0 && Ns(m) && m.set(c[h]) } } mount(e) { this.current = e, f_e.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), xne.current || d_e(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : TL.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), ep(this.notifyUpdate), ep(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) { const n = this.features[e]; n && (n.unmount(), n.isMounted = !1) } this.current = null } addChild(e) { this.children.add(e), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(e) } removeChild(e) { this.children.delete(e), this.enteringChildren && this.enteringChildren.delete(e) } bindToMotionValue(e, n) { this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)(); const r = E0.has(e); r && this.onBindTransform && this.onBindTransform(); const i = n.on("change", s => { this.latestValues[e] = s, this.props.onUpdate && Ri.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let a; window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => { i(), a && a(), n.owner && n.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } updateFeatures() { let e = "animation"; for (e in px) { const n = px[e]; if (!n) continue; const { isEnabled: r, Feature: i } = n; if (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)), this.features[e]) { const a = this.features[e]; a.isMounted ? a.update() : (a.mount(), a.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : na() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, n) { this.latestValues[e] = n } update(e, n) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < PV.length; r++) { const i = PV[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const a = "on" + i, s = e[a]; s && (this.propEventSubscriptions[i] = this.on(i, s)) } this.prevMotionValues = h_e(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(e) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e) } addValue(e, n) { const r = this.values.get(e); n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get()) } removeValue(e) { this.values.delete(e); const n = this.valueSubscriptions.get(e); n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, n) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let r = this.values.get(e); return r === void 0 && n !== void 0 && (r = hx(n === null ? void 0 : n, { owner: this }), this.addValue(e, r)), r } readValue(e, n) { let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options); return r != null && (typeof r == "string" && (dte(r) || hte(r)) ? r = parseFloat(r) : !SSe(r) && tp.test(n) && (r = Xte(e, n)), this.setBaseTarget(e, Ns(r) ? r.get() : r)), Ns(r) ? r.get() : r } setBaseTarget(e, n) { this.baseTarget[e] = n } getBaseTarget(e) { const { initial: n } = this.props; let r; if (typeof n == "string" || typeof n == "object") { const a = vU(this.props, n, this.presenceContext?.custom); a && (r = a[e]) } if (n && r !== void 0) return r; const i = this.getBaseTargetFromProps(this.props, e); return i !== void 0 && !Ns(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, n) { return this.events[e] || (this.events[e] = new X5), this.events[e].add(n) } notify(e, ...n) { this.events[e] && this.events[e].notify(...n) } scheduleRenderMicrotask() { cU.render(this.render) } } class bne extends p_e { constructor() { super(...arguments), this.KeyframeResolver = uSe } sortInstanceNodePosition(e, n) { return e.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(e, n) { return e.style ? e.style[n] : void 0 } removeValueFromRenderState(e, { vars: n, style: r }) { delete n[e], delete r[e] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; Ns(e) && (this.childSubscription = e.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function wne(t, { style: e, vars: n }, r, i) { const a = t.style; let s; for (s in e) a[s] = e[s]; i?.applyProjectionStyles(a, r); for (s in n) a.setProperty(s, n[s]) } function m_e(t) { return window.getComputedStyle(t) } class g_e extends bne { constructor() { super(...arguments), this.type = "html", this.renderInstance = wne } readValueFromInstance(e, n) { if (E0.has(n)) return this.projection?.isProjecting ? vL(n) : A1e(e, n); { const r = m_e(e), i = (Z5(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(e, { transformPagePoint: n }) { return yne(e, n) } build(e, n, r) { pU(e, n, r.transformTemplate) } scrapeMotionValuesFromProps(e, n, r) { return yU(e, n, r) } } const Sne = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function v_e(t, e, n, r) { wne(t, e, void 0, r); for (const i in e.attrs) t.setAttribute(Sne.has(i) ? i : xU(i), e.attrs[i]) } class y_e extends bne { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = na } getBaseTargetFromProps(e, n) { return e[n] } readValueFromInstance(e, n) { if (E0.has(n)) { const r = qte(n); return r && r.default || 0 } return n = Sne.has(n) ? n : xU(n), e.getAttribute(n) } scrapeMotionValuesFromProps(e, n, r) { return dne(e, n, r) } build(e, n, r) { one(e, n, this.isSVGTag, r.transformTemplate, r.style) } renderInstance(e, n, r, i) { v_e(e, n, r, i) } mount(e) { this.isSVGTag = cne(e.tagName), super.mount(e) } } const x_e = (t, e) => gU(t) ? new y_e(e) : new g_e(e, { allowProjection: t !== S.Fragment }); function Zy(t, e, n) { const r = t.getProps(); return vU(r, e, n !== void 0 ? n : r.custom, t) } const CL = t => Array.isArray(t); function b_e(t, e, n) { t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, hx(n)) } function w_e(t) { return CL(t) ? t[t.length - 1] || 0 : t } function S_e(t, e) { const n = Zy(t, e); let { transitionEnd: r = {}, transition: i = {}, ...a } = n || {}; a = { ...a, ...r }; for (const s in a) { const o = w_e(a[s]); b_e(t, s, o) } } function __e(t) { return !!(Ns(t) && t.add) } function NL(t, e) { const n = t.getValue("willChange"); if (__e(n)) return n.add(e); if (!n && vf.WillChange) { const r = new vf.WillChange("auto"); t.addValue("willChange", r), r.add(e) } } function _ne(t) { return t.props[fne] } const E_e = t => t !== null; function M_e(t, { repeat: e, repeatType: n = "loop" }, r) { const i = t.filter(E_e), a = e && n !== "loop" && e % 2 === 1 ? 0 : i.length - 1; return i[a] } const T_e = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, C_e = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), N_e = { type: "keyframes", duration: .8 }, A_e = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, P_e = (t, { keyframes: e }) => e.length > 2 ? N_e : E0.has(t) ? t.startsWith("scale") ? C_e(e[1]) : T_e : A_e; function j_e({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: a, repeatType: s, repeatDelay: o, from: c, elapsed: u, ...d }) { return !!Object.keys(d).length } const bU = (t, e, n, r = {}, i, a) => s => { const o = oU(r, t) || {}, c = o.delay || r.delay || 0; let { elapsed: u = 0 } = r; u = u - Nu(c); const d = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: e.getVelocity(), ...o, delay: -u, onUpdate: h => { e.set(h), o.onUpdate && o.onUpdate(h) }, onComplete: () => { s(), o.onComplete && o.onComplete() }, name: t, motionValue: e, element: a ? void 0 : i }; j_e(o) || Object.assign(d, P_e(t, d)), d.duration && (d.duration = Nu(d.duration)), d.repeatDelay && (d.repeatDelay = Nu(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from); let f = !1; if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (SL(d), d.delay === 0 && (f = !0)), (vf.instantAnimations || vf.skipAnimations) && (f = !0, SL(d), d.delay = 0), d.allowFlatten = !o.type && !o.ease, f && !a && e.get() !== void 0) { const h = M_e(d.keyframes, o); if (h !== void 0) { Ri.update(() => { d.onUpdate(h), d.onComplete() }); return } } return o.isSync ? new aU(d) : new Q1e(d) }; function R_e({ protectedKeys: t, needsAnimating: e }, n) { const r = t.hasOwnProperty(n) && e[n] !== !0; return e[n] = !1, r } function Ene(t, e, { delay: n = 0, transitionOverride: r, type: i } = {}) { let { transition: a = t.getDefaultTransition(), transitionEnd: s, ...o } = e; r && (a = r); const c = [], u = i && t.animationState && t.animationState.getState()[i]; for (const d in o) { const f = t.getValue(d, t.latestValues[d] ?? null), h = o[d]; if (h === void 0 || u && R_e(u, d)) continue; const m = { delay: n, ...oU(a || {}, d) }, g = f.get(); if (g !== void 0 && !f.isAnimating && !Array.isArray(h) && h === g && !m.velocity) continue; let x = !1; if (window.MotionHandoffAnimation) { const b = _ne(t); if (b) { const E = window.MotionHandoffAnimation(b, d, Ri); E !== null && (m.startTime = E, x = !0) } } NL(t, d), f.start(bU(d, f, h, t.shouldReduceMotion && Hte.has(d) ? { type: !1 } : m, t, x)); const v = f.animation; v && c.push(v) } return s && Promise.all(c).then(() => { Ri.update(() => { s && S_e(t, s) }) }), c } function Mne(t, e, n, r = 0, i = 1) { const a = Array.from(t).sort((u, d) => u.sortNodePosition(d)).indexOf(e), s = t.size, o = (s - 1) * r; return typeof n == "function" ? n(a, s) : i === 1 ? a * r : o - a * r } function AL(t, e, n = {}) { const r = Zy(t, e, n.type === "exit" ? t.presenceContext?.custom : void 0); let { transition: i = t.getDefaultTransition() || {} } = r || {}; n.transitionOverride && (i = n.transitionOverride); const a = r ? () => Promise.all(Ene(t, r, n)) : () => Promise.resolve(), s = t.variantChildren && t.variantChildren.size ? (c = 0) => { const { delayChildren: u = 0, staggerChildren: d, staggerDirection: f } = i; return k_e(t, e, c, u, d, f, n) } : () => Promise.resolve(), { when: o } = i; if (o) { const [c, u] = o === "beforeChildren" ? [a, s] : [s, a]; return c().then(() => u()) } else return Promise.all([a(), s(n.delay)]) } function k_e(t, e, n = 0, r = 0, i = 0, a = 1, s) { const o = []; for (const c of t.variantChildren) c.notify("AnimationStart", e), o.push(AL(c, e, { ...s, delay: n + (typeof r == "function" ? 0 : r) + Mne(t.variantChildren, c, r, i, a) }).then(() => c.notify("AnimationComplete", e))); return Promise.all(o) } function I_e(t, e, n = {}) { t.notify("AnimationStart", e); let r; if (Array.isArray(e)) { const i = e.map(a => AL(t, a, n)); r = Promise.all(i) } else if (typeof e == "string") r = AL(t, e, n); else { const i = typeof e == "function" ? Zy(t, e, n.custom) : e; r = Promise.all(Ene(t, i, n)) } return r.then(() => { t.notify("AnimationComplete", e) }) } function Tne(t, e) { if (!Array.isArray(e)) return !1; const n = e.length; if (n !== t.length) return !1; for (let r = 0; r < n; r++)if (e[r] !== t[r]) return !1; return !0 } const O_e = hU.length; function Cne(t) { if (!t) return; if (!t.isControllingVariants) { const n = t.parent ? Cne(t.parent) || {} : {}; return t.props.initial !== void 0 && (n.initial = t.props.initial), n } const e = {}; for (let n = 0; n < O_e; n++) { const r = hU[n], i = t.props[r]; (E1(i) || i === !1) && (e[r] = i) } return e } const D_e = [...fU].reverse(), L_e = fU.length; function F_e(t) { return e => Promise.all(e.map(({ animation: n, options: r }) => I_e(t, n, r))) } function U_e(t) { let e = F_e(t), n = jV(), r = !0; const i = c => (u, d) => { const f = Zy(t, d, c === "exit" ? t.presenceContext?.custom : void 0); if (f) { const { transition: h, transitionEnd: m, ...g } = f; u = { ...u, ...g, ...m } } return u }; function a(c) { e = c(t) } function s(c) { const { props: u } = t, d = Cne(t.parent) || {}, f = [], h = new Set; let m = {}, g = 1 / 0; for (let v = 0; v < L_e; v++) { const b = D_e[v], E = n[b], M = u[b] !== void 0 ? u[b] : d[b], C = E1(M), N = b === c ? E.isActive : null; N === !1 && (g = v); let A = M === d[b] && M !== u[b] && C; if (A && r && t.manuallyAnimateOnMount && (A = !1), E.protectedKeys = { ...m }, !E.isActive && N === null || !M && !E.prevProp || NA(M) || typeof M == "boolean") continue; const j = B_e(E.prevProp, M); let O = j || b === c && E.isActive && !A && C || v > g && C, I = !1; const D = Array.isArray(M) ? M : [M]; let F = D.reduce(i(b), {}); N === !1 && (F = {}); const { prevResolvedValues: B = {} } = E, G = { ...B, ...F }, z = Z => { O = !0, h.has(Z) && (I = !0, h.delete(Z)), E.needsAnimating[Z] = !0; const $ = t.getValue(Z); $ && ($.liveStyle = !1) }; for (const Z in G) { const $ = F[Z], V = B[Z]; if (m.hasOwnProperty(Z)) continue; let K = !1; CL($) && CL(V) ? K = !Tne($, V) : K = $ !== V, K ? $ != null ? z(Z) : h.add(Z) : $ !== void 0 && h.has(Z) ? z(Z) : E.protectedKeys[Z] = !0 } E.prevProp = M, E.prevResolvedValues = F, E.isActive && (m = { ...m, ...F }), r && t.blockInitialAnimation && (O = !1); const q = A && j; O && (!q || I) && f.push(...D.map(Z => { const $ = { type: b }; if (typeof Z == "string" && r && !q && t.manuallyAnimateOnMount && t.parent) { const { parent: V } = t, K = Zy(V, Z); if (V.enteringChildren && K) { const { delayChildren: X } = K.transition || {}; $.delay = Mne(V.enteringChildren, t, X) } } return { animation: Z, options: $ } })) } if (h.size) { const v = {}; if (typeof u.initial != "boolean") { const b = Zy(t, Array.isArray(u.initial) ? u.initial[0] : u.initial); b && b.transition && (v.transition = b.transition) } h.forEach(b => { const E = t.getBaseTarget(b), M = t.getValue(b); M && (M.liveStyle = !0), v[b] = E ?? null }), f.push({ animation: v }) } let x = !!f.length; return r && (u.initial === !1 || u.initial === u.animate) && !t.manuallyAnimateOnMount && (x = !1), r = !1, x ? e(f) : Promise.resolve() } function o(c, u) { if (n[c].isActive === u) return Promise.resolve(); t.variantChildren?.forEach(f => f.animationState?.setActive(c, u)), n[c].isActive = u; const d = s(c); for (const f in n) n[f].protectedKeys = {}; return d } return { animateChanges: s, setActive: o, setAnimateFunction: a, getState: () => n, reset: () => { n = jV() } } } function B_e(t, e) { return typeof e == "string" ? e !== t : Array.isArray(e) ? !Tne(e, t) : !1 } function vm(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function jV() { return { animate: vm(!0), whileInView: vm(), whileHover: vm(), whileTap: vm(), whileDrag: vm(), whileFocus: vm(), exit: vm() } } class hp { constructor(e) { this.isMounted = !1, this.node = e } update() { } } class $_e extends hp { constructor(e) { super(e), e.animationState || (e.animationState = U_e(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); NA(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; e !== n && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let z_e = 0; class V_e extends hp { constructor() { super(...arguments), this.id = z_e++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const i = this.node.animationState.setActive("exit", !e); n && !e && i.then(() => { n(this.id) }) } mount() { const { register: e, onExitComplete: n } = this.node.presenceContext || {}; n && n(this.id), e && (this.unmount = e(this.id)) } unmount() { } } const H_e = { animation: { Feature: $_e }, exit: { Feature: V_e } }; function T1(t, e, n, r = { passive: !0 }) { return t.addEventListener(e, n, r), () => t.removeEventListener(e, n) } function KS(t) { return { point: { x: t.pageX, y: t.pageY } } } const W_e = t => e => uU(e) && t(e, KS(e)); function zw(t, e, n, r) { return T1(t, e, W_e(n), r) } const Nne = 1e-4, G_e = 1 - Nne, q_e = 1 + Nne, Ane = .01, X_e = 0 - Ane, Y_e = 0 + Ane; function Qs(t) { return t.max - t.min } function K_e(t, e, n) { return Math.abs(t - e) <= n } function RV(t, e, n, r = .5) { t.origin = r, t.originPoint = Li(e.min, e.max, t.origin), t.scale = Qs(n) / Qs(e), t.translate = Li(n.min, n.max, t.origin) - t.originPoint, (t.scale >= G_e && t.scale <= q_e || isNaN(t.scale)) && (t.scale = 1), (t.translate >= X_e && t.translate <= Y_e || isNaN(t.translate)) && (t.translate = 0) } function Vw(t, e, n, r) { RV(t.x, e.x, n.x, r ? r.originX : void 0), RV(t.y, e.y, n.y, r ? r.originY : void 0) } function kV(t, e, n) { t.min = n.min + e.min, t.max = t.min + Qs(e) } function Z_e(t, e, n) { kV(t.x, e.x, n.x), kV(t.y, e.y, n.y) } function IV(t, e, n) { t.min = e.min - n.min, t.max = t.min + Qs(e) } function Hw(t, e, n) { IV(t.x, e.x, n.x), IV(t.y, e.y, n.y) } function Il(t) { return [t("x"), t("y")] } const Pne = ({ current: t }) => t ? t.ownerDocument.defaultView : null, OV = (t, e) => Math.abs(t - e); function Q_e(t, e) { const n = OV(t.x, e.x), r = OV(t.y, e.y); return Math.sqrt(n ** 2 + r ** 2) } class jne { constructor(e, n, { transformPagePoint: r, contextWindow: i = window, dragSnapToOrigin: a = !1, distanceThreshold: s = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const h = zj(this.lastMoveEventInfo, this.history), m = this.startEvent !== null, g = Q_e(h.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!m && !g) return; const { point: x } = h, { timestamp: v } = ls; this.history.push({ ...x, timestamp: v }); const { onStart: b, onMove: E } = this.handlers; m || (b && b(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), E && E(this.lastMoveEvent, h) }, this.handlePointerMove = (h, m) => { this.lastMoveEvent = h, this.lastMoveEventInfo = $j(m, this.transformPagePoint), Ri.update(this.updatePoint, !0) }, this.handlePointerUp = (h, m) => { this.end(); const { onEnd: g, onSessionEnd: x, resumeAnimation: v } = this.handlers; if (this.dragSnapToOrigin && v && v(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const b = zj(h.type === "pointercancel" ? this.lastMoveEventInfo : $j(m, this.transformPagePoint), this.history); this.startEvent && g && g(h, b), x && x(h, b) }, !uU(e)) return; this.dragSnapToOrigin = a, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = s, this.contextWindow = i || window; const o = KS(e), c = $j(o, this.transformPagePoint), { point: u } = c, { timestamp: d } = ls; this.history = [{ ...u, timestamp: d }]; const { onSessionStart: f } = n; f && f(e, zj(c, this.history)), this.removeListeners = GS(zw(this.contextWindow, "pointermove", this.handlePointerMove), zw(this.contextWindow, "pointerup", this.handlePointerUp), zw(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), ep(this.updatePoint) } } function $j(t, e) { return e ? { point: e(t.point) } : t } function DV(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function zj({ point: t }, e) { return { point: t, delta: DV(t, Rne(e)), offset: DV(t, J_e(e)), velocity: eEe(e, .1) } } function J_e(t) { return t[0] } function Rne(t) { return t[t.length - 1] } function eEe(t, e) { if (t.length < 2) return { x: 0, y: 0 }; let n = t.length - 1, r = null; const i = Rne(t); for (; n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > Nu(e)));)n--; if (!r) return { x: 0, y: 0 }; const a = Ul(i.timestamp - r.timestamp); if (a === 0) return { x: 0, y: 0 }; const s = { x: (i.x - r.x) / a, y: (i.y - r.y) / a }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function tEe(t, { min: e, max: n }, r) { return e !== void 0 && t < e ? t = r ? Li(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Li(n, t, r.max) : Math.min(t, n)), t } function LV(t, e, n) { return { min: e !== void 0 ? t.min + e : void 0, max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0 } } function nEe(t, { top: e, left: n, bottom: r, right: i }) { return { x: LV(t.x, n, i), y: LV(t.y, e, r) } } function FV(t, e) { let n = e.min - t.min, r = e.max - t.max; return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r } } function rEe(t, e) { return { x: FV(t.x, e.x), y: FV(t.y, e.y) } } function iEe(t, e) { let n = .5; const r = Qs(t), i = Qs(e); return i > r ? n = w1(e.min, e.max - r, t.min) : r > i && (n = w1(t.min, t.max - i, e.min)), gf(0, 1, n) } function aEe(t, e) { const n = {}; return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n } const PL = .35; function sEe(t = PL) { return t === !1 ? t = 0 : t === !0 && (t = PL), { x: UV(t, "left", "right"), y: UV(t, "top", "bottom") } } function UV(t, e, n) { return { min: BV(t, e), max: BV(t, n) } } function BV(t, e) { return typeof t == "number" ? t : t[e] || 0 } const oEe = new WeakMap; class lEe { constructor(e) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = na(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = e } start(e, { snapToCursor: n = !1, distanceThreshold: r } = {}) { const { presenceContext: i } = this.visualElement; if (i && i.isPresent === !1) return; const a = f => { const { dragSnapToOrigin: h } = this.getProps(); h ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(KS(f).point) }, s = (f, h) => { const { drag: m, dragPropagation: g, onDragStart: x } = this.getProps(); if (m && !g && (this.openDragLock && this.openDragLock(), this.openDragLock = pSe(m), !this.openDragLock)) return; this.latestPointerEvent = f, this.latestPanInfo = h, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Il(b => { let E = this.getAxisMotionValue(b).get() || 0; if (Au.test(E)) { const { projection: M } = this.visualElement; if (M && M.layout) { const C = M.layout.layoutBox[b]; C && (E = Qs(C) * (parseFloat(E) / 100)) } } this.originPoint[b] = E }), x && Ri.postRender(() => x(f, h)), NL(this.visualElement, "transform"); const { animationState: v } = this.visualElement; v && v.setActive("whileDrag", !0) }, o = (f, h) => { this.latestPointerEvent = f, this.latestPanInfo = h; const { dragPropagation: m, dragDirectionLock: g, onDirectionLock: x, onDrag: v } = this.getProps(); if (!m && !this.openDragLock) return; const { offset: b } = h; if (g && this.currentDirection === null) { this.currentDirection = cEe(b), this.currentDirection !== null && x && x(this.currentDirection); return } this.updateAxis("x", h.point, b), this.updateAxis("y", h.point, b), this.visualElement.render(), v && v(f, h) }, c = (f, h) => { this.latestPointerEvent = f, this.latestPanInfo = h, this.stop(f, h), this.latestPointerEvent = null, this.latestPanInfo = null }, u = () => Il(f => this.getAnimationState(f) === "paused" && this.getAxisMotionValue(f).animation?.play()), { dragSnapToOrigin: d } = this.getProps(); this.panSession = new jne(e, { onSessionStart: a, onStart: s, onMove: o, onSessionEnd: c, resumeAnimation: u }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: d, distanceThreshold: r, contextWindow: Pne(this.visualElement) }) } stop(e, n) { const r = e || this.latestPointerEvent, i = n || this.latestPanInfo, a = this.isDragging; if (this.cancel(), !a || !i || !r) return; const { velocity: s } = i; this.startAnimation(s); const { onDragEnd: o } = this.getProps(); o && Ri.postRender(() => o(r, i)) } cancel() { this.isDragging = !1; const { projection: e, animationState: n } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(e, n, r) { const { drag: i } = this.getProps(); if (!r || !WE(e, i, this.currentDirection)) return; const a = this.getAxisMotionValue(e); let s = this.originPoint[e] + r[e]; this.constraints && this.constraints[e] && (s = tEe(s, this.constraints[e], this.elastic[e])), a.set(s) } resolveConstraints() { const { dragConstraints: e, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints; e && Iy(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && r ? this.constraints = nEe(r.layoutBox, e) : this.constraints = !1, this.elastic = sEe(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Il(a => { this.constraints !== !1 && this.getAxisMotionValue(a) && (this.constraints[a] = aEe(r.layoutBox[a], this.constraints[a])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps(); if (!e || !Iy(e)) return !1; const r = e.current, { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const a = u_e(r, i.root, this.visualElement.getTransformPagePoint()); let s = rEe(i.layout.layoutBox, a); if (n) { const o = n(o_e(s)); this.hasMutatedConstraints = !!o, o && (s = mne(o)) } return s } startAnimation(e) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: a, dragSnapToOrigin: s, onDragTransitionEnd: o } = this.getProps(), c = this.constraints || {}, u = Il(d => { if (!WE(d, n, this.currentDirection)) return; let f = c && c[d] || {}; s && (f = { min: 0, max: 0 }); const h = i ? 200 : 1e6, m = i ? 40 : 1e7, g = { type: "inertia", velocity: r ? e[d] : 0, bounceStiffness: h, bounceDamping: m, timeConstant: 750, restDelta: 1, restSpeed: 10, ...a, ...f }; return this.startAxisValueAnimation(d, g) }); return Promise.all(u).then(o) } startAxisValueAnimation(e, n) { const r = this.getAxisMotionValue(e); return NL(this.visualElement, e), r.start(bU(e, r, 0, n, this.visualElement, !1)) } stopAnimation() { Il(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { Il(e => this.getAxisMotionValue(e).animation?.pause()) } getAnimationState(e) { return this.getAxisMotionValue(e).animation?.state } getAxisMotionValue(e) { const n = `_drag${e.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0) } snapToCursor(e) { Il(n => { const { drag: r } = this.getProps(); if (!WE(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, a = this.getAxisMotionValue(n); if (i && i.layout) { const { min: s, max: o } = i.layout.layoutBox[n]; a.set(e[n] - Li(s, o, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Iy(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; Il(s => { const o = this.getAxisMotionValue(s); if (o && this.constraints !== !1) { const c = o.get(); i[s] = iEe({ min: c, max: c }, this.constraints[s]) } }); const { transformTemplate: a } = this.visualElement.getProps(); this.visualElement.current.style.transform = a ? a({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Il(s => { if (!WE(s, e, null)) return; const o = this.getAxisMotionValue(s), { min: c, max: u } = this.constraints[s]; o.set(Li(c, u, i[s])) }) } addListeners() { if (!this.visualElement.current) return; oEe.set(this.visualElement, this); const e = this.visualElement.current, n = zw(e, "pointerdown", c => { const { drag: u, dragListener: d = !0 } = this.getProps(); u && d && this.start(c) }), r = () => { const { dragConstraints: c } = this.getProps(); Iy(c) && c.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, a = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Ri.read(r); const s = T1(window, "resize", () => this.scalePositionWithinConstraints()), o = i.addEventListener("didUpdate", (({ delta: c, hasLayoutChanged: u }) => { this.isDragging && u && (Il(d => { const f = this.getAxisMotionValue(d); f && (this.originPoint[d] += c[d].translate, f.set(f.get() + c[d].translate)) }), this.visualElement.render()) })); return () => { s(), n(), a(), o && o() } } getProps() { const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: a = !1, dragElastic: s = PL, dragMomentum: o = !0 } = e; return { ...e, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: a, dragElastic: s, dragMomentum: o } } } function WE(t, e, n) { return (e === !0 || e === t) && (n === null || n === t) } function cEe(t, e = 10) { let n = null; return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n } class uEe extends hp { constructor(e) { super(e), this.removeGroupControls = zl, this.removeListeners = zl, this.controls = new lEe(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || zl } unmount() { this.removeGroupControls(), this.removeListeners() } } const $V = t => (e, n) => { t && Ri.postRender(() => t(e, n)) }; class dEe extends hp { constructor() { super(...arguments), this.removePointerDownListener = zl } onPointerDown(e) { this.session = new jne(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Pne(this.node) }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: $V(e), onStart: $V(n), onMove: r, onEnd: (a, s) => { delete this.session, i && Ri.postRender(() => i(a, s)) } } } mount() { this.removePointerDownListener = zw(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const CT = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function zV(t, e) { return e.max === e.min ? 0 : t / (e.max - e.min) * 100 } const Kb = { correct: (t, e) => { if (!e.target) return t; if (typeof t == "string") if (Dn.test(t)) t = parseFloat(t); else return t; const n = zV(t, e.target.x), r = zV(t, e.target.y); return `${n}% ${r}%` } }, fEe = { correct: (t, { treeScale: e, projectionDelta: n }) => { const r = t, i = tp.parse(t); if (i.length > 5) return r; const a = tp.createTransformer(t), s = typeof i[0] != "number" ? 1 : 0, o = n.x.scale * e.x, c = n.y.scale * e.y; i[0 + s] /= o, i[1 + s] /= c; const u = Li(o, c, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), a(i) } }; let Vj = !1; class hEe extends S.Component { componentDidMount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: a } = e; OSe(pEe), a && (n.group && n.group.add(a), r && r.register && i && r.register(a), Vj && a.root.didUpdate(), a.addEventListener("animationComplete", () => { this.safeToRemove() }), a.setOptions({ ...a.options, onExitComplete: () => this.safeToRemove() })), CT.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: a } = this.props, { projection: s } = r; return s && (s.isPresent = a, Vj = !0, i || e.layoutDependency !== n || n === void 0 || e.isPresent !== a ? s.willUpdate() : this.safeToRemove(), e.isPresent !== a && (a ? s.promote() : s.relegate() || Ri.postRender(() => { const o = s.getStack(); (!o || !o.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), cU.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = e; Vj = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function kne(t) { const [e, n] = tne(), r = S.useContext($5); return l.jsx(hEe, { ...t, layoutGroup: r, switchLayoutGroup: S.useContext(hne), isPresent: e, safeToRemove: n }) } const pEe = { borderRadius: { ...Kb, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Kb, borderTopRightRadius: Kb, borderBottomLeftRadius: Kb, borderBottomRightRadius: Kb, boxShadow: fEe }; function mEe(t, e, n) { const r = Ns(t) ? t : hx(t); return r.start(bU("", r, e, n)), r.animation } const gEe = (t, e) => t.depth - e.depth; class vEe { constructor() { this.children = [], this.isDirty = !1 } add(e) { H5(this.children, e), this.isDirty = !0 } remove(e) { W5(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(gEe), this.isDirty = !1, this.children.forEach(e) } } function yEe(t, e) { const n = Do.now(), r = ({ timestamp: i }) => { const a = i - n; a >= e && (ep(r), t(a - e)) }; return Ri.setup(r, !0), () => ep(r) } const Ine = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], xEe = Ine.length, VV = t => typeof t == "string" ? parseFloat(t) : t, HV = t => typeof t == "number" || Dn.test(t); function bEe(t, e, n, r, i, a) { i ? (t.opacity = Li(0, n.opacity ?? 1, wEe(r)), t.opacityExit = Li(e.opacity ?? 1, 0, SEe(r))) : a && (t.opacity = Li(e.opacity ?? 1, n.opacity ?? 1, r)); for (let s = 0; s < xEe; s++) { const o = `border${Ine[s]}Radius`; let c = WV(e, o), u = WV(n, o); if (c === void 0 && u === void 0) continue; c || (c = 0), u || (u = 0), c === 0 || u === 0 || HV(c) === HV(u) ? (t[o] = Math.max(Li(VV(c), VV(u), r), 0), (Au.test(u) || Au.test(c)) && (t[o] += "%")) : t[o] = u } (e.rotate || n.rotate) && (t.rotate = Li(e.rotate || 0, n.rotate || 0, r)) } function WV(t, e) { return t[e] !== void 0 ? t[e] : t.borderRadius } const wEe = One(0, .5, wte), SEe = One(.5, .95, zl); function One(t, e, n) { return r => r < t ? 0 : r > e ? 1 : n(w1(t, e, r)) } function GV(t, e) { t.min = e.min, t.max = e.max } function Al(t, e) { GV(t.x, e.x), GV(t.y, e.y) } function qV(t, e) { t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin } function XV(t, e, n, r, i) { return t -= e, t = eC(t, 1 / n, r), i !== void 0 && (t = eC(t, 1 / i, r)), t } function _Ee(t, e = 0, n = 1, r = .5, i, a = t, s = t) { if (Au.test(e) && (e = parseFloat(e), e = Li(s.min, s.max, e / 100) - s.min), typeof e != "number") return; let o = Li(a.min, a.max, r); t === a && (o -= e), t.min = XV(t.min, e, n, o, i), t.max = XV(t.max, e, n, o, i) } function YV(t, e, [n, r, i], a, s) { _Ee(t, e[n], e[r], e[i], e.scale, a, s) } const EEe = ["x", "scaleX", "originX"], MEe = ["y", "scaleY", "originY"]; function KV(t, e, n, r) { YV(t.x, e, EEe, n ? n.x : void 0, r ? r.x : void 0), YV(t.y, e, MEe, n ? n.y : void 0, r ? r.y : void 0) } function ZV(t) { return t.translate === 0 && t.scale === 1 } function Dne(t) { return ZV(t.x) && ZV(t.y) } function QV(t, e) { return t.min === e.min && t.max === e.max } function TEe(t, e) { return QV(t.x, e.x) && QV(t.y, e.y) } function JV(t, e) { return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max) } function Lne(t, e) { return JV(t.x, e.x) && JV(t.y, e.y) } function eH(t) { return Qs(t.x) / Qs(t.y) } function tH(t, e) { return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint } class CEe { constructor() { this.members = [] } add(e) { H5(this.members, e), e.scheduleRender() } remove(e) { if (W5(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(e) { const n = this.members.findIndex(i => e === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const a = this.members[i]; if (a.isPresent !== !1) { r = a; break } } return r ? (this.promote(r), !0) : !1 } promote(e, n) { const r = this.lead; if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) { r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: i } = e.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: n, resumingFrom: r } = e; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function NEe(t, e, n) { let r = ""; const i = t.x.translate / e.x, a = t.y.translate / e.y, s = n?.z || 0; if ((i || a || s) && (r = `translate3d(${i}px, ${a}px, ${s}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) { const { transformPerspective: u, rotate: d, rotateX: f, rotateY: h, skewX: m, skewY: g } = n; u && (r = `perspective(${u}px) ${r}`), d && (r += `rotate(${d}deg) `), f && (r += `rotateX(${f}deg) `), h && (r += `rotateY(${h}deg) `), m && (r += `skewX(${m}deg) `), g && (r += `skewY(${g}deg) `) } const o = t.x.scale * e.x, c = t.y.scale * e.y; return (o !== 1 || c !== 1) && (r += `scale(${o}, ${c})`), r || "none" } const Hj = ["", "X", "Y", "Z"], AEe = 1e3; let PEe = 0; function Wj(t, e, n, r) { const { latestValues: i } = e; i[t] && (n[t] = i[t], e.setStaticValue(t, 0), r && (r[t] = 0)) } function Fne(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: e } = t.options; if (!e) return; const n = _ne(e); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: i, layoutId: a } = t.options; window.MotionCancelOptimisedAnimation(n, "transform", Ri, !(i || a)) } const { parent: r } = t; r && !r.hasCheckedOptimisedAppear && Fne(r) } function Une({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, o = e?.()) { this.id = PEe++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(kEe), this.nodes.forEach(LEe), this.nodes.forEach(FEe), this.nodes.forEach(IEe) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = o ? o.root || o : this, this.path = o ? [...o.path, o] : [], this.parent = o, this.depth = o ? o.depth + 1 : 0; for (let c = 0; c < this.path.length; c++)this.path[c].shouldResetTransform = !0; this.root === this && (this.nodes = new vEe) } addEventListener(s, o) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new X5), this.eventHandlers.get(s).add(o) } notifyListeners(s, ...o) { const c = this.eventHandlers.get(s); c && c.notify(...o) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s) { if (this.instance) return; this.isSVG = ene(s) && !bSe(s), this.instance = s; const { layoutId: o, layout: c, visualElement: u } = this.options; if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (c || o) && (this.isLayoutDirty = !0), t) { let d, f = 0; const h = () => this.root.updateBlockedByResize = !1; Ri.read(() => { f = window.innerWidth }), t(s, () => { const m = window.innerWidth; m !== f && (f = m, this.root.updateBlockedByResize = !0, d && d(), d = yEe(h, 250), CT.hasAnimatedSinceResize && (CT.hasAnimatedSinceResize = !1, this.nodes.forEach(iH))) }) } o && this.root.registerSharedNode(o, this), this.options.animate !== !1 && u && (o || c) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeLayoutChanged: h, layout: m }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const g = this.options.transition || u.getDefaultTransition() || VEe, { onLayoutAnimationStart: x, onLayoutAnimationComplete: v } = u.getProps(), b = !this.targetLayout || !Lne(this.targetLayout, m), E = !f && h; if (this.options.layoutRoot || this.resumeFrom || E || f && (b || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const M = { ...oU(g, "layout"), onPlay: x, onComplete: v }; (u.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M), this.setAnimationOrigin(d, E) } else f || iH(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = m }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), ep(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(UEe), this.animationId++) } getTransformTemplate() { const { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Fne(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let d = 0; d < this.path.length; d++) { const f = this.path[d]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } const { layoutId: o, layout: c } = this.options; if (o === void 0 && !c) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(nH); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(rH); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(DEe), this.nodes.forEach(jEe), this.nodes.forEach(REe)) : this.nodes.forEach(rH), this.clearAllSnapshots(); const o = Do.now(); ls.delta = gf(0, 1e3 / 60, o - ls.timestamp), ls.timestamp = o, ls.isProcessing = !0, kj.update.process(ls), kj.preRender.process(ls), kj.render.process(ls), ls.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, cU.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(OEe), this.sharedNodes.forEach(BEe) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Ri.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Ri.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Qs(this.snapshot.measuredBox.x) && !Qs(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let c = 0; c < this.path.length; c++)this.path[c].updateScroll(); const s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = na(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: o } = this.options; o && o.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let o = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (o = !1), o && this.instance) { const c = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: s, isRoot: c, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : c } } } resetTransform() { if (!i) return; const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, o = this.projectionDelta && !Dne(this.projectionDelta), c = this.getTransformTemplate(), u = c ? c(this.latestValues, "") : void 0, d = u !== this.prevTransformTemplateValue; s && this.instance && (o || Dm(this.latestValues) || d) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { const o = this.measurePageBox(); let c = this.removeElementScroll(o); return s && (c = this.removeTransform(c)), HEe(c), { animationId: this.root.animationId, measuredBox: o, layoutBox: c, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: s } = this.options; if (!s) return na(); const o = s.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(WEe))) { const { scroll: u } = this.root; u && (Oy(o.x, u.offset.x), Oy(o.y, u.offset.y)) } return o } removeElementScroll(s) { const o = na(); if (Al(o, s), this.scroll?.wasRoot) return o; for (let c = 0; c < this.path.length; c++) { const u = this.path[c], { scroll: d, options: f } = u; u !== this.root && d && f.layoutScroll && (d.wasRoot && Al(o, s), Oy(o.x, d.offset.x), Oy(o.y, d.offset.y)) } return o } applyTransform(s, o = !1) { const c = na(); Al(c, s); for (let u = 0; u < this.path.length; u++) { const d = this.path[u]; !o && d.options.layoutScroll && d.scroll && d !== d.root && Dy(c, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), Dm(d.latestValues) && Dy(c, d.latestValues) } return Dm(this.latestValues) && Dy(c, this.latestValues), c } removeTransform(s) { const o = na(); Al(o, s); for (let c = 0; c < this.path.length; c++) { const u = this.path[c]; if (!u.instance || !Dm(u.latestValues)) continue; EL(u.latestValues) && u.updateSnapshot(); const d = na(), f = u.measurePageBox(); Al(d, f), KV(o, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, d) } return Dm(this.latestValues) && KV(o, this.latestValues), o } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== ls.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { const o = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = o.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = o.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = o.isSharedProjectionDirty); const c = !!this.resumingFrom || this !== o; if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: d, layoutId: f } = this.options; if (!(!this.layout || !(d || f))) { if (this.resolvedRelativeTargetAt = ls.timestamp, !this.targetDelta && !this.relativeTarget) { const h = this.getClosestProjectingParent(); h && h.layout && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = na(), this.relativeTargetOrigin = na(), Hw(this.relativeTargetOrigin, this.layout.layoutBox, h.layout.layoutBox), Al(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = na(), this.targetWithTransforms = na()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Z_e(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Al(this.target, this.layout.layoutBox), vne(this.target, this.targetDelta)) : Al(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) { this.attemptToResolveRelativeTarget = !1; const h = this.getClosestProjectingParent(); h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = na(), this.relativeTargetOrigin = na(), Hw(this.relativeTargetOrigin, this.target, h.target), Al(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } } } getClosestProjectingParent() { if (!(!this.parent || EL(this.parent.latestValues) || gne(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { const s = this.getLead(), o = !!this.resumingFrom || this !== s; let c = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (c = !1), o && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === ls.timestamp && (c = !1), c) return; const { layout: u, layoutId: d } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d)) return; Al(this.layoutCorrected, this.layout.layoutBox); const f = this.treeScale.x, h = this.treeScale.y; c_e(this.layoutCorrected, this.treeScale, this.path, o), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox, s.targetWithTransforms = na()); const { target: m } = s; if (!m) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (qV(this.prevProjectionDelta.x, this.projectionDelta.x), qV(this.prevProjectionDelta.y, this.projectionDelta.y)), Vw(this.projectionDelta, this.layoutCorrected, m, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== h || !tH(this.projectionDelta.x, this.prevProjectionDelta.x) || !tH(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", m)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { if (this.options.visualElement?.scheduleRender(), s) { const o = this.getStack(); o && o.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Ly(), this.projectionDelta = Ly(), this.projectionDeltaWithTransform = Ly() } setAnimationOrigin(s, o = !1) { const c = this.snapshot, u = c ? c.latestValues : {}, d = { ...this.latestValues }, f = Ly(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !o; const h = na(), m = c ? c.source : void 0, g = this.layout ? this.layout.source : void 0, x = m !== g, v = this.getStack(), b = !v || v.members.length <= 1, E = !!(x && !b && this.options.crossfade === !0 && !this.path.some(zEe)); this.animationProgress = 0; let M; this.mixTargetDelta = C => { const N = C / 1e3; aH(f.x, s.x, N), aH(f.y, s.y, N), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Hw(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), $Ee(this.relativeTarget, this.relativeTargetOrigin, h, N), M && TEe(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = na()), Al(M, this.relativeTarget)), x && (this.animationValues = d, bEe(d, u, this.latestValues, N, E, b)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = N }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (ep(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ri.update(() => { CT.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = hx(0)), this.currentAnimation = mEe(this.motionValue, [0, 1e3], { ...s, velocity: 0, isSync: !0, onUpdate: o => { this.mixTargetDelta(o), s.onUpdate && s.onUpdate(o) }, onStop: () => { }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(AEe), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const s = this.getLead(); let { targetWithTransforms: o, target: c, layout: u, latestValues: d } = s; if (!(!o || !c || !u)) { if (this !== s && this.layout && u && Bne(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { c = this.target || na(); const f = Qs(this.layout.layoutBox.x); c.x.min = s.target.x.min, c.x.max = c.x.min + f; const h = Qs(this.layout.layoutBox.y); c.y.min = s.target.y.min, c.y.max = c.y.min + h } Al(o, c), Dy(o, d), Vw(this.projectionDeltaWithTransform, this.layoutCorrected, o, d) } } registerSharedNode(s, o) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new CEe), this.sharedNodes.get(s).add(o); const u = o.options.initialPromotionConfig; o.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(o) : void 0 }) } isLead() { const s = this.getStack(); return s ? s.lead === this : !0 } getLead() { const { layoutId: s } = this.options; return s ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: s } = this.options; return s ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: o, preserveFollowOpacity: c } = {}) { const u = this.getStack(); u && u.promote(this, c), s && (this.projectionDelta = void 0, this.needsReset = !0), o && this.setOptions({ transition: o }) } relegate() { const s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: s } = this.options; if (!s) return; let o = !1; const { latestValues: c } = s; if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (o = !0), !o) return; const u = {}; c.z && Wj("z", s, u, this.animationValues); for (let d = 0; d < Hj.length; d++)Wj(`rotate${Hj[d]}`, s, u, this.animationValues), Wj(`skew${Hj[d]}`, s, u, this.animationValues); s.render(); for (const d in u) s.setStaticValue(d, u[d]), this.animationValues && (this.animationValues[d] = u[d]); s.scheduleRender() } applyProjectionStyles(s, o) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { s.visibility = "hidden"; return } const c = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, s.visibility = "", s.opacity = "", s.pointerEvents = TT(o?.pointerEvents) || "", s.transform = c ? c(this.latestValues, "") : "none"; return } const u = this.getLead(); if (!this.projectionDelta || !this.layout || !u.target) { this.options.layoutId && (s.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, s.pointerEvents = TT(o?.pointerEvents) || ""), this.hasProjected && !Dm(this.latestValues) && (s.transform = c ? c({}, "") : "none", this.hasProjected = !1); return } s.visibility = ""; const d = u.animationValues || u.latestValues; this.applyTransformsToTarget(); let f = NEe(this.projectionDeltaWithTransform, this.treeScale, d); c && (f = c(d, f)), s.transform = f; const { x: h, y: m } = this.projectionDelta; s.transformOrigin = `${h.origin * 100}% ${m.origin * 100}% 0`, u.animationValues ? s.opacity = u === this ? d.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : s.opacity = u === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0; for (const g in M1) { if (d[g] === void 0) continue; const { correct: x, applyTo: v, isCSSVariable: b } = M1[g], E = f === "none" ? d[g] : x(d[g], u); if (v) { const M = v.length; for (let C = 0; C < M; C++)s[v[C]] = E } else b ? this.options.visualElement.renderState.vars[g] = E : s[g] = E } this.options.layoutId && (s.pointerEvents = u === this ? TT(o?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => s.currentAnimation?.stop()), this.root.nodes.forEach(nH), this.root.sharedNodes.clear() } } } function jEe(t) { t.updateLayout() } function REe(t) { const e = t.resumeFrom?.snapshot || t.snapshot; if (t.isLead() && t.layout && e && t.hasListeners("didUpdate")) { const { layoutBox: n, measuredBox: r } = t.layout, { animationType: i } = t.options, a = e.source !== t.layout.source; i === "size" ? Il(d => { const f = a ? e.measuredBox[d] : e.layoutBox[d], h = Qs(f); f.min = n[d].min, f.max = f.min + h }) : Bne(i, e.layoutBox, n) && Il(d => { const f = a ? e.measuredBox[d] : e.layoutBox[d], h = Qs(n[d]); f.max = f.min + h, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[d].max = t.relativeTarget[d].min + h) }); const s = Ly(); Vw(s, n, e.layoutBox); const o = Ly(); a ? Vw(o, t.applyTransform(r, !0), e.measuredBox) : Vw(o, n, e.layoutBox); const c = !Dne(s); let u = !1; if (!t.resumeFrom) { const d = t.getClosestProjectingParent(); if (d && !d.resumeFrom) { const { snapshot: f, layout: h } = d; if (f && h) { const m = na(); Hw(m, e.layoutBox, f.layoutBox); const g = na(); Hw(g, n, h.layoutBox), Lne(m, g) || (u = !0), d.options.layoutRoot && (t.relativeTarget = g, t.relativeTargetOrigin = m, t.relativeParent = d) } } } t.notifyListeners("didUpdate", { layout: n, snapshot: e, delta: o, layoutDelta: s, hasLayoutChanged: c, hasRelativeLayoutChanged: u }) } else if (t.isLead()) { const { onExitComplete: n } = t.options; n && n() } t.options.transition = void 0 } function kEe(t) { t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function IEe(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function OEe(t) { t.clearSnapshot() } function nH(t) { t.clearMeasurements() } function rH(t) { t.isLayoutDirty = !1 } function DEe(t) { const { visualElement: e } = t.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform() } function iH(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function LEe(t) { t.resolveTargetDelta() } function FEe(t) { t.calcProjection() } function UEe(t) { t.resetSkewAndRotation() } function BEe(t) { t.removeLeadSnapshot() } function aH(t, e, n) { t.translate = Li(e.translate, 0, n), t.scale = Li(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint } function sH(t, e, n, r) { t.min = Li(e.min, n.min, r), t.max = Li(e.max, n.max, r) } function $Ee(t, e, n, r) { sH(t.x, e.x, n.x, r), sH(t.y, e.y, n.y, r) } function zEe(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const VEe = { duration: .45, ease: [.4, 0, .1, 1] }, oH = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), lH = oH("applewebkit/") && !oH("chrome/") ? Math.round : zl; function cH(t) { t.min = lH(t.min), t.max = lH(t.max) } function HEe(t) { cH(t.x), cH(t.y) } function Bne(t, e, n) { return t === "position" || t === "preserve-aspect" && !K_e(eH(e), eH(n), .2) } function WEe(t) { return t !== t.root && t.scroll?.wasRoot } const GEe = Une({ attachResizeListener: (t, e) => T1(t, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Gj = { current: void 0 }, $ne = Une({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!Gj.current) { const t = new GEe({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), Gj.current = t } return Gj.current }, resetTransform: (t, e) => { t.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), qEe = { pan: { Feature: dEe }, drag: { Feature: uEe, ProjectionNode: $ne, MeasureLayout: kne } }; function uH(t, e, n) { const { props: r } = t; t.animationState && r.whileHover && t.animationState.setActive("whileHover", n === "Start"); const i = "onHover" + n, a = r[i]; a && Ri.postRender(() => a(e, KS(e))) } class XEe extends hp { mount() { const { current: e } = this.node; e && (this.unmount = mSe(e, (n, r) => (uH(this.node, r, "Start"), i => uH(this.node, i, "End")))) } unmount() { } } class YEe extends hp { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = GS(T1(this.node.current, "focus", () => this.onFocus()), T1(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function dH(t, e, n) { const { props: r } = t; if (t.current instanceof HTMLButtonElement && t.current.disabled) return; t.animationState && r.whileTap && t.animationState.setActive("whileTap", n === "Start"); const i = "onTap" + (n === "End" ? "" : n), a = r[i]; a && Ri.postRender(() => a(e, KS(e))) } class KEe extends hp { mount() { const { current: e } = this.node; e && (this.unmount = xSe(e, (n, r) => (dH(this.node, r, "Start"), (i, { success: a }) => dH(this.node, i, a ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const jL = new WeakMap, qj = new WeakMap, ZEe = t => { const e = jL.get(t.target); e && e(t) }, QEe = t => { t.forEach(ZEe) }; function JEe({ root: t, ...e }) { const n = t || document; qj.has(n) || qj.set(n, {}); const r = qj.get(n), i = JSON.stringify(e); return r[i] || (r[i] = new IntersectionObserver(QEe, { root: t, ...e })), r[i] } function eMe(t, e, n) { const r = JEe(e); return jL.set(t, n), r.observe(t), () => { jL.delete(t), r.unobserve(t) } } const tMe = { some: 0, all: 1 }; class nMe extends hp { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: a } = e, s = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : tMe[i] }, o = c => { const { isIntersecting: u } = c; if (this.isInView === u || (this.isInView = u, a && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: d, onViewportLeave: f } = this.node.getProps(), h = u ? d : f; h && h(c) }; return eMe(this.node.current, s, o) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: n } = this.node;["amount", "margin", "root"].some(rMe(e, n)) && this.startObserver() } unmount() { } } function rMe({ viewport: t = {} }, { viewport: e = {} } = {}) { return n => t[n] !== e[n] } const iMe = { inView: { Feature: nMe }, tap: { Feature: KEe }, focus: { Feature: YEe }, hover: { Feature: XEe } }, aMe = { layout: { ProjectionNode: $ne, MeasureLayout: kne } }, sMe = { ...H_e, ...iMe, ...qEe, ...aMe }, $e = s_e(sMe, x_e); function oMe(t) { const [e, n] = S.useState(""), r = 64, i = 200; return S.useEffect(() => { if (t.length === 0) return; const a = () => { const d = window.scrollY, f = d + r + i, h = t.map(g => { const x = document.getElementById(g); if (!x) return null; const v = x.getBoundingClientRect(), b = v.top + d, E = b + v.height; return { id: g, top: b, bottom: E } }).filter(g => g !== null).sort((g, x) => g.top - x.top); if (h.length === 0) return; let m = h[0]; if (d < 50) { e !== h[0].id && n(h[0].id); return } for (let g = 0; g < h.length; g++) { const x = h[g]; if (x.top <= f) { if (g < h.length - 1) { const v = h[g + 1]; if (v.top <= f) { const b = Math.abs(x.top - f); if (Math.abs(v.top - f) < b) { m = v; continue } } } m = x } else break } m.id && e !== m.id && n(m.id) }; let s = !1; const o = () => { s || (requestAnimationFrame(() => { a(), s = !1 }), s = !0) }, c = setTimeout(a, 100); window.addEventListener("scroll", o, { passive: !0 }); const u = () => { setTimeout(a, 100) }; return window.addEventListener("resize", u), () => { clearTimeout(c), window.removeEventListener("scroll", o), window.removeEventListener("resize", u) } }, [t, e, r, i]), e } const cr = { HOME: "/", LOGIN: "/login", FORGOT_PASSWORD: "/forgot-password", RESET_PASSWORD: "/reset-password", PRICING: "/pricing", RESOURCES: "/resources", FAQ: "/faq", STYLE_GUIDE: "/styleguide", PENDING_VERIFICATION: "/pending-verification", REJECTED_NOTICE: "/rejected-notice", OAUTH_ROLE_SELECTION: "/oauth/select-role", UNAUTHORIZED: "/unauthorized", TRAINEE_DASHBOARD: "/dashboard/trainee", TRAINEE_SCHEDULE: "/dashboard/trainee/schedule", TRAINEE_SESSIONS: "/dashboard/trainee/sessions", TRAINEE_FEEDBACK: "/dashboard/trainee/feedback", INTERVIEWER_DASHBOARD: "/dashboard/interviewer", INTERVIEWER_ASSIGNED: "/dashboard/interviewer/assigned", INTERVIEWER_CALENDAR: "/dashboard/interviewer/calendar", INTERVIEWER_FEEDBACK: "/dashboard/interviewer/feedback", ADMIN_DASHBOARD: "/dashboard/admin", ADMIN_USERS: "/dashboard/admin/users", ADMIN_INTERVIEWS: "/dashboard/admin/interviews", ADMIN_RESOURCES: "/dashboard/admin/resources", ADMIN_NOTIFICATIONS: "/dashboard/admin/notifications", NOT_FOUND: "*" }; function lMe(t) { switch (t) { case "admin": case "super_admin": case "hr_admin": return cr.ADMIN_DASHBOARD; case "interviewer": return cr.INTERVIEWER_DASHBOARD; case "trainee": default: return cr.TRAINEE_DASHBOARD } } function zne() { const t = ui(), e = fs(); return { navigateToSection: (i, a) => { const s = i.replace(/^#/, ""); if (e.pathname === "/") { setTimeout(() => { const o = document.getElementById(s); if (o) { const d = o.getBoundingClientRect().top + window.pageYOffset - 64; window.scrollTo({ top: Math.max(0, d), behavior: "smooth" }), window.history.replaceState(null, "", `#${s}`); const f = () => { window.dispatchEvent(new Event("scroll")) }; f(), setTimeout(f, 200), setTimeout(f, 400), setTimeout(f, 600), setTimeout(f, 800) } }, 50); return } t("/", { state: { scrollTo: s }, replace: a?.replace }) }, navigateToPage: (i, a) => { t(i, { replace: a?.replace }) } } } var cMe = S.createContext(void 0); function pp(t) { const e = S.useContext(cMe); return t || e || "ltr" } var Xj = 0; function wU() { S.useEffect(() => { const t = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", t[0] ?? fH()), document.body.insertAdjacentElement("beforeend", t[1] ?? fH()), Xj++, () => { Xj === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()), Xj-- } }, []) } function fH() { const t = document.createElement("span"); return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t } var Yj = "focusScope.autoFocusOnMount", Kj = "focusScope.autoFocusOnUnmount", hH = { bubbles: !1, cancelable: !0 }, uMe = "FocusScope", PA = S.forwardRef((t, e) => { const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: a, ...s } = t, [o, c] = S.useState(null), u = Yi(i), d = Yi(a), f = S.useRef(null), h = Mn(e, x => c(x)), m = S.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; S.useEffect(() => { if (r) { let x = function (M) { if (m.paused || !o) return; const C = M.target; o.contains(C) ? f.current = C : Th(f.current, { select: !0 }) }, v = function (M) { if (m.paused || !o) return; const C = M.relatedTarget; C !== null && (o.contains(C) || Th(f.current, { select: !0 })) }, b = function (M) { if (document.activeElement === document.body) for (const N of M) N.removedNodes.length > 0 && Th(o) }; document.addEventListener("focusin", x), document.addEventListener("focusout", v); const E = new MutationObserver(b); return o && E.observe(o, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", x), document.removeEventListener("focusout", v), E.disconnect() } } }, [r, o, m.paused]), S.useEffect(() => { if (o) { mH.add(m); const x = document.activeElement; if (!o.contains(x)) { const b = new CustomEvent(Yj, hH); o.addEventListener(Yj, u), o.dispatchEvent(b), b.defaultPrevented || (dMe(gMe(Vne(o)), { select: !0 }), document.activeElement === x && Th(o)) } return () => { o.removeEventListener(Yj, u), setTimeout(() => { const b = new CustomEvent(Kj, hH); o.addEventListener(Kj, d), o.dispatchEvent(b), b.defaultPrevented || Th(x ?? document.body, { select: !0 }), o.removeEventListener(Kj, d), mH.remove(m) }, 0) } } }, [o, u, d, m]); const g = S.useCallback(x => { if (!n && !r || m.paused) return; const v = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, b = document.activeElement; if (v && b) { const E = x.currentTarget, [M, C] = fMe(E); M && C ? !x.shiftKey && b === C ? (x.preventDefault(), n && Th(M, { select: !0 })) : x.shiftKey && b === M && (x.preventDefault(), n && Th(C, { select: !0 })) : b === E && x.preventDefault() } }, [n, r, m.paused]); return l.jsx(qt.div, { tabIndex: -1, ...s, ref: h, onKeyDown: g }) }); PA.displayName = uMe; function dMe(t, { select: e = !1 } = {}) { const n = document.activeElement; for (const r of t) if (Th(r, { select: e }), document.activeElement !== n) return } function fMe(t) { const e = Vne(t), n = pH(e, t), r = pH(e.reverse(), t); return [n, r] } function Vne(t) { const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const i = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)e.push(n.currentNode); return e } function pH(t, e) { for (const n of t) if (!hMe(n, { upTo: e })) return n } function hMe(t, { upTo: e }) { if (getComputedStyle(t).visibility === "hidden") return !0; for (; t;) { if (e !== void 0 && t === e) return !1; if (getComputedStyle(t).display === "none") return !0; t = t.parentElement } return !1 } function pMe(t) { return t instanceof HTMLInputElement && "select" in t } function Th(t, { select: e = !1 } = {}) { if (t && t.focus) { const n = document.activeElement; t.focus({ preventScroll: !0 }), t !== n && pMe(t) && e && t.select() } } var mH = mMe(); function mMe() { let t = []; return { add(e) { const n = t[0]; e !== n && n?.pause(), t = gH(t, e), t.unshift(e) }, remove(e) { t = gH(t, e), t[0]?.resume() } } } function gH(t, e) { const n = [...t], r = n.indexOf(e); return r !== -1 && n.splice(r, 1), n } function gMe(t) { return t.filter(e => e.tagName !== "A") } var Zj = "rovingFocusGroup.onEntryFocus", vMe = { bubbles: !1, cancelable: !0 }, ZS = "RovingFocusGroup", [RL, Hne, yMe] = m0(ZS), [xMe, M0] = oa(ZS, [yMe]), [bMe, wMe] = xMe(ZS), Wne = S.forwardRef((t, e) => l.jsx(RL.Provider, { scope: t.__scopeRovingFocusGroup, children: l.jsx(RL.Slot, { scope: t.__scopeRovingFocusGroup, children: l.jsx(SMe, { ...t, ref: e }) }) })); Wne.displayName = ZS; var SMe = S.forwardRef((t, e) => { const { __scopeRovingFocusGroup: n, orientation: r, loop: i = !1, dir: a, currentTabStopId: s, defaultCurrentTabStopId: o, onCurrentTabStopIdChange: c, onEntryFocus: u, preventScrollOnEntryFocus: d = !1, ...f } = t, h = S.useRef(null), m = Mn(e, h), g = pp(a), [x, v] = Uo({ prop: s, defaultProp: o ?? null, onChange: c, caller: ZS }), [b, E] = S.useState(!1), M = Yi(u), C = Hne(n), N = S.useRef(!1), [A, j] = S.useState(0); return S.useEffect(() => { const O = h.current; if (O) return O.addEventListener(Zj, M), () => O.removeEventListener(Zj, M) }, [M]), l.jsx(bMe, { scope: n, orientation: r, dir: g, loop: i, currentTabStopId: x, onItemFocus: S.useCallback(O => v(O), [v]), onItemShiftTab: S.useCallback(() => E(!0), []), onFocusableItemAdd: S.useCallback(() => j(O => O + 1), []), onFocusableItemRemove: S.useCallback(() => j(O => O - 1), []), children: l.jsx(qt.div, { tabIndex: b || A === 0 ? -1 : 0, "data-orientation": r, ...f, ref: m, style: { outline: "none", ...t.style }, onMouseDown: Mt(t.onMouseDown, () => { N.current = !0 }), onFocus: Mt(t.onFocus, O => { const I = !N.current; if (O.target === O.currentTarget && I && !b) { const D = new CustomEvent(Zj, vMe); if (O.currentTarget.dispatchEvent(D), !D.defaultPrevented) { const F = C().filter(Y => Y.focusable), B = F.find(Y => Y.active), G = F.find(Y => Y.id === x), q = [B, G, ...F].filter(Boolean).map(Y => Y.ref.current); Xne(q, d) } } N.current = !1 }), onBlur: Mt(t.onBlur, () => E(!1)) }) }) }), Gne = "RovingFocusGroupItem", qne = S.forwardRef((t, e) => { const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: a, children: s, ...o } = t, c = $l(), u = a || c, d = wMe(Gne, n), f = d.currentTabStopId === u, h = Hne(n), { onFocusableItemAdd: m, onFocusableItemRemove: g, currentTabStopId: x } = d; return S.useEffect(() => { if (r) return m(), () => g() }, [r, m, g]), l.jsx(RL.ItemSlot, { scope: n, id: u, focusable: r, active: i, children: l.jsx(qt.span, { tabIndex: f ? 0 : -1, "data-orientation": d.orientation, ...o, ref: e, onMouseDown: Mt(t.onMouseDown, v => { r ? d.onItemFocus(u) : v.preventDefault() }), onFocus: Mt(t.onFocus, () => d.onItemFocus(u)), onKeyDown: Mt(t.onKeyDown, v => { if (v.key === "Tab" && v.shiftKey) { d.onItemShiftTab(); return } if (v.target !== v.currentTarget) return; const b = MMe(v, d.orientation, d.dir); if (b !== void 0) { if (v.metaKey || v.ctrlKey || v.altKey || v.shiftKey) return; v.preventDefault(); let M = h().filter(C => C.focusable).map(C => C.ref.current); if (b === "last") M.reverse(); else if (b === "prev" || b === "next") { b === "prev" && M.reverse(); const C = M.indexOf(v.currentTarget); M = d.loop ? TMe(M, C + 1) : M.slice(C + 1) } setTimeout(() => Xne(M)) } }), children: typeof s == "function" ? s({ isCurrentTabStop: f, hasTabStop: x != null }) : s }) }) }); qne.displayName = Gne; var _Me = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }; function EMe(t, e) { return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t } function MMe(t, e, n) { const r = EMe(t.key, n); if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))) return _Me[r] } function Xne(t, e = !1) { const n = document.activeElement; for (const r of t) if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return } function TMe(t, e) { return t.map((n, r) => t[(e + r) % t.length]) } var SU = Wne, _U = qne, CMe = function (t) { if (typeof document > "u") return null; var e = Array.isArray(t) ? t[0] : t; return e.ownerDocument.body }, Zv = new WeakMap, GE = new WeakMap, qE = {}, Qj = 0, Yne = function (t) { return t && (t.host || Yne(t.parentNode)) }, NMe = function (t, e) { return e.map(function (n) { if (t.contains(n)) return n; var r = Yne(n); return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null) }).filter(function (n) { return !!n }) }, AMe = function (t, e, n, r) { var i = NMe(e, Array.isArray(t) ? t : [t]); qE[n] || (qE[n] = new WeakMap); var a = qE[n], s = [], o = new Set, c = new Set(i), u = function (f) { !f || o.has(f) || (o.add(f), u(f.parentNode)) }; i.forEach(u); var d = function (f) { !f || c.has(f) || Array.prototype.forEach.call(f.children, function (h) { if (o.has(h)) d(h); else try { var m = h.getAttribute(r), g = m !== null && m !== "false", x = (Zv.get(h) || 0) + 1, v = (a.get(h) || 0) + 1; Zv.set(h, x), a.set(h, v), s.push(h), x === 1 && g && GE.set(h, !0), v === 1 && h.setAttribute(n, "true"), g || h.setAttribute(r, "true") } catch (b) { console.error("aria-hidden: cannot operate on ", h, b) } }) }; return d(e), o.clear(), Qj++, function () { s.forEach(function (f) { var h = Zv.get(f) - 1, m = a.get(f) - 1; Zv.set(f, h), a.set(f, m), h || (GE.has(f) || f.removeAttribute(r), GE.delete(f)), m || f.removeAttribute(n) }), Qj--, Qj || (Zv = new WeakMap, Zv = new WeakMap, GE = new WeakMap, qE = {}) } }, EU = function (t, e, n) { n === void 0 && (n = "data-aria-hidden"); var r = Array.from(Array.isArray(t) ? t : [t]), i = CMe(t); return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), AMe(r, i, n, "aria-hidden")) : function () { return null } }, gu = function () { return gu = Object.assign || function (e) { for (var n, r = 1, i = arguments.length; r < i; r++) { n = arguments[r]; for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]) } return e }, gu.apply(this, arguments) }; function Et(t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n } function PMe(t, e, n) { if (n || arguments.length === 2) for (var r = 0, i = e.length, a; r < i; r++)(a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), a[r] = e[r]); return t.concat(a || Array.prototype.slice.call(e)) } var NT = "right-scroll-bar-position", AT = "width-before-scroll-bar", jMe = "with-scroll-bars-hidden", RMe = "--removed-body-scroll-bar-size"; function Jj(t, e) { return typeof t == "function" ? t(e) : t && (t.current = e), t } function kMe(t, e) { var n = S.useState(function () { return { value: t, callback: e, facade: { get current() { return n.value }, set current(r) { var i = n.value; i !== r && (n.value = r, n.callback(r, i)) } } } })[0]; return n.callback = e, n.facade } var IMe = typeof window < "u" ? S.useLayoutEffect : S.useEffect, vH = new WeakMap; function OMe(t, e) { var n = kMe(null, function (r) { return t.forEach(function (i) { return Jj(i, r) }) }); return IMe(function () { var r = vH.get(n); if (r) { var i = new Set(r), a = new Set(t), s = n.current; i.forEach(function (o) { a.has(o) || Jj(o, null) }), a.forEach(function (o) { i.has(o) || Jj(o, s) }) } vH.set(n, t) }, [t]), n } function DMe(t) { return t } function LMe(t, e) { e === void 0 && (e = DMe); var n = [], r = !1, i = { read: function () { if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return n.length ? n[n.length - 1] : t }, useMedium: function (a) { var s = e(a, r); return n.push(s), function () { n = n.filter(function (o) { return o !== s }) } }, assignSyncMedium: function (a) { for (r = !0; n.length;) { var s = n; n = [], s.forEach(a) } n = { push: function (o) { return a(o) }, filter: function () { return n } } }, assignMedium: function (a) { r = !0; var s = []; if (n.length) { var o = n; n = [], o.forEach(a), s = n } var c = function () { var d = s; s = [], d.forEach(a) }, u = function () { return Promise.resolve().then(c) }; u(), n = { push: function (d) { s.push(d), u() }, filter: function (d) { return s = s.filter(d), n } } } }; return i } function FMe(t) { t === void 0 && (t = {}); var e = LMe(null); return e.options = gu({ async: !0, ssr: !1 }, t), e } var Kne = function (t) { var e = t.sideCar, n = Et(t, ["sideCar"]); if (!e) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var r = e.read(); if (!r) throw new Error("Sidecar medium not found"); return S.createElement(r, gu({}, n)) }; Kne.isSideCarExport = !0; function UMe(t, e) { return t.useMedium(e), Kne } var Zne = FMe(), eR = function () { }, jA = S.forwardRef(function (t, e) { var n = S.useRef(null), r = S.useState({ onScrollCapture: eR, onWheelCapture: eR, onTouchMoveCapture: eR }), i = r[0], a = r[1], s = t.forwardProps, o = t.children, c = t.className, u = t.removeScrollBar, d = t.enabled, f = t.shards, h = t.sideCar, m = t.noRelative, g = t.noIsolation, x = t.inert, v = t.allowPinchZoom, b = t.as, E = b === void 0 ? "div" : b, M = t.gapMode, C = Et(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), N = h, A = OMe([n, e]), j = gu(gu({}, C), i); return S.createElement(S.Fragment, null, d && S.createElement(N, { sideCar: Zne, removeScrollBar: u, shards: f, noRelative: m, noIsolation: g, inert: x, setCallbacks: a, allowPinchZoom: !!v, lockRef: n, gapMode: M }), s ? S.cloneElement(S.Children.only(o), gu(gu({}, j), { ref: A })) : S.createElement(E, gu({}, j, { className: c, ref: A }), o)) }); jA.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; jA.classNames = { fullWidth: AT, zeroRight: NT }; var BMe = function () { if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function $Me() { if (!document) return null; var t = document.createElement("style"); t.type = "text/css"; var e = BMe(); return e && t.setAttribute("nonce", e), t } function zMe(t, e) { t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e)) } function VMe(t) { var e = document.head || document.getElementsByTagName("head")[0]; e.appendChild(t) } var HMe = function () { var t = 0, e = null; return { add: function (n) { t == 0 && (e = $Me()) && (zMe(e, n), VMe(e)), t++ }, remove: function () { t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null) } } }, WMe = function () { var t = HMe(); return function (e, n) { S.useEffect(function () { return t.add(e), function () { t.remove() } }, [e && n]) } }, Qne = function () { var t = WMe(), e = function (n) { var r = n.styles, i = n.dynamic; return t(r, i), null }; return e }, GMe = { left: 0, top: 0, right: 0, gap: 0 }, tR = function (t) { return parseInt(t || "", 10) || 0 }, qMe = function (t) { var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], i = e[t === "padding" ? "paddingRight" : "marginRight"]; return [tR(n), tR(r), tR(i)] }, XMe = function (t) { if (t === void 0 && (t = "margin"), typeof window > "u") return GMe; var e = qMe(t), n = document.documentElement.clientWidth, r = window.innerWidth; return { left: e[0], top: e[1], right: e[2], gap: Math.max(0, r - n + e[2] - e[0]) } }, YMe = Qne(), Qy = "data-scroll-locked", KMe = function (t, e, n, r) {
	var i = t.left, a = t.top, s = t.right, o = t.gap; return n === void 0 && (n = "margin"), `
  .`.concat(jMe, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(o, "px ").concat(r, `;
  }
  body[`).concat(Qy, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(o, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(o, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(NT, ` {
    right: `).concat(o, "px ").concat(r, `;
  }
  
  .`).concat(AT, ` {
    margin-right: `).concat(o, "px ").concat(r, `;
  }
  
  .`).concat(NT, " .").concat(NT, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(AT, " .").concat(AT, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Qy, `] {
    `).concat(RMe, ": ").concat(o, `px;
  }
`)
}, yH = function () { var t = parseInt(document.body.getAttribute(Qy) || "0", 10); return isFinite(t) ? t : 0 }, ZMe = function () { S.useEffect(function () { return document.body.setAttribute(Qy, (yH() + 1).toString()), function () { var t = yH() - 1; t <= 0 ? document.body.removeAttribute(Qy) : document.body.setAttribute(Qy, t.toString()) } }, []) }, QMe = function (t) { var e = t.noRelative, n = t.noImportant, r = t.gapMode, i = r === void 0 ? "margin" : r; ZMe(); var a = S.useMemo(function () { return XMe(i) }, [i]); return S.createElement(YMe, { styles: KMe(a, !e, i, n ? "" : "!important") }) }, kL = !1; if (typeof window < "u") try { var XE = Object.defineProperty({}, "passive", { get: function () { return kL = !0, !0 } }); window.addEventListener("test", XE, XE), window.removeEventListener("test", XE, XE) } catch { kL = !1 } var Qv = kL ? { passive: !1 } : !1, JMe = function (t) { return t.tagName === "TEXTAREA" }, Jne = function (t, e) { if (!(t instanceof Element)) return !1; var n = window.getComputedStyle(t); return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !JMe(t) && n[e] === "visible") }, eTe = function (t) { return Jne(t, "overflowY") }, tTe = function (t) { return Jne(t, "overflowX") }, xH = function (t, e) { var n = e.ownerDocument, r = e; do { typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host); var i = ere(t, r); if (i) { var a = tre(t, r), s = a[1], o = a[2]; if (s > o) return !0 } r = r.parentNode } while (r && r !== n.body); return !1 }, nTe = function (t) { var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight; return [e, n, r] }, rTe = function (t) { var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth; return [e, n, r] }, ere = function (t, e) { return t === "v" ? eTe(e) : tTe(e) }, tre = function (t, e) { return t === "v" ? nTe(e) : rTe(e) }, iTe = function (t, e) { return t === "h" && e === "rtl" ? -1 : 1 }, aTe = function (t, e, n, r, i) { var a = iTe(t, window.getComputedStyle(e).direction), s = a * r, o = n.target, c = e.contains(o), u = !1, d = s > 0, f = 0, h = 0; do { if (!o) break; var m = tre(t, o), g = m[0], x = m[1], v = m[2], b = x - v - a * g; (g || b) && ere(t, o) && (f += b, h += g); var E = o.parentNode; o = E && E.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? E.host : E } while (!c && o !== document.body || c && (e.contains(o) || e === o)); return (d && Math.abs(f) < 1 || !d && Math.abs(h) < 1) && (u = !0), u }, YE = function (t) { return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0] }, bH = function (t) { return [t.deltaX, t.deltaY] }, wH = function (t) { return t && "current" in t ? t.current : t }, sTe = function (t, e) { return t[0] === e[0] && t[1] === e[1] }, oTe = function (t) {
	return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}, lTe = 0, Jv = []; function cTe(t) { var e = S.useRef([]), n = S.useRef([0, 0]), r = S.useRef(), i = S.useState(lTe++)[0], a = S.useState(Qne)[0], s = S.useRef(t); S.useEffect(function () { s.current = t }, [t]), S.useEffect(function () { if (t.inert) { document.body.classList.add("block-interactivity-".concat(i)); var x = PMe([t.lockRef.current], (t.shards || []).map(wH), !0).filter(Boolean); return x.forEach(function (v) { return v.classList.add("allow-interactivity-".concat(i)) }), function () { document.body.classList.remove("block-interactivity-".concat(i)), x.forEach(function (v) { return v.classList.remove("allow-interactivity-".concat(i)) }) } } }, [t.inert, t.lockRef.current, t.shards]); var o = S.useCallback(function (x, v) { if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey) return !s.current.allowPinchZoom; var b = YE(x), E = n.current, M = "deltaX" in x ? x.deltaX : E[0] - b[0], C = "deltaY" in x ? x.deltaY : E[1] - b[1], N, A = x.target, j = Math.abs(M) > Math.abs(C) ? "h" : "v"; if ("touches" in x && j === "h" && A.type === "range") return !1; var O = xH(j, A); if (!O) return !0; if (O ? N = j : (N = j === "v" ? "h" : "v", O = xH(j, A)), !O) return !1; if (!r.current && "changedTouches" in x && (M || C) && (r.current = N), !N) return !0; var I = r.current || N; return aTe(I, v, x, I === "h" ? M : C) }, []), c = S.useCallback(function (x) { var v = x; if (!(!Jv.length || Jv[Jv.length - 1] !== a)) { var b = "deltaY" in v ? bH(v) : YE(v), E = e.current.filter(function (N) { return N.name === v.type && (N.target === v.target || v.target === N.shadowParent) && sTe(N.delta, b) })[0]; if (E && E.should) { v.cancelable && v.preventDefault(); return } if (!E) { var M = (s.current.shards || []).map(wH).filter(Boolean).filter(function (N) { return N.contains(v.target) }), C = M.length > 0 ? o(v, M[0]) : !s.current.noIsolation; C && v.cancelable && v.preventDefault() } } }, []), u = S.useCallback(function (x, v, b, E) { var M = { name: x, delta: v, target: b, should: E, shadowParent: uTe(b) }; e.current.push(M), setTimeout(function () { e.current = e.current.filter(function (C) { return C !== M }) }, 1) }, []), d = S.useCallback(function (x) { n.current = YE(x), r.current = void 0 }, []), f = S.useCallback(function (x) { u(x.type, bH(x), x.target, o(x, t.lockRef.current)) }, []), h = S.useCallback(function (x) { u(x.type, YE(x), x.target, o(x, t.lockRef.current)) }, []); S.useEffect(function () { return Jv.push(a), t.setCallbacks({ onScrollCapture: f, onWheelCapture: f, onTouchMoveCapture: h }), document.addEventListener("wheel", c, Qv), document.addEventListener("touchmove", c, Qv), document.addEventListener("touchstart", d, Qv), function () { Jv = Jv.filter(function (x) { return x !== a }), document.removeEventListener("wheel", c, Qv), document.removeEventListener("touchmove", c, Qv), document.removeEventListener("touchstart", d, Qv) } }, []); var m = t.removeScrollBar, g = t.inert; return S.createElement(S.Fragment, null, g ? S.createElement(a, { styles: oTe(i) }) : null, m ? S.createElement(QMe, { noRelative: t.noRelative, gapMode: t.gapMode }) : null) } function uTe(t) { for (var e = null; t !== null;)t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode; return e } const dTe = UMe(Zne, cTe); var RA = S.forwardRef(function (t, e) { return S.createElement(jA, gu({}, t, { ref: e, sideCar: dTe })) }); RA.classNames = jA.classNames; var IL = ["Enter", " "], fTe = ["ArrowDown", "PageUp", "Home"], nre = ["ArrowUp", "PageDown", "End"], hTe = [...fTe, ...nre], pTe = { ltr: [...IL, "ArrowRight"], rtl: [...IL, "ArrowLeft"] }, mTe = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] }, QS = "Menu", [C1, gTe, vTe] = m0(QS), [zg, rre] = oa(QS, [vTe, b0, M0]), kA = b0(), ire = M0(), [yTe, Vg] = zg(QS), [xTe, JS] = zg(QS), are = t => { const { __scopeMenu: e, open: n = !1, children: r, dir: i, onOpenChange: a, modal: s = !0 } = t, o = kA(e), [c, u] = S.useState(null), d = S.useRef(!1), f = Yi(a), h = pp(i); return S.useEffect(() => { const m = () => { d.current = !0, document.addEventListener("pointerdown", g, { capture: !0, once: !0 }), document.addEventListener("pointermove", g, { capture: !0, once: !0 }) }, g = () => d.current = !1; return document.addEventListener("keydown", m, { capture: !0 }), () => { document.removeEventListener("keydown", m, { capture: !0 }), document.removeEventListener("pointerdown", g, { capture: !0 }), document.removeEventListener("pointermove", g, { capture: !0 }) } }, []), l.jsx(Vee, { ...o, children: l.jsx(yTe, { scope: e, open: n, onOpenChange: f, content: c, onContentChange: u, children: l.jsx(xTe, { scope: e, onClose: S.useCallback(() => f(!1), [f]), isUsingKeyboardRef: d, dir: h, modal: s, children: r }) }) }) }; are.displayName = QS; var bTe = "MenuAnchor", MU = S.forwardRef((t, e) => { const { __scopeMenu: n, ...r } = t, i = kA(n); return l.jsx(k5, { ...i, ...r, ref: e }) }); MU.displayName = bTe; var TU = "MenuPortal", [wTe, sre] = zg(TU, { forceMount: void 0 }), ore = t => { const { __scopeMenu: e, forceMount: n, children: r, container: i } = t, a = Vg(TU, e); return l.jsx(wTe, { scope: e, forceMount: n, children: l.jsx(Ka, { present: n || a.open, children: l.jsx(zS, { asChild: !0, container: i, children: r }) }) }) }; ore.displayName = TU; var Vl = "MenuContent", [STe, CU] = zg(Vl), lre = S.forwardRef((t, e) => { const n = sre(Vl, t.__scopeMenu), { forceMount: r = n.forceMount, ...i } = t, a = Vg(Vl, t.__scopeMenu), s = JS(Vl, t.__scopeMenu); return l.jsx(C1.Provider, { scope: t.__scopeMenu, children: l.jsx(Ka, { present: r || a.open, children: l.jsx(C1.Slot, { scope: t.__scopeMenu, children: s.modal ? l.jsx(_Te, { ...i, ref: e }) : l.jsx(ETe, { ...i, ref: e }) }) }) }) }), _Te = S.forwardRef((t, e) => { const n = Vg(Vl, t.__scopeMenu), r = S.useRef(null), i = Mn(e, r); return S.useEffect(() => { const a = r.current; if (a) return EU(a) }, []), l.jsx(NU, { ...t, ref: i, trapFocus: n.open, disableOutsidePointerEvents: n.open, disableOutsideScroll: !0, onFocusOutside: Mt(t.onFocusOutside, a => a.preventDefault(), { checkForDefaultPrevented: !1 }), onDismiss: () => n.onOpenChange(!1) }) }), ETe = S.forwardRef((t, e) => { const n = Vg(Vl, t.__scopeMenu); return l.jsx(NU, { ...t, ref: e, trapFocus: !1, disableOutsidePointerEvents: !1, disableOutsideScroll: !1, onDismiss: () => n.onOpenChange(!1) }) }), MTe = xg("MenuContent.ScrollLock"), NU = S.forwardRef((t, e) => { const { __scopeMenu: n, loop: r = !1, trapFocus: i, onOpenAutoFocus: a, onCloseAutoFocus: s, disableOutsidePointerEvents: o, onEntryFocus: c, onEscapeKeyDown: u, onPointerDownOutside: d, onFocusOutside: f, onInteractOutside: h, onDismiss: m, disableOutsideScroll: g, ...x } = t, v = Vg(Vl, n), b = JS(Vl, n), E = kA(n), M = ire(n), C = gTe(n), [N, A] = S.useState(null), j = S.useRef(null), O = Mn(e, j, v.onContentChange), I = S.useRef(0), D = S.useRef(""), F = S.useRef(0), B = S.useRef(null), G = S.useRef("right"), z = S.useRef(0), q = g ? RA : S.Fragment, Y = g ? { as: MTe, allowPinchZoom: !0 } : void 0, Z = V => { const K = D.current + V, X = C().filter(ae => !ae.disabled), Q = document.activeElement, re = X.find(ae => ae.ref.current === Q)?.textValue, ce = X.map(ae => ae.textValue), be = LTe(ce, K, re), de = X.find(ae => ae.textValue === be)?.ref.current; (function ae(se) { D.current = se, window.clearTimeout(I.current), se !== "" && (I.current = window.setTimeout(() => ae(""), 1e3)) })(K), de && setTimeout(() => de.focus()) }; S.useEffect(() => () => window.clearTimeout(I.current), []), wU(); const $ = S.useCallback(V => G.current === B.current?.side && UTe(V, B.current?.area), []); return l.jsx(STe, { scope: n, searchRef: D, onItemEnter: S.useCallback(V => { $(V) && V.preventDefault() }, [$]), onItemLeave: S.useCallback(V => { $(V) || (j.current?.focus(), A(null)) }, [$]), onTriggerLeave: S.useCallback(V => { $(V) && V.preventDefault() }, [$]), pointerGraceTimerRef: F, onPointerGraceIntentChange: S.useCallback(V => { B.current = V }, []), children: l.jsx(q, { ...Y, children: l.jsx(PA, { asChild: !0, trapped: i, onMountAutoFocus: Mt(a, V => { V.preventDefault(), j.current?.focus({ preventScroll: !0 }) }), onUnmountAutoFocus: s, children: l.jsx(g0, { asChild: !0, disableOutsidePointerEvents: o, onEscapeKeyDown: u, onPointerDownOutside: d, onFocusOutside: f, onInteractOutside: h, onDismiss: m, children: l.jsx(SU, { asChild: !0, ...M, dir: b.dir, orientation: "vertical", loop: r, currentTabStopId: N, onCurrentTabStopIdChange: A, onEntryFocus: Mt(c, V => { b.isUsingKeyboardRef.current || V.preventDefault() }), preventScrollOnEntryFocus: !0, children: l.jsx(I5, { role: "menu", "aria-orientation": "vertical", "data-state": Ere(v.open), "data-radix-menu-content": "", dir: b.dir, ...E, ...x, ref: O, style: { outline: "none", ...x.style }, onKeyDown: Mt(x.onKeyDown, V => { const X = V.target.closest("[data-radix-menu-content]") === V.currentTarget, Q = V.ctrlKey || V.altKey || V.metaKey, re = V.key.length === 1; X && (V.key === "Tab" && V.preventDefault(), !Q && re && Z(V.key)); const ce = j.current; if (V.target !== ce || !hTe.includes(V.key)) return; V.preventDefault(); const de = C().filter(ae => !ae.disabled).map(ae => ae.ref.current); nre.includes(V.key) && de.reverse(), OTe(de) }), onBlur: Mt(t.onBlur, V => { V.currentTarget.contains(V.target) || (window.clearTimeout(I.current), D.current = "") }), onPointerMove: Mt(t.onPointerMove, N1(V => { const K = V.target, X = z.current !== V.clientX; if (V.currentTarget.contains(K) && X) { const Q = V.clientX > z.current ? "right" : "left"; G.current = Q, z.current = V.clientX } })) }) }) }) }) }) }) }); lre.displayName = Vl; var TTe = "MenuGroup", AU = S.forwardRef((t, e) => { const { __scopeMenu: n, ...r } = t; return l.jsx(qt.div, { role: "group", ...r, ref: e }) }); AU.displayName = TTe; var CTe = "MenuLabel", cre = S.forwardRef((t, e) => { const { __scopeMenu: n, ...r } = t; return l.jsx(qt.div, { ...r, ref: e }) }); cre.displayName = CTe; var tC = "MenuItem", SH = "menu.itemSelect", IA = S.forwardRef((t, e) => { const { disabled: n = !1, onSelect: r, ...i } = t, a = S.useRef(null), s = JS(tC, t.__scopeMenu), o = CU(tC, t.__scopeMenu), c = Mn(e, a), u = S.useRef(!1), d = () => { const f = a.current; if (!n && f) { const h = new CustomEvent(SH, { bubbles: !0, cancelable: !0 }); f.addEventListener(SH, m => r?.(m), { once: !0 }), v5(f, h), h.defaultPrevented ? u.current = !1 : s.onClose() } }; return l.jsx(ure, { ...i, ref: c, disabled: n, onClick: Mt(t.onClick, d), onPointerDown: f => { t.onPointerDown?.(f), u.current = !0 }, onPointerUp: Mt(t.onPointerUp, f => { u.current || f.currentTarget?.click() }), onKeyDown: Mt(t.onKeyDown, f => { const h = o.searchRef.current !== ""; n || h && f.key === " " || IL.includes(f.key) && (f.currentTarget.click(), f.preventDefault()) }) }) }); IA.displayName = tC; var ure = S.forwardRef((t, e) => { const { __scopeMenu: n, disabled: r = !1, textValue: i, ...a } = t, s = CU(tC, n), o = ire(n), c = S.useRef(null), u = Mn(e, c), [d, f] = S.useState(!1), [h, m] = S.useState(""); return S.useEffect(() => { const g = c.current; g && m((g.textContent ?? "").trim()) }, [a.children]), l.jsx(C1.ItemSlot, { scope: n, disabled: r, textValue: i ?? h, children: l.jsx(_U, { asChild: !0, ...o, focusable: !r, children: l.jsx(qt.div, { role: "menuitem", "data-highlighted": d ? "" : void 0, "aria-disabled": r || void 0, "data-disabled": r ? "" : void 0, ...a, ref: u, onPointerMove: Mt(t.onPointerMove, N1(g => { r ? s.onItemLeave(g) : (s.onItemEnter(g), g.defaultPrevented || g.currentTarget.focus({ preventScroll: !0 })) })), onPointerLeave: Mt(t.onPointerLeave, N1(g => s.onItemLeave(g))), onFocus: Mt(t.onFocus, () => f(!0)), onBlur: Mt(t.onBlur, () => f(!1)) }) }) }) }), NTe = "MenuCheckboxItem", dre = S.forwardRef((t, e) => { const { checked: n = !1, onCheckedChange: r, ...i } = t; return l.jsx(gre, { scope: t.__scopeMenu, checked: n, children: l.jsx(IA, { role: "menuitemcheckbox", "aria-checked": nC(n) ? "mixed" : n, ...i, ref: e, "data-state": jU(n), onSelect: Mt(i.onSelect, () => r?.(nC(n) ? !0 : !n), { checkForDefaultPrevented: !1 }) }) }) }); dre.displayName = NTe; var fre = "MenuRadioGroup", [ATe, PTe] = zg(fre, { value: void 0, onValueChange: () => { } }), hre = S.forwardRef((t, e) => { const { value: n, onValueChange: r, ...i } = t, a = Yi(r); return l.jsx(ATe, { scope: t.__scopeMenu, value: n, onValueChange: a, children: l.jsx(AU, { ...i, ref: e }) }) }); hre.displayName = fre; var pre = "MenuRadioItem", mre = S.forwardRef((t, e) => { const { value: n, ...r } = t, i = PTe(pre, t.__scopeMenu), a = n === i.value; return l.jsx(gre, { scope: t.__scopeMenu, checked: a, children: l.jsx(IA, { role: "menuitemradio", "aria-checked": a, ...r, ref: e, "data-state": jU(a), onSelect: Mt(r.onSelect, () => i.onValueChange?.(n), { checkForDefaultPrevented: !1 }) }) }) }); mre.displayName = pre; var PU = "MenuItemIndicator", [gre, jTe] = zg(PU, { checked: !1 }), vre = S.forwardRef((t, e) => { const { __scopeMenu: n, forceMount: r, ...i } = t, a = jTe(PU, n); return l.jsx(Ka, { present: r || nC(a.checked) || a.checked === !0, children: l.jsx(qt.span, { ...i, ref: e, "data-state": jU(a.checked) }) }) }); vre.displayName = PU; var RTe = "MenuSeparator", yre = S.forwardRef((t, e) => { const { __scopeMenu: n, ...r } = t; return l.jsx(qt.div, { role: "separator", "aria-orientation": "horizontal", ...r, ref: e }) }); yre.displayName = RTe; var kTe = "MenuArrow", xre = S.forwardRef((t, e) => { const { __scopeMenu: n, ...r } = t, i = kA(n); return l.jsx(O5, { ...i, ...r, ref: e }) }); xre.displayName = kTe; var ITe = "MenuSub", [bct, bre] = zg(ITe), jw = "MenuSubTrigger", wre = S.forwardRef((t, e) => { const n = Vg(jw, t.__scopeMenu), r = JS(jw, t.__scopeMenu), i = bre(jw, t.__scopeMenu), a = CU(jw, t.__scopeMenu), s = S.useRef(null), { pointerGraceTimerRef: o, onPointerGraceIntentChange: c } = a, u = { __scopeMenu: t.__scopeMenu }, d = S.useCallback(() => { s.current && window.clearTimeout(s.current), s.current = null }, []); return S.useEffect(() => d, [d]), S.useEffect(() => { const f = o.current; return () => { window.clearTimeout(f), c(null) } }, [o, c]), l.jsx(MU, { asChild: !0, ...u, children: l.jsx(ure, { id: i.triggerId, "aria-haspopup": "menu", "aria-expanded": n.open, "aria-controls": i.contentId, "data-state": Ere(n.open), ...t, ref: yA(e, i.onTriggerChange), onClick: f => { t.onClick?.(f), !(t.disabled || f.defaultPrevented) && (f.currentTarget.focus(), n.open || n.onOpenChange(!0)) }, onPointerMove: Mt(t.onPointerMove, N1(f => { a.onItemEnter(f), !f.defaultPrevented && !t.disabled && !n.open && !s.current && (a.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => { n.onOpenChange(!0), d() }, 100)) })), onPointerLeave: Mt(t.onPointerLeave, N1(f => { d(); const h = n.content?.getBoundingClientRect(); if (h) { const m = n.content?.dataset.side, g = m === "right", x = g ? -5 : 5, v = h[g ? "left" : "right"], b = h[g ? "right" : "left"]; a.onPointerGraceIntentChange({ area: [{ x: f.clientX + x, y: f.clientY }, { x: v, y: h.top }, { x: b, y: h.top }, { x: b, y: h.bottom }, { x: v, y: h.bottom }], side: m }), window.clearTimeout(o.current), o.current = window.setTimeout(() => a.onPointerGraceIntentChange(null), 300) } else { if (a.onTriggerLeave(f), f.defaultPrevented) return; a.onPointerGraceIntentChange(null) } })), onKeyDown: Mt(t.onKeyDown, f => { const h = a.searchRef.current !== ""; t.disabled || h && f.key === " " || pTe[r.dir].includes(f.key) && (n.onOpenChange(!0), n.content?.focus(), f.preventDefault()) }) }) }) }); wre.displayName = jw; var Sre = "MenuSubContent", _re = S.forwardRef((t, e) => { const n = sre(Vl, t.__scopeMenu), { forceMount: r = n.forceMount, ...i } = t, a = Vg(Vl, t.__scopeMenu), s = JS(Vl, t.__scopeMenu), o = bre(Sre, t.__scopeMenu), c = S.useRef(null), u = Mn(e, c); return l.jsx(C1.Provider, { scope: t.__scopeMenu, children: l.jsx(Ka, { present: r || a.open, children: l.jsx(C1.Slot, { scope: t.__scopeMenu, children: l.jsx(NU, { id: o.contentId, "aria-labelledby": o.triggerId, ...i, ref: u, align: "start", side: s.dir === "rtl" ? "left" : "right", disableOutsidePointerEvents: !1, disableOutsideScroll: !1, trapFocus: !1, onOpenAutoFocus: d => { s.isUsingKeyboardRef.current && c.current?.focus(), d.preventDefault() }, onCloseAutoFocus: d => d.preventDefault(), onFocusOutside: Mt(t.onFocusOutside, d => { d.target !== o.trigger && a.onOpenChange(!1) }), onEscapeKeyDown: Mt(t.onEscapeKeyDown, d => { s.onClose(), d.preventDefault() }), onKeyDown: Mt(t.onKeyDown, d => { const f = d.currentTarget.contains(d.target), h = mTe[s.dir].includes(d.key); f && h && (a.onOpenChange(!1), o.trigger?.focus(), d.preventDefault()) }) }) }) }) }) }); _re.displayName = Sre; function Ere(t) { return t ? "open" : "closed" } function nC(t) { return t === "indeterminate" } function jU(t) { return nC(t) ? "indeterminate" : t ? "checked" : "unchecked" } function OTe(t) { const e = document.activeElement; for (const n of t) if (n === e || (n.focus(), document.activeElement !== e)) return } function DTe(t, e) { return t.map((n, r) => t[(e + r) % t.length]) } function LTe(t, e, n) { const i = e.length > 1 && Array.from(e).every(u => u === e[0]) ? e[0] : e, a = n ? t.indexOf(n) : -1; let s = DTe(t, Math.max(a, 0)); i.length === 1 && (s = s.filter(u => u !== n)); const c = s.find(u => u.toLowerCase().startsWith(i.toLowerCase())); return c !== n ? c : void 0 } function FTe(t, e) { const { x: n, y: r } = t; let i = !1; for (let a = 0, s = e.length - 1; a < e.length; s = a++) { const o = e[a], c = e[s], u = o.x, d = o.y, f = c.x, h = c.y; d > r != h > r && n < (f - u) * (r - d) / (h - d) + u && (i = !i) } return i } function UTe(t, e) { if (!e) return !1; const n = { x: t.clientX, y: t.clientY }; return FTe(n, e) } function N1(t) { return e => e.pointerType === "mouse" ? t(e) : void 0 } var BTe = are, $Te = MU, zTe = ore, VTe = lre, HTe = AU, WTe = cre, GTe = IA, qTe = dre, XTe = hre, YTe = mre, KTe = vre, ZTe = yre, QTe = xre, JTe = wre, eCe = _re, OA = "DropdownMenu", [tCe] = oa(OA, [rre]), uo = rre(), [nCe, Mre] = tCe(OA), Tre = t => { const { __scopeDropdownMenu: e, children: n, dir: r, open: i, defaultOpen: a, onOpenChange: s, modal: o = !0 } = t, c = uo(e), u = S.useRef(null), [d, f] = Uo({ prop: i, defaultProp: a ?? !1, onChange: s, caller: OA }); return l.jsx(nCe, { scope: e, triggerId: $l(), triggerRef: u, contentId: $l(), open: d, onOpenChange: f, onOpenToggle: S.useCallback(() => f(h => !h), [f]), modal: o, children: l.jsx(BTe, { ...c, open: d, onOpenChange: f, dir: r, modal: o, children: n }) }) }; Tre.displayName = OA; var Cre = "DropdownMenuTrigger", Nre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = t, a = Mre(Cre, n), s = uo(n); return l.jsx($Te, { asChild: !0, ...s, children: l.jsx(qt.button, { type: "button", id: a.triggerId, "aria-haspopup": "menu", "aria-expanded": a.open, "aria-controls": a.open ? a.contentId : void 0, "data-state": a.open ? "open" : "closed", "data-disabled": r ? "" : void 0, disabled: r, ...i, ref: yA(e, a.triggerRef), onPointerDown: Mt(t.onPointerDown, o => { !r && o.button === 0 && o.ctrlKey === !1 && (a.onOpenToggle(), a.open || o.preventDefault()) }), onKeyDown: Mt(t.onKeyDown, o => { r || (["Enter", " "].includes(o.key) && a.onOpenToggle(), o.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(o.key) && o.preventDefault()) }) }) }) }); Nre.displayName = Cre; var rCe = "DropdownMenuPortal", Are = t => { const { __scopeDropdownMenu: e, ...n } = t, r = uo(e); return l.jsx(zTe, { ...r, ...n }) }; Are.displayName = rCe; var Pre = "DropdownMenuContent", jre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = Mre(Pre, n), a = uo(n), s = S.useRef(!1); return l.jsx(VTe, { id: i.contentId, "aria-labelledby": i.triggerId, ...a, ...r, ref: e, onCloseAutoFocus: Mt(t.onCloseAutoFocus, o => { s.current || i.triggerRef.current?.focus(), s.current = !1, o.preventDefault() }), onInteractOutside: Mt(t.onInteractOutside, o => { const c = o.detail.originalEvent, u = c.button === 0 && c.ctrlKey === !0, d = c.button === 2 || u; (!i.modal || d) && (s.current = !0) }), style: { ...t.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" } }) }); jre.displayName = Pre; var iCe = "DropdownMenuGroup", aCe = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(HTe, { ...i, ...r, ref: e }) }); aCe.displayName = iCe; var sCe = "DropdownMenuLabel", Rre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(WTe, { ...i, ...r, ref: e }) }); Rre.displayName = sCe; var oCe = "DropdownMenuItem", kre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(GTe, { ...i, ...r, ref: e }) }); kre.displayName = oCe; var lCe = "DropdownMenuCheckboxItem", Ire = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(qTe, { ...i, ...r, ref: e }) }); Ire.displayName = lCe; var cCe = "DropdownMenuRadioGroup", uCe = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(XTe, { ...i, ...r, ref: e }) }); uCe.displayName = cCe; var dCe = "DropdownMenuRadioItem", Ore = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(YTe, { ...i, ...r, ref: e }) }); Ore.displayName = dCe; var fCe = "DropdownMenuItemIndicator", Dre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(KTe, { ...i, ...r, ref: e }) }); Dre.displayName = fCe; var hCe = "DropdownMenuSeparator", Lre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(ZTe, { ...i, ...r, ref: e }) }); Lre.displayName = hCe; var pCe = "DropdownMenuArrow", mCe = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(QTe, { ...i, ...r, ref: e }) }); mCe.displayName = pCe; var gCe = "DropdownMenuSubTrigger", Fre = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(JTe, { ...i, ...r, ref: e }) }); Fre.displayName = gCe; var vCe = "DropdownMenuSubContent", Ure = S.forwardRef((t, e) => { const { __scopeDropdownMenu: n, ...r } = t, i = uo(n); return l.jsx(eCe, { ...i, ...r, ref: e, style: { ...t.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" } }) }); Ure.displayName = vCe; var yCe = Tre, xCe = Nre, bCe = Are, Bre = jre, $re = Rre, zre = kre, Vre = Ire, Hre = Ore, Wre = Dre, Gre = Lre, qre = Fre, Xre = Ure; const e_ = yCe, t_ = xCe, wCe = S.forwardRef(({ className: t, inset: e, children: n, ...r }, i) => l.jsxs(qre, { ref: i, className: _t("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent focus:bg-accent", e && "pl-8", t), ...r, children: [n, l.jsx(DS, { className: "ml-auto h-4 w-4" })] })); wCe.displayName = qre.displayName; const SCe = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Xre, { ref: n, className: _t("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", t), ...e })); SCe.displayName = Xre.displayName; const T0 = S.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => l.jsx(bCe, { children: l.jsx(Bre, { ref: r, sideOffset: e, className: _t("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", t), ...n }) })); T0.displayName = Bre.displayName; const Xs = S.forwardRef(({ className: t, inset: e, ...n }, r) => l.jsx(zre, { ref: r, className: _t("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground", e && "pl-8", t), ...n })); Xs.displayName = zre.displayName; const _Ce = S.forwardRef(({ className: t, children: e, checked: n, ...r }, i) => l.jsxs(Vre, { ref: i, className: _t("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground", t), checked: n, ...r, children: [l.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: l.jsx(Wre, { children: l.jsx(l5, { className: "h-4 w-4" }) }) }), e] })); _Ce.displayName = Vre.displayName; const ECe = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsxs(Hre, { ref: r, className: _t("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground", t), ...n, children: [l.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: l.jsx(Wre, { children: l.jsx(wJ, { className: "h-2 w-2 fill-current" }) }) }), e] })); ECe.displayName = Hre.displayName; const Yre = S.forwardRef(({ className: t, inset: e, ...n }, r) => l.jsx($re, { ref: r, className: _t("px-2 py-1.5 text-sm font-semibold", e && "pl-8", t), ...n })); Yre.displayName = $re.displayName; const OL = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Gre, { ref: n, className: _t("-mx-1 my-1 h-px bg-muted", t), ...e })); OL.displayName = Gre.displayName; function DA() { const [t, e] = S.useState(!1), n = ui(), r = fs(), { user: i, loading: a } = La(), { navigateToSection: s, navigateToPage: o } = zne(), c = oMe(["features", "how-it-works", "testimonials", "resources", "about", "contact"]), u = i ? lMe(i.role) : null, d = r.pathname === "/", f = i?.status === "rejected", h = i?.status === "pending_verification", m = i && !(d && (f || h)), g = [{ label: "Features", sectionId: "features" }, { label: "How It Works", sectionId: "how-it-works" }, { label: "Testimonials", sectionId: "testimonials" }, { label: "About", sectionId: "about" }, { label: "Contact", sectionId: "contact" }], x = [{ label: "Resources", href: "/resources", icon: Kh }, { label: "FAQ", href: "/faq", icon: ff }]; return l.jsxs("nav", { className: "sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60", children: [l.jsxs("div", { className: "container flex h-16 items-center justify-between", children: [l.jsxs(yi, { to: "/", className: "flex items-center space-x-2 group", children: [l.jsxs("div", { className: "relative", children: [l.jsx(Ia, { className: "h-6 w-6 text-primary transition-all duration-300 group-hover:text-secondary group-hover:rotate-12" }), l.jsx("div", { className: "absolute inset-0 blur-lg bg-primary/20 group-hover:bg-secondary/30 transition-all duration-300 -z-10" })] }), l.jsx("span", { className: "text-xl font-bold gradient-text", children: "MockRise" })] }), l.jsxs("div", { className: "hidden lg:flex items-center justify-center space-x-2 xl:space-x-4 mx-auto absolute left-1/2 transform -translate-x-1/2", children: [g.slice(0, 3).map(v => { const b = c === v.sectionId, E = M => { M.preventDefault(), s(v.sectionId) }; return l.jsx("button", { onClick: E, className: `text-sm xl:text-base font-medium transition-all duration-200 relative px-2 py-1 ${b ? "text-primary font-semibold after:absolute after:bottom-[-8px] after:left-0 after:w-full after:h-0.5 after:bg-primary after:rounded-full" : "text-foreground/80 hover:text-primary"}`, children: v.label }, v.label) }), l.jsxs(e_, { children: [l.jsx(t_, { asChild: !0, children: l.jsxs(vt, { variant: "ghost", className: `text-sm xl:text-base font-medium transition-all duration-200 relative p-2 h-auto ${c === "resources" ? "text-primary font-semibold after:absolute after:bottom-[-8px] after:left-0 after:w-full after:h-0.5 after:bg-primary after:rounded-full" : "text-foreground/80 hover:bg-transparent hover:text-primary"}`, children: ["Resources", l.jsx(gA, { className: "ml-1 h-4 w-4" })] }) }), l.jsx(T0, { align: "end", className: "w-48", children: x.map(v => l.jsxs(Xs, { onClick: () => o(v.href), className: "flex items-center gap-2 cursor-pointer", children: [l.jsx(v.icon, { className: "h-4 w-4" }), v.label] }, v.label)) })] }), g.slice(3).map(v => { const b = c === v.sectionId, E = M => { M.preventDefault(), s(v.sectionId) }; return l.jsx("button", { onClick: E, className: `text-sm xl:text-base font-medium transition-all duration-200 relative px-2 py-1 ${b ? "text-primary font-semibold after:absolute after:bottom-[-8px] after:left-0 after:w-full after:h-0.5 after:bg-primary after:rounded-full" : "text-foreground/80 hover:text-primary"}`, children: v.label }, v.label) })] }), l.jsxs("div", { className: "hidden lg:flex items-center space-x-3", children: [l.jsx(uL, {}), !a && !m && l.jsx(vt, { variant: "ghost", onClick: () => n("/login"), className: "hover:bg-gradient-primary hover:opacity-40 hover:scale-105 transition-all duration-200 text-primary", children: "Sign In" }), !a && l.jsx(vt, { onClick: () => { n(m && u ? u : "/login?signup=true") }, className: "bg-gradient-primary text-primary-foreground hover:opacity-90 transition-opacity", children: m ? "Dashboard" : "Get Started" })] }), l.jsxs("div", { className: "flex md:hidden items-center space-x-2", children: [l.jsx(uL, {}), l.jsx(vt, { variant: "ghost", size: "icon", onClick: () => e(!t), children: t ? l.jsx(Pa, { className: "h-6 w-6" }) : l.jsx(Kve, { className: "h-6 w-6" }) })] })] }), l.jsx(YS, { children: t && l.jsx($e.div, { initial: { opacity: 0, height: 0 }, animate: { opacity: 1, height: "auto" }, exit: { opacity: 0, height: 0 }, className: "md:hidden border-t border-border/40 bg-background", children: l.jsxs("div", { className: "container py-4 space-y-4", children: [g.map(v => { const b = () => { e(!1), s(v.sectionId) }; return l.jsx("button", { onClick: b, className: "block text-sm font-medium text-foreground/80 hover:text-primary transition-colors text-left w-full", children: v.label }, v.label) }), l.jsxs("div", { className: "space-y-2", children: [l.jsx("div", { className: "text-sm font-medium text-foreground/60", children: "Resources" }), x.map(v => l.jsxs("button", { onClick: () => { e(!1), o(v.href) }, className: "flex items-center gap-2 text-sm text-foreground/80 hover:text-primary transition-colors ml-4 text-left w-full", children: [l.jsx(v.icon, { className: "h-4 w-4" }), v.label] }, v.label))] }), l.jsxs("div", { className: "flex flex-col space-y-2 pt-4", children: [!a && !m && l.jsx(vt, { variant: "outline", onClick: () => { n("/login"), e(!1) }, children: "Sign In" }), !a && l.jsx(vt, { onClick: () => { n(m && u ? u : "/login?signup=true"), e(!1) }, className: "bg-gradient-primary text-primary-foreground", children: m ? "Dashboard" : "Get Started" })] })] }) }) })] }) } var LA = "Dialog", [Kre, Zre] = oa(LA), [MCe, Yc] = Kre(LA), Qre = t => { const { __scopeDialog: e, children: n, open: r, defaultOpen: i, onOpenChange: a, modal: s = !0 } = t, o = S.useRef(null), c = S.useRef(null), [u, d] = Uo({ prop: r, defaultProp: i ?? !1, onChange: a, caller: LA }); return l.jsx(MCe, { scope: e, triggerRef: o, contentRef: c, contentId: $l(), titleId: $l(), descriptionId: $l(), open: u, onOpenChange: d, onOpenToggle: S.useCallback(() => d(f => !f), [d]), modal: s, children: n }) }; Qre.displayName = LA; var Jre = "DialogTrigger", eie = S.forwardRef((t, e) => { const { __scopeDialog: n, ...r } = t, i = Yc(Jre, n), a = Mn(e, i.triggerRef); return l.jsx(qt.button, { type: "button", "aria-haspopup": "dialog", "aria-expanded": i.open, "aria-controls": i.contentId, "data-state": IU(i.open), ...r, ref: a, onClick: Mt(t.onClick, i.onOpenToggle) }) }); eie.displayName = Jre; var RU = "DialogPortal", [TCe, tie] = Kre(RU, { forceMount: void 0 }), nie = t => { const { __scopeDialog: e, forceMount: n, children: r, container: i } = t, a = Yc(RU, e); return l.jsx(TCe, { scope: e, forceMount: n, children: S.Children.map(r, s => l.jsx(Ka, { present: n || a.open, children: l.jsx(zS, { asChild: !0, container: i, children: s }) })) }) }; nie.displayName = RU; var rC = "DialogOverlay", rie = S.forwardRef((t, e) => { const n = tie(rC, t.__scopeDialog), { forceMount: r = n.forceMount, ...i } = t, a = Yc(rC, t.__scopeDialog); return a.modal ? l.jsx(Ka, { present: r || a.open, children: l.jsx(NCe, { ...i, ref: e }) }) : null }); rie.displayName = rC; var CCe = xg("DialogOverlay.RemoveScroll"), NCe = S.forwardRef((t, e) => { const { __scopeDialog: n, ...r } = t, i = Yc(rC, n); return l.jsx(RA, { as: CCe, allowPinchZoom: !0, shards: [i.contentRef], children: l.jsx(qt.div, { "data-state": IU(i.open), ...r, ref: e, style: { pointerEvents: "auto", ...r.style } }) }) }), _g = "DialogContent", iie = S.forwardRef((t, e) => { const n = tie(_g, t.__scopeDialog), { forceMount: r = n.forceMount, ...i } = t, a = Yc(_g, t.__scopeDialog); return l.jsx(Ka, { present: r || a.open, children: a.modal ? l.jsx(ACe, { ...i, ref: e }) : l.jsx(PCe, { ...i, ref: e }) }) }); iie.displayName = _g; var ACe = S.forwardRef((t, e) => { const n = Yc(_g, t.__scopeDialog), r = S.useRef(null), i = Mn(e, n.contentRef, r); return S.useEffect(() => { const a = r.current; if (a) return EU(a) }, []), l.jsx(aie, { ...t, ref: i, trapFocus: n.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: Mt(t.onCloseAutoFocus, a => { a.preventDefault(), n.triggerRef.current?.focus() }), onPointerDownOutside: Mt(t.onPointerDownOutside, a => { const s = a.detail.originalEvent, o = s.button === 0 && s.ctrlKey === !0; (s.button === 2 || o) && a.preventDefault() }), onFocusOutside: Mt(t.onFocusOutside, a => a.preventDefault()) }) }), PCe = S.forwardRef((t, e) => { const n = Yc(_g, t.__scopeDialog), r = S.useRef(!1), i = S.useRef(!1); return l.jsx(aie, { ...t, ref: e, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: a => { t.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, i.current = !1 }, onInteractOutside: a => { t.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0)); const s = a.target; n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault() } }) }), aie = S.forwardRef((t, e) => { const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: a, ...s } = t, o = Yc(_g, n), c = S.useRef(null), u = Mn(e, c); return wU(), l.jsxs(l.Fragment, { children: [l.jsx(PA, { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: i, onUnmountAutoFocus: a, children: l.jsx(g0, { role: "dialog", id: o.contentId, "aria-describedby": o.descriptionId, "aria-labelledby": o.titleId, "data-state": IU(o.open), ...s, ref: u, onDismiss: () => o.onOpenChange(!1) }) }), l.jsxs(l.Fragment, { children: [l.jsx(RCe, { titleId: o.titleId }), l.jsx(ICe, { contentRef: c, descriptionId: o.descriptionId })] })] }) }), kU = "DialogTitle", sie = S.forwardRef((t, e) => { const { __scopeDialog: n, ...r } = t, i = Yc(kU, n); return l.jsx(qt.h2, { id: i.titleId, ...r, ref: e }) }); sie.displayName = kU; var oie = "DialogDescription", lie = S.forwardRef((t, e) => { const { __scopeDialog: n, ...r } = t, i = Yc(oie, n); return l.jsx(qt.p, { id: i.descriptionId, ...r, ref: e }) }); lie.displayName = oie; var cie = "DialogClose", uie = S.forwardRef((t, e) => { const { __scopeDialog: n, ...r } = t, i = Yc(cie, n); return l.jsx(qt.button, { type: "button", ...r, ref: e, onClick: Mt(t.onClick, () => i.onOpenChange(!1)) }) }); uie.displayName = cie; function IU(t) { return t ? "open" : "closed" } var die = "DialogTitleWarning", [jCe, fie] = mye(die, { contentName: _g, titleName: kU, docsSlug: "dialog" }), RCe = ({ titleId: t }) => {
	const e = fie(die), n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`; return S.useEffect(() => { t && (document.getElementById(t) || console.error(n)) }, [n, t]), null
}, kCe = "DialogDescriptionWarning", ICe = ({ contentRef: t, descriptionId: e }) => { const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${fie(kCe).contentName}}.`; return S.useEffect(() => { const i = t.current?.getAttribute("aria-describedby"); e && i && (document.getElementById(e) || console.warn(r)) }, [r, t, e]), null }, hie = Qre, pie = eie, mie = nie, OU = rie, DU = iie, LU = sie, FU = lie, UU = uie; const sl = hie, OCe = pie, DCe = mie, gie = S.forwardRef(({ className: t, ...e }, n) => l.jsx(OU, { ref: n, className: _t("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", t), ...e })); gie.displayName = OU.displayName; const jo = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsxs(DCe, { children: [l.jsx(gie, {}), l.jsxs(DU, { ref: r, className: _t("fixed left-[50%] top-[50%] z-50 grid w-full max-w-[95vw] sm:max-w-lg max-h-[90vh] overflow-y-auto translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-4 sm:p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg sm:rounded-lg", t), ...n, children: [e, l.jsxs(UU, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none", children: [l.jsx(Pa, { className: "h-4 w-4" }), l.jsx("span", { className: "sr-only", children: "Close" })] })] })] })); jo.displayName = DU.displayName; const Ro = ({ className: t, ...e }) => l.jsx("div", { className: _t("flex flex-col space-y-1.5 text-center sm:text-left", t), ...e }); Ro.displayName = "DialogHeader"; const kc = ({ className: t, ...e }) => l.jsx("div", { className: _t("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", t), ...e }); kc.displayName = "DialogFooter"; const ko = S.forwardRef(({ className: t, ...e }, n) => l.jsx(LU, { ref: n, className: _t("text-lg font-semibold leading-none tracking-tight", t), ...e })); ko.displayName = LU.displayName; const ol = S.forwardRef(({ className: t, ...e }, n) => l.jsx(FU, { ref: n, className: _t("text-sm text-muted-foreground", t), ...e })); ol.displayName = FU.displayName; function A1(t, [e, n]) { return Math.min(n, Math.max(e, t)) } function LCe(t, e) { return S.useReducer((n, r) => e[n][r] ?? n, t) } var BU = "ScrollArea", [vie] = oa(BU), [FCe, Yl] = vie(BU), yie = S.forwardRef((t, e) => { const { __scopeScrollArea: n, type: r = "hover", dir: i, scrollHideDelay: a = 600, ...s } = t, [o, c] = S.useState(null), [u, d] = S.useState(null), [f, h] = S.useState(null), [m, g] = S.useState(null), [x, v] = S.useState(null), [b, E] = S.useState(0), [M, C] = S.useState(0), [N, A] = S.useState(!1), [j, O] = S.useState(!1), I = Mn(e, F => c(F)), D = pp(i); return l.jsx(FCe, { scope: n, type: r, dir: D, scrollHideDelay: a, scrollArea: o, viewport: u, onViewportChange: d, content: f, onContentChange: h, scrollbarX: m, onScrollbarXChange: g, scrollbarXEnabled: N, onScrollbarXEnabledChange: A, scrollbarY: x, onScrollbarYChange: v, scrollbarYEnabled: j, onScrollbarYEnabledChange: O, onCornerWidthChange: E, onCornerHeightChange: C, children: l.jsx(qt.div, { dir: D, ...s, ref: I, style: { position: "relative", "--radix-scroll-area-corner-width": b + "px", "--radix-scroll-area-corner-height": M + "px", ...t.style } }) }) }); yie.displayName = BU; var xie = "ScrollAreaViewport", bie = S.forwardRef((t, e) => { const { __scopeScrollArea: n, children: r, nonce: i, ...a } = t, s = Yl(xie, n), o = S.useRef(null), c = Mn(e, o, s.onViewportChange); return l.jsxs(l.Fragment, { children: [l.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}" }, nonce: i }), l.jsx(qt.div, { "data-radix-scroll-area-viewport": "", ...a, ref: c, style: { overflowX: s.scrollbarXEnabled ? "scroll" : "hidden", overflowY: s.scrollbarYEnabled ? "scroll" : "hidden", ...t.style }, children: l.jsx("div", { ref: s.onContentChange, style: { minWidth: "100%", display: "table" }, children: r }) })] }) }); bie.displayName = xie; var Zu = "ScrollAreaScrollbar", $U = S.forwardRef((t, e) => { const { forceMount: n, ...r } = t, i = Yl(Zu, t.__scopeScrollArea), { onScrollbarXEnabledChange: a, onScrollbarYEnabledChange: s } = i, o = t.orientation === "horizontal"; return S.useEffect(() => (o ? a(!0) : s(!0), () => { o ? a(!1) : s(!1) }), [o, a, s]), i.type === "hover" ? l.jsx(UCe, { ...r, ref: e, forceMount: n }) : i.type === "scroll" ? l.jsx(BCe, { ...r, ref: e, forceMount: n }) : i.type === "auto" ? l.jsx(wie, { ...r, ref: e, forceMount: n }) : i.type === "always" ? l.jsx(zU, { ...r, ref: e }) : null }); $U.displayName = Zu; var UCe = S.forwardRef((t, e) => { const { forceMount: n, ...r } = t, i = Yl(Zu, t.__scopeScrollArea), [a, s] = S.useState(!1); return S.useEffect(() => { const o = i.scrollArea; let c = 0; if (o) { const u = () => { window.clearTimeout(c), s(!0) }, d = () => { c = window.setTimeout(() => s(!1), i.scrollHideDelay) }; return o.addEventListener("pointerenter", u), o.addEventListener("pointerleave", d), () => { window.clearTimeout(c), o.removeEventListener("pointerenter", u), o.removeEventListener("pointerleave", d) } } }, [i.scrollArea, i.scrollHideDelay]), l.jsx(Ka, { present: n || a, children: l.jsx(wie, { "data-state": a ? "visible" : "hidden", ...r, ref: e }) }) }), BCe = S.forwardRef((t, e) => { const { forceMount: n, ...r } = t, i = Yl(Zu, t.__scopeScrollArea), a = t.orientation === "horizontal", s = UA(() => c("SCROLL_END"), 100), [o, c] = LCe("hidden", { hidden: { SCROLL: "scrolling" }, scrolling: { SCROLL_END: "idle", POINTER_ENTER: "interacting" }, interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" }, idle: { HIDE: "hidden", SCROLL: "scrolling", POINTER_ENTER: "interacting" } }); return S.useEffect(() => { if (o === "idle") { const u = window.setTimeout(() => c("HIDE"), i.scrollHideDelay); return () => window.clearTimeout(u) } }, [o, i.scrollHideDelay, c]), S.useEffect(() => { const u = i.viewport, d = a ? "scrollLeft" : "scrollTop"; if (u) { let f = u[d]; const h = () => { const m = u[d]; f !== m && (c("SCROLL"), s()), f = m }; return u.addEventListener("scroll", h), () => u.removeEventListener("scroll", h) } }, [i.viewport, a, c, s]), l.jsx(Ka, { present: n || o !== "hidden", children: l.jsx(zU, { "data-state": o === "hidden" ? "hidden" : "visible", ...r, ref: e, onPointerEnter: Mt(t.onPointerEnter, () => c("POINTER_ENTER")), onPointerLeave: Mt(t.onPointerLeave, () => c("POINTER_LEAVE")) }) }) }), wie = S.forwardRef((t, e) => { const n = Yl(Zu, t.__scopeScrollArea), { forceMount: r, ...i } = t, [a, s] = S.useState(!1), o = t.orientation === "horizontal", c = UA(() => { if (n.viewport) { const u = n.viewport.offsetWidth < n.viewport.scrollWidth, d = n.viewport.offsetHeight < n.viewport.scrollHeight; s(o ? u : d) } }, 10); return mx(n.viewport, c), mx(n.content, c), l.jsx(Ka, { present: r || a, children: l.jsx(zU, { "data-state": a ? "visible" : "hidden", ...i, ref: e }) }) }), zU = S.forwardRef((t, e) => { const { orientation: n = "vertical", ...r } = t, i = Yl(Zu, t.__scopeScrollArea), a = S.useRef(null), s = S.useRef(0), [o, c] = S.useState({ content: 0, viewport: 0, scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 } }), u = Tie(o.viewport, o.content), d = { ...r, sizes: o, onSizesChange: c, hasThumb: u > 0 && u < 1, onThumbChange: h => a.current = h, onThumbPointerUp: () => s.current = 0, onThumbPointerDown: h => s.current = h }; function f(h, m) { return GCe(h, s.current, o, m) } return n === "horizontal" ? l.jsx($Ce, { ...d, ref: e, onThumbPositionChange: () => { if (i.viewport && a.current) { const h = i.viewport.scrollLeft, m = _H(h, o, i.dir); a.current.style.transform = `translate3d(${m}px, 0, 0)` } }, onWheelScroll: h => { i.viewport && (i.viewport.scrollLeft = h) }, onDragScroll: h => { i.viewport && (i.viewport.scrollLeft = f(h, i.dir)) } }) : n === "vertical" ? l.jsx(zCe, { ...d, ref: e, onThumbPositionChange: () => { if (i.viewport && a.current) { const h = i.viewport.scrollTop, m = _H(h, o); a.current.style.transform = `translate3d(0, ${m}px, 0)` } }, onWheelScroll: h => { i.viewport && (i.viewport.scrollTop = h) }, onDragScroll: h => { i.viewport && (i.viewport.scrollTop = f(h)) } }) : null }), $Ce = S.forwardRef((t, e) => { const { sizes: n, onSizesChange: r, ...i } = t, a = Yl(Zu, t.__scopeScrollArea), [s, o] = S.useState(), c = S.useRef(null), u = Mn(e, c, a.onScrollbarXChange); return S.useEffect(() => { c.current && o(getComputedStyle(c.current)) }, [c]), l.jsx(_ie, { "data-orientation": "horizontal", ...i, ref: u, sizes: n, style: { bottom: 0, left: a.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0, right: a.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0, "--radix-scroll-area-thumb-width": FA(n) + "px", ...t.style }, onThumbPointerDown: d => t.onThumbPointerDown(d.x), onDragScroll: d => t.onDragScroll(d.x), onWheelScroll: (d, f) => { if (a.viewport) { const h = a.viewport.scrollLeft + d.deltaX; t.onWheelScroll(h), Nie(h, f) && d.preventDefault() } }, onResize: () => { c.current && a.viewport && s && r({ content: a.viewport.scrollWidth, viewport: a.viewport.offsetWidth, scrollbar: { size: c.current.clientWidth, paddingStart: aC(s.paddingLeft), paddingEnd: aC(s.paddingRight) } }) } }) }), zCe = S.forwardRef((t, e) => { const { sizes: n, onSizesChange: r, ...i } = t, a = Yl(Zu, t.__scopeScrollArea), [s, o] = S.useState(), c = S.useRef(null), u = Mn(e, c, a.onScrollbarYChange); return S.useEffect(() => { c.current && o(getComputedStyle(c.current)) }, [c]), l.jsx(_ie, { "data-orientation": "vertical", ...i, ref: u, sizes: n, style: { top: 0, right: a.dir === "ltr" ? 0 : void 0, left: a.dir === "rtl" ? 0 : void 0, bottom: "var(--radix-scroll-area-corner-height)", "--radix-scroll-area-thumb-height": FA(n) + "px", ...t.style }, onThumbPointerDown: d => t.onThumbPointerDown(d.y), onDragScroll: d => t.onDragScroll(d.y), onWheelScroll: (d, f) => { if (a.viewport) { const h = a.viewport.scrollTop + d.deltaY; t.onWheelScroll(h), Nie(h, f) && d.preventDefault() } }, onResize: () => { c.current && a.viewport && s && r({ content: a.viewport.scrollHeight, viewport: a.viewport.offsetHeight, scrollbar: { size: c.current.clientHeight, paddingStart: aC(s.paddingTop), paddingEnd: aC(s.paddingBottom) } }) } }) }), [VCe, Sie] = vie(Zu), _ie = S.forwardRef((t, e) => { const { __scopeScrollArea: n, sizes: r, hasThumb: i, onThumbChange: a, onThumbPointerUp: s, onThumbPointerDown: o, onThumbPositionChange: c, onDragScroll: u, onWheelScroll: d, onResize: f, ...h } = t, m = Yl(Zu, n), [g, x] = S.useState(null), v = Mn(e, I => x(I)), b = S.useRef(null), E = S.useRef(""), M = m.viewport, C = r.content - r.viewport, N = Yi(d), A = Yi(c), j = UA(f, 10); function O(I) { if (b.current) { const D = I.clientX - b.current.left, F = I.clientY - b.current.top; u({ x: D, y: F }) } } return S.useEffect(() => { const I = D => { const F = D.target; g?.contains(F) && N(D, C) }; return document.addEventListener("wheel", I, { passive: !1 }), () => document.removeEventListener("wheel", I, { passive: !1 }) }, [M, g, C, N]), S.useEffect(A, [r, A]), mx(g, j), mx(m.content, j), l.jsx(VCe, { scope: n, scrollbar: g, hasThumb: i, onThumbChange: Yi(a), onThumbPointerUp: Yi(s), onThumbPositionChange: A, onThumbPointerDown: Yi(o), children: l.jsx(qt.div, { ...h, ref: v, style: { position: "absolute", ...h.style }, onPointerDown: Mt(t.onPointerDown, I => { I.button === 0 && (I.target.setPointerCapture(I.pointerId), b.current = g.getBoundingClientRect(), E.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", m.viewport && (m.viewport.style.scrollBehavior = "auto"), O(I)) }), onPointerMove: Mt(t.onPointerMove, O), onPointerUp: Mt(t.onPointerUp, I => { const D = I.target; D.hasPointerCapture(I.pointerId) && D.releasePointerCapture(I.pointerId), document.body.style.webkitUserSelect = E.current, m.viewport && (m.viewport.style.scrollBehavior = ""), b.current = null }) }) }) }), iC = "ScrollAreaThumb", Eie = S.forwardRef((t, e) => { const { forceMount: n, ...r } = t, i = Sie(iC, t.__scopeScrollArea); return l.jsx(Ka, { present: n || i.hasThumb, children: l.jsx(HCe, { ref: e, ...r }) }) }), HCe = S.forwardRef((t, e) => { const { __scopeScrollArea: n, style: r, ...i } = t, a = Yl(iC, n), s = Sie(iC, n), { onThumbPositionChange: o } = s, c = Mn(e, f => s.onThumbChange(f)), u = S.useRef(void 0), d = UA(() => { u.current && (u.current(), u.current = void 0) }, 100); return S.useEffect(() => { const f = a.viewport; if (f) { const h = () => { if (d(), !u.current) { const m = qCe(f, o); u.current = m, o() } }; return o(), f.addEventListener("scroll", h), () => f.removeEventListener("scroll", h) } }, [a.viewport, d, o]), l.jsx(qt.div, { "data-state": s.hasThumb ? "visible" : "hidden", ...i, ref: c, style: { width: "var(--radix-scroll-area-thumb-width)", height: "var(--radix-scroll-area-thumb-height)", ...r }, onPointerDownCapture: Mt(t.onPointerDownCapture, f => { const m = f.target.getBoundingClientRect(), g = f.clientX - m.left, x = f.clientY - m.top; s.onThumbPointerDown({ x: g, y: x }) }), onPointerUp: Mt(t.onPointerUp, s.onThumbPointerUp) }) }); Eie.displayName = iC; var VU = "ScrollAreaCorner", Mie = S.forwardRef((t, e) => { const n = Yl(VU, t.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY); return n.type !== "scroll" && r ? l.jsx(WCe, { ...t, ref: e }) : null }); Mie.displayName = VU; var WCe = S.forwardRef((t, e) => { const { __scopeScrollArea: n, ...r } = t, i = Yl(VU, n), [a, s] = S.useState(0), [o, c] = S.useState(0), u = !!(a && o); return mx(i.scrollbarX, () => { const d = i.scrollbarX?.offsetHeight || 0; i.onCornerHeightChange(d), c(d) }), mx(i.scrollbarY, () => { const d = i.scrollbarY?.offsetWidth || 0; i.onCornerWidthChange(d), s(d) }), u ? l.jsx(qt.div, { ...r, ref: e, style: { width: a, height: o, position: "absolute", right: i.dir === "ltr" ? 0 : void 0, left: i.dir === "rtl" ? 0 : void 0, bottom: 0, ...t.style } }) : null }); function aC(t) { return t ? parseInt(t, 10) : 0 } function Tie(t, e) { const n = t / e; return isNaN(n) ? 0 : n } function FA(t) { const e = Tie(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = (t.scrollbar.size - n) * e; return Math.max(r, 18) } function GCe(t, e, n, r = "ltr") { const i = FA(n), a = i / 2, s = e || a, o = i - s, c = n.scrollbar.paddingStart + s, u = n.scrollbar.size - n.scrollbar.paddingEnd - o, d = n.content - n.viewport, f = r === "ltr" ? [0, d] : [d * -1, 0]; return Cie([c, u], f)(t) } function _H(t, e, n = "ltr") { const r = FA(e), i = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, a = e.scrollbar.size - i, s = e.content - e.viewport, o = a - r, c = n === "ltr" ? [0, s] : [s * -1, 0], u = A1(t, c); return Cie([0, s], [0, o])(u) } function Cie(t, e) { return n => { if (t[0] === t[1] || e[0] === e[1]) return e[0]; const r = (e[1] - e[0]) / (t[1] - t[0]); return e[0] + r * (n - t[0]) } } function Nie(t, e) { return t > 0 && t < e } var qCe = (t, e = () => { }) => { let n = { left: t.scrollLeft, top: t.scrollTop }, r = 0; return (function i() { const a = { left: t.scrollLeft, top: t.scrollTop }, s = n.left !== a.left, o = n.top !== a.top; (s || o) && e(), n = a, r = window.requestAnimationFrame(i) })(), () => window.cancelAnimationFrame(r) }; function UA(t, e) { const n = Yi(t), r = S.useRef(0); return S.useEffect(() => () => window.clearTimeout(r.current), []), S.useCallback(() => { window.clearTimeout(r.current), r.current = window.setTimeout(n, e) }, [n, e]) } function mx(t, e) { const n = Yi(e); Ki(() => { let r = 0; if (t) { const i = new ResizeObserver(() => { cancelAnimationFrame(r), r = window.requestAnimationFrame(n) }); return i.observe(t), () => { window.cancelAnimationFrame(r), i.unobserve(t) } } }, [t, n]) } var Aie = yie, XCe = bie, YCe = Mie; const Pie = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsxs(Aie, { ref: r, className: _t("relative overflow-hidden", t), ...n, children: [l.jsx(XCe, { className: "h-full w-full rounded-[inherit]", children: e }), l.jsx(jie, {}), l.jsx(YCe, {})] })); Pie.displayName = Aie.displayName; const jie = S.forwardRef(({ className: t, orientation: e = "vertical", ...n }, r) => l.jsx($U, { ref: r, orientation: e, className: _t("flex touch-none select-none transition-colors", e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]", e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]", t), ...n, children: l.jsx(Eie, { className: "relative flex-1 rounded-full bg-border" }) })); jie.displayName = $U.displayName; function gx({ open: t, onOpenChange: e, type: n }) { const r = n === "privacy"; return l.jsx(sl, { open: t, onOpenChange: e, children: l.jsxs(jo, { className: "max-w-3xl max-h-[80vh]", children: [l.jsxs(Ro, { children: [l.jsxs("div", { className: "flex items-center gap-3 mb-2", children: [r ? l.jsx("div", { className: "w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center", children: l.jsx(Zh, { className: "h-5 w-5 text-primary" }) }) : l.jsx("div", { className: "w-10 h-10 rounded-lg bg-secondary/10 flex items-center justify-center", children: l.jsx(df, { className: "h-5 w-5 text-secondary" }) }), l.jsx(ko, { className: "text-2xl", children: r ? "Privacy Policy" : "Terms of Service" })] }), l.jsx(ol, { children: r ? "How we collect, use, and protect your personal information" : "Please read these terms carefully before using our platform" })] }), l.jsx(Pie, { className: "h-[60vh] pr-4", children: l.jsx("div", { className: "space-y-6 text-sm", children: r ? l.jsxs(l.Fragment, { children: [l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Our Commitment to Your Privacy" }), l.jsx("p", { className: "text-muted-foreground", children: "At MockRise, we take your privacy seriously. This Privacy Policy explains how we collect, use, and protect your personal information when you use our platform." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Data Collection" }), l.jsx("p", { className: "text-muted-foreground mb-2", children: "We collect information you provide directly (name, email, profile details) and usage data (interview sessions, performance metrics). All data is encrypted and stored securely." }), l.jsxs("ul", { className: "list-disc list-inside space-y-1 text-muted-foreground ml-2", children: [l.jsx("li", { children: "Personal information: Name, email address, profile picture" }), l.jsx("li", { children: "Interview data: Session recordings, performance scores, feedback" }), l.jsx("li", { children: "Usage analytics: Pages visited, features used, time spent" }), l.jsx("li", { children: "Technical data: IP address, browser type, device information" })] })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Data Usage" }), l.jsx("p", { className: "text-muted-foreground mb-2", children: "We use your data to provide and improve our services, personalize your experience, send important notifications, and generate anonymized analytics to enhance the platform." }), l.jsxs("ul", { className: "list-disc list-inside space-y-1 text-muted-foreground ml-2", children: [l.jsx("li", { children: "Deliver and maintain our interview practice platform" }), l.jsx("li", { children: "Personalize your learning experience and recommendations" }), l.jsx("li", { children: "Analyze performance trends and provide detailed feedback" }), l.jsx("li", { children: "Send service updates, security alerts, and support messages" }), l.jsx("li", { children: "Improve our AI models and platform features" })] })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Data Protection" }), l.jsx("p", { className: "text-muted-foreground", children: "We implement industry-standard security measures including encryption, secure servers, and regular security audits. We never sell your personal data to third parties." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Your Rights" }), l.jsx("p", { className: "text-muted-foreground", children: "You have the right to access, modify, or delete your data at any time through your account settings. For data requests or concerns, contact privacy@mockrise.com." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Cookies and Tracking" }), l.jsx("p", { className: "text-muted-foreground", children: "We use cookies to enhance your experience, remember your preferences, and analyze platform usage. You can control cookie settings through your browser preferences." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Data Retention" }), l.jsx("p", { className: "text-muted-foreground", children: "We retain your data as long as your account is active or as needed to provide services. You can request data deletion at any time, after which we'll remove your information within 30 days." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Changes to This Policy" }), l.jsx("p", { className: "text-muted-foreground", children: "We may update this privacy policy from time to time. We'll notify you of significant changes via email or through the platform. Continued use after changes indicates acceptance." })] }), l.jsx("div", { className: "pt-4 border-t", children: l.jsx("p", { className: "text-xs text-muted-foreground", children: "Last updated: January 2025. For questions or concerns about this privacy policy, contact us at privacy@mockrise.com" }) })] }) : l.jsxs(l.Fragment, { children: [l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Agreement to Terms" }), l.jsx("p", { className: "text-muted-foreground", children: "By using MockRise, you agree to these Terms of Service. Please read them carefully before using our platform." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Account Responsibilities" }), l.jsx("p", { className: "text-muted-foreground mb-2", children: "You are responsible for maintaining the confidentiality of your account credentials and all activities under your account. You must provide accurate information and keep it updated." }), l.jsxs("ul", { className: "list-disc list-inside space-y-1 text-muted-foreground ml-2", children: [l.jsx("li", { children: "Maintain secure passwords and don't share credentials" }), l.jsx("li", { children: "Provide accurate registration information" }), l.jsx("li", { children: "Notify us immediately of unauthorized access" }), l.jsx("li", { children: "You are responsible for all activity on your account" })] })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Acceptable Use" }), l.jsx("p", { className: "text-muted-foreground mb-2", children: "You agree to use MockRise only for lawful purposes and in accordance with these terms. Prohibited activities include:" }), l.jsxs("ul", { className: "list-disc list-inside space-y-1 text-muted-foreground ml-2", children: [l.jsx("li", { children: "Harassment, abuse, or threatening behavior toward others" }), l.jsx("li", { children: "Impersonation or misrepresentation of identity" }), l.jsx("li", { children: "Posting spam, malware, or harmful content" }), l.jsx("li", { children: "Attempting to access unauthorized areas or data" }), l.jsx("li", { children: "Violating others' intellectual property rights" }), l.jsx("li", { children: "Using the platform for illegal or fraudulent purposes" })] })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Intellectual Property" }), l.jsx("p", { className: "text-muted-foreground", children: "All content, features, and functionality on MockRise are owned by us and protected by intellectual property laws. You may not copy, modify, or distribute our content without permission." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "User Content" }), l.jsx("p", { className: "text-muted-foreground", children: "You retain ownership of content you create on MockRise. By posting content, you grant us a license to use, display, and distribute it for platform operations and improvements." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Service Availability" }), l.jsx("p", { className: "text-muted-foreground", children: "We strive to provide reliable service but don't guarantee uninterrupted access. We may modify, suspend, or discontinue features at any time with reasonable notice." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Limitation of Liability" }), l.jsx("p", { className: "text-muted-foreground", children: 'MockRise is provided "as is" without warranties. We are not responsible for any damages arising from your use of the platform. Our maximum liability is limited to the amount you paid us in the past 12 months.' })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Termination" }), l.jsx("p", { className: "text-muted-foreground", children: "We may terminate or suspend your account at any time for violations of these terms. You may close your account at any time through account settings." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Changes to Terms" }), l.jsx("p", { className: "text-muted-foreground", children: "We may update these terms from time to time. Continued use of MockRise after changes constitutes acceptance of the new terms. Significant changes will be communicated via email." })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-foreground mb-2 text-base", children: "Contact Information" }), l.jsx("p", { className: "text-muted-foreground", children: "For questions about these terms, contact us at legal@mockrise.com or through our support channels." })] }), l.jsx("div", { className: "pt-4 border-t", children: l.jsx("p", { className: "text-xs text-muted-foreground", children: "Last updated: January 2025. These terms are governed by Egyptian law. By using MockRise, you agree to the exclusive jurisdiction of Egyptian courts." }) })] }) }) })] }) }) } function Rie() { const [t, e] = S.useState(!1), [n, r] = S.useState(!1), { navigateToSection: i, navigateToPage: a } = zne(); return l.jsxs(l.Fragment, { children: [l.jsx("footer", { className: "bg-background border-t border-border py-12", children: l.jsxs("div", { className: "container mx-auto px-4", children: [l.jsxs("div", { className: "grid md:grid-cols-5 gap-8 mb-8", children: [l.jsxs("div", { children: [l.jsxs(yi, { to: "/", className: "flex items-center space-x-2 group", children: [l.jsxs("div", { className: "relative", children: [l.jsx(Ia, { className: "h-6 w-6 text-primary transition-all duration-300 group-hover:text-secondary group-hover:rotate-12" }), l.jsx("div", { className: "absolute inset-0 blur-lg bg-primary/20 group-hover:bg-secondary/30 transition-all duration-300 -z-10" })] }), l.jsx("span", { className: "text-xl font-bold gradient-text", children: "MockRise" })] }), l.jsx("p", { className: "text-sm text-muted-foreground mb-4 leading-relaxed", children: "Empowering job seekers with AI-powered interview practice for a brighter future." }), l.jsx("div", { className: "flex gap-2", children: [{ icon: d5, href: "https://facebook.com", label: "Facebook" }, { icon: g5, href: "https://twitter.com", label: "Twitter" }, { icon: p5, href: "https://instagram.com", label: "Instagram" }, { icon: BS, href: "https://linkedin.com", label: "LinkedIn" }].map((s, o) => l.jsx($e.a, { href: s.href, "aria-label": s.label, target: "_blank", rel: "noopener noreferrer", whileHover: { scale: 1.2, y: -2 }, whileTap: { scale: .95 }, className: "p-2 rounded-xl bg-muted/20 hover:bg-primary/10 hover:text-primary transition-all", children: l.jsx(s.icon, { className: "h-5 w-5" }) }, o)) })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Product" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("button", { onClick: () => i("features"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "Features" }) }), l.jsx("li", { children: l.jsx("button", { onClick: () => i("resources"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "Resources" }) }), l.jsx("li", { children: l.jsx("button", { onClick: () => a("/pricing"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "Pricing" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Resources" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("button", { onClick: () => a("/resources"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "Resources" }) }), l.jsx("li", { children: l.jsx("button", { onClick: () => a("/faq"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "FAQ" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Company" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("button", { onClick: () => i("about"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "About Us" }) }), l.jsx("li", { children: l.jsx("button", { onClick: () => i("contact"), className: "hover:text-primary transition-colors cursor-pointer text-left", children: "Contact" }) }), l.jsx("li", { children: l.jsx("button", { onClick: () => i("/resources"), className: "hover:text-primary transition-colors cursor-pointer text-left", disabled: !0, children: "Careers" }) }), l.jsx("li", { children: l.jsx("button", { onClick: () => i("/resources"), className: "hover:text-primary transition-colors cursor-pointer text-left", disabled: !0, children: "Blog" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Legal" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsxs("button", { onClick: () => e(!0), className: "hover:text-primary transition-colors flex items-center gap-2", children: [l.jsx(Zh, { className: "h-3 w-3" }), "Privacy Policy"] }) }), l.jsx("li", { children: l.jsxs("button", { onClick: () => r(!0), className: "hover:text-primary transition-colors flex items-center gap-2", children: [l.jsx(df, { className: "h-3 w-3" }), "Terms of Service"] }) })] })] })] }), l.jsx("div", { className: "border-t border-border pt-8 text-center text-sm text-muted-foreground", children: l.jsx("p", { children: " 2025 MockRise. All rights reserved." }) })] }) }), l.jsx(gx, { open: t, onOpenChange: e, type: "privacy" }), l.jsx(gx, { open: n, onOpenChange: r, type: "terms" })] }) }/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const n_ = "180", Lm = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Fm = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, kie = 0, DL = 1, Iie = 2, KCe = 3, Oie = 0, BA = 1, Ww = 2, Pc = 3, yf = 0, io = 1, Oc = 2, Pu = 0, dg = 1, LL = 2, FL = 3, UL = 4, Die = 5, jh = 100, Lie = 101, Fie = 102, Uie = 103, Bie = 104, $ie = 200, zie = 201, Vie = 202, Hie = 203, sC = 204, oC = 205, Wie = 206, Gie = 207, qie = 208, Xie = 209, Yie = 210, Kie = 211, Zie = 212, Qie = 213, Jie = 214, lC = 0, cC = 1, uC = 2, Eg = 3, dC = 4, fC = 5, hC = 6, pC = 7, r_ = 0, eae = 1, tae = 2, ju = 0, nae = 1, rae = 2, iae = 3, HU = 4, aae = 5, sae = 6, oae = 7, BL = "attached", lae = "detached", np = 300, $u = 301, rp = 302, vx = 303, P1 = 304, C0 = 306, j1 = 1e3, va = 1001, R1 = 1002, cs = 1003, WU = 1004, ZCe = 1004, Fy = 1005, QCe = 1005, Xr = 1006, Gw = 1007, JCe = 1007, bu = 1008, $L = 1008, lo = 1009, $A = 1010, zA = 1011, yx = 1012, i_ = 1013, zu = 1014, Ui = 1015, Ya = 1016, VA = 1017, HA = 1018, xx = 1020, GU = 35902, qU = 35899, XU = 1021, YU = 1022, ia = 1023, bx = 1026, wx = 1027, a_ = 1028, s_ = 1029, KU = 1030, WA = 1031, eNe = 1032, GA = 1033, qw = 33776, Xw = 33777, Yw = 33778, Kw = 33779, mC = 35840, gC = 35841, vC = 35842, yC = 35843, xC = 36196, bC = 37492, wC = 37496, SC = 37808, _C = 37809, EC = 37810, MC = 37811, TC = 37812, CC = 37813, NC = 37814, AC = 37815, PC = 37816, jC = 37817, RC = 37818, kC = 37819, IC = 37820, OC = 37821, DC = 36492, LC = 36494, FC = 36495, UC = 36283, BC = 36284, $C = 36285, zC = 36286, cae = 2200, uae = 2201, dae = 2202, k1 = 2300, VC = 2301, PT = 2302, Ym = 2400, Km = 2401, I1 = 2402, qA = 2500, ZU = 2501, tNe = 0, nNe = 1, rNe = 2, fae = 3200, hae = 3201, iNe = 3202, aNe = 3203, mp = 0, pae = 1, Kd = "", qs = "srgb", Vu = "srgb-linear", O1 = "linear", Wr = "srgb", sNe = 0, Um = 7680, oNe = 7681, lNe = 7682, cNe = 7683, uNe = 34055, dNe = 34056, fNe = 5386, hNe = 512, pNe = 513, mNe = 514, gNe = 515, vNe = 516, yNe = 517, xNe = 518, zL = 519, mae = 512, gae = 513, vae = 514, QU = 515, yae = 516, xae = 517, bae = 518, wae = 519, D1 = 35044, bNe = 35048, wNe = 35040, SNe = 35045, _Ne = 35049, ENe = 35041, MNe = 35046, TNe = 35050, CNe = 35042, NNe = "100", VL = "300 es", cl = 2e3, Sx = 2001, ANe = { COMPUTE: "compute", RENDER: "render" }, PNe = { PERSPECTIVE: "perspective", LINEAR: "linear", FLAT: "flat" }, jNe = { NORMAL: "normal", CENTROID: "centroid", SAMPLE: "sample", FIRST: "first", EITHER: "either" }; let Qu = class { addEventListener(e, n) { this._listeners === void 0 && (this._listeners = {}); const r = this._listeners; r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n) } hasEventListener(e, n) { const r = this._listeners; return r === void 0 ? !1 : r[e] !== void 0 && r[e].indexOf(n) !== -1 } removeEventListener(e, n) { const r = this._listeners; if (r === void 0) return; const i = r[e]; if (i !== void 0) { const a = i.indexOf(n); a !== -1 && i.splice(a, 1) } } dispatchEvent(e) { const n = this._listeners; if (n === void 0) return; const r = n[e.type]; if (r !== void 0) { e.target = this; const i = r.slice(0); for (let a = 0, s = i.length; a < s; a++)i[a].call(this, e); e.target = null } } }; const bs = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let EH = 1234567; const fg = Math.PI / 180, _x = 180 / Math.PI; function fl() { const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0; return (bs[t & 255] + bs[t >> 8 & 255] + bs[t >> 16 & 255] + bs[t >> 24 & 255] + "-" + bs[e & 255] + bs[e >> 8 & 255] + "-" + bs[e >> 16 & 15 | 64] + bs[e >> 24 & 255] + "-" + bs[n & 63 | 128] + bs[n >> 8 & 255] + "-" + bs[n >> 16 & 255] + bs[n >> 24 & 255] + bs[r & 255] + bs[r >> 8 & 255] + bs[r >> 16 & 255] + bs[r >> 24 & 255]).toLowerCase() } function In(t, e, n) { return Math.max(e, Math.min(n, t)) } function JU(t, e) { return (t % e + e) % e } function RNe(t, e, n, r, i) { return r + (t - e) * (i - r) / (n - e) } function kNe(t, e, n) { return t !== e ? (n - t) / (e - t) : 0 } function Zw(t, e, n) { return (1 - n) * t + n * e } function INe(t, e, n, r) { return Zw(t, e, 1 - Math.exp(-n * r)) } function ONe(t, e = 1) { return e - Math.abs(JU(t, e * 2) - e) } function DNe(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t)) } function LNe(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10)) } function FNe(t, e) { return t + Math.floor(Math.random() * (e - t + 1)) } function UNe(t, e) { return t + Math.random() * (e - t) } function BNe(t) { return t * (.5 - Math.random()) } function $Ne(t) { t !== void 0 && (EH = t); let e = EH += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function zNe(t) { return t * fg } function VNe(t) { return t * _x } function HNe(t) { return (t & t - 1) === 0 && t !== 0 } function WNe(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) } function GNe(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } function qNe(t, e, n, r, i) { const a = Math.cos, s = Math.sin, o = a(n / 2), c = s(n / 2), u = a((e + r) / 2), d = s((e + r) / 2), f = a((e - r) / 2), h = s((e - r) / 2), m = a((r - e) / 2), g = s((r - e) / 2); switch (i) { case "XYX": t.set(o * d, c * f, c * h, o * u); break; case "YZY": t.set(c * h, o * d, c * f, o * u); break; case "ZXZ": t.set(c * f, c * h, o * d, o * u); break; case "XZX": t.set(o * d, c * g, c * m, o * u); break; case "YXY": t.set(c * m, o * d, c * g, o * u); break; case "ZYZ": t.set(c * g, c * m, o * d, o * u); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } function Ys(t, e) { switch (e.constructor) { case Float32Array: return t; case Uint32Array: return t / 4294967295; case Uint16Array: return t / 65535; case Uint8Array: return t / 255; case Int32Array: return Math.max(t / 2147483647, -1); case Int16Array: return Math.max(t / 32767, -1); case Int8Array: return Math.max(t / 127, -1); default: throw new Error("Invalid component type.") } } function ir(t, e) { switch (e.constructor) { case Float32Array: return t; case Uint32Array: return Math.round(t * 4294967295); case Uint16Array: return Math.round(t * 65535); case Uint8Array: return Math.round(t * 255); case Int32Array: return Math.round(t * 2147483647); case Int16Array: return Math.round(t * 32767); case Int8Array: return Math.round(t * 127); default: throw new Error("Invalid component type.") } } const Io = { DEG2RAD: fg, RAD2DEG: _x, generateUUID: fl, clamp: In, euclideanModulo: JU, mapLinear: RNe, inverseLerp: kNe, lerp: Zw, damp: INe, pingpong: ONe, smoothstep: DNe, smootherstep: LNe, randInt: FNe, randFloat: UNe, randFloatSpread: BNe, seededRandom: $Ne, degToRad: zNe, radToDeg: VNe, isPowerOfTwo: HNe, ceilPowerOfTwo: WNe, floorPowerOfTwo: GNe, setQuaternionFromProperEuler: qNe, normalize: ir, denormalize: Ys }; class lt { constructor(e = 0, n = 0) { lt.prototype.isVector2 = !0, this.x = e, this.y = n } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, n) { return this.x = e, this.y = n, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, n) { switch (e) { case 0: this.x = n; break; case 1: this.y = n; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, n) { return this.x = e.x + n.x, this.y = e.y + n.y, this } addScaledVector(e, n) { return this.x += e.x * n, this.y += e.y * n, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, n) { return this.x = e.x - n.x, this.y = e.y - n.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const n = this.x, r = this.y, i = e.elements; return this.x = i[0] * n + i[3] * r + i[6], this.y = i[1] * n + i[4] * r + i[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, n) { return this.x = In(this.x, e.x, n.x), this.y = In(this.y, e.y, n.y), this } clampScalar(e, n) { return this.x = In(this.x, e, n), this.y = In(this.y, e, n), this } clampLength(e, n) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(In(r, e, n)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const n = Math.sqrt(this.lengthSq() * e.lengthSq()); if (n === 0) return Math.PI / 2; const r = this.dot(e) / n; return Math.acos(In(r, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const n = this.x - e.x, r = this.y - e.y; return n * n + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, n) { return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this } lerpVectors(e, n, r) { return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, n = 0) { return this.x = e[n], this.y = e[n + 1], this } toArray(e = [], n = 0) { return e[n] = this.x, e[n + 1] = this.y, e } fromBufferAttribute(e, n) { return this.x = e.getX(n), this.y = e.getY(n), this } rotateAround(e, n) { const r = Math.cos(n), i = Math.sin(n), a = this.x - e.x, s = this.y - e.y; return this.x = a * r - s * i + e.x, this.y = a * i + s * r + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class As { constructor(e = 0, n = 0, r = 0, i = 1) { this.isQuaternion = !0, this._x = e, this._y = n, this._z = r, this._w = i } static slerpFlat(e, n, r, i, a, s, o) { let c = r[i + 0], u = r[i + 1], d = r[i + 2], f = r[i + 3]; const h = a[s + 0], m = a[s + 1], g = a[s + 2], x = a[s + 3]; if (o === 0) { e[n + 0] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = f; return } if (o === 1) { e[n + 0] = h, e[n + 1] = m, e[n + 2] = g, e[n + 3] = x; return } if (f !== x || c !== h || u !== m || d !== g) { let v = 1 - o; const b = c * h + u * m + d * g + f * x, E = b >= 0 ? 1 : -1, M = 1 - b * b; if (M > Number.EPSILON) { const N = Math.sqrt(M), A = Math.atan2(N, b * E); v = Math.sin(v * A) / N, o = Math.sin(o * A) / N } const C = o * E; if (c = c * v + h * C, u = u * v + m * C, d = d * v + g * C, f = f * v + x * C, v === 1 - o) { const N = 1 / Math.sqrt(c * c + u * u + d * d + f * f); c *= N, u *= N, d *= N, f *= N } } e[n] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = f } static multiplyQuaternionsFlat(e, n, r, i, a, s) { const o = r[i], c = r[i + 1], u = r[i + 2], d = r[i + 3], f = a[s], h = a[s + 1], m = a[s + 2], g = a[s + 3]; return e[n] = o * g + d * f + c * m - u * h, e[n + 1] = c * g + d * h + u * f - o * m, e[n + 2] = u * g + d * m + o * h - c * f, e[n + 3] = d * g - o * f - c * h - u * m, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, n, r, i) { return this._x = e, this._y = n, this._z = r, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, n = !0) { const r = e._x, i = e._y, a = e._z, s = e._order, o = Math.cos, c = Math.sin, u = o(r / 2), d = o(i / 2), f = o(a / 2), h = c(r / 2), m = c(i / 2), g = c(a / 2); switch (s) { case "XYZ": this._x = h * d * f + u * m * g, this._y = u * m * f - h * d * g, this._z = u * d * g + h * m * f, this._w = u * d * f - h * m * g; break; case "YXZ": this._x = h * d * f + u * m * g, this._y = u * m * f - h * d * g, this._z = u * d * g - h * m * f, this._w = u * d * f + h * m * g; break; case "ZXY": this._x = h * d * f - u * m * g, this._y = u * m * f + h * d * g, this._z = u * d * g + h * m * f, this._w = u * d * f - h * m * g; break; case "ZYX": this._x = h * d * f - u * m * g, this._y = u * m * f + h * d * g, this._z = u * d * g - h * m * f, this._w = u * d * f + h * m * g; break; case "YZX": this._x = h * d * f + u * m * g, this._y = u * m * f + h * d * g, this._z = u * d * g - h * m * f, this._w = u * d * f - h * m * g; break; case "XZY": this._x = h * d * f - u * m * g, this._y = u * m * f - h * d * g, this._z = u * d * g + h * m * f, this._w = u * d * f + h * m * g; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return n === !0 && this._onChangeCallback(), this } setFromAxisAngle(e, n) { const r = n / 2, i = Math.sin(r); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this } setFromRotationMatrix(e) { const n = e.elements, r = n[0], i = n[4], a = n[8], s = n[1], o = n[5], c = n[9], u = n[2], d = n[6], f = n[10], h = r + o + f; if (h > 0) { const m = .5 / Math.sqrt(h + 1); this._w = .25 / m, this._x = (d - c) * m, this._y = (a - u) * m, this._z = (s - i) * m } else if (r > o && r > f) { const m = 2 * Math.sqrt(1 + r - o - f); this._w = (d - c) / m, this._x = .25 * m, this._y = (i + s) / m, this._z = (a + u) / m } else if (o > f) { const m = 2 * Math.sqrt(1 + o - r - f); this._w = (a - u) / m, this._x = (i + s) / m, this._y = .25 * m, this._z = (c + d) / m } else { const m = 2 * Math.sqrt(1 + f - r - o); this._w = (s - i) / m, this._x = (a + u) / m, this._y = (c + d) / m, this._z = .25 * m } return this._onChangeCallback(), this } setFromUnitVectors(e, n) { let r = e.dot(n) + 1; return r < 1e-8 ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = r), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(In(this.dot(e), -1, 1))) } rotateTowards(e, n) { const r = this.angleTo(e); if (r === 0) return this; const i = Math.min(1, n / r); return this.slerp(e, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, n) { const r = e._x, i = e._y, a = e._z, s = e._w, o = n._x, c = n._y, u = n._z, d = n._w; return this._x = r * d + s * o + i * u - a * c, this._y = i * d + s * c + a * o - r * u, this._z = a * d + s * u + r * c - i * o, this._w = s * d - r * o - i * c - a * u, this._onChangeCallback(), this } slerp(e, n) { if (n === 0) return this; if (n === 1) return this.copy(e); const r = this._x, i = this._y, a = this._z, s = this._w; let o = s * e._w + r * e._x + i * e._y + a * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = r, this._y = i, this._z = a, this; const c = 1 - o * o; if (c <= Number.EPSILON) { const m = 1 - n; return this._w = m * s + n * this._w, this._x = m * r + n * this._x, this._y = m * i + n * this._y, this._z = m * a + n * this._z, this.normalize(), this } const u = Math.sqrt(c), d = Math.atan2(u, o), f = Math.sin((1 - n) * d) / u, h = Math.sin(n * d) / u; return this._w = s * f + this._w * h, this._x = r * f + this._x * h, this._y = i * f + this._y * h, this._z = a * f + this._z * h, this._onChangeCallback(), this } slerpQuaternions(e, n, r) { return this.copy(e).slerp(n, r) } random() { const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), r = Math.random(), i = Math.sqrt(1 - r), a = Math.sqrt(r); return this.set(i * Math.sin(e), i * Math.cos(e), a * Math.sin(n), a * Math.cos(n)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, n = 0) { return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this } toArray(e = [], n = 0) { return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e } fromBufferAttribute(e, n) { return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class pe { constructor(e = 0, n = 0, r = 0) { pe.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = r } set(e, n, r) { return r === void 0 && (r = this.z), this.x = e, this.y = n, this.z = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, n) { switch (e) { case 0: this.x = n; break; case 1: this.y = n; break; case 2: this.z = n; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, n) { return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this } addScaledVector(e, n) { return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, n) { return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, n) { return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this } applyEuler(e) { return this.applyQuaternion(MH.setFromEuler(e)) } applyAxisAngle(e, n) { return this.applyQuaternion(MH.setFromAxisAngle(e, n)) } applyMatrix3(e) { const n = this.x, r = this.y, i = this.z, a = e.elements; return this.x = a[0] * n + a[3] * r + a[6] * i, this.y = a[1] * n + a[4] * r + a[7] * i, this.z = a[2] * n + a[5] * r + a[8] * i, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const n = this.x, r = this.y, i = this.z, a = e.elements, s = 1 / (a[3] * n + a[7] * r + a[11] * i + a[15]); return this.x = (a[0] * n + a[4] * r + a[8] * i + a[12]) * s, this.y = (a[1] * n + a[5] * r + a[9] * i + a[13]) * s, this.z = (a[2] * n + a[6] * r + a[10] * i + a[14]) * s, this } applyQuaternion(e) { const n = this.x, r = this.y, i = this.z, a = e.x, s = e.y, o = e.z, c = e.w, u = 2 * (s * i - o * r), d = 2 * (o * n - a * i), f = 2 * (a * r - s * n); return this.x = n + c * u + s * f - o * d, this.y = r + c * d + o * u - a * f, this.z = i + c * f + a * d - s * u, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const n = this.x, r = this.y, i = this.z, a = e.elements; return this.x = a[0] * n + a[4] * r + a[8] * i, this.y = a[1] * n + a[5] * r + a[9] * i, this.z = a[2] * n + a[6] * r + a[10] * i, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, n) { return this.x = In(this.x, e.x, n.x), this.y = In(this.y, e.y, n.y), this.z = In(this.z, e.z, n.z), this } clampScalar(e, n) { return this.x = In(this.x, e, n), this.y = In(this.y, e, n), this.z = In(this.z, e, n), this } clampLength(e, n) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(In(r, e, n)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, n) { return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this } lerpVectors(e, n, r) { return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, n) { const r = e.x, i = e.y, a = e.z, s = n.x, o = n.y, c = n.z; return this.x = i * c - a * o, this.y = a * s - r * c, this.z = r * o - i * s, this } projectOnVector(e) { const n = e.lengthSq(); if (n === 0) return this.set(0, 0, 0); const r = e.dot(this) / n; return this.copy(e).multiplyScalar(r) } projectOnPlane(e) { return nR.copy(this).projectOnVector(e), this.sub(nR) } reflect(e) { return this.sub(nR.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const n = Math.sqrt(this.lengthSq() * e.lengthSq()); if (n === 0) return Math.PI / 2; const r = this.dot(e) / n; return Math.acos(In(r, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const n = this.x - e.x, r = this.y - e.y, i = this.z - e.z; return n * n + r * r + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, n, r) { const i = Math.sin(n) * e; return this.x = i * Math.sin(r), this.y = Math.cos(n) * e, this.z = i * Math.cos(r), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, n, r) { return this.x = e * Math.sin(n), this.y = r, this.z = e * Math.cos(n), this } setFromMatrixPosition(e) { const n = e.elements; return this.x = n[12], this.y = n[13], this.z = n[14], this } setFromMatrixScale(e) { const n = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length(); return this.x = n, this.y = r, this.z = i, this } setFromMatrixColumn(e, n) { return this.fromArray(e.elements, n * 4) } setFromMatrix3Column(e, n) { return this.fromArray(e.elements, n * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, n = 0) { return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this } toArray(e = [], n = 0) { return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e } fromBufferAttribute(e, n) { return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, r = Math.sqrt(1 - n * n); return this.x = r * Math.cos(e), this.y = n, this.z = r * Math.sin(e), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const nR = new pe, MH = new As; class Qn { constructor(e, n, r, i, a, s, o, c, u) { Qn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, n, r, i, a, s, o, c, u) } set(e, n, r, i, a, s, o, c, u) { const d = this.elements; return d[0] = e, d[1] = i, d[2] = o, d[3] = n, d[4] = a, d[5] = c, d[6] = r, d[7] = s, d[8] = u, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const n = this.elements, r = e.elements; return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], this } extractBasis(e, n, r) { return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const n = e.elements; return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, n) { const r = e.elements, i = n.elements, a = this.elements, s = r[0], o = r[3], c = r[6], u = r[1], d = r[4], f = r[7], h = r[2], m = r[5], g = r[8], x = i[0], v = i[3], b = i[6], E = i[1], M = i[4], C = i[7], N = i[2], A = i[5], j = i[8]; return a[0] = s * x + o * E + c * N, a[3] = s * v + o * M + c * A, a[6] = s * b + o * C + c * j, a[1] = u * x + d * E + f * N, a[4] = u * v + d * M + f * A, a[7] = u * b + d * C + f * j, a[2] = h * x + m * E + g * N, a[5] = h * v + m * M + g * A, a[8] = h * b + m * C + g * j, this } multiplyScalar(e) { const n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this } determinant() { const e = this.elements, n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], c = e[6], u = e[7], d = e[8]; return n * s * d - n * o * u - r * a * d + r * o * c + i * a * u - i * s * c } invert() { const e = this.elements, n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], c = e[6], u = e[7], d = e[8], f = d * s - o * u, h = o * c - d * a, m = u * a - s * c, g = n * f + r * h + i * m; if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const x = 1 / g; return e[0] = f * x, e[1] = (i * u - d * r) * x, e[2] = (o * r - i * s) * x, e[3] = h * x, e[4] = (d * n - i * c) * x, e[5] = (i * a - o * n) * x, e[6] = m * x, e[7] = (r * c - u * n) * x, e[8] = (s * n - r * a) * x, this } transpose() { let e; const n = this.elements; return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const n = this.elements; return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this } setUvTransform(e, n, r, i, a, s, o) { const c = Math.cos(a), u = Math.sin(a); return this.set(r * c, r * u, -r * (c * s + u * o) + s + e, -i * u, i * c, -i * (-u * s + c * o) + o + n, 0, 0, 1), this } scale(e, n) { return this.premultiply(rR.makeScale(e, n)), this } rotate(e) { return this.premultiply(rR.makeRotation(-e)), this } translate(e, n) { return this.premultiply(rR.makeTranslation(e, n)), this } makeTranslation(e, n) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, n, 0, 0, 1), this } makeRotation(e) { const n = Math.cos(e), r = Math.sin(e); return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this } makeScale(e, n) { return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this } equals(e) { const n = this.elements, r = e.elements; for (let i = 0; i < 9; i++)if (n[i] !== r[i]) return !1; return !0 } fromArray(e, n = 0) { for (let r = 0; r < 9; r++)this.elements[r] = e[r + n]; return this } toArray(e = [], n = 0) { const r = this.elements; return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const rR = new Qn; function Sae(t) { for (let e = t.length - 1; e >= 0; --e)if (t[e] >= 65535) return !0; return !1 } const XNe = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function Uy(t, e) { return new XNe[t](e) } function L1(t) { return document.createElementNS("http://www.w3.org/1999/xhtml", t) } function _ae() { const t = L1("canvas"); return t.style.display = "block", t } const TH = {}; function F1(t) { t in TH || (TH[t] = !0, console.warn(t)) } function YNe(t, e, n) { return new Promise(function (r, i) { function a() { switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) { case t.WAIT_FAILED: i(); break; case t.TIMEOUT_EXPIRED: setTimeout(a, n); break; default: r() } } setTimeout(a, n) }) } const CH = new Qn().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), NH = new Qn().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715); function KNe() { const t = { enabled: !0, workingColorSpace: Vu, spaces: {}, convert: function (i, a, s) { return this.enabled === !1 || a === s || !a || !s || (this.spaces[a].transfer === Wr && (i.r = sf(i.r), i.g = sf(i.g), i.b = sf(i.b)), this.spaces[a].primaries !== this.spaces[s].primaries && (i.applyMatrix3(this.spaces[a].toXYZ), i.applyMatrix3(this.spaces[s].fromXYZ)), this.spaces[s].transfer === Wr && (i.r = Jy(i.r), i.g = Jy(i.g), i.b = Jy(i.b))), i }, workingToColorSpace: function (i, a) { return this.convert(i, this.workingColorSpace, a) }, colorSpaceToWorking: function (i, a) { return this.convert(i, a, this.workingColorSpace) }, getPrimaries: function (i) { return this.spaces[i].primaries }, getTransfer: function (i) { return i === Kd ? O1 : this.spaces[i].transfer }, getToneMappingMode: function (i) { return this.spaces[i].outputColorSpaceConfig.toneMappingMode || "standard" }, getLuminanceCoefficients: function (i, a = this.workingColorSpace) { return i.fromArray(this.spaces[a].luminanceCoefficients) }, define: function (i) { Object.assign(this.spaces, i) }, _getMatrix: function (i, a, s) { return i.copy(this.spaces[a].toXYZ).multiply(this.spaces[s].fromXYZ) }, _getDrawingBufferColorSpace: function (i) { return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace }, _getUnpackColorSpace: function (i = this.workingColorSpace) { return this.spaces[i].workingColorSpaceConfig.unpackColorSpace }, fromWorkingColorSpace: function (i, a) { return F1("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), t.workingToColorSpace(i, a) }, toWorkingColorSpace: function (i, a) { return F1("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), t.colorSpaceToWorking(i, a) } }, e = [.64, .33, .3, .6, .15, .06], n = [.2126, .7152, .0722], r = [.3127, .329]; return t.define({ [Vu]: { primaries: e, whitePoint: r, transfer: O1, toXYZ: CH, fromXYZ: NH, luminanceCoefficients: n, workingColorSpaceConfig: { unpackColorSpace: qs }, outputColorSpaceConfig: { drawingBufferColorSpace: qs } }, [qs]: { primaries: e, whitePoint: r, transfer: Wr, toXYZ: CH, fromXYZ: NH, luminanceCoefficients: n, outputColorSpaceConfig: { drawingBufferColorSpace: qs } } }), t } const Nr = KNe(); function sf(t) { return t < .04045 ? t * .0773993808 : Math.pow(t * .9478672986 + .0521327014, 2.4) } function Jy(t) { return t < .0031308 ? t * 12.92 : 1.055 * Math.pow(t, .41666) - .055 } let ey; class Eae { static getDataURL(e, n = "image/png") { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let r; if (e instanceof HTMLCanvasElement) r = e; else { ey === void 0 && (ey = L1("canvas")), ey.width = e.width, ey.height = e.height; const i = ey.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), r = ey } return r.toDataURL(n) } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const n = L1("canvas"); n.width = e.width, n.height = e.height; const r = n.getContext("2d"); r.drawImage(e, 0, 0, e.width, e.height); const i = r.getImageData(0, 0, e.width, e.height), a = i.data; for (let s = 0; s < a.length; s++)a[s] = sf(a[s] / 255) * 255; return r.putImageData(i, 0, 0), n } else if (e.data) { const n = e.data.slice(0); for (let r = 0; r < n.length; r++)n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[r] = Math.floor(sf(n[r] / 255) * 255) : n[r] = sf(n[r]); return { data: n, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let ZNe = 0; class Oh { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: ZNe++ }), this.uuid = fl(), this.data = e, this.dataReady = !0, this.version = 0 } getSize(e) { const n = this.data; return typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement ? e.set(n.videoWidth, n.videoHeight, 0) : n instanceof VideoFrame ? e.set(n.displayHeight, n.displayWidth, 0) : n !== null ? e.set(n.width, n.height, n.depth || 0) : e.set(0, 0, 0), e } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const n = e === void 0 || typeof e == "string"; if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const r = { uuid: this.uuid, url: "" }, i = this.data; if (i !== null) { let a; if (Array.isArray(i)) { a = []; for (let s = 0, o = i.length; s < o; s++)i[s].isDataTexture ? a.push(iR(i[s].image)) : a.push(iR(i[s])) } else a = iR(i); r.url = a } return n || (e.images[this.uuid] = r), r } } function iR(t) { return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? Eae.getDataURL(t) : t.data ? { data: Array.from(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let QNe = 0; const aR = new pe; class ti extends Qu { constructor(e = ti.DEFAULT_IMAGE, n = ti.DEFAULT_MAPPING, r = va, i = va, a = Xr, s = bu, o = ia, c = lo, u = ti.DEFAULT_ANISOTROPY, d = Kd) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: QNe++ }), this.uuid = fl(), this.name = "", this.source = new Oh(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = r, this.wrapT = i, this.magFilter = a, this.minFilter = s, this.anisotropy = u, this.format = o, this.internalFormat = null, this.type = c, this.offset = new lt(0, 0), this.repeat = new lt(1, 1), this.center = new lt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Qn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = d, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0 } get width() { return this.source.getSize(aR).x } get height() { return this.source.getSize(aR).y } get depth() { return this.source.getSize(aR).z } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } addUpdateRange(e, n) { this.updateRanges.push({ start: e, count: n }) } clearUpdateRanges() { this.updateRanges.length = 0 } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } setValues(e) { for (const n in e) { const r = e[n]; if (r === void 0) { console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`); continue } const i = this[n]; if (i === void 0) { console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`); continue } i && r && i.isVector2 && r.isVector2 || i && r && i.isVector3 && r.isVector3 || i && r && i.isMatrix3 && r.isMatrix3 ? i.copy(r) : this[n] = r } } toJSON(e) { const n = e === void 0 || typeof e == "string"; if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const r = { metadata: { version: 4.7, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (r.userData = this.userData), n || (e.textures[this.uuid] = r), r } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== np) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case j1: e.x = e.x - Math.floor(e.x); break; case va: e.x = e.x < 0 ? 0 : 1; break; case R1: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case j1: e.y = e.y - Math.floor(e.y); break; case va: e.y = e.y < 0 ? 0 : 1; break; case R1: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } set needsPMREMUpdate(e) { e === !0 && this.pmremVersion++ } } ti.DEFAULT_IMAGE = null; ti.DEFAULT_MAPPING = np; ti.DEFAULT_ANISOTROPY = 1; class jr { constructor(e = 0, n = 0, r = 0, i = 1) { jr.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = r, this.w = i } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, n, r, i) { return this.x = e, this.y = n, this.z = r, this.w = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, n) { switch (e) { case 0: this.x = n; break; case 1: this.y = n; break; case 2: this.z = n; break; case 3: this.w = n; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, n) { return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this } addScaledVector(e, n) { return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, n) { return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const n = this.x, r = this.y, i = this.z, a = this.w, s = e.elements; return this.x = s[0] * n + s[4] * r + s[8] * i + s[12] * a, this.y = s[1] * n + s[5] * r + s[9] * i + s[13] * a, this.z = s[2] * n + s[6] * r + s[10] * i + s[14] * a, this.w = s[3] * n + s[7] * r + s[11] * i + s[15] * a, this } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const n = Math.sqrt(1 - e.w * e.w); return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this } setAxisAngleFromRotationMatrix(e) { let n, r, i, a; const c = e.elements, u = c[0], d = c[4], f = c[8], h = c[1], m = c[5], g = c[9], x = c[2], v = c[6], b = c[10]; if (Math.abs(d - h) < .01 && Math.abs(f - x) < .01 && Math.abs(g - v) < .01) { if (Math.abs(d + h) < .1 && Math.abs(f + x) < .1 && Math.abs(g + v) < .1 && Math.abs(u + m + b - 3) < .1) return this.set(1, 0, 0, 0), this; n = Math.PI; const M = (u + 1) / 2, C = (m + 1) / 2, N = (b + 1) / 2, A = (d + h) / 4, j = (f + x) / 4, O = (g + v) / 4; return M > C && M > N ? M < .01 ? (r = 0, i = .707106781, a = .707106781) : (r = Math.sqrt(M), i = A / r, a = j / r) : C > N ? C < .01 ? (r = .707106781, i = 0, a = .707106781) : (i = Math.sqrt(C), r = A / i, a = O / i) : N < .01 ? (r = .707106781, i = .707106781, a = 0) : (a = Math.sqrt(N), r = j / a, i = O / a), this.set(r, i, a, n), this } let E = Math.sqrt((v - g) * (v - g) + (f - x) * (f - x) + (h - d) * (h - d)); return Math.abs(E) < .001 && (E = 1), this.x = (v - g) / E, this.y = (f - x) / E, this.z = (h - d) / E, this.w = Math.acos((u + m + b - 1) / 2), this } setFromMatrixPosition(e) { const n = e.elements; return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, n) { return this.x = In(this.x, e.x, n.x), this.y = In(this.y, e.y, n.y), this.z = In(this.z, e.z, n.z), this.w = In(this.w, e.w, n.w), this } clampScalar(e, n) { return this.x = In(this.x, e, n), this.y = In(this.y, e, n), this.z = In(this.z, e, n), this.w = In(this.w, e, n), this } clampLength(e, n) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(In(r, e, n)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, n) { return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this } lerpVectors(e, n, r) { return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this.w = e.w + (n.w - e.w) * r, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, n = 0) { return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this } toArray(e = [], n = 0) { return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e } fromBufferAttribute(e, n) { return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class eB extends Qu { constructor(e = 1, n = 1, r = {}) { super(), r = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: Xr, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1, depth: 1, multiview: !1 }, r), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = r.depth, this.scissor = new jr(0, 0, e, n), this.scissorTest = !1, this.viewport = new jr(0, 0, e, n); const i = { width: e, height: n, depth: r.depth }, a = new ti(i); this.textures = []; const s = r.count; for (let o = 0; o < s; o++)this.textures[o] = a.clone(), this.textures[o].isRenderTargetTexture = !0, this.textures[o].renderTarget = this; this._setTextureOptions(r), this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = r.depthTexture, this.samples = r.samples, this.multiview = r.multiview } _setTextureOptions(e = {}) { const n = { minFilter: Xr, generateMipmaps: !1, flipY: !1, internalFormat: null }; e.mapping !== void 0 && (n.mapping = e.mapping), e.wrapS !== void 0 && (n.wrapS = e.wrapS), e.wrapT !== void 0 && (n.wrapT = e.wrapT), e.wrapR !== void 0 && (n.wrapR = e.wrapR), e.magFilter !== void 0 && (n.magFilter = e.magFilter), e.minFilter !== void 0 && (n.minFilter = e.minFilter), e.format !== void 0 && (n.format = e.format), e.type !== void 0 && (n.type = e.type), e.anisotropy !== void 0 && (n.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (n.colorSpace = e.colorSpace), e.flipY !== void 0 && (n.flipY = e.flipY), e.generateMipmaps !== void 0 && (n.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (n.internalFormat = e.internalFormat); for (let r = 0; r < this.textures.length; r++)this.textures[r].setValues(n) } get texture() { return this.textures[0] } set texture(e) { this.textures[0] = e } set depthTexture(e) { this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e } get depthTexture() { return this._depthTexture } setSize(e, n, r = 1) { if (this.width !== e || this.height !== n || this.depth !== r) { this.width = e, this.height = n, this.depth = r; for (let i = 0, a = this.textures.length; i < a; i++)this.textures[i].image.width = e, this.textures[i].image.height = n, this.textures[i].image.depth = r, this.textures[i].isArrayTexture = this.textures[i].image.depth > 1; this.dispose() } this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0; for (let n = 0, r = e.textures.length; n < r; n++) { this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0, this.textures[n].renderTarget = this; const i = Object.assign({}, e.textures[n].image); this.textures[n].source = new Oh(i) } return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Hl extends eB { constructor(e = 1, n = 1, r = {}) { super(e, n, r), this.isWebGLRenderTarget = !0 } } class XA extends ti { constructor(e = null, n = 1, r = 1, i = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: r, depth: i }, this.magFilter = cs, this.minFilter = cs, this.wrapR = va, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class JNe extends Hl { constructor(e = 1, n = 1, r = 1, i = {}) { super(e, n, i), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new XA(null, e, n, r), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0 } } class YA extends ti { constructor(e = null, n = 1, r = 1, i = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: r, depth: i }, this.magFilter = cs, this.minFilter = cs, this.wrapR = va, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class eAe extends Hl { constructor(e = 1, n = 1, r = 1, i = {}) { super(e, n, i), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new YA(null, e, n, r), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0 } } class Ps { constructor(e = new pe(1 / 0, 1 / 0, 1 / 0), n = new pe(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = n } set(e, n) { return this.min.copy(e), this.max.copy(n), this } setFromArray(e) { this.makeEmpty(); for (let n = 0, r = e.length; n < r; n += 3)this.expandByPoint(_c.fromArray(e, n)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let n = 0, r = e.count; n < r; n++)this.expandByPoint(_c.fromBufferAttribute(e, n)); return this } setFromPoints(e) { this.makeEmpty(); for (let n = 0, r = e.length; n < r; n++)this.expandByPoint(e[n]); return this } setFromCenterAndSize(e, n) { const r = _c.copy(n).multiplyScalar(.5); return this.min.copy(e).sub(r), this.max.copy(e).add(r), this } setFromObject(e, n = !1) { return this.makeEmpty(), this.expandByObject(e, n) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, n = !1) { e.updateWorldMatrix(!1, !1); const r = e.geometry; if (r !== void 0) { const a = r.getAttribute("position"); if (n === !0 && a !== void 0 && e.isInstancedMesh !== !0) for (let s = 0, o = a.count; s < o; s++)e.isMesh === !0 ? e.getVertexPosition(s, _c) : _c.fromBufferAttribute(a, s), _c.applyMatrix4(e.matrixWorld), this.expandByPoint(_c); else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), KE.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(), KE.copy(r.boundingBox)), KE.applyMatrix4(e.matrixWorld), this.union(KE) } const i = e.children; for (let a = 0, s = i.length; a < s; a++)this.expandByObject(i[a], n); return this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, n) { return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z } intersectsSphere(e) { return this.clampPoint(e.center, _c), _c.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let n, r; return e.normal.x > 0 ? (n = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, r += e.normal.z * this.min.z), n <= -e.constant && r >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Zb), ZE.subVectors(this.max, Zb), ty.subVectors(e.a, Zb), ny.subVectors(e.b, Zb), ry.subVectors(e.c, Zb), mh.subVectors(ny, ty), gh.subVectors(ry, ny), ym.subVectors(ty, ry); let n = [0, -mh.z, mh.y, 0, -gh.z, gh.y, 0, -ym.z, ym.y, mh.z, 0, -mh.x, gh.z, 0, -gh.x, ym.z, 0, -ym.x, -mh.y, mh.x, 0, -gh.y, gh.x, 0, -ym.y, ym.x, 0]; return !sR(n, ty, ny, ry, ZE) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !sR(n, ty, ny, ry, ZE)) ? !1 : (QE.crossVectors(mh, gh), n = [QE.x, QE.y, QE.z], sR(n, ty, ny, ry, ZE)) } clampPoint(e, n) { return n.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, _c).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(_c).length() * .5), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (Fd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Fd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Fd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Fd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Fd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Fd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Fd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Fd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Fd), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } toJSON() { return { min: this.min.toArray(), max: this.max.toArray() } } fromJSON(e) { return this.min.fromArray(e.min), this.max.fromArray(e.max), this } } const Fd = [new pe, new pe, new pe, new pe, new pe, new pe, new pe, new pe], _c = new pe, KE = new Ps, ty = new pe, ny = new pe, ry = new pe, mh = new pe, gh = new pe, ym = new pe, Zb = new pe, ZE = new pe, QE = new pe, xm = new pe; function sR(t, e, n, r, i) { for (let a = 0, s = t.length - 3; a <= s; a += 3) { xm.fromArray(t, a); const o = i.x * Math.abs(xm.x) + i.y * Math.abs(xm.y) + i.z * Math.abs(xm.z), c = e.dot(xm), u = n.dot(xm), d = r.dot(xm); if (Math.max(-Math.max(c, u, d), Math.min(c, u, d)) > o) return !1 } return !0 } const tAe = new Ps, Qb = new pe, oR = new pe; class us { constructor(e = new pe, n = -1) { this.isSphere = !0, this.center = e, this.radius = n } set(e, n) { return this.center.copy(e), this.radius = n, this } setFromPoints(e, n) { const r = this.center; n !== void 0 ? r.copy(n) : tAe.setFromPoints(e).getCenter(r); let i = 0; for (let a = 0, s = e.length; a < s; a++)i = Math.max(i, r.distanceToSquared(e[a])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const n = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= n * n } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, n) { const r = this.center.distanceToSquared(e); return n.copy(e), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; Qb.subVectors(e, this.center); const n = Qb.lengthSq(); if (n > this.radius * this.radius) { const r = Math.sqrt(n), i = (r - this.radius) * .5; this.center.addScaledVector(Qb, i / r), this.radius += i } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (oR.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Qb.copy(e.center).add(oR)), this.expandByPoint(Qb.copy(e.center).sub(oR))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } toJSON() { return { radius: this.radius, center: this.center.toArray() } } fromJSON(e) { return this.radius = e.radius, this.center.fromArray(e.center), this } } const Ud = new pe, lR = new pe, JE = new pe, vh = new pe, cR = new pe, eM = new pe, uR = new pe; class Hg { constructor(e = new pe, n = new pe(0, 0, -1)) { this.origin = e, this.direction = n } set(e, n) { return this.origin.copy(e), this.direction.copy(n), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, n) { return n.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Ud)), this } closestPointToPoint(e, n) { n.subVectors(e, this.origin); const r = n.dot(this.direction); return r < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, r) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const n = Ud.subVectors(e, this.origin).dot(this.direction); return n < 0 ? this.origin.distanceToSquared(e) : (Ud.copy(this.origin).addScaledVector(this.direction, n), Ud.distanceToSquared(e)) } distanceSqToSegment(e, n, r, i) { lR.copy(e).add(n).multiplyScalar(.5), JE.copy(n).sub(e).normalize(), vh.copy(this.origin).sub(lR); const a = e.distanceTo(n) * .5, s = -this.direction.dot(JE), o = vh.dot(this.direction), c = -vh.dot(JE), u = vh.lengthSq(), d = Math.abs(1 - s * s); let f, h, m, g; if (d > 0) if (f = s * c - o, h = s * o - c, g = a * d, f >= 0) if (h >= -g) if (h <= g) { const x = 1 / d; f *= x, h *= x, m = f * (f + s * h + 2 * o) + h * (s * f + h + 2 * c) + u } else h = a, f = Math.max(0, -(s * h + o)), m = -f * f + h * (h + 2 * c) + u; else h = -a, f = Math.max(0, -(s * h + o)), m = -f * f + h * (h + 2 * c) + u; else h <= -g ? (f = Math.max(0, -(-s * a + o)), h = f > 0 ? -a : Math.min(Math.max(-a, -c), a), m = -f * f + h * (h + 2 * c) + u) : h <= g ? (f = 0, h = Math.min(Math.max(-a, -c), a), m = h * (h + 2 * c) + u) : (f = Math.max(0, -(s * a + o)), h = f > 0 ? a : Math.min(Math.max(-a, -c), a), m = -f * f + h * (h + 2 * c) + u); else h = s > 0 ? -a : a, f = Math.max(0, -(s * h + o)), m = -f * f + h * (h + 2 * c) + u; return r && r.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(lR).addScaledVector(JE, h), m } intersectSphere(e, n) { Ud.subVectors(e.center, this.origin); const r = Ud.dot(this.direction), i = Ud.dot(Ud) - r * r, a = e.radius * e.radius; if (i > a) return null; const s = Math.sqrt(a - i), o = r - s, c = r + s; return c < 0 ? null : o < 0 ? this.at(c, n) : this.at(o, n) } intersectsSphere(e) { return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const n = e.normal.dot(this.direction); if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const r = -(this.origin.dot(e.normal) + e.constant) / n; return r >= 0 ? r : null } intersectPlane(e, n) { const r = this.distanceToPlane(e); return r === null ? null : this.at(r, n) } intersectsPlane(e) { const n = e.distanceToPoint(this.origin); return n === 0 || e.normal.dot(this.direction) * n < 0 } intersectBox(e, n) { let r, i, a, s, o, c; const u = 1 / this.direction.x, d = 1 / this.direction.y, f = 1 / this.direction.z, h = this.origin; return u >= 0 ? (r = (e.min.x - h.x) * u, i = (e.max.x - h.x) * u) : (r = (e.max.x - h.x) * u, i = (e.min.x - h.x) * u), d >= 0 ? (a = (e.min.y - h.y) * d, s = (e.max.y - h.y) * d) : (a = (e.max.y - h.y) * d, s = (e.min.y - h.y) * d), r > s || a > i || ((a > r || isNaN(r)) && (r = a), (s < i || isNaN(i)) && (i = s), f >= 0 ? (o = (e.min.z - h.z) * f, c = (e.max.z - h.z) * f) : (o = (e.max.z - h.z) * f, c = (e.min.z - h.z) * f), r > c || o > i) || ((o > r || r !== r) && (r = o), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(r >= 0 ? r : i, n) } intersectsBox(e) { return this.intersectBox(e, Ud) !== null } intersectTriangle(e, n, r, i, a) { cR.subVectors(n, e), eM.subVectors(r, e), uR.crossVectors(cR, eM); let s = this.direction.dot(uR), o; if (s > 0) { if (i) return null; o = 1 } else if (s < 0) o = -1, s = -s; else return null; vh.subVectors(this.origin, e); const c = o * this.direction.dot(eM.crossVectors(vh, eM)); if (c < 0) return null; const u = o * this.direction.dot(cR.cross(vh)); if (u < 0 || c + u > s) return null; const d = -o * vh.dot(uR); return d < 0 ? null : this.at(d / s, a) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class Fn { constructor(e, n, r, i, a, s, o, c, u, d, f, h, m, g, x, v) { Fn.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, n, r, i, a, s, o, c, u, d, f, h, m, g, x, v) } set(e, n, r, i, a, s, o, c, u, d, f, h, m, g, x, v) { const b = this.elements; return b[0] = e, b[4] = n, b[8] = r, b[12] = i, b[1] = a, b[5] = s, b[9] = o, b[13] = c, b[2] = u, b[6] = d, b[10] = f, b[14] = h, b[3] = m, b[7] = g, b[11] = x, b[15] = v, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new Fn().fromArray(this.elements) } copy(e) { const n = this.elements, r = e.elements; return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this } copyPosition(e) { const n = this.elements, r = e.elements; return n[12] = r[12], n[13] = r[13], n[14] = r[14], this } setFromMatrix3(e) { const n = e.elements; return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1), this } extractBasis(e, n, r) { return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this } makeBasis(e, n, r) { return this.set(e.x, n.x, r.x, 0, e.y, n.y, r.y, 0, e.z, n.z, r.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const n = this.elements, r = e.elements, i = 1 / iy.setFromMatrixColumn(e, 0).length(), a = 1 / iy.setFromMatrixColumn(e, 1).length(), s = 1 / iy.setFromMatrixColumn(e, 2).length(); return n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = 0, n[4] = r[4] * a, n[5] = r[5] * a, n[6] = r[6] * a, n[7] = 0, n[8] = r[8] * s, n[9] = r[9] * s, n[10] = r[10] * s, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this } makeRotationFromEuler(e) { const n = this.elements, r = e.x, i = e.y, a = e.z, s = Math.cos(r), o = Math.sin(r), c = Math.cos(i), u = Math.sin(i), d = Math.cos(a), f = Math.sin(a); if (e.order === "XYZ") { const h = s * d, m = s * f, g = o * d, x = o * f; n[0] = c * d, n[4] = -c * f, n[8] = u, n[1] = m + g * u, n[5] = h - x * u, n[9] = -o * c, n[2] = x - h * u, n[6] = g + m * u, n[10] = s * c } else if (e.order === "YXZ") { const h = c * d, m = c * f, g = u * d, x = u * f; n[0] = h + x * o, n[4] = g * o - m, n[8] = s * u, n[1] = s * f, n[5] = s * d, n[9] = -o, n[2] = m * o - g, n[6] = x + h * o, n[10] = s * c } else if (e.order === "ZXY") { const h = c * d, m = c * f, g = u * d, x = u * f; n[0] = h - x * o, n[4] = -s * f, n[8] = g + m * o, n[1] = m + g * o, n[5] = s * d, n[9] = x - h * o, n[2] = -s * u, n[6] = o, n[10] = s * c } else if (e.order === "ZYX") { const h = s * d, m = s * f, g = o * d, x = o * f; n[0] = c * d, n[4] = g * u - m, n[8] = h * u + x, n[1] = c * f, n[5] = x * u + h, n[9] = m * u - g, n[2] = -u, n[6] = o * c, n[10] = s * c } else if (e.order === "YZX") { const h = s * c, m = s * u, g = o * c, x = o * u; n[0] = c * d, n[4] = x - h * f, n[8] = g * f + m, n[1] = f, n[5] = s * d, n[9] = -o * d, n[2] = -u * d, n[6] = m * f + g, n[10] = h - x * f } else if (e.order === "XZY") { const h = s * c, m = s * u, g = o * c, x = o * u; n[0] = c * d, n[4] = -f, n[8] = u * d, n[1] = h * f + x, n[5] = s * d, n[9] = m * f - g, n[2] = g * f - m, n[6] = o * d, n[10] = x * f + h } return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(nAe, e, rAe) } lookAt(e, n, r) { const i = this.elements; return el.subVectors(e, n), el.lengthSq() === 0 && (el.z = 1), el.normalize(), yh.crossVectors(r, el), yh.lengthSq() === 0 && (Math.abs(r.z) === 1 ? el.x += 1e-4 : el.z += 1e-4, el.normalize(), yh.crossVectors(r, el)), yh.normalize(), tM.crossVectors(el, yh), i[0] = yh.x, i[4] = tM.x, i[8] = el.x, i[1] = yh.y, i[5] = tM.y, i[9] = el.y, i[2] = yh.z, i[6] = tM.z, i[10] = el.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, n) { const r = e.elements, i = n.elements, a = this.elements, s = r[0], o = r[4], c = r[8], u = r[12], d = r[1], f = r[5], h = r[9], m = r[13], g = r[2], x = r[6], v = r[10], b = r[14], E = r[3], M = r[7], C = r[11], N = r[15], A = i[0], j = i[4], O = i[8], I = i[12], D = i[1], F = i[5], B = i[9], G = i[13], z = i[2], q = i[6], Y = i[10], Z = i[14], $ = i[3], V = i[7], K = i[11], X = i[15]; return a[0] = s * A + o * D + c * z + u * $, a[4] = s * j + o * F + c * q + u * V, a[8] = s * O + o * B + c * Y + u * K, a[12] = s * I + o * G + c * Z + u * X, a[1] = d * A + f * D + h * z + m * $, a[5] = d * j + f * F + h * q + m * V, a[9] = d * O + f * B + h * Y + m * K, a[13] = d * I + f * G + h * Z + m * X, a[2] = g * A + x * D + v * z + b * $, a[6] = g * j + x * F + v * q + b * V, a[10] = g * O + x * B + v * Y + b * K, a[14] = g * I + x * G + v * Z + b * X, a[3] = E * A + M * D + C * z + N * $, a[7] = E * j + M * F + C * q + N * V, a[11] = E * O + M * B + C * Y + N * K, a[15] = E * I + M * G + C * Z + N * X, this } multiplyScalar(e) { const n = this.elements; return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this } determinant() { const e = this.elements, n = e[0], r = e[4], i = e[8], a = e[12], s = e[1], o = e[5], c = e[9], u = e[13], d = e[2], f = e[6], h = e[10], m = e[14], g = e[3], x = e[7], v = e[11], b = e[15]; return g * (+a * c * f - i * u * f - a * o * h + r * u * h + i * o * m - r * c * m) + x * (+n * c * m - n * u * h + a * s * h - i * s * m + i * u * d - a * c * d) + v * (+n * u * f - n * o * m - a * s * f + r * s * m + a * o * d - r * u * d) + b * (-i * o * d - n * c * f + n * o * h + i * s * f - r * s * h + r * c * d) } transpose() { const e = this.elements; let n; return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this } setPosition(e, n, r) { const i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = n, i[14] = r), this } invert() { const e = this.elements, n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], c = e[6], u = e[7], d = e[8], f = e[9], h = e[10], m = e[11], g = e[12], x = e[13], v = e[14], b = e[15], E = f * v * u - x * h * u + x * c * m - o * v * m - f * c * b + o * h * b, M = g * h * u - d * v * u - g * c * m + s * v * m + d * c * b - s * h * b, C = d * x * u - g * f * u + g * o * m - s * x * m - d * o * b + s * f * b, N = g * f * c - d * x * c - g * o * h + s * x * h + d * o * v - s * f * v, A = n * E + r * M + i * C + a * N; if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const j = 1 / A; return e[0] = E * j, e[1] = (x * h * a - f * v * a - x * i * m + r * v * m + f * i * b - r * h * b) * j, e[2] = (o * v * a - x * c * a + x * i * u - r * v * u - o * i * b + r * c * b) * j, e[3] = (f * c * a - o * h * a - f * i * u + r * h * u + o * i * m - r * c * m) * j, e[4] = M * j, e[5] = (d * v * a - g * h * a + g * i * m - n * v * m - d * i * b + n * h * b) * j, e[6] = (g * c * a - s * v * a - g * i * u + n * v * u + s * i * b - n * c * b) * j, e[7] = (s * h * a - d * c * a + d * i * u - n * h * u - s * i * m + n * c * m) * j, e[8] = C * j, e[9] = (g * f * a - d * x * a - g * r * m + n * x * m + d * r * b - n * f * b) * j, e[10] = (s * x * a - g * o * a + g * r * u - n * x * u - s * r * b + n * o * b) * j, e[11] = (d * o * a - s * f * a - d * r * u + n * f * u + s * r * m - n * o * m) * j, e[12] = N * j, e[13] = (d * x * i - g * f * i + g * r * h - n * x * h - d * r * v + n * f * v) * j, e[14] = (g * o * i - s * x * i - g * r * c + n * x * c + s * r * v - n * o * v) * j, e[15] = (s * f * i - d * o * i + d * r * c - n * f * c - s * r * h + n * o * h) * j, this } scale(e) { const n = this.elements, r = e.x, i = e.y, a = e.z; return n[0] *= r, n[4] *= i, n[8] *= a, n[1] *= r, n[5] *= i, n[9] *= a, n[2] *= r, n[6] *= i, n[10] *= a, n[3] *= r, n[7] *= i, n[11] *= a, this } getMaxScaleOnAxis() { const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(n, r, i)) } makeTranslation(e, n, r) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1), this } makeRotationX(e) { const n = Math.cos(e), r = Math.sin(e); return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this } makeRotationY(e) { const n = Math.cos(e), r = Math.sin(e); return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const n = Math.cos(e), r = Math.sin(e); return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, n) { const r = Math.cos(n), i = Math.sin(n), a = 1 - r, s = e.x, o = e.y, c = e.z, u = a * s, d = a * o; return this.set(u * s + r, u * o - i * c, u * c + i * o, 0, u * o + i * c, d * o + r, d * c - i * s, 0, u * c - i * o, d * c + i * s, a * c * c + r, 0, 0, 0, 0, 1), this } makeScale(e, n, r) { return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this } makeShear(e, n, r, i, a, s) { return this.set(1, r, a, 0, e, 1, s, 0, n, i, 1, 0, 0, 0, 0, 1), this } compose(e, n, r) { const i = this.elements, a = n._x, s = n._y, o = n._z, c = n._w, u = a + a, d = s + s, f = o + o, h = a * u, m = a * d, g = a * f, x = s * d, v = s * f, b = o * f, E = c * u, M = c * d, C = c * f, N = r.x, A = r.y, j = r.z; return i[0] = (1 - (x + b)) * N, i[1] = (m + C) * N, i[2] = (g - M) * N, i[3] = 0, i[4] = (m - C) * A, i[5] = (1 - (h + b)) * A, i[6] = (v + E) * A, i[7] = 0, i[8] = (g + M) * j, i[9] = (v - E) * j, i[10] = (1 - (h + x)) * j, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } decompose(e, n, r) { const i = this.elements; let a = iy.set(i[0], i[1], i[2]).length(); const s = iy.set(i[4], i[5], i[6]).length(), o = iy.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (a = -a), e.x = i[12], e.y = i[13], e.z = i[14], Ec.copy(this); const u = 1 / a, d = 1 / s, f = 1 / o; return Ec.elements[0] *= u, Ec.elements[1] *= u, Ec.elements[2] *= u, Ec.elements[4] *= d, Ec.elements[5] *= d, Ec.elements[6] *= d, Ec.elements[8] *= f, Ec.elements[9] *= f, Ec.elements[10] *= f, n.setFromRotationMatrix(Ec), r.x = a, r.y = s, r.z = o, this } makePerspective(e, n, r, i, a, s, o = cl, c = !1) { const u = this.elements, d = 2 * a / (n - e), f = 2 * a / (r - i), h = (n + e) / (n - e), m = (r + i) / (r - i); let g, x; if (c) g = a / (s - a), x = s * a / (s - a); else if (o === cl) g = -(s + a) / (s - a), x = -2 * s * a / (s - a); else if (o === Sx) g = -s / (s - a), x = -s * a / (s - a); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o); return u[0] = d, u[4] = 0, u[8] = h, u[12] = 0, u[1] = 0, u[5] = f, u[9] = m, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = g, u[14] = x, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this } makeOrthographic(e, n, r, i, a, s, o = cl, c = !1) { const u = this.elements, d = 2 / (n - e), f = 2 / (r - i), h = -(n + e) / (n - e), m = -(r + i) / (r - i); let g, x; if (c) g = 1 / (s - a), x = s / (s - a); else if (o === cl) g = -2 / (s - a), x = -(s + a) / (s - a); else if (o === Sx) g = -1 / (s - a), x = -a / (s - a); else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o); return u[0] = d, u[4] = 0, u[8] = 0, u[12] = h, u[1] = 0, u[5] = f, u[9] = 0, u[13] = m, u[2] = 0, u[6] = 0, u[10] = g, u[14] = x, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this } equals(e) { const n = this.elements, r = e.elements; for (let i = 0; i < 16; i++)if (n[i] !== r[i]) return !1; return !0 } fromArray(e, n = 0) { for (let r = 0; r < 16; r++)this.elements[r] = e[r + n]; return this } toArray(e = [], n = 0) { const r = this.elements; return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e[n + 9] = r[9], e[n + 10] = r[10], e[n + 11] = r[11], e[n + 12] = r[12], e[n + 13] = r[13], e[n + 14] = r[14], e[n + 15] = r[15], e } } const iy = new pe, Ec = new Fn, nAe = new pe(0, 0, 0), rAe = new pe(1, 1, 1), yh = new pe, tM = new pe, el = new pe, AH = new Fn, PH = new As; class ml { constructor(e = 0, n = 0, r = 0, i = ml.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = n, this._z = r, this._order = i } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, n, r, i = this._order) { return this._x = e, this._y = n, this._z = r, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, n = this._order, r = !0) { const i = e.elements, a = i[0], s = i[4], o = i[8], c = i[1], u = i[5], d = i[9], f = i[2], h = i[6], m = i[10]; switch (n) { case "XYZ": this._y = Math.asin(In(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-d, m), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(h, u), this._z = 0); break; case "YXZ": this._x = Math.asin(-In(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(o, m), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-f, a), this._z = 0); break; case "ZXY": this._x = Math.asin(In(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-f, m), this._z = Math.atan2(-s, u)) : (this._y = 0, this._z = Math.atan2(c, a)); break; case "ZYX": this._y = Math.asin(-In(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(h, m), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-s, u)); break; case "YZX": this._z = Math.asin(In(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-d, u), this._y = Math.atan2(-f, a)) : (this._x = 0, this._y = Math.atan2(o, m)); break; case "XZY": this._z = Math.asin(-In(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, u), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-d, m), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n) }return this._order = n, r === !0 && this._onChangeCallback(), this } setFromQuaternion(e, n, r) { return AH.makeRotationFromQuaternion(e), this.setFromRotationMatrix(AH, n, r) } setFromVector3(e, n = this._order) { return this.set(e.x, e.y, e.z, n) } reorder(e) { return PH.setFromEuler(this), this.setFromQuaternion(PH, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], n = 0) { return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } ml.DEFAULT_ORDER = "XYZ"; class hg { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let iAe = 0; const jH = new pe, ay = new As, Bd = new Fn, nM = new pe, Jb = new pe, aAe = new pe, sAe = new As, RH = new pe(1, 0, 0), kH = new pe(0, 1, 0), IH = new pe(0, 0, 1), OH = { type: "added" }, oAe = { type: "removed" }, sy = { type: "childadded", child: null }, dR = { type: "childremoved", child: null }; class kr extends Qu { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: iAe++ }), this.uuid = fl(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = kr.DEFAULT_UP.clone(); const e = new pe, n = new ml, r = new As, i = new pe(1, 1, 1); function a() { r.setFromEuler(n, !1) } function s() { n.setFromQuaternion(r, void 0, !1) } n._onChange(a), r._onChange(s), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: n }, quaternion: { configurable: !0, enumerable: !0, value: r }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Fn }, normalMatrix: { value: new Qn } }), this.matrix = new Fn, this.matrixWorld = new Fn, this.matrixAutoUpdate = kr.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = kr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new hg, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, n) { this.quaternion.setFromAxisAngle(e, n) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, n) { return ay.setFromAxisAngle(e, n), this.quaternion.multiply(ay), this } rotateOnWorldAxis(e, n) { return ay.setFromAxisAngle(e, n), this.quaternion.premultiply(ay), this } rotateX(e) { return this.rotateOnAxis(RH, e) } rotateY(e) { return this.rotateOnAxis(kH, e) } rotateZ(e) { return this.rotateOnAxis(IH, e) } translateOnAxis(e, n) { return jH.copy(e).applyQuaternion(this.quaternion), this.position.add(jH.multiplyScalar(n)), this } translateX(e) { return this.translateOnAxis(RH, e) } translateY(e) { return this.translateOnAxis(kH, e) } translateZ(e) { return this.translateOnAxis(IH, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Bd.copy(this.matrixWorld).invert()) } lookAt(e, n, r) { e.isVector3 ? nM.copy(e) : nM.set(e, n, r); const i = this.parent; this.updateWorldMatrix(!0, !1), Jb.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Bd.lookAt(Jb, nM, this.up) : Bd.lookAt(nM, Jb, this.up), this.quaternion.setFromRotationMatrix(Bd), i && (Bd.extractRotation(i.matrixWorld), ay.setFromRotationMatrix(Bd), this.quaternion.premultiply(ay.invert())) } add(e) { if (arguments.length > 1) { for (let n = 0; n < arguments.length; n++)this.add(arguments[n]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(OH), sy.child = e, this.dispatchEvent(sy), sy.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let r = 0; r < arguments.length; r++)this.remove(arguments[r]); return this } const n = this.children.indexOf(e); return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(oAe), dR.child = e, this.dispatchEvent(dR), dR.child = null), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), Bd.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Bd.multiply(e.parent.matrixWorld)), e.applyMatrix4(Bd), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(OH), sy.child = e, this.dispatchEvent(sy), sy.child = null, this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, n) { if (this[e] === n) return this; for (let r = 0, i = this.children.length; r < i; r++) { const s = this.children[r].getObjectByProperty(e, n); if (s !== void 0) return s } } getObjectsByProperty(e, n, r = []) { this[e] === n && r.push(this); const i = this.children; for (let a = 0, s = i.length; a < s; a++)i[a].getObjectsByProperty(e, n, r); return r } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jb, e, aAe), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jb, sAe, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const n = this.matrixWorld.elements; return e.set(n[8], n[9], n[10]).normalize() } raycast() { } traverse(e) { e(this); const n = this.children; for (let r = 0, i = n.length; r < i; r++)n[r].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const n = this.children; for (let r = 0, i = n.length; r < i; r++)n[r].traverseVisible(e) } traverseAncestors(e) { const n = this.parent; n !== null && (e(n), n.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0); const n = this.children; for (let r = 0, i = n.length; r < i; r++)n[r].updateMatrixWorld(e) } updateWorldMatrix(e, n) { const r = this.parent; if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) { const i = this.children; for (let a = 0, s = i.length; a < s; a++)i[a].updateWorldMatrix(!1, !0) } } toJSON(e) { const n = e === void 0 || typeof e == "string", r = {}; n && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, r.metadata = { version: 4.7, type: "Object", generator: "Object3D.toJSON" }); const i = {}; i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.geometryInfo = this._geometryInfo.map(o => ({ ...o, boundingBox: o.boundingBox ? o.boundingBox.toJSON() : void 0, boundingSphere: o.boundingSphere ? o.boundingSphere.toJSON() : void 0 })), i.instanceInfo = this._instanceInfo.map(o => ({ ...o })), i.availableInstanceIds = this._availableInstanceIds.slice(), i.availableGeometryIds = this._availableGeometryIds.slice(), i.nextIndexStart = this._nextIndexStart, i.nextVertexStart = this._nextVertexStart, i.geometryCount = this._geometryCount, i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.matricesTexture = this._matricesTexture.toJSON(e), i.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON())); function a(o, c) { return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(e)), c.uuid } if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = a(e.geometries, this.geometry); const o = this.geometry.parameters; if (o !== void 0 && o.shapes !== void 0) { const c = o.shapes; if (Array.isArray(c)) for (let u = 0, d = c.length; u < d; u++) { const f = c[u]; a(e.shapes, f) } else a(e.shapes, c) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const o = []; for (let c = 0, u = this.material.length; c < u; c++)o.push(a(e.materials, this.material[c])); i.material = o } else i.material = a(e.materials, this.material); if (this.children.length > 0) { i.children = []; for (let o = 0; o < this.children.length; o++)i.children.push(this.children[o].toJSON(e).object) } if (this.animations.length > 0) { i.animations = []; for (let o = 0; o < this.animations.length; o++) { const c = this.animations[o]; i.animations.push(a(e.animations, c)) } } if (n) { const o = s(e.geometries), c = s(e.materials), u = s(e.textures), d = s(e.images), f = s(e.shapes), h = s(e.skeletons), m = s(e.animations), g = s(e.nodes); o.length > 0 && (r.geometries = o), c.length > 0 && (r.materials = c), u.length > 0 && (r.textures = u), d.length > 0 && (r.images = d), f.length > 0 && (r.shapes = f), h.length > 0 && (r.skeletons = h), m.length > 0 && (r.animations = m), g.length > 0 && (r.nodes = g) } return r.object = i, r; function s(o) { const c = []; for (const u in o) { const d = o[u]; delete d.metadata, c.push(d) } return c } } clone(e) { return new this.constructor().copy(this, e) } copy(e, n = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0) for (let r = 0; r < e.children.length; r++) { const i = e.children[r]; this.add(i.clone()) } return this } } kr.DEFAULT_UP = new pe(0, 1, 0); kr.DEFAULT_MATRIX_AUTO_UPDATE = !0; kr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const Mc = new pe, $d = new pe, fR = new pe, zd = new pe, oy = new pe, ly = new pe, DH = new pe, hR = new pe, pR = new pe, mR = new pe, gR = new jr, vR = new jr, yR = new jr; class Oo { constructor(e = new pe, n = new pe, r = new pe) { this.a = e, this.b = n, this.c = r } static getNormal(e, n, r, i) { i.subVectors(r, n), Mc.subVectors(e, n), i.cross(Mc); const a = i.lengthSq(); return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0) } static getBarycoord(e, n, r, i, a) { Mc.subVectors(i, n), $d.subVectors(r, n), fR.subVectors(e, n); const s = Mc.dot(Mc), o = Mc.dot($d), c = Mc.dot(fR), u = $d.dot($d), d = $d.dot(fR), f = s * u - o * o; if (f === 0) return a.set(0, 0, 0), null; const h = 1 / f, m = (u * c - o * d) * h, g = (s * d - o * c) * h; return a.set(1 - m - g, g, m) } static containsPoint(e, n, r, i) { return this.getBarycoord(e, n, r, i, zd) === null ? !1 : zd.x >= 0 && zd.y >= 0 && zd.x + zd.y <= 1 } static getInterpolation(e, n, r, i, a, s, o, c) { return this.getBarycoord(e, n, r, i, zd) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(a, zd.x), c.addScaledVector(s, zd.y), c.addScaledVector(o, zd.z), c) } static getInterpolatedAttribute(e, n, r, i, a, s) { return gR.setScalar(0), vR.setScalar(0), yR.setScalar(0), gR.fromBufferAttribute(e, n), vR.fromBufferAttribute(e, r), yR.fromBufferAttribute(e, i), s.setScalar(0), s.addScaledVector(gR, a.x), s.addScaledVector(vR, a.y), s.addScaledVector(yR, a.z), s } static isFrontFacing(e, n, r, i) { return Mc.subVectors(r, n), $d.subVectors(e, n), Mc.cross($d).dot(i) < 0 } set(e, n, r) { return this.a.copy(e), this.b.copy(n), this.c.copy(r), this } setFromPointsAndIndices(e, n, r, i) { return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[i]), this } setFromAttributeAndIndices(e, n, r, i) { return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Mc.subVectors(this.c, this.b), $d.subVectors(this.a, this.b), Mc.cross($d).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Oo.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, n) { return Oo.getBarycoord(e, this.a, this.b, this.c, n) } getInterpolation(e, n, r, i, a) { return Oo.getInterpolation(e, this.a, this.b, this.c, n, r, i, a) } containsPoint(e) { return Oo.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Oo.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, n) { const r = this.a, i = this.b, a = this.c; let s, o; oy.subVectors(i, r), ly.subVectors(a, r), hR.subVectors(e, r); const c = oy.dot(hR), u = ly.dot(hR); if (c <= 0 && u <= 0) return n.copy(r); pR.subVectors(e, i); const d = oy.dot(pR), f = ly.dot(pR); if (d >= 0 && f <= d) return n.copy(i); const h = c * f - d * u; if (h <= 0 && c >= 0 && d <= 0) return s = c / (c - d), n.copy(r).addScaledVector(oy, s); mR.subVectors(e, a); const m = oy.dot(mR), g = ly.dot(mR); if (g >= 0 && m <= g) return n.copy(a); const x = m * u - c * g; if (x <= 0 && u >= 0 && g <= 0) return o = u / (u - g), n.copy(r).addScaledVector(ly, o); const v = d * g - m * f; if (v <= 0 && f - d >= 0 && m - g >= 0) return DH.subVectors(a, i), o = (f - d) / (f - d + (m - g)), n.copy(i).addScaledVector(DH, o); const b = 1 / (v + x + h); return s = x * b, o = h * b, n.copy(r).addScaledVector(oy, s).addScaledVector(ly, o) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } const Mae = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, xh = { h: 0, s: 0, l: 0 }, rM = { h: 0, s: 0, l: 0 }; function xR(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t } let Kt = class { constructor(e, n, r) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, r) } set(e, n, r) { if (n === void 0 && r === void 0) { const i = e; i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i) } else this.setRGB(e, n, r); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, n = qs) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Nr.colorSpaceToWorking(this, n), this } setRGB(e, n, r, i = Nr.workingColorSpace) { return this.r = e, this.g = n, this.b = r, Nr.colorSpaceToWorking(this, i), this } setHSL(e, n, r, i = Nr.workingColorSpace) { if (e = JU(e, 1), n = In(n, 0, 1), r = In(r, 0, 1), n === 0) this.r = this.g = this.b = r; else { const a = r <= .5 ? r * (1 + n) : r + n - r * n, s = 2 * r - a; this.r = xR(s, a, e + 1 / 3), this.g = xR(s, a, e), this.b = xR(s, a, e - 1 / 3) } return Nr.colorSpaceToWorking(this, i), this } setStyle(e, n = qs) { function r(a) { a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let i; if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) { let a; const s = i[1], o = i[2]; switch (s) { case "rgb": case "rgba": if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(a[4]), this.setRGB(Math.min(255, parseInt(a[1], 10)) / 255, Math.min(255, parseInt(a[2], 10)) / 255, Math.min(255, parseInt(a[3], 10)) / 255, n); if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(a[4]), this.setRGB(Math.min(100, parseInt(a[1], 10)) / 100, Math.min(100, parseInt(a[2], 10)) / 100, Math.min(100, parseInt(a[3], 10)) / 100, n); break; case "hsl": case "hsla": if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(a[4]), this.setHSL(parseFloat(a[1]) / 360, parseFloat(a[2]) / 100, parseFloat(a[3]) / 100, n); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) { const a = i[1], s = a.length; if (s === 3) return this.setRGB(parseInt(a.charAt(0), 16) / 15, parseInt(a.charAt(1), 16) / 15, parseInt(a.charAt(2), 16) / 15, n); if (s === 6) return this.setHex(parseInt(a, 16), n); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, n); return this } setColorName(e, n = qs) { const r = Mae[e.toLowerCase()]; return r !== void 0 ? this.setHex(r, n) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = sf(e.r), this.g = sf(e.g), this.b = sf(e.b), this } copyLinearToSRGB(e) { return this.r = Jy(e.r), this.g = Jy(e.g), this.b = Jy(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = qs) { return Nr.workingToColorSpace(ws.copy(this), e), Math.round(In(ws.r * 255, 0, 255)) * 65536 + Math.round(In(ws.g * 255, 0, 255)) * 256 + Math.round(In(ws.b * 255, 0, 255)) } getHexString(e = qs) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, n = Nr.workingColorSpace) { Nr.workingToColorSpace(ws.copy(this), n); const r = ws.r, i = ws.g, a = ws.b, s = Math.max(r, i, a), o = Math.min(r, i, a); let c, u; const d = (o + s) / 2; if (o === s) c = 0, u = 0; else { const f = s - o; switch (u = d <= .5 ? f / (s + o) : f / (2 - s - o), s) { case r: c = (i - a) / f + (i < a ? 6 : 0); break; case i: c = (a - r) / f + 2; break; case a: c = (r - i) / f + 4; break }c /= 6 } return e.h = c, e.s = u, e.l = d, e } getRGB(e, n = Nr.workingColorSpace) { return Nr.workingToColorSpace(ws.copy(this), n), e.r = ws.r, e.g = ws.g, e.b = ws.b, e } getStyle(e = qs) { Nr.workingToColorSpace(ws.copy(this), e); const n = ws.r, r = ws.g, i = ws.b; return e !== qs ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(i * 255)})` } offsetHSL(e, n, r) { return this.getHSL(xh), this.setHSL(xh.h + e, xh.s + n, xh.l + r) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, n) { return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, n) { return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this } lerpColors(e, n, r) { return this.r = e.r + (n.r - e.r) * r, this.g = e.g + (n.g - e.g) * r, this.b = e.b + (n.b - e.b) * r, this } lerpHSL(e, n) { this.getHSL(xh), e.getHSL(rM); const r = Zw(xh.h, rM.h, n), i = Zw(xh.s, rM.s, n), a = Zw(xh.l, rM.l, n); return this.setHSL(r, i, a), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const n = this.r, r = this.g, i = this.b, a = e.elements; return this.r = a[0] * n + a[3] * r + a[6] * i, this.g = a[1] * n + a[4] * r + a[7] * i, this.b = a[2] * n + a[5] * r + a[8] * i, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, n = 0) { return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this } toArray(e = [], n = 0) { return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e } fromBufferAttribute(e, n) { return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } }; const ws = new Kt; Kt.NAMES = Mae; let lAe = 0; class Rs extends Qu { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: lAe++ }), this.uuid = fl(), this.name = "", this.type = "Material", this.blending = dg, this.side = yf, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = sC, this.blendDst = oC, this.blendEquation = jh, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Kt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Eg, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = zL, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Um, this.stencilZFail = Um, this.stencilZPass = Um, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const n in e) { const r = e[n]; if (r === void 0) { console.warn(`THREE.Material: parameter '${n}' has value of undefined.`); continue } const i = this[n]; if (i === void 0) { console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`); continue } i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[n] = r } } toJSON(e) { const n = e === void 0 || typeof e == "string"; n && (e = { textures: {}, images: {} }); const r = { metadata: { version: 4.7, type: "Material", generator: "Material.toJSON" } }; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.sheenColorMap && this.sheenColorMap.isTexture && (r.sheenColorMap = this.sheenColorMap.toJSON(e).uuid), this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (r.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid), this.dispersion !== void 0 && (r.dispersion = this.dispersion), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapRotation !== void 0 && (r.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== dg && (r.blending = this.blending), this.side !== yf && (r.side = this.side), this.vertexColors === !0 && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = !0), this.blendSrc !== sC && (r.blendSrc = this.blendSrc), this.blendDst !== oC && (r.blendDst = this.blendDst), this.blendEquation !== jh && (r.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (r.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (r.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha), this.depthFunc !== Eg && (r.depthFunc = this.depthFunc), this.depthTest === !1 && (r.depthTest = this.depthTest), this.depthWrite === !1 && (r.depthWrite = this.depthWrite), this.colorWrite === !1 && (r.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (r.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== zL && (r.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (r.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (r.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Um && (r.stencilFail = this.stencilFail), this.stencilZFail !== Um && (r.stencilZFail = this.stencilZFail), this.stencilZPass !== Um && (r.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = !0), this.alphaToCoverage === !0 && (r.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0), this.forceSinglePass === !0 && (r.forceSinglePass = !0), this.wireframe === !0 && (r.wireframe = !0), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = !0), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData); function i(a) { const s = []; for (const o in a) { const c = a[o]; delete c.metadata, s.push(c) } return s } if (n) { const a = i(e.textures), s = i(e.images); a.length > 0 && (r.textures = a), s.length > 0 && (r.images = s) } return r } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const n = e.clippingPlanes; let r = null; if (n !== null) { const i = n.length; r = new Array(i); for (let a = 0; a !== i; ++a)r[a] = n[a].clone() } return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } class _f extends Rs { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ml, this.combine = r_, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const Zd = cAe(); function cAe() { const t = new ArrayBuffer(4), e = new Float32Array(t), n = new Uint32Array(t), r = new Uint32Array(512), i = new Uint32Array(512); for (let c = 0; c < 256; ++c) { const u = c - 127; u < -27 ? (r[c] = 0, r[c | 256] = 32768, i[c] = 24, i[c | 256] = 24) : u < -14 ? (r[c] = 1024 >> -u - 14, r[c | 256] = 1024 >> -u - 14 | 32768, i[c] = -u - 1, i[c | 256] = -u - 1) : u <= 15 ? (r[c] = u + 15 << 10, r[c | 256] = u + 15 << 10 | 32768, i[c] = 13, i[c | 256] = 13) : u < 128 ? (r[c] = 31744, r[c | 256] = 64512, i[c] = 24, i[c | 256] = 24) : (r[c] = 31744, r[c | 256] = 64512, i[c] = 13, i[c | 256] = 13) } const a = new Uint32Array(2048), s = new Uint32Array(64), o = new Uint32Array(64); for (let c = 1; c < 1024; ++c) { let u = c << 13, d = 0; for (; (u & 8388608) === 0;)u <<= 1, d -= 8388608; u &= -8388609, d += 947912704, a[c] = u | d } for (let c = 1024; c < 2048; ++c)a[c] = 939524096 + (c - 1024 << 13); for (let c = 1; c < 31; ++c)s[c] = c << 23; s[31] = 1199570944, s[32] = 2147483648; for (let c = 33; c < 63; ++c)s[c] = 2147483648 + (c - 32 << 23); s[63] = 3347054592; for (let c = 1; c < 64; ++c)c !== 32 && (o[c] = 1024); return { floatView: e, uint32View: n, baseTable: r, shiftTable: i, mantissaTable: a, exponentTable: s, offsetTable: o } } function No(t) { Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = In(t, -65504, 65504), Zd.floatView[0] = t; const e = Zd.uint32View[0], n = e >> 23 & 511; return Zd.baseTable[n] + ((e & 8388607) >> Zd.shiftTable[n]) } function Rw(t) { const e = t >> 10; return Zd.uint32View[0] = Zd.mantissaTable[Zd.offsetTable[e] + (t & 1023)] + Zd.exponentTable[e], Zd.floatView[0] } class Zm { static toHalfFloat(e) { return No(e) } static fromHalfFloat(e) { return Rw(e) } } const pa = new pe, iM = new lt; let uAe = 0; class Lr { constructor(e, n, r = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: uAe++ }), this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = r, this.usage = D1, this.updateRanges = [], this.gpuType = Ui, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, n) { this.updateRanges.push({ start: e, count: n }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, n, r) { e *= this.itemSize, r *= n.itemSize; for (let i = 0, a = this.itemSize; i < a; i++)this.array[e + i] = n.array[r + i]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let n = 0, r = this.count; n < r; n++)iM.fromBufferAttribute(this, n), iM.applyMatrix3(e), this.setXY(n, iM.x, iM.y); else if (this.itemSize === 3) for (let n = 0, r = this.count; n < r; n++)pa.fromBufferAttribute(this, n), pa.applyMatrix3(e), this.setXYZ(n, pa.x, pa.y, pa.z); return this } applyMatrix4(e) { for (let n = 0, r = this.count; n < r; n++)pa.fromBufferAttribute(this, n), pa.applyMatrix4(e), this.setXYZ(n, pa.x, pa.y, pa.z); return this } applyNormalMatrix(e) { for (let n = 0, r = this.count; n < r; n++)pa.fromBufferAttribute(this, n), pa.applyNormalMatrix(e), this.setXYZ(n, pa.x, pa.y, pa.z); return this } transformDirection(e) { for (let n = 0, r = this.count; n < r; n++)pa.fromBufferAttribute(this, n), pa.transformDirection(e), this.setXYZ(n, pa.x, pa.y, pa.z); return this } set(e, n = 0) { return this.array.set(e, n), this } getComponent(e, n) { let r = this.array[e * this.itemSize + n]; return this.normalized && (r = Ys(r, this.array)), r } setComponent(e, n, r) { return this.normalized && (r = ir(r, this.array)), this.array[e * this.itemSize + n] = r, this } getX(e) { let n = this.array[e * this.itemSize]; return this.normalized && (n = Ys(n, this.array)), n } setX(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize] = n, this } getY(e) { let n = this.array[e * this.itemSize + 1]; return this.normalized && (n = Ys(n, this.array)), n } setY(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize + 1] = n, this } getZ(e) { let n = this.array[e * this.itemSize + 2]; return this.normalized && (n = Ys(n, this.array)), n } setZ(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize + 2] = n, this } getW(e) { let n = this.array[e * this.itemSize + 3]; return this.normalized && (n = Ys(n, this.array)), n } setW(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize + 3] = n, this } setXY(e, n, r) { return e *= this.itemSize, this.normalized && (n = ir(n, this.array), r = ir(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this } setXYZ(e, n, r, i) { return e *= this.itemSize, this.normalized && (n = ir(n, this.array), r = ir(r, this.array), i = ir(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = i, this } setXYZW(e, n, r, i, a) { return e *= this.itemSize, this.normalized && (n = ir(n, this.array), r = ir(r, this.array), i = ir(i, this.array), a = ir(a, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = a, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== D1 && (e.usage = this.usage), e } } class dAe extends Lr { constructor(e, n, r) { super(new Int8Array(e), n, r) } } class fAe extends Lr { constructor(e, n, r) { super(new Uint8Array(e), n, r) } } class hAe extends Lr { constructor(e, n, r) { super(new Uint8ClampedArray(e), n, r) } } class pAe extends Lr { constructor(e, n, r) { super(new Int16Array(e), n, r) } } class tB extends Lr { constructor(e, n, r) { super(new Uint16Array(e), n, r) } } class mAe extends Lr { constructor(e, n, r) { super(new Int32Array(e), n, r) } } class nB extends Lr { constructor(e, n, r) { super(new Uint32Array(e), n, r) } } class gAe extends Lr { constructor(e, n, r) { super(new Uint16Array(e), n, r), this.isFloat16BufferAttribute = !0 } getX(e) { let n = Rw(this.array[e * this.itemSize]); return this.normalized && (n = Ys(n, this.array)), n } setX(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize] = No(n), this } getY(e) { let n = Rw(this.array[e * this.itemSize + 1]); return this.normalized && (n = Ys(n, this.array)), n } setY(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize + 1] = No(n), this } getZ(e) { let n = Rw(this.array[e * this.itemSize + 2]); return this.normalized && (n = Ys(n, this.array)), n } setZ(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize + 2] = No(n), this } getW(e) { let n = Rw(this.array[e * this.itemSize + 3]); return this.normalized && (n = Ys(n, this.array)), n } setW(e, n) { return this.normalized && (n = ir(n, this.array)), this.array[e * this.itemSize + 3] = No(n), this } setXY(e, n, r) { return e *= this.itemSize, this.normalized && (n = ir(n, this.array), r = ir(r, this.array)), this.array[e + 0] = No(n), this.array[e + 1] = No(r), this } setXYZ(e, n, r, i) { return e *= this.itemSize, this.normalized && (n = ir(n, this.array), r = ir(r, this.array), i = ir(i, this.array)), this.array[e + 0] = No(n), this.array[e + 1] = No(r), this.array[e + 2] = No(i), this } setXYZW(e, n, r, i, a) { return e *= this.itemSize, this.normalized && (n = ir(n, this.array), r = ir(r, this.array), i = ir(i, this.array), a = ir(a, this.array)), this.array[e + 0] = No(n), this.array[e + 1] = No(r), this.array[e + 2] = No(i), this.array[e + 3] = No(a), this } } class hn extends Lr { constructor(e, n, r) { super(new Float32Array(e), n, r) } } let vAe = 0; const Pl = new Fn, bR = new kr, cy = new pe, tl = new Ps, ew = new Ps, Wa = new pe; class Kn extends Qu { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: vAe++ }), this.uuid = fl(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (Sae(e) ? nB : tB)(e, 1) : this.index = e, this } setIndirect(e) { return this.indirect = e, this } getIndirect() { return this.indirect } getAttribute(e) { return this.attributes[e] } setAttribute(e, n) { return this.attributes[e] = n, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, n, r = 0) { this.groups.push({ start: e, count: n, materialIndex: r }) } clearGroups() { this.groups = [] } setDrawRange(e, n) { this.drawRange.start = e, this.drawRange.count = n } applyMatrix4(e) { const n = this.attributes.position; n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0); const r = this.attributes.normal; if (r !== void 0) { const a = new Qn().getNormalMatrix(e); r.applyNormalMatrix(a), r.needsUpdate = !0 } const i = this.attributes.tangent; return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return Pl.makeRotationFromQuaternion(e), this.applyMatrix4(Pl), this } rotateX(e) { return Pl.makeRotationX(e), this.applyMatrix4(Pl), this } rotateY(e) { return Pl.makeRotationY(e), this.applyMatrix4(Pl), this } rotateZ(e) { return Pl.makeRotationZ(e), this.applyMatrix4(Pl), this } translate(e, n, r) { return Pl.makeTranslation(e, n, r), this.applyMatrix4(Pl), this } scale(e, n, r) { return Pl.makeScale(e, n, r), this.applyMatrix4(Pl), this } lookAt(e) { return bR.lookAt(e), bR.updateMatrix(), this.applyMatrix4(bR.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(cy).negate(), this.translate(cy.x, cy.y, cy.z), this } setFromPoints(e) { const n = this.getAttribute("position"); if (n === void 0) { const r = []; for (let i = 0, a = e.length; i < a; i++) { const s = e[i]; r.push(s.x, s.y, s.z || 0) } this.setAttribute("position", new hn(r, 3)) } else { const r = Math.min(e.length, n.count); for (let i = 0; i < r; i++) { const a = e[i]; n.setXYZ(i, a.x, a.y, a.z || 0) } e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0 } return this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Ps); const e = this.attributes.position, n = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new pe(-1 / 0, -1 / 0, -1 / 0), new pe(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), n) for (let r = 0, i = n.length; r < i; r++) { const a = n[r]; tl.setFromBufferAttribute(a), this.morphTargetsRelative ? (Wa.addVectors(this.boundingBox.min, tl.min), this.boundingBox.expandByPoint(Wa), Wa.addVectors(this.boundingBox.max, tl.max), this.boundingBox.expandByPoint(Wa)) : (this.boundingBox.expandByPoint(tl.min), this.boundingBox.expandByPoint(tl.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new us); const e = this.attributes.position, n = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new pe, 1 / 0); return } if (e) { const r = this.boundingSphere.center; if (tl.setFromBufferAttribute(e), n) for (let a = 0, s = n.length; a < s; a++) { const o = n[a]; ew.setFromBufferAttribute(o), this.morphTargetsRelative ? (Wa.addVectors(tl.min, ew.min), tl.expandByPoint(Wa), Wa.addVectors(tl.max, ew.max), tl.expandByPoint(Wa)) : (tl.expandByPoint(ew.min), tl.expandByPoint(ew.max)) } tl.getCenter(r); let i = 0; for (let a = 0, s = e.count; a < s; a++)Wa.fromBufferAttribute(e, a), i = Math.max(i, r.distanceToSquared(Wa)); if (n) for (let a = 0, s = n.length; a < s; a++) { const o = n[a], c = this.morphTargetsRelative; for (let u = 0, d = o.count; u < d; u++)Wa.fromBufferAttribute(o, u), c && (cy.fromBufferAttribute(e, u), Wa.add(cy)), i = Math.max(i, r.distanceToSquared(Wa)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, n = this.attributes; if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const r = n.position, i = n.normal, a = n.uv; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Lr(new Float32Array(4 * r.count), 4)); const s = this.getAttribute("tangent"), o = [], c = []; for (let O = 0; O < r.count; O++)o[O] = new pe, c[O] = new pe; const u = new pe, d = new pe, f = new pe, h = new lt, m = new lt, g = new lt, x = new pe, v = new pe; function b(O, I, D) { u.fromBufferAttribute(r, O), d.fromBufferAttribute(r, I), f.fromBufferAttribute(r, D), h.fromBufferAttribute(a, O), m.fromBufferAttribute(a, I), g.fromBufferAttribute(a, D), d.sub(u), f.sub(u), m.sub(h), g.sub(h); const F = 1 / (m.x * g.y - g.x * m.y); isFinite(F) && (x.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(F), v.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(F), o[O].add(x), o[I].add(x), o[D].add(x), c[O].add(v), c[I].add(v), c[D].add(v)) } let E = this.groups; E.length === 0 && (E = [{ start: 0, count: e.count }]); for (let O = 0, I = E.length; O < I; ++O) { const D = E[O], F = D.start, B = D.count; for (let G = F, z = F + B; G < z; G += 3)b(e.getX(G + 0), e.getX(G + 1), e.getX(G + 2)) } const M = new pe, C = new pe, N = new pe, A = new pe; function j(O) { N.fromBufferAttribute(i, O), A.copy(N); const I = o[O]; M.copy(I), M.sub(N.multiplyScalar(N.dot(I))).normalize(), C.crossVectors(A, I); const F = C.dot(c[O]) < 0 ? -1 : 1; s.setXYZW(O, M.x, M.y, M.z, F) } for (let O = 0, I = E.length; O < I; ++O) { const D = E[O], F = D.start, B = D.count; for (let G = F, z = F + B; G < z; G += 3)j(e.getX(G + 0)), j(e.getX(G + 1)), j(e.getX(G + 2)) } } computeVertexNormals() { const e = this.index, n = this.getAttribute("position"); if (n !== void 0) { let r = this.getAttribute("normal"); if (r === void 0) r = new Lr(new Float32Array(n.count * 3), 3), this.setAttribute("normal", r); else for (let h = 0, m = r.count; h < m; h++)r.setXYZ(h, 0, 0, 0); const i = new pe, a = new pe, s = new pe, o = new pe, c = new pe, u = new pe, d = new pe, f = new pe; if (e) for (let h = 0, m = e.count; h < m; h += 3) { const g = e.getX(h + 0), x = e.getX(h + 1), v = e.getX(h + 2); i.fromBufferAttribute(n, g), a.fromBufferAttribute(n, x), s.fromBufferAttribute(n, v), d.subVectors(s, a), f.subVectors(i, a), d.cross(f), o.fromBufferAttribute(r, g), c.fromBufferAttribute(r, x), u.fromBufferAttribute(r, v), o.add(d), c.add(d), u.add(d), r.setXYZ(g, o.x, o.y, o.z), r.setXYZ(x, c.x, c.y, c.z), r.setXYZ(v, u.x, u.y, u.z) } else for (let h = 0, m = n.count; h < m; h += 3)i.fromBufferAttribute(n, h + 0), a.fromBufferAttribute(n, h + 1), s.fromBufferAttribute(n, h + 2), d.subVectors(s, a), f.subVectors(i, a), d.cross(f), r.setXYZ(h + 0, d.x, d.y, d.z), r.setXYZ(h + 1, d.x, d.y, d.z), r.setXYZ(h + 2, d.x, d.y, d.z); this.normalizeNormals(), r.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let n = 0, r = e.count; n < r; n++)Wa.fromBufferAttribute(e, n), Wa.normalize(), e.setXYZ(n, Wa.x, Wa.y, Wa.z) } toNonIndexed() { function e(o, c) { const u = o.array, d = o.itemSize, f = o.normalized, h = new u.constructor(c.length * d); let m = 0, g = 0; for (let x = 0, v = c.length; x < v; x++) { o.isInterleavedBufferAttribute ? m = c[x] * o.data.stride + o.offset : m = c[x] * d; for (let b = 0; b < d; b++)h[g++] = u[m++] } return new Lr(h, d, f) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const n = new Kn, r = this.index.array, i = this.attributes; for (const o in i) { const c = i[o], u = e(c, r); n.setAttribute(o, u) } const a = this.morphAttributes; for (const o in a) { const c = [], u = a[o]; for (let d = 0, f = u.length; d < f; d++) { const h = u[d], m = e(h, r); c.push(m) } n.morphAttributes[o] = c } n.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let o = 0, c = s.length; o < c; o++) { const u = s[o]; n.addGroup(u.start, u.count, u.materialIndex) } return n } toJSON() { const e = { metadata: { version: 4.7, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const c = this.parameters; for (const u in c) c[u] !== void 0 && (e[u] = c[u]); return e } e.data = { attributes: {} }; const n = this.index; n !== null && (e.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) }); const r = this.attributes; for (const c in r) { const u = r[c]; e.data.attributes[c] = u.toJSON(e.data) } const i = {}; let a = !1; for (const c in this.morphAttributes) { const u = this.morphAttributes[c], d = []; for (let f = 0, h = u.length; f < h; f++) { const m = u[f]; d.push(m.toJSON(e.data)) } d.length > 0 && (i[c] = d, a = !0) } a && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); const o = this.boundingSphere; return o !== null && (e.data.boundingSphere = o.toJSON()), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const n = {}; this.name = e.name; const r = e.index; r !== null && this.setIndex(r.clone()); const i = e.attributes; for (const u in i) { const d = i[u]; this.setAttribute(u, d.clone(n)) } const a = e.morphAttributes; for (const u in a) { const d = [], f = a[u]; for (let h = 0, m = f.length; h < m; h++)d.push(f[h].clone(n)); this.morphAttributes[u] = d } this.morphTargetsRelative = e.morphTargetsRelative; const s = e.groups; for (let u = 0, d = s.length; u < d; u++) { const f = s[u]; this.addGroup(f.start, f.count, f.materialIndex) } const o = e.boundingBox; o !== null && (this.boundingBox = o.clone()); const c = e.boundingSphere; return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const LH = new Fn, bm = new Hg, aM = new us, FH = new pe, sM = new pe, oM = new pe, lM = new pe, wR = new pe, cM = new pe, UH = new pe, uM = new pe; class Bi extends kr { constructor(e = new Kn, n = new _f) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets() } copy(e, n) { return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const n = this.geometry.morphAttributes, r = Object.keys(n); if (r.length > 0) { const i = n[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let a = 0, s = i.length; a < s; a++) { const o = i[a].name || String(a); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = a } } } } getVertexPosition(e, n) { const r = this.geometry, i = r.attributes.position, a = r.morphAttributes.position, s = r.morphTargetsRelative; n.fromBufferAttribute(i, e); const o = this.morphTargetInfluences; if (a && o) { cM.set(0, 0, 0); for (let c = 0, u = a.length; c < u; c++) { const d = o[c], f = a[c]; d !== 0 && (wR.fromBufferAttribute(f, e), s ? cM.addScaledVector(wR, d) : cM.addScaledVector(wR.sub(n), d)) } n.add(cM) } return n } raycast(e, n) { const r = this.geometry, i = this.material, a = this.matrixWorld; i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), aM.copy(r.boundingSphere), aM.applyMatrix4(a), bm.copy(e.ray).recast(e.near), !(aM.containsPoint(bm.origin) === !1 && (bm.intersectSphere(aM, FH) === null || bm.origin.distanceToSquared(FH) > (e.far - e.near) ** 2)) && (LH.copy(a).invert(), bm.copy(e.ray).applyMatrix4(LH), !(r.boundingBox !== null && bm.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, n, bm))) } _computeIntersections(e, n, r) { let i; const a = this.geometry, s = this.material, o = a.index, c = a.attributes.position, u = a.attributes.uv, d = a.attributes.uv1, f = a.attributes.normal, h = a.groups, m = a.drawRange; if (o !== null) if (Array.isArray(s)) for (let g = 0, x = h.length; g < x; g++) { const v = h[g], b = s[v.materialIndex], E = Math.max(v.start, m.start), M = Math.min(o.count, Math.min(v.start + v.count, m.start + m.count)); for (let C = E, N = M; C < N; C += 3) { const A = o.getX(C), j = o.getX(C + 1), O = o.getX(C + 2); i = dM(this, b, e, r, u, d, f, A, j, O), i && (i.faceIndex = Math.floor(C / 3), i.face.materialIndex = v.materialIndex, n.push(i)) } } else { const g = Math.max(0, m.start), x = Math.min(o.count, m.start + m.count); for (let v = g, b = x; v < b; v += 3) { const E = o.getX(v), M = o.getX(v + 1), C = o.getX(v + 2); i = dM(this, s, e, r, u, d, f, E, M, C), i && (i.faceIndex = Math.floor(v / 3), n.push(i)) } } else if (c !== void 0) if (Array.isArray(s)) for (let g = 0, x = h.length; g < x; g++) { const v = h[g], b = s[v.materialIndex], E = Math.max(v.start, m.start), M = Math.min(c.count, Math.min(v.start + v.count, m.start + m.count)); for (let C = E, N = M; C < N; C += 3) { const A = C, j = C + 1, O = C + 2; i = dM(this, b, e, r, u, d, f, A, j, O), i && (i.faceIndex = Math.floor(C / 3), i.face.materialIndex = v.materialIndex, n.push(i)) } } else { const g = Math.max(0, m.start), x = Math.min(c.count, m.start + m.count); for (let v = g, b = x; v < b; v += 3) { const E = v, M = v + 1, C = v + 2; i = dM(this, s, e, r, u, d, f, E, M, C), i && (i.faceIndex = Math.floor(v / 3), n.push(i)) } } } } function yAe(t, e, n, r, i, a, s, o) { let c; if (e.side === io ? c = r.intersectTriangle(s, a, i, !0, o) : c = r.intersectTriangle(i, a, s, e.side === yf, o), c === null) return null; uM.copy(o), uM.applyMatrix4(t.matrixWorld); const u = n.ray.origin.distanceTo(uM); return u < n.near || u > n.far ? null : { distance: u, point: uM.clone(), object: t } } function dM(t, e, n, r, i, a, s, o, c, u) { t.getVertexPosition(o, sM), t.getVertexPosition(c, oM), t.getVertexPosition(u, lM); const d = yAe(t, e, n, r, sM, oM, lM, UH); if (d) { const f = new pe; Oo.getBarycoord(UH, sM, oM, lM, f), i && (d.uv = Oo.getInterpolatedAttribute(i, o, c, u, f, new lt)), a && (d.uv1 = Oo.getInterpolatedAttribute(a, o, c, u, f, new lt)), s && (d.normal = Oo.getInterpolatedAttribute(s, o, c, u, f, new pe), d.normal.dot(r.direction) > 0 && d.normal.multiplyScalar(-1)); const h = { a: o, b: c, c: u, normal: new pe, materialIndex: 0 }; Oo.getNormal(sM, oM, lM, h.normal), d.face = h, d.barycoord = f } return d } class Wg extends Kn { constructor(e = 1, n = 1, r = 1, i = 1, a = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: n, depth: r, widthSegments: i, heightSegments: a, depthSegments: s }; const o = this; i = Math.floor(i), a = Math.floor(a), s = Math.floor(s); const c = [], u = [], d = [], f = []; let h = 0, m = 0; g("z", "y", "x", -1, -1, r, n, e, s, a, 0), g("z", "y", "x", 1, -1, r, n, -e, s, a, 1), g("x", "z", "y", 1, 1, e, r, n, i, s, 2), g("x", "z", "y", 1, -1, e, r, -n, i, s, 3), g("x", "y", "z", 1, -1, e, n, r, i, a, 4), g("x", "y", "z", -1, -1, e, n, -r, i, a, 5), this.setIndex(c), this.setAttribute("position", new hn(u, 3)), this.setAttribute("normal", new hn(d, 3)), this.setAttribute("uv", new hn(f, 2)); function g(x, v, b, E, M, C, N, A, j, O, I) { const D = C / j, F = N / O, B = C / 2, G = N / 2, z = A / 2, q = j + 1, Y = O + 1; let Z = 0, $ = 0; const V = new pe; for (let K = 0; K < Y; K++) { const X = K * F - G; for (let Q = 0; Q < q; Q++) { const re = Q * D - B; V[x] = re * E, V[v] = X * M, V[b] = z, u.push(V.x, V.y, V.z), V[x] = 0, V[v] = 0, V[b] = A > 0 ? 1 : -1, d.push(V.x, V.y, V.z), f.push(Q / j), f.push(1 - K / O), Z += 1 } } for (let K = 0; K < O; K++)for (let X = 0; X < j; X++) { const Q = h + X + q * K, re = h + X + q * (K + 1), ce = h + (X + 1) + q * (K + 1), be = h + (X + 1) + q * K; c.push(Q, re, be), c.push(re, ce, be), $ += 6 } o.addGroup(m, $, I), m += $, h += Z } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Wg(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Ex(t) { const e = {}; for (const n in t) { e[n] = {}; for (const r in t[n]) { const i = t[n][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][r] = null) : e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i } } return e } function Ws(t) { const e = {}; for (let n = 0; n < t.length; n++) { const r = Ex(t[n]); for (const i in r) e[i] = r[i] } return e } function xAe(t) { const e = []; for (let n = 0; n < t.length; n++)e.push(t[n].clone()); return e } function Tae(t) { const e = t.getRenderTarget(); return e === null ? t.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Nr.workingColorSpace } const Cae = { clone: Ex, merge: Ws }; var bAe = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, wAe = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class Bo extends Rs { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = bAe, this.fragmentShader = wAe, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ex(e.uniforms), this.uniformsGroups = xAe(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const n = super.toJSON(e); n.glslVersion = this.glslVersion, n.uniforms = {}; for (const i in this.uniforms) { const s = this.uniforms[i].value; s && s.isTexture ? n.uniforms[i] = { type: "t", value: s.toJSON(e).uuid } : s && s.isColor ? n.uniforms[i] = { type: "c", value: s.getHex() } : s && s.isVector2 ? n.uniforms[i] = { type: "v2", value: s.toArray() } : s && s.isVector3 ? n.uniforms[i] = { type: "v3", value: s.toArray() } : s && s.isVector4 ? n.uniforms[i] = { type: "v4", value: s.toArray() } : s && s.isMatrix3 ? n.uniforms[i] = { type: "m3", value: s.toArray() } : s && s.isMatrix4 ? n.uniforms[i] = { type: "m4", value: s.toArray() } : n.uniforms[i] = { value: s } } Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping; const r = {}; for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0); return Object.keys(r).length > 0 && (n.extensions = r), n } } class o_ extends kr { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Fn, this.projectionMatrix = new Fn, this.projectionMatrixInverse = new Fn, this.coordinateSystem = cl, this._reversedDepth = !1 } get reversedDepth() { return this._reversedDepth } copy(e, n) { return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, n) { super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } const bh = new pe, BH = new lt, $H = new lt; class ra extends o_ { constructor(e = 50, n = 1, r = .1, i = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, n) { return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const n = .5 * this.getFilmHeight() / e; this.fov = _x * 2 * Math.atan(n), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(fg * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return _x * 2 * Math.atan(Math.tan(fg * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(e, n, r) { bh.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(bh.x, bh.y).multiplyScalar(-e / bh.z), bh.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), r.set(bh.x, bh.y).multiplyScalar(-e / bh.z) } getViewSize(e, n) { return this.getViewBounds(e, BH, $H), n.subVectors($H, BH) } setViewOffset(e, n, r, i, a, s) { this.aspect = e / n, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = i, this.view.width = a, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let n = e * Math.tan(fg * .5 * this.fov) / this.zoom, r = 2 * n, i = this.aspect * r, a = -.5 * i; const s = this.view; if (this.view !== null && this.view.enabled) { const c = s.fullWidth, u = s.fullHeight; a += s.offsetX * i / c, n -= s.offsetY * r / u, i *= s.width / c, r *= s.height / u } const o = this.filmOffset; o !== 0 && (a += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + i, n, n - r, e, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const n = super.toJSON(e); return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n } } const uy = -90, dy = 1; class Nae extends kr { constructor(e, n, r) { super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null, this.activeMipmapLevel = 0; const i = new ra(uy, dy, e, n); i.layers = this.layers, this.add(i); const a = new ra(uy, dy, e, n); a.layers = this.layers, this.add(a); const s = new ra(uy, dy, e, n); s.layers = this.layers, this.add(s); const o = new ra(uy, dy, e, n); o.layers = this.layers, this.add(o); const c = new ra(uy, dy, e, n); c.layers = this.layers, this.add(c); const u = new ra(uy, dy, e, n); u.layers = this.layers, this.add(u) } updateCoordinateSystem() { const e = this.coordinateSystem, n = this.children.concat(), [r, i, a, s, o, c] = n; for (const u of n) this.remove(u); if (e === cl) r.up.set(0, 1, 0), r.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1); else if (e === Sx) r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); for (const u of n) this.add(u), u.updateMatrixWorld() } update(e, n) { this.parent === null && this.updateMatrixWorld(); const { renderTarget: r, activeMipmapLevel: i } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [a, s, o, c, u, d] = this.children, f = e.getRenderTarget(), h = e.getActiveCubeFace(), m = e.getActiveMipmapLevel(), g = e.xr.enabled; e.xr.enabled = !1; const x = r.texture.generateMipmaps; r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0, i), e.render(n, a), e.setRenderTarget(r, 1, i), e.render(n, s), e.setRenderTarget(r, 2, i), e.render(n, o), e.setRenderTarget(r, 3, i), e.render(n, c), e.setRenderTarget(r, 4, i), e.render(n, u), r.texture.generateMipmaps = x, e.setRenderTarget(r, 5, i), e.render(n, d), e.setRenderTarget(f, h, m), e.xr.enabled = g, r.texture.needsPMREMUpdate = !0 } } class l_ extends ti { constructor(e = [], n = $u, r, i, a, s, o, c, u, d) { super(e, n, r, i, a, s, o, c, u, d), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class rB extends Hl {
	constructor(e = 1, n = {}) { super(e, e, n), this.isWebGLCubeRenderTarget = !0; const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r]; this.texture = new l_(i), this._setTextureOptions(n), this.texture.isRenderTargetTexture = !0 } fromEquirectangularTexture(e, n) {
		this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter; const r = {
			uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, i = new Wg(5, 5, 5), a = new Bo({ name: "CubemapFromEquirect", uniforms: Ex(r.uniforms), vertexShader: r.vertexShader, fragmentShader: r.fragmentShader, side: io, blending: Pu }); a.uniforms.tEquirect.value = n; const s = new Bi(i, a), o = n.minFilter; return n.minFilter === bu && (n.minFilter = Xr), new Nae(1, 10, this).update(e, s), n.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
	} clear(e, n = !0, r = !0, i = !0) { const a = e.getRenderTarget(); for (let s = 0; s < 6; s++)e.setRenderTarget(this, s), e.clear(n, r, i); e.setRenderTarget(a) }
} class By extends kr { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const SAe = { type: "move" }; class jT { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new By, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new By, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new pe, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new pe), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new By, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new pe, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new pe), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const n = this._hand; if (n) for (const r of e.hand.values()) this._getHandJoint(n, r) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, n, r) { let i = null, a = null, s = null; const o = this._targetRay, c = this._grip, u = this._hand; if (e && n.session.visibilityState !== "visible-blurred") { if (u && e.hand) { s = !0; for (const x of e.hand.values()) { const v = n.getJointPose(x, r), b = this._getHandJoint(u, x); v !== null && (b.matrix.fromArray(v.transform.matrix), b.matrix.decompose(b.position, b.rotation, b.scale), b.matrixWorldNeedsUpdate = !0, b.jointRadius = v.radius), b.visible = v !== null } const d = u.joints["index-finger-tip"], f = u.joints["thumb-tip"], h = d.position.distanceTo(f.position), m = .02, g = .005; u.inputState.pinching && h > m + g ? (u.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !u.inputState.pinching && h <= m - g && (u.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else c !== null && e.gripSpace && (a = n.getPose(e.gripSpace, r), a !== null && (c.matrix.fromArray(a.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(a.linearVelocity)) : c.hasLinearVelocity = !1, a.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(a.angularVelocity)) : c.hasAngularVelocity = !1)); o !== null && (i = n.getPose(e.targetRaySpace, r), i === null && a !== null && (i = a), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(SAe))) } return o !== null && (o.visible = i !== null), c !== null && (c.visible = a !== null), u !== null && (u.visible = s !== null), this } _getHandJoint(e, n) { if (e.joints[n.jointName] === void 0) { const r = new By; r.matrixAutoUpdate = !1, r.visible = !1, e.joints[n.jointName] = r, e.add(r) } return e.joints[n.jointName] } } class KA { constructor(e, n = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new Kt(e), this.density = n } clone() { return new KA(this.color, this.density) } toJSON() { return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density } } } class ZA { constructor(e, n = 1, r = 1e3) { this.isFog = !0, this.name = "", this.color = new Kt(e), this.near = n, this.far = r } clone() { return new ZA(this.color, this.near, this.far) } toJSON() { return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far } } } class c_ extends kr { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new ml, this.environmentIntensity = 1, this.environmentRotation = new ml, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, n) { return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const n = super.toJSON(e); return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n } } class QA { constructor(e, n) { this.isInterleavedBuffer = !0, this.array = e, this.stride = n, this.count = e !== void 0 ? e.length / n : 0, this.usage = D1, this.updateRanges = [], this.version = 0, this.uuid = fl() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, n) { this.updateRanges.push({ start: e, count: n }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, n, r) { e *= this.stride, r *= n.stride; for (let i = 0, a = this.stride; i < a; i++)this.array[e + i] = n.array[r + i]; return this } set(e, n = 0) { return this.array.set(e, n), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fl()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const n = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(n, this.stride); return r.setUsage(this.usage), r } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fl()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const Hs = new pe; class Mg { constructor(e, n, r, i = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = n, this.offset = r, this.normalized = i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let n = 0, r = this.data.count; n < r; n++)Hs.fromBufferAttribute(this, n), Hs.applyMatrix4(e), this.setXYZ(n, Hs.x, Hs.y, Hs.z); return this } applyNormalMatrix(e) { for (let n = 0, r = this.count; n < r; n++)Hs.fromBufferAttribute(this, n), Hs.applyNormalMatrix(e), this.setXYZ(n, Hs.x, Hs.y, Hs.z); return this } transformDirection(e) { for (let n = 0, r = this.count; n < r; n++)Hs.fromBufferAttribute(this, n), Hs.transformDirection(e), this.setXYZ(n, Hs.x, Hs.y, Hs.z); return this } getComponent(e, n) { let r = this.array[e * this.data.stride + this.offset + n]; return this.normalized && (r = Ys(r, this.array)), r } setComponent(e, n, r) { return this.normalized && (r = ir(r, this.array)), this.data.array[e * this.data.stride + this.offset + n] = r, this } setX(e, n) { return this.normalized && (n = ir(n, this.array)), this.data.array[e * this.data.stride + this.offset] = n, this } setY(e, n) { return this.normalized && (n = ir(n, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = n, this } setZ(e, n) { return this.normalized && (n = ir(n, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = n, this } setW(e, n) { return this.normalized && (n = ir(n, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = n, this } getX(e) { let n = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (n = Ys(n, this.array)), n } getY(e) { let n = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (n = Ys(n, this.array)), n } getZ(e) { let n = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (n = Ys(n, this.array)), n } getW(e) { let n = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (n = Ys(n, this.array)), n } setXY(e, n, r) { return e = e * this.data.stride + this.offset, this.normalized && (n = ir(n, this.array), r = ir(r, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this } setXYZ(e, n, r, i) { return e = e * this.data.stride + this.offset, this.normalized && (n = ir(n, this.array), r = ir(r, this.array), i = ir(i, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this } setXYZW(e, n, r, i, a) { return e = e * this.data.stride + this.offset, this.normalized && (n = ir(n, this.array), r = ir(r, this.array), i = ir(i, this.array), a = ir(a, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = a, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const n = []; for (let r = 0; r < this.count; r++) { const i = r * this.data.stride + this.offset; for (let a = 0; a < this.itemSize; a++)n.push(this.data.array[i + a]) } return new Lr(new this.array.constructor(n), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Mg(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const n = []; for (let r = 0; r < this.count; r++) { const i = r * this.data.stride + this.offset; for (let a = 0; a < this.itemSize; a++)n.push(this.data.array[i + a]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: n, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class iB extends Rs { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let fy; const tw = new pe, hy = new pe, py = new pe, my = new lt, nw = new lt, Aae = new Fn, fM = new pe, rw = new pe, hM = new pe, zH = new lt, SR = new lt, VH = new lt; class Pae extends kr { constructor(e = new iB) { if (super(), this.isSprite = !0, this.type = "Sprite", fy === void 0) { fy = new Kn; const n = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), r = new QA(n, 5); fy.setIndex([0, 1, 2, 0, 2, 3]), fy.setAttribute("position", new Mg(r, 3, 0, !1)), fy.setAttribute("uv", new Mg(r, 2, 3, !1)) } this.geometry = fy, this.material = e, this.center = new lt(.5, .5), this.count = 1 } raycast(e, n) { e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), hy.setFromMatrixScale(this.matrixWorld), Aae.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), py.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && hy.multiplyScalar(-py.z); const r = this.material.rotation; let i, a; r !== 0 && (a = Math.cos(r), i = Math.sin(r)); const s = this.center; pM(fM.set(-.5, -.5, 0), py, s, hy, i, a), pM(rw.set(.5, -.5, 0), py, s, hy, i, a), pM(hM.set(.5, .5, 0), py, s, hy, i, a), zH.set(0, 0), SR.set(1, 0), VH.set(1, 1); let o = e.ray.intersectTriangle(fM, rw, hM, !1, tw); if (o === null && (pM(rw.set(-.5, .5, 0), py, s, hy, i, a), SR.set(0, 1), o = e.ray.intersectTriangle(fM, hM, rw, !1, tw), o === null)) return; const c = e.ray.origin.distanceTo(tw); c < e.near || c > e.far || n.push({ distance: c, point: tw.clone(), uv: Oo.getInterpolation(tw, fM, rw, hM, zH, SR, VH, new lt), face: null, object: this }) } copy(e, n) { return super.copy(e, n), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this } } function pM(t, e, n, r, i, a) { my.subVectors(t, n).addScalar(.5).multiply(r), i !== void 0 ? (nw.x = a * my.x - i * my.y, nw.y = i * my.x + a * my.y) : nw.copy(my), t.copy(e), t.x += nw.x, t.y += nw.y, t.applyMatrix4(Aae) } const mM = new pe, HH = new pe; class jae extends kr { constructor() { super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const n = e.levels; for (let r = 0, i = n.length; r < i; r++) { const a = n[r]; this.addLevel(a.object.clone(), a.distance, a.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, n = 0, r = 0) { n = Math.abs(n); const i = this.levels; let a; for (a = 0; a < i.length && !(n < i[a].distance); a++); return i.splice(a, 0, { distance: n, hysteresis: r, object: e }), this.add(e), this } removeLevel(e) { const n = this.levels; for (let r = 0; r < n.length; r++)if (n[r].distance === e) { const i = n.splice(r, 1); return this.remove(i[0].object), !0 } return !1 } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const n = this.levels; if (n.length > 0) { let r, i; for (r = 1, i = n.length; r < i; r++) { let a = n[r].distance; if (n[r].object.visible && (a -= a * n[r].hysteresis), e < a) break } return n[r - 1].object } return null } raycast(e, n) { if (this.levels.length > 0) { mM.setFromMatrixPosition(this.matrixWorld); const i = e.ray.origin.distanceTo(mM); this.getObjectForDistance(i).raycast(e, n) } } update(e) { const n = this.levels; if (n.length > 1) { mM.setFromMatrixPosition(e.matrixWorld), HH.setFromMatrixPosition(this.matrixWorld); const r = mM.distanceTo(HH) / e.zoom; n[0].object.visible = !0; let i, a; for (i = 1, a = n.length; i < a; i++) { let s = n[i].distance; if (n[i].object.visible && (s -= s * n[i].hysteresis), r >= s) n[i - 1].object.visible = !1, n[i].object.visible = !0; else break } for (this._currentLevel = i - 1; i < a; i++)n[i].object.visible = !1 } } toJSON(e) { const n = super.toJSON(e); this.autoUpdate === !1 && (n.object.autoUpdate = !1), n.object.levels = []; const r = this.levels; for (let i = 0, a = r.length; i < a; i++) { const s = r[i]; n.object.levels.push({ object: s.object.uuid, distance: s.distance, hysteresis: s.hysteresis }) } return n } } const WH = new pe, GH = new jr, qH = new jr, _Ae = new pe, XH = new Fn, gM = new pe, _R = new us, YH = new Fn, ER = new Hg; class Rae extends Bi { constructor(e, n) { super(e, n), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = BL, this.bindMatrix = new Fn, this.bindMatrixInverse = new Fn, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; this.boundingBox === null && (this.boundingBox = new Ps), this.boundingBox.makeEmpty(); const n = e.getAttribute("position"); for (let r = 0; r < n.count; r++)this.getVertexPosition(r, gM), this.boundingBox.expandByPoint(gM) } computeBoundingSphere() { const e = this.geometry; this.boundingSphere === null && (this.boundingSphere = new us), this.boundingSphere.makeEmpty(); const n = e.getAttribute("position"); for (let r = 0; r < n.count; r++)this.getVertexPosition(r, gM), this.boundingSphere.expandByPoint(gM) } copy(e, n) { return super.copy(e, n), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, n) { const r = this.material, i = this.matrixWorld; r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _R.copy(this.boundingSphere), _R.applyMatrix4(i), e.ray.intersectsSphere(_R) !== !1 && (YH.copy(i).invert(), ER.copy(e.ray).applyMatrix4(YH), !(this.boundingBox !== null && ER.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, n, ER))) } getVertexPosition(e, n) { return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n } bind(e, n) { this.skeleton = e, n === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), n = this.matrixWorld), this.bindMatrix.copy(n), this.bindMatrixInverse.copy(n).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new jr, n = this.geometry.attributes.skinWeight; for (let r = 0, i = n.count; r < i; r++) { e.fromBufferAttribute(n, r); const a = 1 / e.manhattanLength(); a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0), n.setXYZW(r, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === BL ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === lae ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, n) { const r = this.skeleton, i = this.geometry; GH.fromBufferAttribute(i.attributes.skinIndex, e), qH.fromBufferAttribute(i.attributes.skinWeight, e), WH.copy(n).applyMatrix4(this.bindMatrix), n.set(0, 0, 0); for (let a = 0; a < 4; a++) { const s = qH.getComponent(a); if (s !== 0) { const o = GH.getComponent(a); XH.multiplyMatrices(r.bones[o].matrixWorld, r.boneInverses[o]), n.addScaledVector(_Ae.copy(WH).applyMatrix4(XH), s) } } return n.applyMatrix4(this.bindMatrixInverse) } } class aB extends kr { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class Uc extends ti { constructor(e = null, n = 1, r = 1, i, a, s, o, c, u = cs, d = cs, f, h) { super(null, s, o, c, u, d, i, a, f, h), this.isDataTexture = !0, this.image = { data: e, width: n, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const KH = new Fn, EAe = new Fn; let kae = class Iae { constructor(e = [], n = []) { this.uuid = fl(), this.bones = e.slice(0), this.boneInverses = n, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { const e = this.bones, n = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), n.length === 0) this.calculateInverses(); else if (e.length !== n.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let r = 0, i = this.bones.length; r < i; r++)this.boneInverses.push(new Fn) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, n = this.bones.length; e < n; e++) { const r = new Fn; this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r) } } pose() { for (let e = 0, n = this.bones.length; e < n; e++) { const r = this.bones[e]; r && r.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, n = this.bones.length; e < n; e++) { const r = this.bones[e]; r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale)) } } update() { const e = this.bones, n = this.boneInverses, r = this.boneMatrices, i = this.boneTexture; for (let a = 0, s = e.length; a < s; a++) { const o = e[a] ? e[a].matrixWorld : EAe; KH.multiplyMatrices(o, n[a]), KH.toArray(r, a * 16) } i !== null && (i.needsUpdate = !0) } clone() { return new Iae(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = Math.ceil(e / 4) * 4, e = Math.max(e, 4); const n = new Float32Array(e * e * 4); n.set(this.boneMatrices); const r = new Uc(n, e, e, ia, Ui); return r.needsUpdate = !0, this.boneMatrices = n, this.boneTexture = r, this } getBoneByName(e) { for (let n = 0, r = this.bones.length; n < r; n++) { const i = this.bones[n]; if (i.name === e) return i } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, n) { this.uuid = e.uuid; for (let r = 0, i = e.bones.length; r < i; r++) { const a = e.bones[r]; let s = n[a]; s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", a), s = new aB), this.bones.push(s), this.boneInverses.push(new Fn().fromArray(e.boneInverses[r])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.7, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const n = this.bones, r = this.boneInverses; for (let i = 0, a = n.length; i < a; i++) { const s = n[i]; e.bones.push(s.uuid); const o = r[i]; e.boneInverses.push(o.toArray()) } return e } }; class Mx extends Lr { constructor(e, n, r, i = 1) { super(e, n, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const gy = new Fn, ZH = new Fn, vM = [], QH = new Ps, MAe = new Fn, iw = new Bi, aw = new us; class Oae extends Bi { constructor(e, n, r) { super(e, n), this.isInstancedMesh = !0, this.instanceMatrix = new Mx(new Float32Array(r * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = r, this.boundingBox = null, this.boundingSphere = null; for (let i = 0; i < r; i++)this.setMatrixAt(i, MAe) } computeBoundingBox() { const e = this.geometry, n = this.count; this.boundingBox === null && (this.boundingBox = new Ps), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let r = 0; r < n; r++)this.getMatrixAt(r, gy), QH.copy(e.boundingBox).applyMatrix4(gy), this.boundingBox.union(QH) } computeBoundingSphere() { const e = this.geometry, n = this.count; this.boundingSphere === null && (this.boundingSphere = new us), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let r = 0; r < n; r++)this.getMatrixAt(r, gy), aw.copy(e.boundingSphere).applyMatrix4(gy), this.boundingSphere.union(aw) } copy(e, n) { return super.copy(e, n), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, n) { n.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, n) { n.fromArray(this.instanceMatrix.array, e * 16) } getMorphAt(e, n) { const r = n.morphTargetInfluences, i = this.morphTexture.source.data.data, a = r.length + 1, s = e * a + 1; for (let o = 0; o < r.length; o++)r[o] = i[s + o] } raycast(e, n) { const r = this.matrixWorld, i = this.count; if (iw.geometry = this.geometry, iw.material = this.material, iw.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), aw.copy(this.boundingSphere), aw.applyMatrix4(r), e.ray.intersectsSphere(aw) !== !1)) for (let a = 0; a < i; a++) { this.getMatrixAt(a, gy), ZH.multiplyMatrices(r, gy), iw.matrixWorld = ZH, iw.raycast(e, vM); for (let s = 0, o = vM.length; s < o; s++) { const c = vM[s]; c.instanceId = a, c.object = this, n.push(c) } vM.length = 0 } } setColorAt(e, n) { this.instanceColor === null && (this.instanceColor = new Mx(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), n.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, n) { n.toArray(this.instanceMatrix.array, e * 16) } setMorphAt(e, n) { const r = n.morphTargetInfluences, i = r.length + 1; this.morphTexture === null && (this.morphTexture = new Uc(new Float32Array(i * this.count), i, this.count, a_, Ui)); const a = this.morphTexture.source.data.data; let s = 0; for (let u = 0; u < r.length; u++)s += r[u]; const o = this.geometry.morphTargetsRelative ? 1 : 1 - s, c = i * e; a[c] = o, a.set(r, c + 1) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null) } } const MR = new pe, TAe = new pe, CAe = new Qn; class Yd { constructor(e = new pe(1, 0, 0), n = 0) { this.isPlane = !0, this.normal = e, this.constant = n } set(e, n) { return this.normal.copy(e), this.constant = n, this } setComponents(e, n, r, i) { return this.normal.set(e, n, r), this.constant = i, this } setFromNormalAndCoplanarPoint(e, n) { return this.normal.copy(e), this.constant = -n.dot(this.normal), this } setFromCoplanarPoints(e, n, r) { const i = MR.subVectors(r, n).cross(TAe.subVectors(e, n)).normalize(); return this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, n) { return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, n) { const r = e.delta(MR), i = this.normal.dot(r); if (i === 0) return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null; const a = -(e.start.dot(this.normal) + this.constant) / i; return a < 0 || a > 1 ? null : n.copy(e.start).addScaledVector(r, a) } intersectsLine(e) { const n = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end); return n < 0 && r > 0 || r < 0 && n > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, n) { const r = n || CAe.getNormalMatrix(e), i = this.coplanarPoint(MR).applyMatrix4(e), a = this.normal.applyMatrix3(r).normalize(); return this.constant = -i.dot(a), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const wm = new us, NAe = new lt(.5, .5), yM = new pe; class N0 { constructor(e = new Yd, n = new Yd, r = new Yd, i = new Yd, a = new Yd, s = new Yd) { this.planes = [e, n, r, i, a, s] } set(e, n, r, i, a, s) { const o = this.planes; return o[0].copy(e), o[1].copy(n), o[2].copy(r), o[3].copy(i), o[4].copy(a), o[5].copy(s), this } copy(e) { const n = this.planes; for (let r = 0; r < 6; r++)n[r].copy(e.planes[r]); return this } setFromProjectionMatrix(e, n = cl, r = !1) { const i = this.planes, a = e.elements, s = a[0], o = a[1], c = a[2], u = a[3], d = a[4], f = a[5], h = a[6], m = a[7], g = a[8], x = a[9], v = a[10], b = a[11], E = a[12], M = a[13], C = a[14], N = a[15]; if (i[0].setComponents(u - s, m - d, b - g, N - E).normalize(), i[1].setComponents(u + s, m + d, b + g, N + E).normalize(), i[2].setComponents(u + o, m + f, b + x, N + M).normalize(), i[3].setComponents(u - o, m - f, b - x, N - M).normalize(), r) i[4].setComponents(c, h, v, C).normalize(), i[5].setComponents(u - c, m - h, b - v, N - C).normalize(); else if (i[4].setComponents(u - c, m - h, b - v, N - C).normalize(), n === cl) i[5].setComponents(u + c, m + h, b + v, N + C).normalize(); else if (n === Sx) i[5].setComponents(c, h, v, C).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n); return this } intersectsObject(e) { if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), wm.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const n = e.geometry; n.boundingSphere === null && n.computeBoundingSphere(), wm.copy(n.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(wm) } intersectsSprite(e) { wm.center.set(0, 0, 0); const n = NAe.distanceTo(e.center); return wm.radius = .7071067811865476 + n, wm.applyMatrix4(e.matrixWorld), this.intersectsSphere(wm) } intersectsSphere(e) { const n = this.planes, r = e.center, i = -e.radius; for (let a = 0; a < 6; a++)if (n[a].distanceToPoint(r) < i) return !1; return !0 } intersectsBox(e) { const n = this.planes; for (let r = 0; r < 6; r++) { const i = n[r]; if (yM.x = i.normal.x > 0 ? e.max.x : e.min.x, yM.y = i.normal.y > 0 ? e.max.y : e.min.y, yM.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(yM) < 0) return !1 } return !0 } containsPoint(e) { const n = this.planes; for (let r = 0; r < 6; r++)if (n[r].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } const hu = new Fn, pu = new N0; class JA { constructor() { this.coordinateSystem = cl } intersectsObject(e, n) { if (!n.isArrayCamera || n.cameras.length === 0) return !1; for (let r = 0; r < n.cameras.length; r++) { const i = n.cameras[r]; if (hu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), pu.setFromProjectionMatrix(hu, i.coordinateSystem, i.reversedDepth), pu.intersectsObject(e)) return !0 } return !1 } intersectsSprite(e, n) { if (!n || !n.cameras || n.cameras.length === 0) return !1; for (let r = 0; r < n.cameras.length; r++) { const i = n.cameras[r]; if (hu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), pu.setFromProjectionMatrix(hu, i.coordinateSystem, i.reversedDepth), pu.intersectsSprite(e)) return !0 } return !1 } intersectsSphere(e, n) { if (!n || !n.cameras || n.cameras.length === 0) return !1; for (let r = 0; r < n.cameras.length; r++) { const i = n.cameras[r]; if (hu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), pu.setFromProjectionMatrix(hu, i.coordinateSystem, i.reversedDepth), pu.intersectsSphere(e)) return !0 } return !1 } intersectsBox(e, n) { if (!n || !n.cameras || n.cameras.length === 0) return !1; for (let r = 0; r < n.cameras.length; r++) { const i = n.cameras[r]; if (hu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), pu.setFromProjectionMatrix(hu, i.coordinateSystem, i.reversedDepth), pu.intersectsBox(e)) return !0 } return !1 } containsPoint(e, n) { if (!n || !n.cameras || n.cameras.length === 0) return !1; for (let r = 0; r < n.cameras.length; r++) { const i = n.cameras[r]; if (hu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), pu.setFromProjectionMatrix(hu, i.coordinateSystem, i.reversedDepth), pu.containsPoint(e)) return !0 } return !1 } clone() { return new JA } } function TR(t, e) { return t - e } function AAe(t, e) { return t.z - e.z } function PAe(t, e) { return e.z - t.z } class jAe { constructor() { this.index = 0, this.pool = [], this.list = [] } push(e, n, r, i) { const a = this.pool, s = this.list; this.index >= a.length && a.push({ start: -1, count: -1, z: -1, index: -1 }); const o = a[this.index]; s.push(o), this.index++, o.start = e, o.count = n, o.z = r, o.index = i } reset() { this.list.length = 0, this.index = 0 } } const Co = new Fn, RAe = new Kt(1, 1, 1), JH = new N0, kAe = new JA, xM = new Ps, Sm = new us, sw = new pe, eW = new pe, IAe = new pe, CR = new jAe, Ss = new Bi, bM = []; function OAe(t, e, n = 0) { const r = e.itemSize; if (t.isInterleavedBufferAttribute || t.array.constructor !== e.array.constructor) { const i = t.count; for (let a = 0; a < i; a++)for (let s = 0; s < r; s++)e.setComponent(a + n, s, t.getComponent(a, s)) } else e.array.set(t.array, n * r); e.needsUpdate = !0 } function _m(t, e) { if (t.constructor !== e.constructor) { const n = Math.min(t.length, e.length); for (let r = 0; r < n; r++)e[r] = t[r] } else { const n = Math.min(t.length, e.length); e.set(new t.constructor(t.buffer, 0, n)) } } class Dae extends Bi { constructor(e, n, r = n * 2, i) { super(new Kn, i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = n, this._maxIndexCount = r, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture() } get maxInstanceCount() { return this._maxInstanceCount } get instanceCount() { return this._instanceInfo.length - this._availableInstanceIds.length } get unusedVertexCount() { return this._maxVertexCount - this._nextVertexStart } get unusedIndexCount() { return this._maxIndexCount - this._nextIndexStart } _initMatricesTexture() { let e = Math.sqrt(this._maxInstanceCount * 4); e = Math.ceil(e / 4) * 4, e = Math.max(e, 4); const n = new Float32Array(e * e * 4), r = new Uc(n, e, e, ia, Ui); this._matricesTexture = r } _initIndirectTexture() { let e = Math.sqrt(this._maxInstanceCount); e = Math.ceil(e); const n = new Uint32Array(e * e), r = new Uc(n, e, e, s_, zu); this._indirectTexture = r } _initColorsTexture() { let e = Math.sqrt(this._maxInstanceCount); e = Math.ceil(e); const n = new Float32Array(e * e * 4).fill(1), r = new Uc(n, e, e, ia, Ui); r.colorSpace = Nr.workingColorSpace, this._colorsTexture = r } _initializeGeometry(e) { const n = this.geometry, r = this._maxVertexCount, i = this._maxIndexCount; if (this._geometryInitialized === !1) { for (const a in e.attributes) { const s = e.getAttribute(a), { array: o, itemSize: c, normalized: u } = s, d = new o.constructor(r * c), f = new Lr(d, c, u); n.setAttribute(a, f) } if (e.getIndex() !== null) { const a = r > 65535 ? new Uint32Array(i) : new Uint16Array(i); n.setIndex(new Lr(a, 1)) } this._geometryInitialized = !0 } } _validateGeometry(e) { const n = this.geometry; if (!!e.getIndex() != !!n.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".'); for (const r in n.attributes) { if (!e.hasAttribute(r)) throw new Error(`THREE.BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`); const i = e.getAttribute(r), a = n.getAttribute(r); if (i.itemSize !== a.itemSize || i.normalized !== a.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.") } } validateInstanceId(e) { const n = this._instanceInfo; if (e < 0 || e >= n.length || n[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`) } validateGeometryId(e) { const n = this._geometryInfo; if (e < 0 || e >= n.length || n[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`) } setCustomSort(e) { return this.customSort = e, this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Ps); const e = this.boundingBox, n = this._instanceInfo; e.makeEmpty(); for (let r = 0, i = n.length; r < i; r++) { if (n[r].active === !1) continue; const a = n[r].geometryIndex; this.getMatrixAt(r, Co), this.getBoundingBoxAt(a, xM).applyMatrix4(Co), e.union(xM) } } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new us); const e = this.boundingSphere, n = this._instanceInfo; e.makeEmpty(); for (let r = 0, i = n.length; r < i; r++) { if (n[r].active === !1) continue; const a = n[r].geometryIndex; this.getMatrixAt(r, Co), this.getBoundingSphereAt(a, Sm).applyMatrix4(Co), e.union(Sm) } } addInstance(e) { if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached."); const r = { visible: !0, active: !0, geometryIndex: e }; let i = null; this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(TR), i = this._availableInstanceIds.shift(), this._instanceInfo[i] = r) : (i = this._instanceInfo.length, this._instanceInfo.push(r)); const a = this._matricesTexture; Co.identity().toArray(a.image.data, i * 16), a.needsUpdate = !0; const s = this._colorsTexture; return s && (RAe.toArray(s.image.data, i * 4), s.needsUpdate = !0), this._visibilityChanged = !0, i } addGeometry(e, n = -1, r = -1) { this._initializeGeometry(e), this._validateGeometry(e); const i = { vertexStart: -1, vertexCount: -1, reservedVertexCount: -1, indexStart: -1, indexCount: -1, reservedIndexCount: -1, start: -1, count: -1, boundingBox: null, boundingSphere: null, active: !0 }, a = this._geometryInfo; i.vertexStart = this._nextVertexStart, i.reservedVertexCount = n === -1 ? e.getAttribute("position").count : n; const s = e.getIndex(); if (s !== null && (i.indexStart = this._nextIndexStart, i.reservedIndexCount = r === -1 ? s.count : r), i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."); let c; return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(TR), c = this._availableGeometryIds.shift(), a[c] = i) : (c = this._geometryCount, this._geometryCount++, a.push(i)), this.setGeometryAt(c, e), this._nextIndexStart = i.indexStart + i.reservedIndexCount, this._nextVertexStart = i.vertexStart + i.reservedVertexCount, c } setGeometryAt(e, n) { if (e >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached."); this._validateGeometry(n); const r = this.geometry, i = r.getIndex() !== null, a = r.getIndex(), s = n.getIndex(), o = this._geometryInfo[e]; if (i && s.count > o.reservedIndexCount || n.attributes.position.count > o.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry."); const c = o.vertexStart, u = o.reservedVertexCount; o.vertexCount = n.getAttribute("position").count; for (const d in r.attributes) { const f = n.getAttribute(d), h = r.getAttribute(d); OAe(f, h, c); const m = f.itemSize; for (let g = f.count, x = u; g < x; g++) { const v = c + g; for (let b = 0; b < m; b++)h.setComponent(v, b, 0) } h.needsUpdate = !0, h.addUpdateRange(c * m, u * m) } if (i) { const d = o.indexStart, f = o.reservedIndexCount; o.indexCount = n.getIndex().count; for (let h = 0; h < s.count; h++)a.setX(d + h, c + s.getX(h)); for (let h = s.count, m = f; h < m; h++)a.setX(d + h, c); a.needsUpdate = !0, a.addUpdateRange(d, o.reservedIndexCount) } return o.start = i ? o.indexStart : o.vertexStart, o.count = i ? o.indexCount : o.vertexCount, o.boundingBox = null, n.boundingBox !== null && (o.boundingBox = n.boundingBox.clone()), o.boundingSphere = null, n.boundingSphere !== null && (o.boundingSphere = n.boundingSphere.clone()), this._visibilityChanged = !0, e } deleteGeometry(e) { const n = this._geometryInfo; if (e >= n.length || n[e].active === !1) return this; const r = this._instanceInfo; for (let i = 0, a = r.length; i < a; i++)r[i].active && r[i].geometryIndex === e && this.deleteInstance(i); return n[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this } deleteInstance(e) { return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this } optimize() { let e = 0, n = 0; const r = this._geometryInfo, i = r.map((s, o) => o).sort((s, o) => r[s].vertexStart - r[o].vertexStart), a = this.geometry; for (let s = 0, o = r.length; s < o; s++) { const c = i[s], u = r[c]; if (u.active !== !1) { if (a.index !== null) { if (u.indexStart !== n) { const { indexStart: d, vertexStart: f, reservedIndexCount: h } = u, m = a.index, g = m.array, x = e - f; for (let v = d; v < d + h; v++)g[v] = g[v] + x; m.array.copyWithin(n, d, d + h), m.addUpdateRange(n, h), u.indexStart = n } n += u.reservedIndexCount } if (u.vertexStart !== e) { const { vertexStart: d, reservedVertexCount: f } = u, h = a.attributes; for (const m in h) { const g = h[m], { array: x, itemSize: v } = g; x.copyWithin(e * v, d * v, (d + f) * v), g.addUpdateRange(e * v, f * v) } u.vertexStart = e } e += u.reservedVertexCount, u.start = a.index ? u.indexStart : u.vertexStart, this._nextIndexStart = a.index ? u.indexStart + u.reservedIndexCount : 0, this._nextVertexStart = u.vertexStart + u.reservedVertexCount } } return this } getBoundingBoxAt(e, n) { if (e >= this._geometryCount) return null; const r = this.geometry, i = this._geometryInfo[e]; if (i.boundingBox === null) { const a = new Ps, s = r.index, o = r.attributes.position; for (let c = i.start, u = i.start + i.count; c < u; c++) { let d = c; s && (d = s.getX(d)), a.expandByPoint(sw.fromBufferAttribute(o, d)) } i.boundingBox = a } return n.copy(i.boundingBox), n } getBoundingSphereAt(e, n) { if (e >= this._geometryCount) return null; const r = this.geometry, i = this._geometryInfo[e]; if (i.boundingSphere === null) { const a = new us; this.getBoundingBoxAt(e, xM), xM.getCenter(a.center); const s = r.index, o = r.attributes.position; let c = 0; for (let u = i.start, d = i.start + i.count; u < d; u++) { let f = u; s && (f = s.getX(f)), sw.fromBufferAttribute(o, f), c = Math.max(c, a.center.distanceToSquared(sw)) } a.radius = Math.sqrt(c), i.boundingSphere = a } return n.copy(i.boundingSphere), n } setMatrixAt(e, n) { this.validateInstanceId(e); const r = this._matricesTexture, i = this._matricesTexture.image.data; return n.toArray(i, e * 16), r.needsUpdate = !0, this } getMatrixAt(e, n) { return this.validateInstanceId(e), n.fromArray(this._matricesTexture.image.data, e * 16) } setColorAt(e, n) { return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), n.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this } getColorAt(e, n) { return this.validateInstanceId(e), n.fromArray(this._colorsTexture.image.data, e * 4) } setVisibleAt(e, n) { return this.validateInstanceId(e), this._instanceInfo[e].visible === n ? this : (this._instanceInfo[e].visible = n, this._visibilityChanged = !0, this) } getVisibleAt(e) { return this.validateInstanceId(e), this._instanceInfo[e].visible } setGeometryIdAt(e, n) { return this.validateInstanceId(e), this.validateGeometryId(n), this._instanceInfo[e].geometryIndex = n, this } getGeometryIdAt(e) { return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex } getGeometryRangeAt(e, n = {}) { this.validateGeometryId(e); const r = this._geometryInfo[e]; return n.vertexStart = r.vertexStart, n.vertexCount = r.vertexCount, n.reservedVertexCount = r.reservedVertexCount, n.indexStart = r.indexStart, n.indexCount = r.indexCount, n.reservedIndexCount = r.reservedIndexCount, n.start = r.start, n.count = r.count, n } setInstanceCount(e) { const n = this._availableInstanceIds, r = this._instanceInfo; for (n.sort(TR); n[n.length - 1] === r.length - 1;)r.pop(), n.pop(); if (e < r.length) throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`); const i = new Int32Array(e), a = new Int32Array(e); _m(this._multiDrawCounts, i), _m(this._multiDrawStarts, a), this._multiDrawCounts = i, this._multiDrawStarts = a, this._maxInstanceCount = e; const s = this._indirectTexture, o = this._matricesTexture, c = this._colorsTexture; s.dispose(), this._initIndirectTexture(), _m(s.image.data, this._indirectTexture.image.data), o.dispose(), this._initMatricesTexture(), _m(o.image.data, this._matricesTexture.image.data), c && (c.dispose(), this._initColorsTexture(), _m(c.image.data, this._colorsTexture.image.data)) } setGeometrySize(e, n) { const r = [...this._geometryInfo].filter(o => o.active); if (Math.max(...r.map(o => o.vertexStart + o.reservedVertexCount)) > e) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${n}. Cannot shrink further.`); if (this.geometry.index && Math.max(...r.map(c => c.indexStart + c.reservedIndexCount)) > n) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${n}. Cannot shrink further.`); const a = this.geometry; a.dispose(), this._maxVertexCount = e, this._maxIndexCount = n, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new Kn, this._initializeGeometry(a)); const s = this.geometry; a.index && _m(a.index.array, s.index.array); for (const o in a.attributes) _m(a.attributes[o].array, s.attributes[o].array) } raycast(e, n) { const r = this._instanceInfo, i = this._geometryInfo, a = this.matrixWorld, s = this.geometry; Ss.material = this.material, Ss.geometry.index = s.index, Ss.geometry.attributes = s.attributes, Ss.geometry.boundingBox === null && (Ss.geometry.boundingBox = new Ps), Ss.geometry.boundingSphere === null && (Ss.geometry.boundingSphere = new us); for (let o = 0, c = r.length; o < c; o++) { if (!r[o].visible || !r[o].active) continue; const u = r[o].geometryIndex, d = i[u]; Ss.geometry.setDrawRange(d.start, d.count), this.getMatrixAt(o, Ss.matrixWorld).premultiply(a), this.getBoundingBoxAt(u, Ss.geometry.boundingBox), this.getBoundingSphereAt(u, Ss.geometry.boundingSphere), Ss.raycast(e, bM); for (let f = 0, h = bM.length; f < h; f++) { const m = bM[f]; m.object = this, m.batchId = o, n.push(m) } bM.length = 0 } Ss.material = null, Ss.geometry.index = null, Ss.geometry.attributes = {}, Ss.geometry.setDrawRange(0, 1 / 0) } copy(e) { return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map(n => ({ ...n, boundingBox: n.boundingBox !== null ? n.boundingBox.clone() : null, boundingSphere: n.boundingSphere !== null ? n.boundingSphere.clone() : null })), this._instanceInfo = e._instanceInfo.map(n => ({ ...n })), this._availableInstanceIds = e._availableInstanceIds.slice(), this._availableGeometryIds = e._availableGeometryIds.slice(), this._nextIndexStart = e._nextIndexStart, this._nextVertexStart = e._nextVertexStart, this._geometryCount = e._geometryCount, this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._indirectTexture = e._indirectTexture.clone(), this._indirectTexture.image.data = this._indirectTexture.image.data.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this } dispose() { this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null) } onBeforeRender(e, n, r, i, a) { if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return; const s = i.getIndex(), o = s === null ? 1 : s.array.BYTES_PER_ELEMENT, c = this._instanceInfo, u = this._multiDrawStarts, d = this._multiDrawCounts, f = this._geometryInfo, h = this.perObjectFrustumCulled, m = this._indirectTexture, g = m.image.data, x = r.isArrayCamera ? kAe : JH; h && !r.isArrayCamera && (Co.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(this.matrixWorld), JH.setFromProjectionMatrix(Co, r.coordinateSystem, r.reversedDepth)); let v = 0; if (this.sortObjects) { Co.copy(this.matrixWorld).invert(), sw.setFromMatrixPosition(r.matrixWorld).applyMatrix4(Co), eW.set(0, 0, -1).transformDirection(r.matrixWorld).transformDirection(Co); for (let M = 0, C = c.length; M < C; M++)if (c[M].visible && c[M].active) { const N = c[M].geometryIndex; this.getMatrixAt(M, Co), this.getBoundingSphereAt(N, Sm).applyMatrix4(Co); let A = !1; if (h && (A = !x.intersectsSphere(Sm, r)), !A) { const j = f[N], O = IAe.subVectors(Sm.center, sw).dot(eW); CR.push(j.start, j.count, O, M) } } const b = CR.list, E = this.customSort; E === null ? b.sort(a.transparent ? PAe : AAe) : E.call(this, b, r); for (let M = 0, C = b.length; M < C; M++) { const N = b[M]; u[v] = N.start * o, d[v] = N.count, g[v] = N.index, v++ } CR.reset() } else for (let b = 0, E = c.length; b < E; b++)if (c[b].visible && c[b].active) { const M = c[b].geometryIndex; let C = !1; if (h && (this.getMatrixAt(b, Co), this.getBoundingSphereAt(M, Sm).applyMatrix4(Co), C = !x.intersectsSphere(Sm, r)), !C) { const N = f[M]; u[v] = N.start * o, d[v] = N.count, g[v] = b, v++ } } m.needsUpdate = !0, this._multiDrawCount = v, this._visibilityChanged = !1 } onBeforeShadow(e, n, r, i, a, s) { this.onBeforeRender(e, null, i, a, s) } } class fo extends Rs { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Kt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const HC = new pe, WC = new pe, tW = new Fn, ow = new Hg, wM = new us, NR = new pe, nW = new pe; let ip = class extends kr { constructor(e = new Kn, n = new fo) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, n) { return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const n = e.attributes.position, r = [0]; for (let i = 1, a = n.count; i < a; i++)HC.fromBufferAttribute(n, i - 1), WC.fromBufferAttribute(n, i), r[i] = r[i - 1], r[i] += HC.distanceTo(WC); e.setAttribute("lineDistance", new hn(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, n) { const r = this.geometry, i = this.matrixWorld, a = e.params.Line.threshold, s = r.drawRange; if (r.boundingSphere === null && r.computeBoundingSphere(), wM.copy(r.boundingSphere), wM.applyMatrix4(i), wM.radius += a, e.ray.intersectsSphere(wM) === !1) return; tW.copy(i).invert(), ow.copy(e.ray).applyMatrix4(tW); const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, u = this.isLineSegments ? 2 : 1, d = r.index, h = r.attributes.position; if (d !== null) { const m = Math.max(0, s.start), g = Math.min(d.count, s.start + s.count); for (let x = m, v = g - 1; x < v; x += u) { const b = d.getX(x), E = d.getX(x + 1), M = SM(this, e, ow, c, b, E, x); M && n.push(M) } if (this.isLineLoop) { const x = d.getX(g - 1), v = d.getX(m), b = SM(this, e, ow, c, x, v, g - 1); b && n.push(b) } } else { const m = Math.max(0, s.start), g = Math.min(h.count, s.start + s.count); for (let x = m, v = g - 1; x < v; x += u) { const b = SM(this, e, ow, c, x, x + 1, x); b && n.push(b) } if (this.isLineLoop) { const x = SM(this, e, ow, c, g - 1, m, g - 1); x && n.push(x) } } } updateMorphTargets() { const n = this.geometry.morphAttributes, r = Object.keys(n); if (r.length > 0) { const i = n[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let a = 0, s = i.length; a < s; a++) { const o = i[a].name || String(a); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = a } } } } }; function SM(t, e, n, r, i, a, s) { const o = t.geometry.attributes.position; if (HC.fromBufferAttribute(o, i), WC.fromBufferAttribute(o, a), n.distanceSqToSegment(HC, WC, NR, nW) > r) return; NR.applyMatrix4(t.matrixWorld); const u = e.ray.origin.distanceTo(NR); if (!(u < e.near || u > e.far)) return { distance: u, point: nW.clone().applyMatrix4(t.matrixWorld), index: s, face: null, faceIndex: null, barycoord: null, object: t } } const rW = new pe, iW = new pe; class Ju extends ip { constructor(e, n) { super(e, n), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const n = e.attributes.position, r = []; for (let i = 0, a = n.count; i < a; i += 2)rW.fromBufferAttribute(n, i), iW.fromBufferAttribute(n, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + rW.distanceTo(iW); e.setAttribute("lineDistance", new hn(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class Lae extends ip { constructor(e, n) { super(e, n), this.isLineLoop = !0, this.type = "LineLoop" } } class sB extends Rs { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const aW = new Fn, HL = new Hg, _M = new us, EM = new pe; class Fae extends kr { constructor(e = new Kn, n = new sB) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = n, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, n) { return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, n) { const r = this.geometry, i = this.matrixWorld, a = e.params.Points.threshold, s = r.drawRange; if (r.boundingSphere === null && r.computeBoundingSphere(), _M.copy(r.boundingSphere), _M.applyMatrix4(i), _M.radius += a, e.ray.intersectsSphere(_M) === !1) return; aW.copy(i).invert(), HL.copy(e.ray).applyMatrix4(aW); const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, u = r.index, f = r.attributes.position; if (u !== null) { const h = Math.max(0, s.start), m = Math.min(u.count, s.start + s.count); for (let g = h, x = m; g < x; g++) { const v = u.getX(g); EM.fromBufferAttribute(f, v), sW(EM, v, c, i, e, n, this) } } else { const h = Math.max(0, s.start), m = Math.min(f.count, s.start + s.count); for (let g = h, x = m; g < x; g++)EM.fromBufferAttribute(f, g), sW(EM, g, c, i, e, n, this) } } updateMorphTargets() { const n = this.geometry.morphAttributes, r = Object.keys(n); if (r.length > 0) { const i = n[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let a = 0, s = i.length; a < s; a++) { const o = i[a].name || String(a); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = a } } } } } function sW(t, e, n, r, i, a, s) { const o = HL.distanceSqToPoint(t); if (o < n) { const c = new pe; HL.closestPointToPoint(t, c), c.applyMatrix4(r); const u = i.ray.origin.distanceTo(c); if (u < i.near || u > i.far) return; a.push({ distance: u, distanceToRay: Math.sqrt(o), point: c, index: e, face: null, faceIndex: null, barycoord: null, object: s }) } } class Uae extends ti { constructor(e, n, r, i, a = Xr, s = Xr, o, c, u) { super(e, n, r, i, a, s, o, c, u), this.isVideoTexture = !0, this.generateMipmaps = !1, this._requestVideoFrameCallbackId = 0; const d = this; function f() { d.needsUpdate = !0, d._requestVideoFrameCallbackId = e.requestVideoFrameCallback(f) } "requestVideoFrameCallback" in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(f)) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } dispose() { this._requestVideoFrameCallbackId !== 0 && this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId), super.dispose() } } class DAe extends Uae { constructor(e, n, r, i, a, s, o, c) { super({}, e, n, r, i, a, s, o, c), this.isVideoFrameTexture = !0 } update() { } clone() { return new this.constructor().copy(this) } setFrame(e) { this.image = e, this.needsUpdate = !0 } } class LAe extends ti { constructor(e, n) { super({ width: e, height: n }), this.isFramebufferTexture = !0, this.magFilter = cs, this.minFilter = cs, this.generateMipmaps = !1, this.needsUpdate = !0 } } class e2 extends ti { constructor(e, n, r, i, a, s, o, c, u, d, f, h) { super(null, s, o, c, u, d, i, a, f, h), this.isCompressedTexture = !0, this.image = { width: n, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class FAe extends e2 { constructor(e, n, r, i, a, s) { super(e, n, r, a, s), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = va, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class UAe extends e2 { constructor(e, n, r) { super(void 0, e[0].width, e[0].height, n, r, $u), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class BAe extends ti { constructor(e, n, r, i, a, s, o, c, u) { super(e, n, r, i, a, s, o, c, u), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class oB extends ti { constructor(e, n, r = zu, i, a, s, o = cs, c = cs, u, d = bx, f = 1) { if (d !== bx && d !== wx) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); const h = { width: e, height: n, depth: f }; super(h, i, a, s, o, c, d, r, u), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.source = new Oh(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this } toJSON(e) { const n = super.toJSON(e); return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n } } class lB extends ti { constructor(e = null) { super(), this.sourceTexture = e, this.isExternalTexture = !0 } copy(e) { return super.copy(e), this.sourceTexture = e.sourceTexture, this } } class t2 extends Kn { constructor(e = 1, n = 1, r = 4, i = 8, a = 1) { super(), this.type = "CapsuleGeometry", this.parameters = { radius: e, height: n, capSegments: r, radialSegments: i, heightSegments: a }, n = Math.max(0, n), r = Math.max(1, Math.floor(r)), i = Math.max(3, Math.floor(i)), a = Math.max(1, Math.floor(a)); const s = [], o = [], c = [], u = [], d = n / 2, f = Math.PI / 2 * e, h = n, m = 2 * f + h, g = r * 2 + a, x = i + 1, v = new pe, b = new pe; for (let E = 0; E <= g; E++) { let M = 0, C = 0, N = 0, A = 0; if (E <= r) { const I = E / r, D = I * Math.PI / 2; C = -d - e * Math.cos(D), N = e * Math.sin(D), A = -e * Math.cos(D), M = I * f } else if (E <= r + a) { const I = (E - r) / a; C = -d + I * n, N = e, A = 0, M = f + I * h } else { const I = (E - r - a) / r, D = I * Math.PI / 2; C = d + e * Math.sin(D), N = e * Math.cos(D), A = e * Math.sin(D), M = f + h + I * f } const j = Math.max(0, Math.min(1, M / m)); let O = 0; E === 0 ? O = .5 / i : E === g && (O = -.5 / i); for (let I = 0; I <= i; I++) { const D = I / i, F = D * Math.PI * 2, B = Math.sin(F), G = Math.cos(F); b.x = -N * G, b.y = C, b.z = N * B, o.push(b.x, b.y, b.z), v.set(-N * G, A, N * B), v.normalize(), c.push(v.x, v.y, v.z), u.push(D + O, j) } if (E > 0) { const I = (E - 1) * x; for (let D = 0; D < i; D++) { const F = I + D, B = I + D + 1, G = E * x + D, z = E * x + D + 1; s.push(F, B, G), s.push(B, z, G) } } } this.setIndex(s), this.setAttribute("position", new hn(o, 3)), this.setAttribute("normal", new hn(c, 3)), this.setAttribute("uv", new hn(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new t2(e.radius, e.height, e.capSegments, e.radialSegments, e.heightSegments) } } class n2 extends Kn { constructor(e = 1, n = 32, r = 0, i = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: n, thetaStart: r, thetaLength: i }, n = Math.max(3, n); const a = [], s = [], o = [], c = [], u = new pe, d = new lt; s.push(0, 0, 0), o.push(0, 0, 1), c.push(.5, .5); for (let f = 0, h = 3; f <= n; f++, h += 3) { const m = r + f / n * i; u.x = e * Math.cos(m), u.y = e * Math.sin(m), s.push(u.x, u.y, u.z), o.push(0, 0, 1), d.x = (s[h] / e + 1) / 2, d.y = (s[h + 1] / e + 1) / 2, c.push(d.x, d.y) } for (let f = 1; f <= n; f++)a.push(f, f + 1, 0); this.setIndex(a), this.setAttribute("position", new hn(s, 3)), this.setAttribute("normal", new hn(o, 3)), this.setAttribute("uv", new hn(c, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new n2(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class u_ extends Kn { constructor(e = 1, n = 1, r = 1, i = 32, a = 1, s = !1, o = 0, c = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: n, height: r, radialSegments: i, heightSegments: a, openEnded: s, thetaStart: o, thetaLength: c }; const u = this; i = Math.floor(i), a = Math.floor(a); const d = [], f = [], h = [], m = []; let g = 0; const x = [], v = r / 2; let b = 0; E(), s === !1 && (e > 0 && M(!0), n > 0 && M(!1)), this.setIndex(d), this.setAttribute("position", new hn(f, 3)), this.setAttribute("normal", new hn(h, 3)), this.setAttribute("uv", new hn(m, 2)); function E() { const C = new pe, N = new pe; let A = 0; const j = (n - e) / r; for (let O = 0; O <= a; O++) { const I = [], D = O / a, F = D * (n - e) + e; for (let B = 0; B <= i; B++) { const G = B / i, z = G * c + o, q = Math.sin(z), Y = Math.cos(z); N.x = F * q, N.y = -D * r + v, N.z = F * Y, f.push(N.x, N.y, N.z), C.set(q, j, Y).normalize(), h.push(C.x, C.y, C.z), m.push(G, 1 - D), I.push(g++) } x.push(I) } for (let O = 0; O < i; O++)for (let I = 0; I < a; I++) { const D = x[I][O], F = x[I + 1][O], B = x[I + 1][O + 1], G = x[I][O + 1]; (e > 0 || I !== 0) && (d.push(D, F, G), A += 3), (n > 0 || I !== a - 1) && (d.push(F, B, G), A += 3) } u.addGroup(b, A, 0), b += A } function M(C) { const N = g, A = new lt, j = new pe; let O = 0; const I = C === !0 ? e : n, D = C === !0 ? 1 : -1; for (let B = 1; B <= i; B++)f.push(0, v * D, 0), h.push(0, D, 0), m.push(.5, .5), g++; const F = g; for (let B = 0; B <= i; B++) { const z = B / i * c + o, q = Math.cos(z), Y = Math.sin(z); j.x = I * Y, j.y = v * D, j.z = I * q, f.push(j.x, j.y, j.z), h.push(0, D, 0), A.x = q * .5 + .5, A.y = Y * .5 * D + .5, m.push(A.x, A.y), g++ } for (let B = 0; B < i; B++) { const G = N + B, z = F + B; C === !0 ? d.push(z, z + 1, G) : d.push(z + 1, z, G), O += 3 } u.addGroup(b, O, C === !0 ? 1 : 2), b += O } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new u_(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class d_ extends u_ { constructor(e = 1, n = 1, r = 32, i = 1, a = !1, s = 0, o = Math.PI * 2) { super(0, e, n, r, i, a, s, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: n, radialSegments: r, heightSegments: i, openEnded: a, thetaStart: s, thetaLength: o } } static fromJSON(e) { return new d_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class gp extends Kn { constructor(e = [], n = [], r = 1, i = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: n, radius: r, detail: i }; const a = [], s = []; o(i), u(r), d(), this.setAttribute("position", new hn(a, 3)), this.setAttribute("normal", new hn(a.slice(), 3)), this.setAttribute("uv", new hn(s, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function o(E) { const M = new pe, C = new pe, N = new pe; for (let A = 0; A < n.length; A += 3)m(n[A + 0], M), m(n[A + 1], C), m(n[A + 2], N), c(M, C, N, E) } function c(E, M, C, N) { const A = N + 1, j = []; for (let O = 0; O <= A; O++) { j[O] = []; const I = E.clone().lerp(C, O / A), D = M.clone().lerp(C, O / A), F = A - O; for (let B = 0; B <= F; B++)B === 0 && O === A ? j[O][B] = I : j[O][B] = I.clone().lerp(D, B / F) } for (let O = 0; O < A; O++)for (let I = 0; I < 2 * (A - O) - 1; I++) { const D = Math.floor(I / 2); I % 2 === 0 ? (h(j[O][D + 1]), h(j[O + 1][D]), h(j[O][D])) : (h(j[O][D + 1]), h(j[O + 1][D + 1]), h(j[O + 1][D])) } } function u(E) { const M = new pe; for (let C = 0; C < a.length; C += 3)M.x = a[C + 0], M.y = a[C + 1], M.z = a[C + 2], M.normalize().multiplyScalar(E), a[C + 0] = M.x, a[C + 1] = M.y, a[C + 2] = M.z } function d() { const E = new pe; for (let M = 0; M < a.length; M += 3) { E.x = a[M + 0], E.y = a[M + 1], E.z = a[M + 2]; const C = v(E) / 2 / Math.PI + .5, N = b(E) / Math.PI + .5; s.push(C, 1 - N) } g(), f() } function f() { for (let E = 0; E < s.length; E += 6) { const M = s[E + 0], C = s[E + 2], N = s[E + 4], A = Math.max(M, C, N), j = Math.min(M, C, N); A > .9 && j < .1 && (M < .2 && (s[E + 0] += 1), C < .2 && (s[E + 2] += 1), N < .2 && (s[E + 4] += 1)) } } function h(E) { a.push(E.x, E.y, E.z) } function m(E, M) { const C = E * 3; M.x = e[C + 0], M.y = e[C + 1], M.z = e[C + 2] } function g() { const E = new pe, M = new pe, C = new pe, N = new pe, A = new lt, j = new lt, O = new lt; for (let I = 0, D = 0; I < a.length; I += 9, D += 6) { E.set(a[I + 0], a[I + 1], a[I + 2]), M.set(a[I + 3], a[I + 4], a[I + 5]), C.set(a[I + 6], a[I + 7], a[I + 8]), A.set(s[D + 0], s[D + 1]), j.set(s[D + 2], s[D + 3]), O.set(s[D + 4], s[D + 5]), N.copy(E).add(M).add(C).divideScalar(3); const F = v(N); x(A, D + 0, E, F), x(j, D + 2, M, F), x(O, D + 4, C, F) } } function x(E, M, C, N) { N < 0 && E.x === 1 && (s[M] = E.x - 1), C.x === 0 && C.z === 0 && (s[M] = N / 2 / Math.PI + .5) } function v(E) { return Math.atan2(E.z, -E.x) } function b(E) { return Math.atan2(-E.y, Math.sqrt(E.x * E.x + E.z * E.z)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new gp(e.vertices, e.indices, e.radius, e.details) } } class r2 extends gp { constructor(e = 1, n = 0) { const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, a = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i], s = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(a, s, e, n), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: n } } static fromJSON(e) { return new r2(e.radius, e.detail) } } const MM = new pe, TM = new pe, AR = new pe, CM = new Oo; class Bae extends Kn { constructor(e = null, n = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: n }, e !== null) { const i = Math.pow(10, 4), a = Math.cos(fg * n), s = e.getIndex(), o = e.getAttribute("position"), c = s ? s.count : o.count, u = [0, 0, 0], d = ["a", "b", "c"], f = new Array(3), h = {}, m = []; for (let g = 0; g < c; g += 3) { s ? (u[0] = s.getX(g), u[1] = s.getX(g + 1), u[2] = s.getX(g + 2)) : (u[0] = g, u[1] = g + 1, u[2] = g + 2); const { a: x, b: v, c: b } = CM; if (x.fromBufferAttribute(o, u[0]), v.fromBufferAttribute(o, u[1]), b.fromBufferAttribute(o, u[2]), CM.getNormal(AR), f[0] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(x.z * i)}`, f[1] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${Math.round(v.z * i)}`, f[2] = `${Math.round(b.x * i)},${Math.round(b.y * i)},${Math.round(b.z * i)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0])) for (let E = 0; E < 3; E++) { const M = (E + 1) % 3, C = f[E], N = f[M], A = CM[d[E]], j = CM[d[M]], O = `${C}_${N}`, I = `${N}_${C}`; I in h && h[I] ? (AR.dot(h[I].normal) <= a && (m.push(A.x, A.y, A.z), m.push(j.x, j.y, j.z)), h[I] = null) : O in h || (h[O] = { index0: u[E], index1: u[M], normal: AR.clone() }) } } for (const g in h) if (h[g]) { const { index0: x, index1: v } = h[g]; MM.fromBufferAttribute(o, x), TM.fromBufferAttribute(o, v), m.push(MM.x, MM.y, MM.z), m.push(TM.x, TM.y, TM.z) } this.setAttribute("position", new hn(m, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } let Kc = class { constructor() { this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null } getPoint() { console.warn("THREE.Curve: .getPoint() not implemented.") } getPointAt(e, n) { const r = this.getUtoTmapping(e); return this.getPoint(r, n) } getPoints(e = 5) { const n = []; for (let r = 0; r <= e; r++)n.push(this.getPoint(r / e)); return n } getSpacedPoints(e = 5) { const n = []; for (let r = 0; r <= e; r++)n.push(this.getPointAt(r / e)); return n } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const n = []; let r, i = this.getPoint(0), a = 0; n.push(0); for (let s = 1; s <= e; s++)r = this.getPoint(s / e), a += r.distanceTo(i), n.push(a), i = r; return this.cacheArcLengths = n, n } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, n = null) { const r = this.getLengths(); let i = 0; const a = r.length; let s; n ? s = n : s = e * r[a - 1]; let o = 0, c = a - 1, u; for (; o <= c;)if (i = Math.floor(o + (c - o) / 2), u = r[i] - s, u < 0) o = i + 1; else if (u > 0) c = i - 1; else { c = i; break } if (i = c, r[i] === s) return i / (a - 1); const d = r[i], h = r[i + 1] - d, m = (s - d) / h; return (i + m) / (a - 1) } getTangent(e, n) { let i = e - 1e-4, a = e + 1e-4; i < 0 && (i = 0), a > 1 && (a = 1); const s = this.getPoint(i), o = this.getPoint(a), c = n || (s.isVector2 ? new lt : new pe); return c.copy(o).sub(s).normalize(), c } getTangentAt(e, n) { const r = this.getUtoTmapping(e); return this.getTangent(r, n) } computeFrenetFrames(e, n = !1) { const r = new pe, i = [], a = [], s = [], o = new pe, c = new Fn; for (let m = 0; m <= e; m++) { const g = m / e; i[m] = this.getTangentAt(g, new pe) } a[0] = new pe, s[0] = new pe; let u = Number.MAX_VALUE; const d = Math.abs(i[0].x), f = Math.abs(i[0].y), h = Math.abs(i[0].z); d <= u && (u = d, r.set(1, 0, 0)), f <= u && (u = f, r.set(0, 1, 0)), h <= u && r.set(0, 0, 1), o.crossVectors(i[0], r).normalize(), a[0].crossVectors(i[0], o), s[0].crossVectors(i[0], a[0]); for (let m = 1; m <= e; m++) { if (a[m] = a[m - 1].clone(), s[m] = s[m - 1].clone(), o.crossVectors(i[m - 1], i[m]), o.length() > Number.EPSILON) { o.normalize(); const g = Math.acos(In(i[m - 1].dot(i[m]), -1, 1)); a[m].applyMatrix4(c.makeRotationAxis(o, g)) } s[m].crossVectors(i[m], a[m]) } if (n === !0) { let m = Math.acos(In(a[0].dot(a[e]), -1, 1)); m /= e, i[0].dot(o.crossVectors(a[0], a[e])) > 0 && (m = -m); for (let g = 1; g <= e; g++)a[g].applyMatrix4(c.makeRotationAxis(i[g], m * g)), s[g].crossVectors(i[g], a[g]) } return { tangents: i, normals: a, binormals: s } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.7, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } }; class i2 extends Kc { constructor(e = 0, n = 0, r = 1, i = 1, a = 0, s = Math.PI * 2, o = !1, c = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = r, this.yRadius = i, this.aStartAngle = a, this.aEndAngle = s, this.aClockwise = o, this.aRotation = c } getPoint(e, n = new lt) { const r = n, i = Math.PI * 2; let a = this.aEndAngle - this.aStartAngle; const s = Math.abs(a) < Number.EPSILON; for (; a < 0;)a += i; for (; a > i;)a -= i; a < Number.EPSILON && (s ? a = 0 : a = i), this.aClockwise === !0 && !s && (a === i ? a = -i : a = a - i); const o = this.aStartAngle + e * a; let c = this.aX + this.xRadius * Math.cos(o), u = this.aY + this.yRadius * Math.sin(o); if (this.aRotation !== 0) { const d = Math.cos(this.aRotation), f = Math.sin(this.aRotation), h = c - this.aX, m = u - this.aY; c = h * d - m * f + this.aX, u = h * f + m * d + this.aY } return r.set(c, u) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class $ae extends i2 { constructor(e, n, r, i, a, s) { super(e, n, r, r, i, a, s), this.isArcCurve = !0, this.type = "ArcCurve" } } function cB() { let t = 0, e = 0, n = 0, r = 0; function i(a, s, o, c) { t = a, e = o, n = -3 * a + 3 * s - 2 * o - c, r = 2 * a - 2 * s + o + c } return { initCatmullRom: function (a, s, o, c, u) { i(s, o, u * (o - a), u * (c - s)) }, initNonuniformCatmullRom: function (a, s, o, c, u, d, f) { let h = (s - a) / u - (o - a) / (u + d) + (o - s) / d, m = (o - s) / d - (c - s) / (d + f) + (c - o) / f; h *= d, m *= d, i(s, o, h, m) }, calc: function (a) { const s = a * a, o = s * a; return t + e * a + n * s + r * o } } } const NM = new pe, PR = new cB, jR = new cB, RR = new cB; class zae extends Kc { constructor(e = [], n = !1, r = "centripetal", i = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = r, this.tension = i } getPoint(e, n = new pe) { const r = n, i = this.points, a = i.length, s = (a - (this.closed ? 0 : 1)) * e; let o = Math.floor(s), c = s - o; this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a : c === 0 && o === a - 1 && (o = a - 2, c = 1); let u, d; this.closed || o > 0 ? u = i[(o - 1) % a] : (NM.subVectors(i[0], i[1]).add(i[0]), u = NM); const f = i[o % a], h = i[(o + 1) % a]; if (this.closed || o + 2 < a ? d = i[(o + 2) % a] : (NM.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), d = NM), this.curveType === "centripetal" || this.curveType === "chordal") { const m = this.curveType === "chordal" ? .5 : .25; let g = Math.pow(u.distanceToSquared(f), m), x = Math.pow(f.distanceToSquared(h), m), v = Math.pow(h.distanceToSquared(d), m); x < 1e-4 && (x = 1), g < 1e-4 && (g = x), v < 1e-4 && (v = x), PR.initNonuniformCatmullRom(u.x, f.x, h.x, d.x, g, x, v), jR.initNonuniformCatmullRom(u.y, f.y, h.y, d.y, g, x, v), RR.initNonuniformCatmullRom(u.z, f.z, h.z, d.z, g, x, v) } else this.curveType === "catmullrom" && (PR.initCatmullRom(u.x, f.x, h.x, d.x, this.tension), jR.initCatmullRom(u.y, f.y, h.y, d.y, this.tension), RR.initCatmullRom(u.z, f.z, h.z, d.z, this.tension)); return r.set(PR.calc(c), jR.calc(c), RR.calc(c)), r } copy(e) { super.copy(e), this.points = []; for (let n = 0, r = e.points.length; n < r; n++) { const i = e.points[n]; this.points.push(i.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let n = 0, r = this.points.length; n < r; n++) { const i = this.points[n]; e.points.push(i.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let n = 0, r = e.points.length; n < r; n++) { const i = e.points[n]; this.points.push(new pe().fromArray(i)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function oW(t, e, n, r, i) { const a = (r - e) * .5, s = (i - n) * .5, o = t * t, c = t * o; return (2 * n - 2 * r + a + s) * c + (-3 * n + 3 * r - 2 * a - s) * o + a * t + n } function $Ae(t, e) { const n = 1 - t; return n * n * e } function zAe(t, e) { return 2 * (1 - t) * t * e } function VAe(t, e) { return t * t * e } function Qw(t, e, n, r) { return $Ae(t, e) + zAe(t, n) + VAe(t, r) } function HAe(t, e) { const n = 1 - t; return n * n * n * e } function WAe(t, e) { const n = 1 - t; return 3 * n * n * t * e } function GAe(t, e) { return 3 * (1 - t) * t * t * e } function qAe(t, e) { return t * t * t * e } function Jw(t, e, n, r, i) { return HAe(t, e) + WAe(t, n) + GAe(t, r) + qAe(t, i) } class uB extends Kc { constructor(e = new lt, n = new lt, r = new lt, i = new lt) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = i } getPoint(e, n = new lt) { const r = n, i = this.v0, a = this.v1, s = this.v2, o = this.v3; return r.set(Jw(e, i.x, a.x, s.x, o.x), Jw(e, i.y, a.y, s.y, o.y)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class Vae extends Kc { constructor(e = new pe, n = new pe, r = new pe, i = new pe) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = i } getPoint(e, n = new pe) { const r = n, i = this.v0, a = this.v1, s = this.v2, o = this.v3; return r.set(Jw(e, i.x, a.x, s.x, o.x), Jw(e, i.y, a.y, s.y, o.y), Jw(e, i.z, a.z, s.z, o.z)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class dB extends Kc { constructor(e = new lt, n = new lt) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n } getPoint(e, n = new lt) { const r = n; return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r } getPointAt(e, n) { return this.getPoint(e, n) } getTangent(e, n = new lt) { return n.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, n) { return this.getTangent(e, n) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class Hae extends Kc { constructor(e = new pe, n = new pe) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n } getPoint(e, n = new pe) { const r = n; return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r } getPointAt(e, n) { return this.getPoint(e, n) } getTangent(e, n = new pe) { return n.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, n) { return this.getTangent(e, n) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class fB extends Kc { constructor(e = new lt, n = new lt, r = new lt) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r } getPoint(e, n = new lt) { const r = n, i = this.v0, a = this.v1, s = this.v2; return r.set(Qw(e, i.x, a.x, s.x), Qw(e, i.y, a.y, s.y)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class hB extends Kc { constructor(e = new pe, n = new pe, r = new pe) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r } getPoint(e, n = new pe) { const r = n, i = this.v0, a = this.v1, s = this.v2; return r.set(Qw(e, i.x, a.x, s.x), Qw(e, i.y, a.y, s.y), Qw(e, i.z, a.z, s.z)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class pB extends Kc { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, n = new lt) { const r = n, i = this.points, a = (i.length - 1) * e, s = Math.floor(a), o = a - s, c = i[s === 0 ? s : s - 1], u = i[s], d = i[s > i.length - 2 ? i.length - 1 : s + 1], f = i[s > i.length - 3 ? i.length - 1 : s + 2]; return r.set(oW(o, c.x, u.x, d.x, f.x), oW(o, c.y, u.y, d.y, f.y)), r } copy(e) { super.copy(e), this.points = []; for (let n = 0, r = e.points.length; n < r; n++) { const i = e.points[n]; this.points.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let n = 0, r = this.points.length; n < r; n++) { const i = this.points[n]; e.points.push(i.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let n = 0, r = e.points.length; n < r; n++) { const i = e.points[n]; this.points.push(new lt().fromArray(i)) } return this } } var GC = Object.freeze({ __proto__: null, ArcCurve: $ae, CatmullRomCurve3: zae, CubicBezierCurve: uB, CubicBezierCurve3: Vae, EllipseCurve: i2, LineCurve: dB, LineCurve3: Hae, QuadraticBezierCurve: fB, QuadraticBezierCurve3: hB, SplineCurve: pB }); class Wae extends Kc { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1); if (!e.equals(n)) { const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3"; this.curves.push(new GC[r](n, e)) } return this } getPoint(e, n) { const r = e * this.getLength(), i = this.getCurveLengths(); let a = 0; for (; a < i.length;) { if (i[a] >= r) { const s = i[a] - r, o = this.curves[a], c = o.getLength(), u = c === 0 ? 0 : 1 - s / c; return o.getPointAt(u, n) } a++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let n = 0; for (let r = 0, i = this.curves.length; r < i; r++)n += this.curves[r].getLength(), e.push(n); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const n = []; for (let r = 0; r <= e; r++)n.push(this.getPoint(r / e)); return this.autoClose && n.push(n[0]), n } getPoints(e = 12) { const n = []; let r; for (let i = 0, a = this.curves; i < a.length; i++) { const s = a[i], o = s.isEllipseCurve ? e * 2 : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e, c = s.getPoints(o); for (let u = 0; u < c.length; u++) { const d = c[u]; r && r.equals(d) || (n.push(d), r = d) } } return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n } copy(e) { super.copy(e), this.curves = []; for (let n = 0, r = e.curves.length; n < r; n++) { const i = e.curves[n]; this.curves.push(i.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let n = 0, r = this.curves.length; n < r; n++) { const i = this.curves[n]; e.curves.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let n = 0, r = e.curves.length; n < r; n++) { const i = e.curves[n]; this.curves.push(new GC[i.type]().fromJSON(i)) } return this } } let qC = class extends Wae { constructor(e) { super(), this.type = "Path", this.currentPoint = new lt, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let n = 1, r = e.length; n < r; n++)this.lineTo(e[n].x, e[n].y); return this } moveTo(e, n) { return this.currentPoint.set(e, n), this } lineTo(e, n) { const r = new dB(this.currentPoint.clone(), new lt(e, n)); return this.curves.push(r), this.currentPoint.set(e, n), this } quadraticCurveTo(e, n, r, i) { const a = new fB(this.currentPoint.clone(), new lt(e, n), new lt(r, i)); return this.curves.push(a), this.currentPoint.set(r, i), this } bezierCurveTo(e, n, r, i, a, s) { const o = new uB(this.currentPoint.clone(), new lt(e, n), new lt(r, i), new lt(a, s)); return this.curves.push(o), this.currentPoint.set(a, s), this } splineThru(e) { const n = [this.currentPoint.clone()].concat(e), r = new pB(n); return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this } arc(e, n, r, i, a, s) { const o = this.currentPoint.x, c = this.currentPoint.y; return this.absarc(e + o, n + c, r, i, a, s), this } absarc(e, n, r, i, a, s) { return this.absellipse(e, n, r, r, i, a, s), this } ellipse(e, n, r, i, a, s, o, c) { const u = this.currentPoint.x, d = this.currentPoint.y; return this.absellipse(e + u, n + d, r, i, a, s, o, c), this } absellipse(e, n, r, i, a, s, o, c) { const u = new i2(e, n, r, i, a, s, o, c); if (this.curves.length > 0) { const f = u.getPoint(0); f.equals(this.currentPoint) || this.lineTo(f.x, f.y) } this.curves.push(u); const d = u.getPoint(1); return this.currentPoint.copy(d), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } }, pg = class extends qC { constructor(e) { super(e), this.uuid = fl(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const n = []; for (let r = 0, i = this.holes.length; r < i; r++)n[r] = this.holes[r].getPoints(e); return n } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let n = 0, r = e.holes.length; n < r; n++) { const i = e.holes[n]; this.holes.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let n = 0, r = this.holes.length; n < r; n++) { const i = this.holes[n]; e.holes.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let n = 0, r = e.holes.length; n < r; n++) { const i = e.holes[n]; this.holes.push(new qC().fromJSON(i)) } return this } }; function XAe(t, e, n = 2) { const r = e && e.length, i = r ? e[0] * n : t.length; let a = Gae(t, 0, i, n, !0); const s = []; if (!a || a.next === a.prev) return s; let o, c, u; if (r && (a = JAe(t, e, a, n)), t.length > 80 * n) { o = 1 / 0, c = 1 / 0; let d = -1 / 0, f = -1 / 0; for (let h = n; h < i; h += n) { const m = t[h], g = t[h + 1]; m < o && (o = m), g < c && (c = g), m > d && (d = m), g > f && (f = g) } u = Math.max(d - o, f - c), u = u !== 0 ? 32767 / u : 0 } return U1(a, s, n, o, c, u, 0), s } function Gae(t, e, n, r, i) { let a; if (i === u2e(t, e, n, r) > 0) for (let s = e; s < n; s += r)a = lW(s / r | 0, t[s], t[s + 1], a); else for (let s = n - r; s >= e; s -= r)a = lW(s / r | 0, t[s], t[s + 1], a); return a && Tx(a, a.next) && ($1(a), a = a.next), a } function Tg(t, e) { if (!t) return t; e || (e = t); let n = t, r; do if (r = !1, !n.steiner && (Tx(n, n.next) || Fi(n.prev, n, n.next) === 0)) { if ($1(n), n = e = n.prev, n === n.next) break; r = !0 } else n = n.next; while (r || n !== e); return e } function U1(t, e, n, r, i, a, s) { if (!t) return; !s && a && i2e(t, r, i, a); let o = t; for (; t.prev !== t.next;) { const c = t.prev, u = t.next; if (a ? KAe(t, r, i, a) : YAe(t)) { e.push(c.i, t.i, u.i), $1(t), t = u.next, o = u.next; continue } if (t = u, t === o) { s ? s === 1 ? (t = ZAe(Tg(t), e), U1(t, e, n, r, i, a, 2)) : s === 2 && QAe(t, e, n, r, i, a) : U1(Tg(t), e, n, r, i, a, 1); break } } } function YAe(t) { const e = t.prev, n = t, r = t.next; if (Fi(e, n, r) >= 0) return !1; const i = e.x, a = n.x, s = r.x, o = e.y, c = n.y, u = r.y, d = Math.min(i, a, s), f = Math.min(o, c, u), h = Math.max(i, a, s), m = Math.max(o, c, u); let g = r.next; for (; g !== e;) { if (g.x >= d && g.x <= h && g.y >= f && g.y <= m && kw(i, o, a, c, s, u, g.x, g.y) && Fi(g.prev, g, g.next) >= 0) return !1; g = g.next } return !0 } function KAe(t, e, n, r) { const i = t.prev, a = t, s = t.next; if (Fi(i, a, s) >= 0) return !1; const o = i.x, c = a.x, u = s.x, d = i.y, f = a.y, h = s.y, m = Math.min(o, c, u), g = Math.min(d, f, h), x = Math.max(o, c, u), v = Math.max(d, f, h), b = WL(m, g, e, n, r), E = WL(x, v, e, n, r); let M = t.prevZ, C = t.nextZ; for (; M && M.z >= b && C && C.z <= E;) { if (M.x >= m && M.x <= x && M.y >= g && M.y <= v && M !== i && M !== s && kw(o, d, c, f, u, h, M.x, M.y) && Fi(M.prev, M, M.next) >= 0 || (M = M.prevZ, C.x >= m && C.x <= x && C.y >= g && C.y <= v && C !== i && C !== s && kw(o, d, c, f, u, h, C.x, C.y) && Fi(C.prev, C, C.next) >= 0)) return !1; C = C.nextZ } for (; M && M.z >= b;) { if (M.x >= m && M.x <= x && M.y >= g && M.y <= v && M !== i && M !== s && kw(o, d, c, f, u, h, M.x, M.y) && Fi(M.prev, M, M.next) >= 0) return !1; M = M.prevZ } for (; C && C.z <= E;) { if (C.x >= m && C.x <= x && C.y >= g && C.y <= v && C !== i && C !== s && kw(o, d, c, f, u, h, C.x, C.y) && Fi(C.prev, C, C.next) >= 0) return !1; C = C.nextZ } return !0 } function ZAe(t, e) { let n = t; do { const r = n.prev, i = n.next.next; !Tx(r, i) && Xae(r, n, n.next, i) && B1(r, i) && B1(i, r) && (e.push(r.i, n.i, i.i), $1(n), $1(n.next), n = t = i), n = n.next } while (n !== t); return Tg(n) } function QAe(t, e, n, r, i, a) { let s = t; do { let o = s.next.next; for (; o !== s.prev;) { if (s.i !== o.i && o2e(s, o)) { let c = Yae(s, o); s = Tg(s, s.next), c = Tg(c, c.next), U1(s, e, n, r, i, a, 0), U1(c, e, n, r, i, a, 0); return } o = o.next } s = s.next } while (s !== t) } function JAe(t, e, n, r) { const i = []; for (let a = 0, s = e.length; a < s; a++) { const o = e[a] * r, c = a < s - 1 ? e[a + 1] * r : t.length, u = Gae(t, o, c, r, !1); u === u.next && (u.steiner = !0), i.push(s2e(u)) } i.sort(e2e); for (let a = 0; a < i.length; a++)n = t2e(i[a], n); return n } function e2e(t, e) { let n = t.x - e.x; if (n === 0 && (n = t.y - e.y, n === 0)) { const r = (t.next.y - t.y) / (t.next.x - t.x), i = (e.next.y - e.y) / (e.next.x - e.x); n = r - i } return n } function t2e(t, e) { const n = n2e(t, e); if (!n) return e; const r = Yae(n, t); return Tg(r, r.next), Tg(n, n.next) } function n2e(t, e) { let n = e; const r = t.x, i = t.y; let a = -1 / 0, s; if (Tx(t, n)) return n; do { if (Tx(t, n.next)) return n.next; if (i <= n.y && i >= n.next.y && n.next.y !== n.y) { const f = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (f <= r && f > a && (a = f, s = n.x < n.next.x ? n : n.next, f === r)) return s } n = n.next } while (n !== e); if (!s) return null; const o = s, c = s.x, u = s.y; let d = 1 / 0; n = s; do { if (r >= n.x && n.x >= c && r !== n.x && qae(i < u ? r : a, i, c, u, i < u ? a : r, i, n.x, n.y)) { const f = Math.abs(i - n.y) / (r - n.x); B1(n, t) && (f < d || f === d && (n.x > s.x || n.x === s.x && r2e(s, n))) && (s = n, d = f) } n = n.next } while (n !== o); return s } function r2e(t, e) { return Fi(t.prev, t, e.prev) < 0 && Fi(e.next, t, t.next) < 0 } function i2e(t, e, n, r) { let i = t; do i.z === 0 && (i.z = WL(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, a2e(i) } function a2e(t) { let e, n = 1; do { let r = t, i; t = null; let a = null; for (e = 0; r;) { e++; let s = r, o = 0; for (let u = 0; u < n && (o++, s = s.nextZ, !!s); u++); let c = n; for (; o > 0 || c > 0 && s;)o !== 0 && (c === 0 || !s || r.z <= s.z) ? (i = r, r = r.nextZ, o--) : (i = s, s = s.nextZ, c--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i; r = s } a.nextZ = null, n *= 2 } while (e > 1); return t } function WL(t, e, n, r, i) { return t = (t - n) * i | 0, e = (e - r) * i | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1 } function s2e(t) { let e = t, n = t; do (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next; while (e !== t); return n } function qae(t, e, n, r, i, a, s, o) { return (i - s) * (e - o) >= (t - s) * (a - o) && (t - s) * (r - o) >= (n - s) * (e - o) && (n - s) * (a - o) >= (i - s) * (r - o) } function kw(t, e, n, r, i, a, s, o) { return !(t === s && e === o) && qae(t, e, n, r, i, a, s, o) } function o2e(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !l2e(t, e) && (B1(t, e) && B1(e, t) && c2e(t, e) && (Fi(t.prev, t, e.prev) || Fi(t, e.prev, e)) || Tx(t, e) && Fi(t.prev, t, t.next) > 0 && Fi(e.prev, e, e.next) > 0) } function Fi(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function Tx(t, e) { return t.x === e.x && t.y === e.y } function Xae(t, e, n, r) { const i = PM(Fi(t, e, n)), a = PM(Fi(t, e, r)), s = PM(Fi(n, r, t)), o = PM(Fi(n, r, e)); return !!(i !== a && s !== o || i === 0 && AM(t, n, e) || a === 0 && AM(t, r, e) || s === 0 && AM(n, t, r) || o === 0 && AM(n, e, r)) } function AM(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function PM(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function l2e(t, e) { let n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Xae(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 } function B1(t, e) { return Fi(t.prev, t, t.next) < 0 ? Fi(t, e, t.next) >= 0 && Fi(t, t.prev, e) >= 0 : Fi(t, e, t.prev) < 0 || Fi(t, t.next, e) < 0 } function c2e(t, e) { let n = t, r = !1; const i = (t.x + e.x) / 2, a = (t.y + e.y) / 2; do n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== t); return r } function Yae(t, e) { const n = GL(t.i, t.x, t.y), r = GL(e.i, e.x, e.y), i = t.next, a = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r } function lW(t, e, n, r) { const i = GL(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function $1(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function GL(t, e, n) { return { i: t, x: e, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } function u2e(t, e, n, r) { let i = 0; for (let a = e, s = n - r; a < n; a += r)i += (t[s] - t[a]) * (t[a + 1] + t[s + 1]), s = a; return i } class d2e { static triangulate(e, n, r = 2) { return XAe(e, n, r) } } class Fc { static area(e) { const n = e.length; let r = 0; for (let i = n - 1, a = 0; a < n; i = a++)r += e[i].x * e[a].y - e[a].x * e[i].y; return r * .5 } static isClockWise(e) { return Fc.area(e) < 0 } static triangulateShape(e, n) { const r = [], i = [], a = []; cW(e), uW(r, e); let s = e.length; n.forEach(cW); for (let c = 0; c < n.length; c++)i.push(s), s += n[c].length, uW(r, n[c]); const o = d2e.triangulate(r, i); for (let c = 0; c < o.length; c += 3)a.push(o.slice(c, c + 3)); return a } } function cW(t) { const e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function uW(t, e) { for (let n = 0; n < e.length; n++)t.push(e[n].x), t.push(e[n].y) } class a2 extends Kn { constructor(e = new pg([new lt(.5, .5), new lt(-.5, .5), new lt(-.5, -.5), new lt(.5, -.5)]), n = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: n }, e = Array.isArray(e) ? e : [e]; const r = this, i = [], a = []; for (let o = 0, c = e.length; o < c; o++) { const u = e[o]; s(u) } this.setAttribute("position", new hn(i, 3)), this.setAttribute("uv", new hn(a, 2)), this.computeVertexNormals(); function s(o) { const c = [], u = n.curveSegments !== void 0 ? n.curveSegments : 12, d = n.steps !== void 0 ? n.steps : 1, f = n.depth !== void 0 ? n.depth : 1; let h = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0, m = n.bevelThickness !== void 0 ? n.bevelThickness : .2, g = n.bevelSize !== void 0 ? n.bevelSize : m - .1, x = n.bevelOffset !== void 0 ? n.bevelOffset : 0, v = n.bevelSegments !== void 0 ? n.bevelSegments : 3; const b = n.extrudePath, E = n.UVGenerator !== void 0 ? n.UVGenerator : f2e; let M, C = !1, N, A, j, O; b && (M = b.getSpacedPoints(d), C = !0, h = !1, N = b.computeFrenetFrames(d, !1), A = new pe, j = new pe, O = new pe), h || (v = 0, m = 0, g = 0, x = 0); const I = o.extractPoints(u); let D = I.shape; const F = I.holes; if (!Fc.isClockWise(D)) { D = D.reverse(); for (let xe = 0, _e = F.length; xe < _e; xe++) { const je = F[xe]; Fc.isClockWise(je) && (F[xe] = je.reverse()) } } function G(xe) { const je = 10000000000000001e-36; let ke = xe[0]; for (let Ze = 1; Ze <= xe.length; Ze++) { const Xe = Ze % xe.length, nt = xe[Xe], Tt = nt.x - ke.x, St = nt.y - ke.y, ee = Tt * Tt + St * St, ne = Math.max(Math.abs(nt.x), Math.abs(nt.y), Math.abs(ke.x), Math.abs(ke.y)), Re = je * ne * ne; if (ee <= Re) { xe.splice(Xe, 1), Ze--; continue } ke = nt } } G(D), F.forEach(G); const z = F.length, q = D; for (let xe = 0; xe < z; xe++) { const _e = F[xe]; D = D.concat(_e) } function Y(xe, _e, je) { return _e || console.error("THREE.ExtrudeGeometry: vec does not exist"), xe.clone().addScaledVector(_e, je) } const Z = D.length; function $(xe, _e, je) { let ke, Ze, Xe; const nt = xe.x - _e.x, Tt = xe.y - _e.y, St = je.x - xe.x, ee = je.y - xe.y, ne = nt * nt + Tt * Tt, Re = nt * ee - Tt * St; if (Math.abs(Re) > Number.EPSILON) { const Ue = Math.sqrt(ne), et = Math.sqrt(St * St + ee * ee), Ge = _e.x - Tt / Ue, Xt = _e.y + nt / Ue, yt = je.x - ee / et, Yt = je.y + St / et, en = ((yt - Ge) * ee - (Yt - Xt) * St) / (nt * ee - Tt * St); ke = Ge + nt * en - xe.x, Ze = Xt + Tt * en - xe.y; const pt = ke * ke + Ze * Ze; if (pt <= 2) return new lt(ke, Ze); Xe = Math.sqrt(pt / 2) } else { let Ue = !1; nt > Number.EPSILON ? St > Number.EPSILON && (Ue = !0) : nt < -Number.EPSILON ? St < -Number.EPSILON && (Ue = !0) : Math.sign(Tt) === Math.sign(ee) && (Ue = !0), Ue ? (ke = -Tt, Ze = nt, Xe = Math.sqrt(ne)) : (ke = nt, Ze = Tt, Xe = Math.sqrt(ne / 2)) } return new lt(ke / Xe, Ze / Xe) } const V = []; for (let xe = 0, _e = q.length, je = _e - 1, ke = xe + 1; xe < _e; xe++, je++, ke++)je === _e && (je = 0), ke === _e && (ke = 0), V[xe] = $(q[xe], q[je], q[ke]); const K = []; let X, Q = V.concat(); for (let xe = 0, _e = z; xe < _e; xe++) { const je = F[xe]; X = []; for (let ke = 0, Ze = je.length, Xe = Ze - 1, nt = ke + 1; ke < Ze; ke++, Xe++, nt++)Xe === Ze && (Xe = 0), nt === Ze && (nt = 0), X[ke] = $(je[ke], je[Xe], je[nt]); K.push(X), Q = Q.concat(X) } let re; if (v === 0) re = Fc.triangulateShape(q, F); else { const xe = [], _e = []; for (let je = 0; je < v; je++) { const ke = je / v, Ze = m * Math.cos(ke * Math.PI / 2), Xe = g * Math.sin(ke * Math.PI / 2) + x; for (let nt = 0, Tt = q.length; nt < Tt; nt++) { const St = Y(q[nt], V[nt], Xe); he(St.x, St.y, -Ze), ke === 0 && xe.push(St) } for (let nt = 0, Tt = z; nt < Tt; nt++) { const St = F[nt]; X = K[nt]; const ee = []; for (let ne = 0, Re = St.length; ne < Re; ne++) { const Ue = Y(St[ne], X[ne], Xe); he(Ue.x, Ue.y, -Ze), ke === 0 && ee.push(Ue) } ke === 0 && _e.push(ee) } } re = Fc.triangulateShape(xe, _e) } const ce = re.length, be = g + x; for (let xe = 0; xe < Z; xe++) { const _e = h ? Y(D[xe], Q[xe], be) : D[xe]; C ? (j.copy(N.normals[0]).multiplyScalar(_e.x), A.copy(N.binormals[0]).multiplyScalar(_e.y), O.copy(M[0]).add(j).add(A), he(O.x, O.y, O.z)) : he(_e.x, _e.y, 0) } for (let xe = 1; xe <= d; xe++)for (let _e = 0; _e < Z; _e++) { const je = h ? Y(D[_e], Q[_e], be) : D[_e]; C ? (j.copy(N.normals[xe]).multiplyScalar(je.x), A.copy(N.binormals[xe]).multiplyScalar(je.y), O.copy(M[xe]).add(j).add(A), he(O.x, O.y, O.z)) : he(je.x, je.y, f / d * xe) } for (let xe = v - 1; xe >= 0; xe--) { const _e = xe / v, je = m * Math.cos(_e * Math.PI / 2), ke = g * Math.sin(_e * Math.PI / 2) + x; for (let Ze = 0, Xe = q.length; Ze < Xe; Ze++) { const nt = Y(q[Ze], V[Ze], ke); he(nt.x, nt.y, f + je) } for (let Ze = 0, Xe = F.length; Ze < Xe; Ze++) { const nt = F[Ze]; X = K[Ze]; for (let Tt = 0, St = nt.length; Tt < St; Tt++) { const ee = Y(nt[Tt], X[Tt], ke); C ? he(ee.x, ee.y + M[d - 1].y, M[d - 1].x + je) : he(ee.x, ee.y, f + je) } } } de(), ae(); function de() { const xe = i.length / 3; if (h) { let _e = 0, je = Z * _e; for (let ke = 0; ke < ce; ke++) { const Ze = re[ke]; Ae(Ze[2] + je, Ze[1] + je, Ze[0] + je) } _e = d + v * 2, je = Z * _e; for (let ke = 0; ke < ce; ke++) { const Ze = re[ke]; Ae(Ze[0] + je, Ze[1] + je, Ze[2] + je) } } else { for (let _e = 0; _e < ce; _e++) { const je = re[_e]; Ae(je[2], je[1], je[0]) } for (let _e = 0; _e < ce; _e++) { const je = re[_e]; Ae(je[0] + Z * d, je[1] + Z * d, je[2] + Z * d) } } r.addGroup(xe, i.length / 3 - xe, 0) } function ae() { const xe = i.length / 3; let _e = 0; se(q, _e), _e += q.length; for (let je = 0, ke = F.length; je < ke; je++) { const Ze = F[je]; se(Ze, _e), _e += Ze.length } r.addGroup(xe, i.length / 3 - xe, 1) } function se(xe, _e) { let je = xe.length; for (; --je >= 0;) { const ke = je; let Ze = je - 1; Ze < 0 && (Ze = xe.length - 1); for (let Xe = 0, nt = d + v * 2; Xe < nt; Xe++) { const Tt = Z * Xe, St = Z * (Xe + 1), ee = _e + ke + Tt, ne = _e + Ze + Tt, Re = _e + Ze + St, Ue = _e + ke + St; Ce(ee, ne, Re, Ue) } } } function he(xe, _e, je) { c.push(xe), c.push(_e), c.push(je) } function Ae(xe, _e, je) { fe(xe), fe(_e), fe(je); const ke = i.length / 3, Ze = E.generateTopUV(r, i, ke - 3, ke - 2, ke - 1); oe(Ze[0]), oe(Ze[1]), oe(Ze[2]) } function Ce(xe, _e, je, ke) { fe(xe), fe(_e), fe(ke), fe(_e), fe(je), fe(ke); const Ze = i.length / 3, Xe = E.generateSideWallUV(r, i, Ze - 6, Ze - 3, Ze - 2, Ze - 1); oe(Xe[0]), oe(Xe[1]), oe(Xe[3]), oe(Xe[1]), oe(Xe[2]), oe(Xe[3]) } function fe(xe) { i.push(c[xe * 3 + 0]), i.push(c[xe * 3 + 1]), i.push(c[xe * 3 + 2]) } function oe(xe) { a.push(xe.x), a.push(xe.y) } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), n = this.parameters.shapes, r = this.parameters.options; return h2e(n, r, e) } static fromJSON(e, n) { const r = []; for (let a = 0, s = e.shapes.length; a < s; a++) { const o = n[e.shapes[a]]; r.push(o) } const i = e.options.extrudePath; return i !== void 0 && (e.options.extrudePath = new GC[i.type]().fromJSON(i)), new a2(r, e.options) } } const f2e = { generateTopUV: function (t, e, n, r, i) { const a = e[n * 3], s = e[n * 3 + 1], o = e[r * 3], c = e[r * 3 + 1], u = e[i * 3], d = e[i * 3 + 1]; return [new lt(a, s), new lt(o, c), new lt(u, d)] }, generateSideWallUV: function (t, e, n, r, i, a) { const s = e[n * 3], o = e[n * 3 + 1], c = e[n * 3 + 2], u = e[r * 3], d = e[r * 3 + 1], f = e[r * 3 + 2], h = e[i * 3], m = e[i * 3 + 1], g = e[i * 3 + 2], x = e[a * 3], v = e[a * 3 + 1], b = e[a * 3 + 2]; return Math.abs(o - d) < Math.abs(s - u) ? [new lt(s, 1 - c), new lt(u, 1 - f), new lt(h, 1 - g), new lt(x, 1 - b)] : [new lt(o, 1 - c), new lt(d, 1 - f), new lt(m, 1 - g), new lt(v, 1 - b)] } }; function h2e(t, e, n) { if (n.shapes = [], Array.isArray(t)) for (let r = 0, i = t.length; r < i; r++) { const a = t[r]; n.shapes.push(a.uuid) } else n.shapes.push(t.uuid); return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n } class f_ extends gp { constructor(e = 1, n = 0) { const r = (1 + Math.sqrt(5)) / 2, i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1], a = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(i, a, e, n), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: n } } static fromJSON(e) { return new f_(e.radius, e.detail) } } class s2 extends Kn { constructor(e = [new lt(0, -.5), new lt(.5, 0), new lt(0, .5)], n = 12, r = 0, i = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: n, phiStart: r, phiLength: i }, n = Math.floor(n), i = In(i, 0, Math.PI * 2); const a = [], s = [], o = [], c = [], u = [], d = 1 / n, f = new pe, h = new lt, m = new pe, g = new pe, x = new pe; let v = 0, b = 0; for (let E = 0; E <= e.length - 1; E++)switch (E) { case 0: v = e[E + 1].x - e[E].x, b = e[E + 1].y - e[E].y, m.x = b * 1, m.y = -v, m.z = b * 0, x.copy(m), m.normalize(), c.push(m.x, m.y, m.z); break; case e.length - 1: c.push(x.x, x.y, x.z); break; default: v = e[E + 1].x - e[E].x, b = e[E + 1].y - e[E].y, m.x = b * 1, m.y = -v, m.z = b * 0, g.copy(m), m.x += x.x, m.y += x.y, m.z += x.z, m.normalize(), c.push(m.x, m.y, m.z), x.copy(g) }for (let E = 0; E <= n; E++) { const M = r + E * d * i, C = Math.sin(M), N = Math.cos(M); for (let A = 0; A <= e.length - 1; A++) { f.x = e[A].x * C, f.y = e[A].y, f.z = e[A].x * N, s.push(f.x, f.y, f.z), h.x = E / n, h.y = A / (e.length - 1), o.push(h.x, h.y); const j = c[3 * A + 0] * C, O = c[3 * A + 1], I = c[3 * A + 0] * N; u.push(j, O, I) } } for (let E = 0; E < n; E++)for (let M = 0; M < e.length - 1; M++) { const C = M + E * e.length, N = C, A = C + e.length, j = C + e.length + 1, O = C + 1; a.push(N, A, O), a.push(j, O, A) } this.setIndex(a), this.setAttribute("position", new hn(s, 3)), this.setAttribute("uv", new hn(o, 2)), this.setAttribute("normal", new hn(u, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new s2(e.points, e.segments, e.phiStart, e.phiLength) } } class h_ extends gp { constructor(e = 1, n = 0) { const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(r, i, e, n), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: n } } static fromJSON(e) { return new h_(e.radius, e.detail) } } class vp extends Kn { constructor(e = 1, n = 1, r = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: n, widthSegments: r, heightSegments: i }; const a = e / 2, s = n / 2, o = Math.floor(r), c = Math.floor(i), u = o + 1, d = c + 1, f = e / o, h = n / c, m = [], g = [], x = [], v = []; for (let b = 0; b < d; b++) { const E = b * h - s; for (let M = 0; M < u; M++) { const C = M * f - a; g.push(C, -E, 0), x.push(0, 0, 1), v.push(M / o), v.push(1 - b / c) } } for (let b = 0; b < c; b++)for (let E = 0; E < o; E++) { const M = E + u * b, C = E + u * (b + 1), N = E + 1 + u * (b + 1), A = E + 1 + u * b; m.push(M, C, A), m.push(C, N, A) } this.setIndex(m), this.setAttribute("position", new hn(g, 3)), this.setAttribute("normal", new hn(x, 3)), this.setAttribute("uv", new hn(v, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new vp(e.width, e.height, e.widthSegments, e.heightSegments) } } class o2 extends Kn { constructor(e = .5, n = 1, r = 32, i = 1, a = 0, s = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: n, thetaSegments: r, phiSegments: i, thetaStart: a, thetaLength: s }, r = Math.max(3, r), i = Math.max(1, i); const o = [], c = [], u = [], d = []; let f = e; const h = (n - e) / i, m = new pe, g = new lt; for (let x = 0; x <= i; x++) { for (let v = 0; v <= r; v++) { const b = a + v / r * s; m.x = f * Math.cos(b), m.y = f * Math.sin(b), c.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / n + 1) / 2, g.y = (m.y / n + 1) / 2, d.push(g.x, g.y) } f += h } for (let x = 0; x < i; x++) { const v = x * (r + 1); for (let b = 0; b < r; b++) { const E = b + v, M = E, C = E + r + 1, N = E + r + 2, A = E + 1; o.push(M, C, A), o.push(C, N, A) } } this.setIndex(o), this.setAttribute("position", new hn(c, 3)), this.setAttribute("normal", new hn(u, 3)), this.setAttribute("uv", new hn(d, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new o2(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class l2 extends Kn { constructor(e = new pg([new lt(0, .5), new lt(-.5, -.5), new lt(.5, -.5)]), n = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: n }; const r = [], i = [], a = [], s = []; let o = 0, c = 0; if (Array.isArray(e) === !1) u(e); else for (let d = 0; d < e.length; d++)u(e[d]), this.addGroup(o, c, d), o += c, c = 0; this.setIndex(r), this.setAttribute("position", new hn(i, 3)), this.setAttribute("normal", new hn(a, 3)), this.setAttribute("uv", new hn(s, 2)); function u(d) { const f = i.length / 3, h = d.extractPoints(n); let m = h.shape; const g = h.holes; Fc.isClockWise(m) === !1 && (m = m.reverse()); for (let v = 0, b = g.length; v < b; v++) { const E = g[v]; Fc.isClockWise(E) === !0 && (g[v] = E.reverse()) } const x = Fc.triangulateShape(m, g); for (let v = 0, b = g.length; v < b; v++) { const E = g[v]; m = m.concat(E) } for (let v = 0, b = m.length; v < b; v++) { const E = m[v]; i.push(E.x, E.y, 0), a.push(0, 0, 1), s.push(E.x, E.y) } for (let v = 0, b = x.length; v < b; v++) { const E = x[v], M = E[0] + f, C = E[1] + f, N = E[2] + f; r.push(M, C, N), c += 3 } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), n = this.parameters.shapes; return p2e(n, e) } static fromJSON(e, n) { const r = []; for (let i = 0, a = e.shapes.length; i < a; i++) { const s = n[e.shapes[i]]; r.push(s) } return new l2(r, e.curveSegments) } } function p2e(t, e) { if (e.shapes = [], Array.isArray(t)) for (let n = 0, r = t.length; n < r; n++) { const i = t[n]; e.shapes.push(i.uuid) } else e.shapes.push(t.uuid); return e } class p_ extends Kn { constructor(e = 1, n = 32, r = 16, i = 0, a = Math.PI * 2, s = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: n, heightSegments: r, phiStart: i, phiLength: a, thetaStart: s, thetaLength: o }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r)); const c = Math.min(s + o, Math.PI); let u = 0; const d = [], f = new pe, h = new pe, m = [], g = [], x = [], v = []; for (let b = 0; b <= r; b++) { const E = [], M = b / r; let C = 0; b === 0 && s === 0 ? C = .5 / n : b === r && c === Math.PI && (C = -.5 / n); for (let N = 0; N <= n; N++) { const A = N / n; f.x = -e * Math.cos(i + A * a) * Math.sin(s + M * o), f.y = e * Math.cos(s + M * o), f.z = e * Math.sin(i + A * a) * Math.sin(s + M * o), g.push(f.x, f.y, f.z), h.copy(f).normalize(), x.push(h.x, h.y, h.z), v.push(A + C, 1 - M), E.push(u++) } d.push(E) } for (let b = 0; b < r; b++)for (let E = 0; E < n; E++) { const M = d[b][E + 1], C = d[b][E], N = d[b + 1][E], A = d[b + 1][E + 1]; (b !== 0 || s > 0) && m.push(M, C, A), (b !== r - 1 || c < Math.PI) && m.push(C, N, A) } this.setIndex(m), this.setAttribute("position", new hn(g, 3)), this.setAttribute("normal", new hn(x, 3)), this.setAttribute("uv", new hn(v, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new p_(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class c2 extends gp { constructor(e = 1, n = 0) { const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(r, i, e, n), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: n } } static fromJSON(e) { return new c2(e.radius, e.detail) } } class u2 extends Kn { constructor(e = 1, n = .4, r = 12, i = 48, a = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: n, radialSegments: r, tubularSegments: i, arc: a }, r = Math.floor(r), i = Math.floor(i); const s = [], o = [], c = [], u = [], d = new pe, f = new pe, h = new pe; for (let m = 0; m <= r; m++)for (let g = 0; g <= i; g++) { const x = g / i * a, v = m / r * Math.PI * 2; f.x = (e + n * Math.cos(v)) * Math.cos(x), f.y = (e + n * Math.cos(v)) * Math.sin(x), f.z = n * Math.sin(v), o.push(f.x, f.y, f.z), d.x = e * Math.cos(x), d.y = e * Math.sin(x), h.subVectors(f, d).normalize(), c.push(h.x, h.y, h.z), u.push(g / i), u.push(m / r) } for (let m = 1; m <= r; m++)for (let g = 1; g <= i; g++) { const x = (i + 1) * m + g - 1, v = (i + 1) * (m - 1) + g - 1, b = (i + 1) * (m - 1) + g, E = (i + 1) * m + g; s.push(x, v, E), s.push(v, b, E) } this.setIndex(s), this.setAttribute("position", new hn(o, 3)), this.setAttribute("normal", new hn(c, 3)), this.setAttribute("uv", new hn(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new u2(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class d2 extends Kn { constructor(e = 1, n = .4, r = 64, i = 8, a = 2, s = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: n, tubularSegments: r, radialSegments: i, p: a, q: s }, r = Math.floor(r), i = Math.floor(i); const o = [], c = [], u = [], d = [], f = new pe, h = new pe, m = new pe, g = new pe, x = new pe, v = new pe, b = new pe; for (let M = 0; M <= r; ++M) { const C = M / r * a * Math.PI * 2; E(C, a, s, e, m), E(C + .01, a, s, e, g), v.subVectors(g, m), b.addVectors(g, m), x.crossVectors(v, b), b.crossVectors(x, v), x.normalize(), b.normalize(); for (let N = 0; N <= i; ++N) { const A = N / i * Math.PI * 2, j = -n * Math.cos(A), O = n * Math.sin(A); f.x = m.x + (j * b.x + O * x.x), f.y = m.y + (j * b.y + O * x.y), f.z = m.z + (j * b.z + O * x.z), c.push(f.x, f.y, f.z), h.subVectors(f, m).normalize(), u.push(h.x, h.y, h.z), d.push(M / r), d.push(N / i) } } for (let M = 1; M <= r; M++)for (let C = 1; C <= i; C++) { const N = (i + 1) * (M - 1) + (C - 1), A = (i + 1) * M + (C - 1), j = (i + 1) * M + C, O = (i + 1) * (M - 1) + C; o.push(N, A, O), o.push(A, j, O) } this.setIndex(o), this.setAttribute("position", new hn(c, 3)), this.setAttribute("normal", new hn(u, 3)), this.setAttribute("uv", new hn(d, 2)); function E(M, C, N, A, j) { const O = Math.cos(M), I = Math.sin(M), D = N / C * M, F = Math.cos(D); j.x = A * (2 + F) * .5 * O, j.y = A * (2 + F) * I * .5, j.z = A * Math.sin(D) * .5 } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new d2(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class f2 extends Kn { constructor(e = new hB(new pe(-1, -1, 0), new pe(-1, 1, 0), new pe(1, 1, 0)), n = 64, r = 1, i = 8, a = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: n, radius: r, radialSegments: i, closed: a }; const s = e.computeFrenetFrames(n, a); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals; const o = new pe, c = new pe, u = new lt; let d = new pe; const f = [], h = [], m = [], g = []; x(), this.setIndex(g), this.setAttribute("position", new hn(f, 3)), this.setAttribute("normal", new hn(h, 3)), this.setAttribute("uv", new hn(m, 2)); function x() { for (let M = 0; M < n; M++)v(M); v(a === !1 ? n : 0), E(), b() } function v(M) { d = e.getPointAt(M / n, d); const C = s.normals[M], N = s.binormals[M]; for (let A = 0; A <= i; A++) { const j = A / i * Math.PI * 2, O = Math.sin(j), I = -Math.cos(j); c.x = I * C.x + O * N.x, c.y = I * C.y + O * N.y, c.z = I * C.z + O * N.z, c.normalize(), h.push(c.x, c.y, c.z), o.x = d.x + r * c.x, o.y = d.y + r * c.y, o.z = d.z + r * c.z, f.push(o.x, o.y, o.z) } } function b() { for (let M = 1; M <= n; M++)for (let C = 1; C <= i; C++) { const N = (i + 1) * (M - 1) + (C - 1), A = (i + 1) * M + (C - 1), j = (i + 1) * M + C, O = (i + 1) * (M - 1) + C; g.push(N, A, O), g.push(A, j, O) } } function E() { for (let M = 0; M <= n; M++)for (let C = 0; C <= i; C++)u.x = M / n, u.y = C / i, m.push(u.x, u.y) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new f2(new GC[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class Kae extends Kn { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const n = [], r = new Set, i = new pe, a = new pe; if (e.index !== null) { const s = e.attributes.position, o = e.index; let c = e.groups; c.length === 0 && (c = [{ start: 0, count: o.count, materialIndex: 0 }]); for (let u = 0, d = c.length; u < d; ++u) { const f = c[u], h = f.start, m = f.count; for (let g = h, x = h + m; g < x; g += 3)for (let v = 0; v < 3; v++) { const b = o.getX(g + v), E = o.getX(g + (v + 1) % 3); i.fromBufferAttribute(s, b), a.fromBufferAttribute(s, E), dW(i, a, r) === !0 && (n.push(i.x, i.y, i.z), n.push(a.x, a.y, a.z)) } } } else { const s = e.attributes.position; for (let o = 0, c = s.count / 3; o < c; o++)for (let u = 0; u < 3; u++) { const d = 3 * o + u, f = 3 * o + (u + 1) % 3; i.fromBufferAttribute(s, d), a.fromBufferAttribute(s, f), dW(i, a, r) === !0 && (n.push(i.x, i.y, i.z), n.push(a.x, a.y, a.z)) } } this.setAttribute("position", new hn(n, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function dW(t, e, n) { const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`; return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0) } var fW = Object.freeze({ __proto__: null, BoxGeometry: Wg, CapsuleGeometry: t2, CircleGeometry: n2, ConeGeometry: d_, CylinderGeometry: u_, DodecahedronGeometry: r2, EdgesGeometry: Bae, ExtrudeGeometry: a2, IcosahedronGeometry: f_, LatheGeometry: s2, OctahedronGeometry: h_, PlaneGeometry: vp, PolyhedronGeometry: gp, RingGeometry: o2, ShapeGeometry: l2, SphereGeometry: p_, TetrahedronGeometry: c2, TorusGeometry: u2, TorusKnotGeometry: d2, TubeGeometry: f2, WireframeGeometry: Kae }); class Zae extends Rs { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Kt(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class Qae extends Bo { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class mB extends Rs { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new Kt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = mp, this.normalScale = new lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ml, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class Jae extends mB { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new lt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return In(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (n) { this.ior = (1 + .4 * n) / (1 - .4 * n) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Kt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Kt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Kt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get dispersion() { return this._dispersion } set dispersion(e) { this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class ese extends Rs { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Kt(16777215), this.specular = new Kt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = mp, this.normalScale = new lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ml, this.combine = r_, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class tse extends Rs { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Kt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = mp, this.normalScale = new lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class nse extends Rs { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = mp, this.normalScale = new lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class rse extends Rs { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = mp, this.normalScale = new lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ml, this.combine = r_, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class gB extends Rs { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = fae, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class vB extends Rs { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } class ise extends Rs { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Kt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = mp, this.normalScale = new lt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class ase extends fo { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function Qm(t, e) { return !t || t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t) } function sse(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) } function ose(t) { function e(i, a) { return t[i] - t[a] } const n = t.length, r = new Array(n); for (let i = 0; i !== n; ++i)r[i] = i; return r.sort(e), r } function qL(t, e, n) { const r = t.length, i = new t.constructor(r); for (let a = 0, s = 0; s !== r; ++a) { const o = n[a] * e; for (let c = 0; c !== e; ++c)i[s++] = t[o + c] } return i } function yB(t, e, n, r) { let i = 1, a = t[0]; for (; a !== void 0 && a[r] === void 0;)a = t[i++]; if (a === void 0) return; let s = a[r]; if (s !== void 0) if (Array.isArray(s)) do s = a[r], s !== void 0 && (e.push(a.time), n.push(...s)), a = t[i++]; while (a !== void 0); else if (s.toArray !== void 0) do s = a[r], s !== void 0 && (e.push(a.time), s.toArray(n, n.length)), a = t[i++]; while (a !== void 0); else do s = a[r], s !== void 0 && (e.push(a.time), n.push(s)), a = t[i++]; while (a !== void 0) } function m2e(t, e, n, r, i = 30) { const a = t.clone(); a.name = e; const s = []; for (let c = 0; c < a.tracks.length; ++c) { const u = a.tracks[c], d = u.getValueSize(), f = [], h = []; for (let m = 0; m < u.times.length; ++m) { const g = u.times[m] * i; if (!(g < n || g >= r)) { f.push(u.times[m]); for (let x = 0; x < d; ++x)h.push(u.values[m * d + x]) } } f.length !== 0 && (u.times = Qm(f, u.times.constructor), u.values = Qm(h, u.values.constructor), s.push(u)) } a.tracks = s; let o = 1 / 0; for (let c = 0; c < a.tracks.length; ++c)o > a.tracks[c].times[0] && (o = a.tracks[c].times[0]); for (let c = 0; c < a.tracks.length; ++c)a.tracks[c].shift(-1 * o); return a.resetDuration(), a } function g2e(t, e = 0, n = t, r = 30) { r <= 0 && (r = 30); const i = n.tracks.length, a = e / r; for (let s = 0; s < i; ++s) { const o = n.tracks[s], c = o.ValueTypeName; if (c === "bool" || c === "string") continue; const u = t.tracks.find(function (b) { return b.name === o.name && b.ValueTypeName === c }); if (u === void 0) continue; let d = 0; const f = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3); let h = 0; const m = u.getValueSize(); u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = m / 3); const g = o.times.length - 1; let x; if (a <= o.times[0]) { const b = d, E = f - d; x = o.values.slice(b, E) } else if (a >= o.times[g]) { const b = g * f + d, E = b + f - d; x = o.values.slice(b, E) } else { const b = o.createInterpolant(), E = d, M = f - d; b.evaluate(a), x = b.resultBuffer.slice(E, M) } c === "quaternion" && new As().fromArray(x).normalize().conjugate().toArray(x); const v = u.times.length; for (let b = 0; b < v; ++b) { const E = b * m + h; if (c === "quaternion") As.multiplyQuaternionsFlat(u.values, E, x, 0, u.values, E); else { const M = m - h * 2; for (let C = 0; C < M; ++C)u.values[E + C] -= x[C] } } } return t.blendMode = ZU, t } class v2e { static convertArray(e, n) { return Qm(e, n) } static isTypedArray(e) { return sse(e) } static getKeyframeOrder(e) { return ose(e) } static sortedArray(e, n, r) { return qL(e, n, r) } static flattenJSON(e, n, r, i) { yB(e, n, r, i) } static subclip(e, n, r, i, a = 30) { return m2e(e, n, r, i, a) } static makeClipAdditive(e, n = 0, r = e, i = 30) { return g2e(e, n, r, i) } } class m_ { constructor(e, n, r, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new n.constructor(r), this.sampleValues = n, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const n = this.parameterPositions; let r = this._cachedIndex, i = n[r], a = n[r - 1]; e: { t: { let s; n: { r: if (!(e < i)) { for (let o = r + 2; ;) { if (i === void 0) { if (e < a) break r; return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1) } if (r === o) break; if (a = i, i = n[++r], e < i) break t } s = n.length; break n } if (!(e >= a)) { const o = n[1]; e < o && (r = 2, a = o); for (let c = r - 2; ;) { if (a === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === c) break; if (i = a, a = n[--r - 1], e >= a) break t } s = r, r = 0; break n } break e } for (; r < s;) { const o = r + s >>> 1; e < n[o] ? s = o : r = o + 1 } if (i = n[r], a = n[r - 1], a === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === void 0) return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1) } this._cachedIndex = r, this.intervalChanged_(r, a, i) } return this.interpolate_(r, a, e, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const n = this.resultBuffer, r = this.sampleValues, i = this.valueSize, a = e * i; for (let s = 0; s !== i; ++s)n[s] = r[a + s]; return n } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class lse extends m_ { constructor(e, n, r, i) { super(e, n, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ym, endingEnd: Ym } } intervalChanged_(e, n, r) { const i = this.parameterPositions; let a = e - 2, s = e + 1, o = i[a], c = i[s]; if (o === void 0) switch (this.getSettings_().endingStart) { case Km: a = e, o = 2 * n - r; break; case I1: a = i.length - 2, o = n + i[a] - i[a + 1]; break; default: a = e, o = r }if (c === void 0) switch (this.getSettings_().endingEnd) { case Km: s = e, c = 2 * r - n; break; case I1: s = 1, c = r + i[1] - i[0]; break; default: s = e - 1, c = n }const u = (r - n) * .5, d = this.valueSize; this._weightPrev = u / (n - o), this._weightNext = u / (c - r), this._offsetPrev = a * d, this._offsetNext = s * d } interpolate_(e, n, r, i) { const a = this.resultBuffer, s = this.sampleValues, o = this.valueSize, c = e * o, u = c - o, d = this._offsetPrev, f = this._offsetNext, h = this._weightPrev, m = this._weightNext, g = (r - n) / (i - n), x = g * g, v = x * g, b = -h * v + 2 * h * x - h * g, E = (1 + h) * v + (-1.5 - 2 * h) * x + (-.5 + h) * g + 1, M = (-1 - m) * v + (1.5 + m) * x + .5 * g, C = m * v - m * x; for (let N = 0; N !== o; ++N)a[N] = b * s[d + N] + E * s[u + N] + M * s[c + N] + C * s[f + N]; return a } } class xB extends m_ { constructor(e, n, r, i) { super(e, n, r, i) } interpolate_(e, n, r, i) { const a = this.resultBuffer, s = this.sampleValues, o = this.valueSize, c = e * o, u = c - o, d = (r - n) / (i - n), f = 1 - d; for (let h = 0; h !== o; ++h)a[h] = s[u + h] * f + s[c + h] * d; return a } } class cse extends m_ { constructor(e, n, r, i) { super(e, n, r, i) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Kl { constructor(e, n, r, i) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (n === void 0 || n.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Qm(n, this.TimeBufferType), this.values = Qm(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(e) { const n = e.constructor; let r; if (n.toJSON !== this.toJSON) r = n.toJSON(e); else { r = { name: e.name, times: Qm(e.times, Array), values: Qm(e.values, Array) }; const i = e.getInterpolation(); i !== e.DefaultInterpolation && (r.interpolation = i) } return r.type = e.ValueTypeName, r } InterpolantFactoryMethodDiscrete(e) { return new cse(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new xB(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new lse(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let n; switch (e) { case k1: n = this.InterpolantFactoryMethodDiscrete; break; case VC: n = this.InterpolantFactoryMethodLinear; break; case PT: n = this.InterpolantFactoryMethodSmooth; break }if (n === void 0) { const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(r); return console.warn("THREE.KeyframeTrack:", r), this } return this.createInterpolant = n, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return k1; case this.InterpolantFactoryMethodLinear: return VC; case this.InterpolantFactoryMethodSmooth: return PT } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const n = this.times; for (let r = 0, i = n.length; r !== i; ++r)n[r] += e } return this } scale(e) { if (e !== 1) { const n = this.times; for (let r = 0, i = n.length; r !== i; ++r)n[r] *= e } return this } trim(e, n) { const r = this.times, i = r.length; let a = 0, s = i - 1; for (; a !== i && r[a] < e;)++a; for (; s !== -1 && r[s] > n;)--s; if (++s, a !== 0 || s !== i) { a >= s && (s = Math.max(s, 1), a = s - 1); const o = this.getValueSize(); this.times = r.slice(a, s), this.values = this.values.slice(a * o, s * o) } return this } validate() { let e = !0; const n = this.getValueSize(); n - Math.floor(n) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const r = this.times, i = this.values, a = r.length; a === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let o = 0; o !== a; o++) { const c = r[o]; if (typeof c == "number" && isNaN(c)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), e = !1; break } if (s !== null && s > c) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, s), e = !1; break } s = c } if (i !== void 0 && sse(i)) for (let o = 0, c = i.length; o !== c; ++o) { const u = i[o]; if (isNaN(u)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, u), e = !1; break } } return e } optimize() { const e = this.times.slice(), n = this.values.slice(), r = this.getValueSize(), i = this.getInterpolation() === PT, a = e.length - 1; let s = 1; for (let o = 1; o < a; ++o) { let c = !1; const u = e[o], d = e[o + 1]; if (u !== d && (o !== 1 || u !== e[0])) if (i) c = !0; else { const f = o * r, h = f - r, m = f + r; for (let g = 0; g !== r; ++g) { const x = n[f + g]; if (x !== n[h + g] || x !== n[m + g]) { c = !0; break } } } if (c) { if (o !== s) { e[s] = e[o]; const f = o * r, h = s * r; for (let m = 0; m !== r; ++m)n[h + m] = n[f + m] } ++s } } if (a > 0) { e[s] = e[a]; for (let o = a * r, c = s * r, u = 0; u !== r; ++u)n[c + u] = n[o + u]; ++s } return s !== e.length ? (this.times = e.slice(0, s), this.values = n.slice(0, s * r)) : (this.times = e, this.values = n), this } clone() { const e = this.times.slice(), n = this.values.slice(), r = this.constructor, i = new r(this.name, e, n); return i.createInterpolant = this.createInterpolant, i } } Kl.prototype.ValueTypeName = ""; Kl.prototype.TimeBufferType = Float32Array; Kl.prototype.ValueBufferType = Float32Array; Kl.prototype.DefaultInterpolation = VC; class Gg extends Kl { constructor(e, n, r) { super(e, n, r) } } Gg.prototype.ValueTypeName = "bool"; Gg.prototype.ValueBufferType = Array; Gg.prototype.DefaultInterpolation = k1; Gg.prototype.InterpolantFactoryMethodLinear = void 0; Gg.prototype.InterpolantFactoryMethodSmooth = void 0; class bB extends Kl { constructor(e, n, r, i) { super(e, n, r, i) } } bB.prototype.ValueTypeName = "color"; class z1 extends Kl { constructor(e, n, r, i) { super(e, n, r, i) } } z1.prototype.ValueTypeName = "number"; class use extends m_ { constructor(e, n, r, i) { super(e, n, r, i) } interpolate_(e, n, r, i) { const a = this.resultBuffer, s = this.sampleValues, o = this.valueSize, c = (r - n) / (i - n); let u = e * o; for (let d = u + o; u !== d; u += 4)As.slerpFlat(a, 0, s, u - o, s, u, c); return a } } class g_ extends Kl { constructor(e, n, r, i) { super(e, n, r, i) } InterpolantFactoryMethodLinear(e) { return new use(this.times, this.values, this.getValueSize(), e) } } g_.prototype.ValueTypeName = "quaternion"; g_.prototype.InterpolantFactoryMethodSmooth = void 0; class qg extends Kl { constructor(e, n, r) { super(e, n, r) } } qg.prototype.ValueTypeName = "string"; qg.prototype.ValueBufferType = Array; qg.prototype.DefaultInterpolation = k1; qg.prototype.InterpolantFactoryMethodLinear = void 0; qg.prototype.InterpolantFactoryMethodSmooth = void 0; class V1 extends Kl { constructor(e, n, r, i) { super(e, n, r, i) } } V1.prototype.ValueTypeName = "vector"; class H1 { constructor(e = "", n = -1, r = [], i = qA) { this.name = e, this.tracks = r, this.duration = n, this.blendMode = i, this.uuid = fl(), this.userData = {}, this.duration < 0 && this.resetDuration() } static parse(e) { const n = [], r = e.tracks, i = 1 / (e.fps || 1); for (let s = 0, o = r.length; s !== o; ++s)n.push(x2e(r[s]).scale(i)); const a = new this(e.name, e.duration, n, e.blendMode); return a.uuid = e.uuid, a.userData = JSON.parse(e.userData || "{}"), a } static toJSON(e) { const n = [], r = e.tracks, i = { name: e.name, duration: e.duration, tracks: n, uuid: e.uuid, blendMode: e.blendMode, userData: JSON.stringify(e.userData) }; for (let a = 0, s = r.length; a !== s; ++a)n.push(Kl.toJSON(r[a])); return i } static CreateFromMorphTargetSequence(e, n, r, i) { const a = n.length, s = []; for (let o = 0; o < a; o++) { let c = [], u = []; c.push((o + a - 1) % a, o, (o + 1) % a), u.push(0, 1, 0); const d = ose(c); c = qL(c, 1, d), u = qL(u, 1, d), !i && c[0] === 0 && (c.push(a), u.push(u[0])), s.push(new z1(".morphTargetInfluences[" + n[o].name + "]", c, u).scale(1 / r)) } return new this(e, -1, s) } static findByName(e, n) { let r = e; if (!Array.isArray(e)) { const i = e; r = i.geometry && i.geometry.animations || i.animations } for (let i = 0; i < r.length; i++)if (r[i].name === n) return r[i]; return null } static CreateClipsFromMorphTargetSequences(e, n, r) { const i = {}, a = /^([\w-]*?)([\d]+)$/; for (let o = 0, c = e.length; o < c; o++) { const u = e[o], d = u.name.match(a); if (d && d.length > 1) { const f = d[1]; let h = i[f]; h || (i[f] = h = []), h.push(u) } } const s = []; for (const o in i) s.push(this.CreateFromMorphTargetSequence(o, i[o], n, r)); return s } static parseAnimation(e, n) { if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const r = function (f, h, m, g, x) { if (m.length !== 0) { const v = [], b = []; yB(m, v, b, g), v.length !== 0 && x.push(new f(h, v, b)) } }, i = [], a = e.name || "default", s = e.fps || 30, o = e.blendMode; let c = e.length || -1; const u = e.hierarchy || []; for (let f = 0; f < u.length; f++) { const h = u[f].keys; if (!(!h || h.length === 0)) if (h[0].morphTargets) { const m = {}; let g; for (g = 0; g < h.length; g++)if (h[g].morphTargets) for (let x = 0; x < h[g].morphTargets.length; x++)m[h[g].morphTargets[x]] = -1; for (const x in m) { const v = [], b = []; for (let E = 0; E !== h[g].morphTargets.length; ++E) { const M = h[g]; v.push(M.time), b.push(M.morphTarget === x ? 1 : 0) } i.push(new z1(".morphTargetInfluence[" + x + "]", v, b)) } c = m.length * s } else { const m = ".bones[" + n[f].name + "]"; r(V1, m + ".position", h, "pos", i), r(g_, m + ".quaternion", h, "rot", i), r(V1, m + ".scale", h, "scl", i) } } return i.length === 0 ? null : new this(a, c, i, o) } resetDuration() { const e = this.tracks; let n = 0; for (let r = 0, i = e.length; r !== i; ++r) { const a = this.tracks[r]; n = Math.max(n, a.times[a.times.length - 1]) } return this.duration = n, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let n = 0; n < this.tracks.length; n++)e = e && this.tracks[n].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let r = 0; r < this.tracks.length; r++)e.push(this.tracks[r].clone()); const n = new this.constructor(this.name, this.duration, e, this.blendMode); return n.userData = JSON.parse(JSON.stringify(this.userData)), n } toJSON() { return this.constructor.toJSON(this) } } function y2e(t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return z1; case "vector": case "vector2": case "vector3": case "vector4": return V1; case "color": return bB; case "quaternion": return g_; case "bool": case "boolean": return Gg; case "string": return qg }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) } function x2e(t) { if (t.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = y2e(t.type); if (t.times === void 0) { const n = [], r = []; yB(t.keys, n, r, "value"), t.times = n, t.values = r } return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } const wu = { enabled: !1, files: {}, add: function (t, e) { this.enabled !== !1 && (this.files[t] = e) }, get: function (t) { if (this.enabled !== !1) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; class h2 { constructor(e, n, r) { const i = this; let a = !1, s = 0, o = 0, c; const u = []; this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = r, this.abortController = new AbortController, this.itemStart = function (d) { o++, a === !1 && i.onStart !== void 0 && i.onStart(d, s, o), a = !0 }, this.itemEnd = function (d) { s++, i.onProgress !== void 0 && i.onProgress(d, s, o), s === o && (a = !1, i.onLoad !== void 0 && i.onLoad()) }, this.itemError = function (d) { i.onError !== void 0 && i.onError(d) }, this.resolveURL = function (d) { return c ? c(d) : d }, this.setURLModifier = function (d) { return c = d, this }, this.addHandler = function (d, f) { return u.push(d, f), this }, this.removeHandler = function (d) { const f = u.indexOf(d); return f !== -1 && u.splice(f, 2), this }, this.getHandler = function (d) { for (let f = 0, h = u.length; f < h; f += 2) { const m = u[f], g = u[f + 1]; if (m.global && (m.lastIndex = 0), m.test(d)) return g } return null }, this.abort = function () { return this.abortController.abort(), this.abortController = new AbortController, this } } } const dse = new h2; class ho { constructor(e) { this.manager = e !== void 0 ? e : dse, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, n) { const r = this; return new Promise(function (i, a) { r.load(e, i, n, a) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } abort() { return this } } ho.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const Vd = {}; class b2e extends Error { constructor(e, n) { super(e), this.response = n } } class hl extends ho { constructor(e) { super(e), this.mimeType = "", this.responseType = "", this._abortController = new AbortController } load(e, n, r, i) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const a = wu.get(`file:${e}`); if (a !== void 0) return this.manager.itemStart(e), setTimeout(() => { n && n(a), this.manager.itemEnd(e) }, 0), a; if (Vd[e] !== void 0) { Vd[e].push({ onLoad: n, onProgress: r, onError: i }); return } Vd[e] = [], Vd[e].push({ onLoad: n, onProgress: r, onError: i }); const s = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin", signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal }), o = this.mimeType, c = this.responseType; fetch(s).then(u => { if (u.status === 200 || u.status === 0) { if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u; const d = Vd[e], f = u.body.getReader(), h = u.headers.get("X-File-Size") || u.headers.get("Content-Length"), m = h ? parseInt(h) : 0, g = m !== 0; let x = 0; const v = new ReadableStream({ start(b) { E(); function E() { f.read().then(({ done: M, value: C }) => { if (M) b.close(); else { x += C.byteLength; const N = new ProgressEvent("progress", { lengthComputable: g, loaded: x, total: m }); for (let A = 0, j = d.length; A < j; A++) { const O = d[A]; O.onProgress && O.onProgress(N) } b.enqueue(C), E() } }, M => { b.error(M) }) } } }); return new Response(v) } else throw new b2e(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u) }).then(u => { switch (c) { case "arraybuffer": return u.arrayBuffer(); case "blob": return u.blob(); case "document": return u.text().then(d => new DOMParser().parseFromString(d, o)); case "json": return u.json(); default: if (o === "") return u.text(); { const f = /charset="?([^;"\s]*)"?/i.exec(o), h = f && f[1] ? f[1].toLowerCase() : void 0, m = new TextDecoder(h); return u.arrayBuffer().then(g => m.decode(g)) } } }).then(u => { wu.add(`file:${e}`, u); const d = Vd[e]; delete Vd[e]; for (let f = 0, h = d.length; f < h; f++) { const m = d[f]; m.onLoad && m.onLoad(u) } }).catch(u => { const d = Vd[e]; if (d === void 0) throw this.manager.itemError(e), u; delete Vd[e]; for (let f = 0, h = d.length; f < h; f++) { const m = d[f]; m.onError && m.onError(u) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } abort() { return this._abortController.abort(), this._abortController = new AbortController, this } } class w2e extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = this, s = new hl(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (o) { try { n(a.parse(JSON.parse(o))) } catch (c) { i ? i(c) : console.error(c), a.manager.itemError(e) } }, r, i) } parse(e) { const n = []; for (let r = 0; r < e.length; r++) { const i = H1.parse(e[r]); n.push(i) } return n } } class S2e extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = this, s = [], o = new e2, c = new hl(this.manager); c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(a.withCredentials); let u = 0; function d(f) { c.load(e[f], function (h) { const m = a.parse(h, !0); s[f] = { width: m.width, height: m.height, format: m.format, mipmaps: m.mipmaps }, u += 1, u === 6 && (m.mipmapCount === 1 && (o.minFilter = Xr), o.image = s, o.format = m.format, o.needsUpdate = !0, n && n(o)) }, r, i) } if (Array.isArray(e)) for (let f = 0, h = e.length; f < h; ++f)d(f); else c.load(e, function (f) { const h = a.parse(f, !0); if (h.isCubemap) { const m = h.mipmaps.length / h.mipmapCount; for (let g = 0; g < m; g++) { s[g] = { mipmaps: [] }; for (let x = 0; x < h.mipmapCount; x++)s[g].mipmaps.push(h.mipmaps[g * h.mipmapCount + x]), s[g].format = h.format, s[g].width = h.width, s[g].height = h.height } o.image = s } else o.image.width = h.width, o.image.height = h.height, o.mipmaps = h.mipmaps; h.mipmapCount === 1 && (o.minFilter = Xr), o.format = h.format, o.needsUpdate = !0, n && n(o) }, r, i); return o } } const vy = new WeakMap; class W1 extends ho { constructor(e) { super(e) } load(e, n, r, i) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const a = this, s = wu.get(`image:${e}`); if (s !== void 0) { if (s.complete === !0) a.manager.itemStart(e), setTimeout(function () { n && n(s), a.manager.itemEnd(e) }, 0); else { let f = vy.get(s); f === void 0 && (f = [], vy.set(s, f)), f.push({ onLoad: n, onError: i }) } return s } const o = L1("img"); function c() { d(), n && n(this); const f = vy.get(this) || []; for (let h = 0; h < f.length; h++) { const m = f[h]; m.onLoad && m.onLoad(this) } vy.delete(this), a.manager.itemEnd(e) } function u(f) { d(), i && i(f), wu.remove(`image:${e}`); const h = vy.get(this) || []; for (let m = 0; m < h.length; m++) { const g = h[m]; g.onError && g.onError(f) } vy.delete(this), a.manager.itemError(e), a.manager.itemEnd(e) } function d() { o.removeEventListener("load", c, !1), o.removeEventListener("error", u, !1) } return o.addEventListener("load", c, !1), o.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), wu.add(`image:${e}`, o), a.manager.itemStart(e), o.src = e, o } } class fse extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = new l_; a.colorSpace = qs; const s = new W1(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let o = 0; function c(u) { s.load(e[u], function (d) { a.images[u] = d, o++, o === 6 && (a.needsUpdate = !0, n && n(a)) }, void 0, i) } for (let u = 0; u < e.length; ++u)c(u); return a } } class wB extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = this, s = new Uc, o = new hl(this.manager); return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(a.withCredentials), o.load(e, function (c) { let u; try { u = a.parse(c) } catch (d) { if (i !== void 0) i(d); else { console.error(d); return } } u.image !== void 0 ? s.image = u.image : u.data !== void 0 && (s.image.width = u.width, s.image.height = u.height, s.image.data = u.data), s.wrapS = u.wrapS !== void 0 ? u.wrapS : va, s.wrapT = u.wrapT !== void 0 ? u.wrapT : va, s.magFilter = u.magFilter !== void 0 ? u.magFilter : Xr, s.minFilter = u.minFilter !== void 0 ? u.minFilter : Xr, s.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.colorSpace !== void 0 && (s.colorSpace = u.colorSpace), u.flipY !== void 0 && (s.flipY = u.flipY), u.format !== void 0 && (s.format = u.format), u.type !== void 0 && (s.type = u.type), u.mipmaps !== void 0 && (s.mipmaps = u.mipmaps, s.minFilter = bu), u.mipmapCount === 1 && (s.minFilter = Xr), u.generateMipmaps !== void 0 && (s.generateMipmaps = u.generateMipmaps), s.needsUpdate = !0, n && n(s, u) }, r, i), s } } class _2e extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = new ti, s = new W1(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function (o) { a.image = o, a.needsUpdate = !0, n !== void 0 && n(a) }, r, i), a } } class yp extends kr { constructor(e, n = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Kt(e), this.intensity = n } dispose() { } copy(e, n) { return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const n = super.toJSON(e); return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n } } class hse extends yp { constructor(e, n, r) { super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(kr.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Kt(n) } copy(e, n) { return super.copy(e, n), this.groundColor.copy(e.groundColor), this } } const kR = new Fn, hW = new pe, pW = new pe; class SB { constructor(e) { this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new lt(512, 512), this.mapType = lo, this.map = null, this.mapPass = null, this.matrix = new Fn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new N0, this._frameExtents = new lt(1, 1), this._viewportCount = 1, this._viewports = [new jr(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const n = this.camera, r = this.matrix; hW.setFromMatrixPosition(e.matrixWorld), n.position.copy(hW), pW.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(pW), n.updateMatrixWorld(), kR.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(kR, n.coordinateSystem, n.reversedDepth), n.reversedDepth ? r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(kR) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class E2e extends SB { constructor() { super(new ra(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1 } updateMatrices(e) { const n = this.camera, r = _x * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height * this.aspect, a = e.distance || n.far; (r !== n.fov || i !== n.aspect || a !== n.far) && (n.fov = r, n.aspect = i, n.far = a, n.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class pse extends yp { constructor(e, n, r = 0, i = Math.PI / 3, a = 0, s = 2) { super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(kr.DEFAULT_UP), this.updateMatrix(), this.target = new kr, this.distance = r, this.angle = i, this.penumbra = a, this.decay = s, this.map = null, this.shadow = new E2e } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, n) { return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const mW = new Fn, lw = new pe, IR = new pe; class M2e extends SB { constructor() { super(new ra(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new lt(4, 2), this._viewportCount = 6, this._viewports = [new jr(2, 1, 1, 1), new jr(0, 1, 1, 1), new jr(3, 1, 1, 1), new jr(1, 1, 1, 1), new jr(3, 0, 1, 1), new jr(1, 0, 1, 1)], this._cubeDirections = [new pe(1, 0, 0), new pe(-1, 0, 0), new pe(0, 0, 1), new pe(0, 0, -1), new pe(0, 1, 0), new pe(0, -1, 0)], this._cubeUps = [new pe(0, 1, 0), new pe(0, 1, 0), new pe(0, 1, 0), new pe(0, 1, 0), new pe(0, 0, 1), new pe(0, 0, -1)] } updateMatrices(e, n = 0) { const r = this.camera, i = this.matrix, a = e.distance || r.far; a !== r.far && (r.far = a, r.updateProjectionMatrix()), lw.setFromMatrixPosition(e.matrixWorld), r.position.copy(lw), IR.copy(r.position), IR.add(this._cubeDirections[n]), r.up.copy(this._cubeUps[n]), r.lookAt(IR), r.updateMatrixWorld(), i.makeTranslation(-lw.x, -lw.y, -lw.z), mW.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(mW, r.coordinateSystem, r.reversedDepth) } } class mse extends yp { constructor(e, n, r = 0, i = 2) { super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new M2e } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, n) { return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class of extends o_ { constructor(e = -1, n = 1, r = 1, i = -1, a = .1, s = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = r, this.bottom = i, this.near = a, this.far = s, this.updateProjectionMatrix() } copy(e, n) { return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, n, r, i, a, s) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = i, this.view.width = a, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let a = r - e, s = r + e, o = i + n, c = i - n; if (this.view !== null && this.view.enabled) { const u = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom; a += u * this.view.offsetX, s = a + u * this.view.width, o -= d * this.view.offsetY, c = o - d * this.view.height } this.projectionMatrix.makeOrthographic(a, s, o, c, this.near, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const n = super.toJSON(e); return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n } } class T2e extends SB { constructor() { super(new of(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class gse extends yp { constructor(e, n) { super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(kr.DEFAULT_UP), this.updateMatrix(), this.target = new kr, this.shadow = new T2e } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class vse extends yp { constructor(e, n) { super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight" } } class yse extends yp { constructor(e, n, r = 10, i = 10) { super(e, n), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const n = super.toJSON(e); return n.object.width = this.width, n.object.height = this.height, n } } class xse { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new pe) } set(e) { for (let n = 0; n < 9; n++)this.coefficients[n].copy(e[n]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, n) { const r = e.x, i = e.y, a = e.z, s = this.coefficients; return n.copy(s[0]).multiplyScalar(.282095), n.addScaledVector(s[1], .488603 * i), n.addScaledVector(s[2], .488603 * a), n.addScaledVector(s[3], .488603 * r), n.addScaledVector(s[4], 1.092548 * (r * i)), n.addScaledVector(s[5], 1.092548 * (i * a)), n.addScaledVector(s[6], .315392 * (3 * a * a - 1)), n.addScaledVector(s[7], 1.092548 * (r * a)), n.addScaledVector(s[8], .546274 * (r * r - i * i)), n } getIrradianceAt(e, n) { const r = e.x, i = e.y, a = e.z, s = this.coefficients; return n.copy(s[0]).multiplyScalar(.886227), n.addScaledVector(s[1], 2 * .511664 * i), n.addScaledVector(s[2], 2 * .511664 * a), n.addScaledVector(s[3], 2 * .511664 * r), n.addScaledVector(s[4], 2 * .429043 * r * i), n.addScaledVector(s[5], 2 * .429043 * i * a), n.addScaledVector(s[6], .743125 * a * a - .247708), n.addScaledVector(s[7], 2 * .429043 * r * a), n.addScaledVector(s[8], .429043 * (r * r - i * i)), n } add(e) { for (let n = 0; n < 9; n++)this.coefficients[n].add(e.coefficients[n]); return this } addScaledSH(e, n) { for (let r = 0; r < 9; r++)this.coefficients[r].addScaledVector(e.coefficients[r], n); return this } scale(e) { for (let n = 0; n < 9; n++)this.coefficients[n].multiplyScalar(e); return this } lerp(e, n) { for (let r = 0; r < 9; r++)this.coefficients[r].lerp(e.coefficients[r], n); return this } equals(e) { for (let n = 0; n < 9; n++)if (!this.coefficients[n].equals(e.coefficients[n])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, n = 0) { const r = this.coefficients; for (let i = 0; i < 9; i++)r[i].fromArray(e, n + i * 3); return this } toArray(e = [], n = 0) { const r = this.coefficients; for (let i = 0; i < 9; i++)r[i].toArray(e, n + i * 3); return e } static getBasisAt(e, n) { const r = e.x, i = e.y, a = e.z; n[0] = .282095, n[1] = .488603 * i, n[2] = .488603 * a, n[3] = .488603 * r, n[4] = 1.092548 * r * i, n[5] = 1.092548 * i * a, n[6] = .315392 * (3 * a * a - 1), n[7] = 1.092548 * r * a, n[8] = .546274 * (r * r - i * i) } } class bse extends yp { constructor(e = new xse, n = 1) { super(void 0, n), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const n = super.toJSON(e); return n.object.sh = this.sh.toArray(), n } } class p2 extends ho { constructor(e) { super(e), this.textures = {} } load(e, n, r, i) { const a = this, s = new hl(a.manager); s.setPath(a.path), s.setRequestHeader(a.requestHeader), s.setWithCredentials(a.withCredentials), s.load(e, function (o) { try { n(a.parse(JSON.parse(o))) } catch (c) { i ? i(c) : console.error(c), a.manager.itemError(e) } }, r, i) } parse(e) { const n = this.textures; function r(a) { return n[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a), n[a] } const i = this.createMaterialFromType(e.type); if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Kt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const a in e.uniforms) { const s = e.uniforms[a]; switch (i.uniforms[a] = {}, s.type) { case "t": i.uniforms[a].value = r(s.value); break; case "c": i.uniforms[a].value = new Kt().setHex(s.value); break; case "v2": i.uniforms[a].value = new lt().fromArray(s.value); break; case "v3": i.uniforms[a].value = new pe().fromArray(s.value); break; case "v4": i.uniforms[a].value = new jr().fromArray(s.value); break; case "m3": i.uniforms[a].value = new Qn().fromArray(s.value); break; case "m4": i.uniforms[a].value = new Fn().fromArray(s.value); break; default: i.uniforms[a].value = s.value } } if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0) for (const a in e.extensions) i.extensions[a] = e.extensions[a]; if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) { let a = e.normalScale; Array.isArray(a) === !1 && (a = [a, a]), i.normalScale = new lt().fromArray(a) } return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new lt().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i } setTextures(e) { return this.textures = e, this } createMaterialFromType(e) { return p2.createMaterialFromType(e) } static createMaterialFromType(e) { const n = { ShadowMaterial: Zae, SpriteMaterial: iB, RawShaderMaterial: Qae, ShaderMaterial: Bo, PointsMaterial: sB, MeshPhysicalMaterial: Jae, MeshStandardMaterial: mB, MeshPhongMaterial: ese, MeshToonMaterial: tse, MeshNormalMaterial: nse, MeshLambertMaterial: rse, MeshDepthMaterial: gB, MeshDistanceMaterial: vB, MeshBasicMaterial: _f, MeshMatcapMaterial: ise, LineDashedMaterial: ase, LineBasicMaterial: fo, Material: Rs }; return new n[e] } } class XL { static extractUrlBase(e) { const n = e.lastIndexOf("/"); return n === -1 ? "./" : e.slice(0, n + 1) } static resolveURL(e, n) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(n) && /^\//.test(e) && (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : n + e) } } class wse extends Kn { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class Sse extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = this, s = new hl(a.manager); s.setPath(a.path), s.setRequestHeader(a.requestHeader), s.setWithCredentials(a.withCredentials), s.load(e, function (o) { try { n(a.parse(JSON.parse(o))) } catch (c) { i ? i(c) : console.error(c), a.manager.itemError(e) } }, r, i) } parse(e) { const n = {}, r = {}; function i(m, g) { if (n[g] !== void 0) return n[g]; const v = m.interleavedBuffers[g], b = a(m, v.buffer), E = Uy(v.type, b), M = new QA(E, v.stride); return M.uuid = v.uuid, n[g] = M, M } function a(m, g) { if (r[g] !== void 0) return r[g]; const v = m.arrayBuffers[g], b = new Uint32Array(v).buffer; return r[g] = b, b } const s = e.isInstancedBufferGeometry ? new wse : new Kn, o = e.data.index; if (o !== void 0) { const m = Uy(o.type, o.array); s.setIndex(new Lr(m, 1)) } const c = e.data.attributes; for (const m in c) { const g = c[m]; let x; if (g.isInterleavedBufferAttribute) { const v = i(e.data, g.data); x = new Mg(v, g.itemSize, g.offset, g.normalized) } else { const v = Uy(g.type, g.array), b = g.isInstancedBufferAttribute ? Mx : Lr; x = new b(v, g.itemSize, g.normalized) } g.name !== void 0 && (x.name = g.name), g.usage !== void 0 && x.setUsage(g.usage), s.setAttribute(m, x) } const u = e.data.morphAttributes; if (u) for (const m in u) { const g = u[m], x = []; for (let v = 0, b = g.length; v < b; v++) { const E = g[v]; let M; if (E.isInterleavedBufferAttribute) { const C = i(e.data, E.data); M = new Mg(C, E.itemSize, E.offset, E.normalized) } else { const C = Uy(E.type, E.array); M = new Lr(C, E.itemSize, E.normalized) } E.name !== void 0 && (M.name = E.name), x.push(M) } s.morphAttributes[m] = x } e.data.morphTargetsRelative && (s.morphTargetsRelative = !0); const f = e.data.groups || e.data.drawcalls || e.data.offsets; if (f !== void 0) for (let m = 0, g = f.length; m !== g; ++m) { const x = f[m]; s.addGroup(x.start, x.count, x.materialIndex) } const h = e.data.boundingSphere; return h !== void 0 && (s.boundingSphere = new us().fromJSON(h)), e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s } } class C2e extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = this, s = this.path === "" ? XL.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || s; const o = new hl(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (c) { let u = null; try { u = JSON.parse(c) } catch (f) { i !== void 0 && i(f), console.error("THREE:ObjectLoader: Can't parse " + e + ".", f.message); return } const d = u.metadata; if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") { i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } a.parse(u, n) }, r, i) } async loadAsync(e, n) { const r = this, i = this.path === "" ? XL.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || i; const a = new hl(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials); const s = await a.loadAsync(e, n), o = JSON.parse(s), c = o.metadata; if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await r.parseAsync(o) } parse(e, n) { const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), a = this.parseGeometries(e.geometries, i), s = this.parseImages(e.images, function () { n !== void 0 && n(u) }), o = this.parseTextures(e.textures, s), c = this.parseMaterials(e.materials, o), u = this.parseObject(e.object, a, c, o, r), d = this.parseSkeletons(e.skeletons, u); if (this.bindSkeletons(u, d), this.bindLightTargets(u), n !== void 0) { let f = !1; for (const h in s) if (s[h].data instanceof HTMLImageElement) { f = !0; break } f === !1 && n(u) } return u } async parseAsync(e) { const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), a = await this.parseImagesAsync(e.images), s = this.parseTextures(e.textures, a), o = this.parseMaterials(e.materials, s), c = this.parseObject(e.object, i, o, s, n), u = this.parseSkeletons(e.skeletons, c); return this.bindSkeletons(c, u), this.bindLightTargets(c), c } parseShapes(e) { const n = {}; if (e !== void 0) for (let r = 0, i = e.length; r < i; r++) { const a = new pg().fromJSON(e[r]); n[a.uuid] = a } return n } parseSkeletons(e, n) { const r = {}, i = {}; if (n.traverse(function (a) { a.isBone && (i[a.uuid] = a) }), e !== void 0) for (let a = 0, s = e.length; a < s; a++) { const o = new kae().fromJSON(e[a], i); r[o.uuid] = o } return r } parseGeometries(e, n) { const r = {}; if (e !== void 0) { const i = new Sse; for (let a = 0, s = e.length; a < s; a++) { let o; const c = e[a]; switch (c.type) { case "BufferGeometry": case "InstancedBufferGeometry": o = i.parse(c); break; default: c.type in fW ? o = fW[c.type].fromJSON(c, n) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`) }o.uuid = c.uuid, c.name !== void 0 && (o.name = c.name), c.userData !== void 0 && (o.userData = c.userData), r[c.uuid] = o } } return r } parseMaterials(e, n) { const r = {}, i = {}; if (e !== void 0) { const a = new p2; a.setTextures(n); for (let s = 0, o = e.length; s < o; s++) { const c = e[s]; r[c.uuid] === void 0 && (r[c.uuid] = a.parse(c)), i[c.uuid] = r[c.uuid] } } return i } parseAnimations(e) { const n = {}; if (e !== void 0) for (let r = 0; r < e.length; r++) { const i = e[r], a = H1.parse(i); n[a.uuid] = a } return n } parseImages(e, n) { const r = this, i = {}; let a; function s(c) { return r.manager.itemStart(c), a.load(c, function () { r.manager.itemEnd(c) }, void 0, function () { r.manager.itemError(c), r.manager.itemEnd(c) }) } function o(c) { if (typeof c == "string") { const u = c, d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u; return s(d) } else return c.data ? { data: Uy(c.type, c.data), width: c.width, height: c.height } : null } if (e !== void 0 && e.length > 0) { const c = new h2(n); a = new W1(c), a.setCrossOrigin(this.crossOrigin); for (let u = 0, d = e.length; u < d; u++) { const f = e[u], h = f.url; if (Array.isArray(h)) { const m = []; for (let g = 0, x = h.length; g < x; g++) { const v = h[g], b = o(v); b !== null && (b instanceof HTMLImageElement ? m.push(b) : m.push(new Uc(b.data, b.width, b.height))) } i[f.uuid] = new Oh(m) } else { const m = o(f.url); i[f.uuid] = new Oh(m) } } } return i } async parseImagesAsync(e) { const n = this, r = {}; let i; async function a(s) { if (typeof s == "string") { const o = s, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : n.resourcePath + o; return await i.loadAsync(c) } else return s.data ? { data: Uy(s.type, s.data), width: s.width, height: s.height } : null } if (e !== void 0 && e.length > 0) { i = new W1(this.manager), i.setCrossOrigin(this.crossOrigin); for (let s = 0, o = e.length; s < o; s++) { const c = e[s], u = c.url; if (Array.isArray(u)) { const d = []; for (let f = 0, h = u.length; f < h; f++) { const m = u[f], g = await a(m); g !== null && (g instanceof HTMLImageElement ? d.push(g) : d.push(new Uc(g.data, g.width, g.height))) } r[c.uuid] = new Oh(d) } else { const d = await a(c.url); r[c.uuid] = new Oh(d) } } } return r } parseTextures(e, n) { function r(a, s) { return typeof a == "number" ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), s[a]) } const i = {}; if (e !== void 0) for (let a = 0, s = e.length; a < s; a++) { const o = e[a]; o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), n[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image); const c = n[o.image], u = c.data; let d; Array.isArray(u) ? (d = new l_, u.length === 6 && (d.needsUpdate = !0)) : (u && u.data ? d = new Uc : d = new ti, u && (d.needsUpdate = !0)), d.source = c, d.uuid = o.uuid, o.name !== void 0 && (d.name = o.name), o.mapping !== void 0 && (d.mapping = r(o.mapping, N2e)), o.channel !== void 0 && (d.channel = o.channel), o.offset !== void 0 && d.offset.fromArray(o.offset), o.repeat !== void 0 && d.repeat.fromArray(o.repeat), o.center !== void 0 && d.center.fromArray(o.center), o.rotation !== void 0 && (d.rotation = o.rotation), o.wrap !== void 0 && (d.wrapS = r(o.wrap[0], gW), d.wrapT = r(o.wrap[1], gW)), o.format !== void 0 && (d.format = o.format), o.internalFormat !== void 0 && (d.internalFormat = o.internalFormat), o.type !== void 0 && (d.type = o.type), o.colorSpace !== void 0 && (d.colorSpace = o.colorSpace), o.minFilter !== void 0 && (d.minFilter = r(o.minFilter, vW)), o.magFilter !== void 0 && (d.magFilter = r(o.magFilter, vW)), o.anisotropy !== void 0 && (d.anisotropy = o.anisotropy), o.flipY !== void 0 && (d.flipY = o.flipY), o.generateMipmaps !== void 0 && (d.generateMipmaps = o.generateMipmaps), o.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (d.unpackAlignment = o.unpackAlignment), o.compareFunction !== void 0 && (d.compareFunction = o.compareFunction), o.userData !== void 0 && (d.userData = o.userData), i[o.uuid] = d } return i } parseObject(e, n, r, i, a) { let s; function o(h) { return n[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", h), n[h] } function c(h) { if (h !== void 0) { if (Array.isArray(h)) { const m = []; for (let g = 0, x = h.length; g < x; g++) { const v = h[g]; r[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), m.push(r[v]) } return m } return r[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", h), r[h] } } function u(h) { return i[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", h), i[h] } let d, f; switch (e.type) { case "Scene": s = new c_, e.background !== void 0 && (Number.isInteger(e.background) ? s.background = new Kt(e.background) : s.background = u(e.background)), e.environment !== void 0 && (s.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? s.fog = new ZA(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (s.fog = new KA(e.fog.color, e.fog.density)), e.fog.name !== "" && (s.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (s.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (s.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && s.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (s.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && s.environmentRotation.fromArray(e.environmentRotation); break; case "PerspectiveCamera": s = new ra(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (s.focus = e.focus), e.zoom !== void 0 && (s.zoom = e.zoom), e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset), e.view !== void 0 && (s.view = Object.assign({}, e.view)); break; case "OrthographicCamera": s = new of(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (s.zoom = e.zoom), e.view !== void 0 && (s.view = Object.assign({}, e.view)); break; case "AmbientLight": s = new vse(e.color, e.intensity); break; case "DirectionalLight": s = new gse(e.color, e.intensity), s.target = e.target || ""; break; case "PointLight": s = new mse(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": s = new yse(e.color, e.intensity, e.width, e.height); break; case "SpotLight": s = new pse(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), s.target = e.target || ""; break; case "HemisphereLight": s = new hse(e.color, e.groundColor, e.intensity); break; case "LightProbe": s = new bse().fromJSON(e); break; case "SkinnedMesh": d = o(e.geometry), f = c(e.material), s = new Rae(d, f), e.bindMode !== void 0 && (s.bindMode = e.bindMode), e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (s.skeleton = e.skeleton); break; case "Mesh": d = o(e.geometry), f = c(e.material), s = new Bi(d, f); break; case "InstancedMesh": d = o(e.geometry), f = c(e.material); const h = e.count, m = e.instanceMatrix, g = e.instanceColor; s = new Oae(d, f, h), s.instanceMatrix = new Mx(new Float32Array(m.array), 16), g !== void 0 && (s.instanceColor = new Mx(new Float32Array(g.array), g.itemSize)); break; case "BatchedMesh": d = o(e.geometry), f = c(e.material), s = new Dae(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, f), s.geometry = d, s.perObjectFrustumCulled = e.perObjectFrustumCulled, s.sortObjects = e.sortObjects, s._drawRanges = e.drawRanges, s._reservedRanges = e.reservedRanges, s._geometryInfo = e.geometryInfo.map(x => { let v = null, b = null; return x.boundingBox !== void 0 && (v = new Ps().fromJSON(x.boundingBox)), x.boundingSphere !== void 0 && (b = new us().fromJSON(x.boundingSphere)), { ...x, boundingBox: v, boundingSphere: b } }), s._instanceInfo = e.instanceInfo, s._availableInstanceIds = e._availableInstanceIds, s._availableGeometryIds = e._availableGeometryIds, s._nextIndexStart = e.nextIndexStart, s._nextVertexStart = e.nextVertexStart, s._geometryCount = e.geometryCount, s._maxInstanceCount = e.maxInstanceCount, s._maxVertexCount = e.maxVertexCount, s._maxIndexCount = e.maxIndexCount, s._geometryInitialized = e.geometryInitialized, s._matricesTexture = u(e.matricesTexture.uuid), s._indirectTexture = u(e.indirectTexture.uuid), e.colorsTexture !== void 0 && (s._colorsTexture = u(e.colorsTexture.uuid)), e.boundingSphere !== void 0 && (s.boundingSphere = new us().fromJSON(e.boundingSphere)), e.boundingBox !== void 0 && (s.boundingBox = new Ps().fromJSON(e.boundingBox)); break; case "LOD": s = new jae; break; case "Line": s = new ip(o(e.geometry), c(e.material)); break; case "LineLoop": s = new Lae(o(e.geometry), c(e.material)); break; case "LineSegments": s = new Ju(o(e.geometry), c(e.material)); break; case "PointCloud": case "Points": s = new Fae(o(e.geometry), c(e.material)); break; case "Sprite": s = new Pae(c(e.material)); break; case "Group": s = new By; break; case "Bone": s = new aB; break; default: s = new kr }if (s.uuid = e.uuid, e.name !== void 0 && (s.name = e.name), e.matrix !== void 0 ? (s.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (e.position !== void 0 && s.position.fromArray(e.position), e.rotation !== void 0 && s.rotation.fromArray(e.rotation), e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion), e.scale !== void 0 && s.scale.fromArray(e.scale)), e.up !== void 0 && s.up.fromArray(e.up), e.castShadow !== void 0 && (s.castShadow = e.castShadow), e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (s.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (s.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (s.visible = e.visible), e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder), e.userData !== void 0 && (s.userData = e.userData), e.layers !== void 0 && (s.layers.mask = e.layers), e.children !== void 0) { const h = e.children; for (let m = 0; m < h.length; m++)s.add(this.parseObject(h[m], n, r, i, a)) } if (e.animations !== void 0) { const h = e.animations; for (let m = 0; m < h.length; m++) { const g = h[m]; s.animations.push(a[g]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate); const h = e.levels; for (let m = 0; m < h.length; m++) { const g = h[m], x = s.getObjectByProperty("uuid", g.object); x !== void 0 && s.addLevel(x, g.distance, g.hysteresis) } } return s } bindSkeletons(e, n) { Object.keys(n).length !== 0 && e.traverse(function (r) { if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) { const i = n[r.skeleton]; i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix) } }) } bindLightTargets(e) { e.traverse(function (n) { if (n.isDirectionalLight || n.isSpotLight) { const r = n.target, i = e.getObjectByProperty("uuid", r); i !== void 0 ? n.target = i : n.target = new kr } }) } } const N2e = { UVMapping: np, CubeReflectionMapping: $u, CubeRefractionMapping: rp, EquirectangularReflectionMapping: vx, EquirectangularRefractionMapping: P1, CubeUVReflectionMapping: C0 }, gW = { RepeatWrapping: j1, ClampToEdgeWrapping: va, MirroredRepeatWrapping: R1 }, vW = { NearestFilter: cs, NearestMipmapNearestFilter: WU, NearestMipmapLinearFilter: Fy, LinearFilter: Xr, LinearMipmapNearestFilter: Gw, LinearMipmapLinearFilter: bu }, OR = new WeakMap; class A2e extends ho { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" }, this._abortController = new AbortController } setOptions(e) { return this.options = e, this } load(e, n, r, i) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const a = this, s = wu.get(`image-bitmap:${e}`); if (s !== void 0) { if (a.manager.itemStart(e), s.then) { s.then(u => { if (OR.has(s) === !0) i && i(OR.get(s)), a.manager.itemError(e), a.manager.itemEnd(e); else return n && n(u), a.manager.itemEnd(e), u }); return } return setTimeout(function () { n && n(s), a.manager.itemEnd(e) }, 0), s } const o = {}; o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader, o.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal; const c = fetch(e, o).then(function (u) { return u.blob() }).then(function (u) { return createImageBitmap(u, Object.assign(a.options, { colorSpaceConversion: "none" })) }).then(function (u) { return wu.add(`image-bitmap:${e}`, u), n && n(u), a.manager.itemEnd(e), u }).catch(function (u) { i && i(u), OR.set(c, u), wu.remove(`image-bitmap:${e}`), a.manager.itemError(e), a.manager.itemEnd(e) }); wu.add(`image-bitmap:${e}`, c), a.manager.itemStart(e) } abort() { return this._abortController.abort(), this._abortController = new AbortController, this } } let jM; class _B { static getContext() { return jM === void 0 && (jM = new (window.AudioContext || window.webkitAudioContext)), jM } static setContext(e) { jM = e } } class P2e extends ho { constructor(e) { super(e) } load(e, n, r, i) { const a = this, s = new hl(this.manager); s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (c) { try { const u = c.slice(0); _B.getContext().decodeAudioData(u, function (f) { n(f) }).catch(o) } catch (u) { o(u) } }, r, i); function o(c) { i ? i(c) : console.error(c), a.manager.itemError(e) } } } const yW = new Fn, xW = new Fn, Em = new Fn; class j2e { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ra, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ra, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const n = this._cache; if (n.focus !== e.focus || n.fov !== e.fov || n.aspect !== e.aspect * this.aspect || n.near !== e.near || n.far !== e.far || n.zoom !== e.zoom || n.eyeSep !== this.eyeSep) { n.focus = e.focus, n.fov = e.fov, n.aspect = e.aspect * this.aspect, n.near = e.near, n.far = e.far, n.zoom = e.zoom, n.eyeSep = this.eyeSep, Em.copy(e.projectionMatrix); const i = n.eyeSep / 2, a = i * n.near / n.focus, s = n.near * Math.tan(fg * n.fov * .5) / n.zoom; let o, c; xW.elements[12] = -i, yW.elements[12] = i, o = -s * n.aspect + a, c = s * n.aspect + a, Em.elements[0] = 2 * n.near / (c - o), Em.elements[8] = (c + o) / (c - o), this.cameraL.projectionMatrix.copy(Em), o = -s * n.aspect - a, c = s * n.aspect - a, Em.elements[0] = 2 * n.near / (c - o), Em.elements[8] = (c + o) / (c - o), this.cameraR.projectionMatrix.copy(Em) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(xW), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(yW) } } class _se extends ra { constructor(e = []) { super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e } } class EB { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const n = performance.now(); e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e } return e } } const Mm = new pe, DR = new As, R2e = new pe, Tm = new pe, Cm = new pe; class k2e extends kr { constructor() { super(), this.type = "AudioListener", this.context = _B.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new EB } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const n = this.context.listener; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Mm, DR, R2e), Tm.set(0, 0, -1).applyQuaternion(DR), Cm.set(0, 1, 0).applyQuaternion(DR), n.positionX) { const r = this.context.currentTime + this.timeDelta; n.positionX.linearRampToValueAtTime(Mm.x, r), n.positionY.linearRampToValueAtTime(Mm.y, r), n.positionZ.linearRampToValueAtTime(Mm.z, r), n.forwardX.linearRampToValueAtTime(Tm.x, r), n.forwardY.linearRampToValueAtTime(Tm.y, r), n.forwardZ.linearRampToValueAtTime(Tm.z, r), n.upX.linearRampToValueAtTime(Cm.x, r), n.upY.linearRampToValueAtTime(Cm.y, r), n.upZ.linearRampToValueAtTime(Cm.z, r) } else n.setPosition(Mm.x, Mm.y, Mm.z), n.setOrientation(Tm.x, Tm.y, Tm.z, Cm.x, Cm.y, Cm.z) } } class Ese extends kr { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const n = this.context.createBufferSource(); return n.buffer = this.buffer, n.loop = this.loop, n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.onended = this.onEnded.bind(this), n.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = n, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop(e = 0) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, n = this.filters.length; e < n; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this._connected !== !1) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, n = this.filters.length; e < n; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1, this._progress = 0 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } copy(e, n) { return super.copy(e, n), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this) } clone(e) { return new this.constructor(this.listener).copy(this, e) } } const Nm = new pe, bW = new As, I2e = new pe, Am = new pe; class O2e extends Ese { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { return super.connect(), this.panner.connect(this.gain), this } disconnect() { return super.disconnect(), this.panner.disconnect(this.gain), this } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, n, r) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = n, this.panner.coneOuterGain = r, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(Nm, bW, I2e), Am.set(0, 0, 1).applyQuaternion(bW); const n = this.panner; if (n.positionX) { const r = this.context.currentTime + this.listener.timeDelta; n.positionX.linearRampToValueAtTime(Nm.x, r), n.positionY.linearRampToValueAtTime(Nm.y, r), n.positionZ.linearRampToValueAtTime(Nm.z, r), n.orientationX.linearRampToValueAtTime(Am.x, r), n.orientationY.linearRampToValueAtTime(Am.y, r), n.orientationZ.linearRampToValueAtTime(Am.z, r) } else n.setPosition(Nm.x, Nm.y, Nm.z), n.setOrientation(Am.x, Am.y, Am.z) } } class D2e { constructor(e, n = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = n, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const n = this.getFrequencyData(); for (let r = 0; r < n.length; r++)e += n[r]; return e / n.length } } class Mse { constructor(e, n, r) { this.binding = e, this.valueSize = r; let i, a, s; switch (n) { case "quaternion": i = this._slerp, a = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5; break; case "string": case "bool": i = this._select, a = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5); break; default: i = this._lerp, a = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = a, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, n) { const r = this.buffer, i = this.valueSize, a = e * i + i; let s = this.cumulativeWeight; if (s === 0) { for (let o = 0; o !== i; ++o)r[a + o] = r[o]; s = n } else { s += n; const o = n / s; this._mixBufferRegion(r, a, 0, o, i) } this.cumulativeWeight = s } accumulateAdditive(e) { const n = this.buffer, r = this.valueSize, i = r * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(n, i, 0, e, r), this.cumulativeWeightAdditive += e } apply(e) { const n = this.valueSize, r = this.buffer, i = e * n + n, a = this.cumulativeWeight, s = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1) { const c = n * this._origIndex; this._mixBufferRegion(r, i, c, 1 - a, n) } s > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n); for (let c = n, u = n + n; c !== u; ++c)if (r[c] !== r[c + n]) { o.setValue(r, i); break } } saveOriginalState() { const e = this.binding, n = this.buffer, r = this.valueSize, i = r * this._origIndex; e.getValue(n, i); for (let a = r, s = i; a !== s; ++a)n[a] = n[i + a % r]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, n = e + this.valueSize; for (let r = e; r < n; r++)this.buffer[r] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, n = this._addIndex * this.valueSize; for (let r = 0; r < this.valueSize; r++)this.buffer[n + r] = this.buffer[e + r] } _select(e, n, r, i, a) { if (i >= .5) for (let s = 0; s !== a; ++s)e[n + s] = e[r + s] } _slerp(e, n, r, i) { As.slerpFlat(e, n, e, n, e, r, i) } _slerpAdditive(e, n, r, i, a) { const s = this._workIndex * a; As.multiplyQuaternionsFlat(e, s, e, n, e, r), As.slerpFlat(e, n, e, n, e, s, i) } _lerp(e, n, r, i, a) { const s = 1 - i; for (let o = 0; o !== a; ++o) { const c = n + o; e[c] = e[c] * s + e[r + o] * i } } _lerpAdditive(e, n, r, i, a) { for (let s = 0; s !== a; ++s) { const o = n + s; e[o] = e[o] + e[r + s] * i } } } const MB = "\\[\\]\\.:\\/", L2e = new RegExp("[" + MB + "]", "g"), TB = "[^" + MB + "]", F2e = "[^" + MB.replace("\\.", "") + "]", U2e = /((?:WC+[\/:])*)/.source.replace("WC", TB), B2e = /(WCOD+)?/.source.replace("WCOD", F2e), $2e = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", TB), z2e = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", TB), V2e = new RegExp("^" + U2e + B2e + $2e + z2e + "$"), H2e = ["material", "materials", "bones", "map"]; class W2e { constructor(e, n, r) { const i = r || Pr.parseTrackName(n); this._targetGroup = e, this._bindings = e.subscribe_(n, i) } getValue(e, n) { this.bind(); const r = this._targetGroup.nCachedObjects_, i = this._bindings[r]; i !== void 0 && i.getValue(e, n) } setValue(e, n) { const r = this._bindings; for (let i = this._targetGroup.nCachedObjects_, a = r.length; i !== a; ++i)r[i].setValue(e, n) } bind() { const e = this._bindings; for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)e[n].bind() } unbind() { const e = this._bindings; for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)e[n].unbind() } } class Pr { constructor(e, n, r) { this.path = n, this.parsedPath = r || Pr.parseTrackName(n), this.node = Pr.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, n, r) { return e && e.isAnimationObjectGroup ? new Pr.Composite(e, n, r) : new Pr(e, n, r) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(L2e, "") } static parseTrackName(e) { const n = V2e.exec(e); if (n === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const r = { nodeName: n[2], objectName: n[3], objectIndex: n[4], propertyName: n[5], propertyIndex: n[6] }, i = r.nodeName && r.nodeName.lastIndexOf("."); if (i !== void 0 && i !== -1) { const a = r.nodeName.substring(i + 1); H2e.indexOf(a) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = a) } if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return r } static findNode(e, n) { if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid) return e; if (e.skeleton) { const r = e.skeleton.getBoneByName(n); if (r !== void 0) return r } if (e.children) { const r = function (a) { for (let s = 0; s < a.length; s++) { const o = a[s]; if (o.name === n || o.uuid === n) return o; const c = r(o.children); if (c) return c } return null }, i = r(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, n) { e[n] = this.targetObject[this.propertyName] } _getValue_array(e, n) { const r = this.resolvedProperty; for (let i = 0, a = r.length; i !== a; ++i)e[n++] = r[i] } _getValue_arrayElement(e, n) { e[n] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, n) { this.resolvedProperty.toArray(e, n) } _setValue_direct(e, n) { this.targetObject[this.propertyName] = e[n] } _setValue_direct_setNeedsUpdate(e, n) { this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, n) { this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, n) { const r = this.resolvedProperty; for (let i = 0, a = r.length; i !== a; ++i)r[i] = e[n++] } _setValue_array_setNeedsUpdate(e, n) { const r = this.resolvedProperty; for (let i = 0, a = r.length; i !== a; ++i)r[i] = e[n++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, n) { const r = this.resolvedProperty; for (let i = 0, a = r.length; i !== a; ++i)r[i] = e[n++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, n) { this.resolvedProperty[this.propertyIndex] = e[n] } _setValue_arrayElement_setNeedsUpdate(e, n) { this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) { this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, n) { this.resolvedProperty.fromArray(e, n) } _setValue_fromArray_setNeedsUpdate(e, n) { this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) { this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, n) { this.bind(), this.getValue(e, n) } _setValue_unbound(e, n) { this.bind(), this.setValue(e, n) } bind() { let e = this.node; const n = this.parsedPath, r = n.objectName, i = n.propertyName; let a = n.propertyIndex; if (e || (e = Pr.findNode(this.rootNode, n.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (r) { let u = n.objectIndex; switch (r) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let d = 0; d < e.length; d++)if (e[d].name === u) { u = d; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[r] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[r] }if (u !== void 0) { if (e[u] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[u] } } const s = e[i]; if (s === void 0) { const u = n.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e); return } let o = this.Versioning.None; this.targetObject = e, e.isMaterial === !0 ? o = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate); let c = this.BindingType.Direct; if (a !== void 0) { if (i === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[a] !== void 0 && (a = e.morphTargetDictionary[a]) } c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = a } else s.fromArray !== void 0 && s.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Pr.Composite = W2e; Pr.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; Pr.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; Pr.prototype.GetterByBindingType = [Pr.prototype._getValue_direct, Pr.prototype._getValue_array, Pr.prototype._getValue_arrayElement, Pr.prototype._getValue_toArray]; Pr.prototype.SetterByBindingTypeAndVersioning = [[Pr.prototype._setValue_direct, Pr.prototype._setValue_direct_setNeedsUpdate, Pr.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Pr.prototype._setValue_array, Pr.prototype._setValue_array_setNeedsUpdate, Pr.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Pr.prototype._setValue_arrayElement, Pr.prototype._setValue_arrayElement_setNeedsUpdate, Pr.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Pr.prototype._setValue_fromArray, Pr.prototype._setValue_fromArray_setNeedsUpdate, Pr.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class G2e { constructor() { this.isAnimationObjectGroup = !0, this.uuid = fl(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let r = 0, i = arguments.length; r !== i; ++r)e[arguments[r].uuid] = r; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const n = this; this.stats = { objects: { get total() { return n._objects.length }, get inUse() { return this.total - n.nCachedObjects_ } }, get bindingsPerObject() { return n._bindings.length } } } add() { const e = this._objects, n = this._indicesByUUID, r = this._paths, i = this._parsedPaths, a = this._bindings, s = a.length; let o, c = e.length, u = this.nCachedObjects_; for (let d = 0, f = arguments.length; d !== f; ++d) { const h = arguments[d], m = h.uuid; let g = n[m]; if (g === void 0) { g = c++, n[m] = g, e.push(h); for (let x = 0, v = s; x !== v; ++x)a[x].push(new Pr(h, r[x], i[x])) } else if (g < u) { o = e[g]; const x = --u, v = e[x]; n[v.uuid] = g, e[g] = v, n[m] = x, e[x] = h; for (let b = 0, E = s; b !== E; ++b) { const M = a[b], C = M[x]; let N = M[g]; M[g] = C, N === void 0 && (N = new Pr(h, r[b], i[b])), M[x] = N } } else e[g] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = u } remove() { const e = this._objects, n = this._indicesByUUID, r = this._bindings, i = r.length; let a = this.nCachedObjects_; for (let s = 0, o = arguments.length; s !== o; ++s) { const c = arguments[s], u = c.uuid, d = n[u]; if (d !== void 0 && d >= a) { const f = a++, h = e[f]; n[h.uuid] = d, e[d] = h, n[u] = f, e[f] = c; for (let m = 0, g = i; m !== g; ++m) { const x = r[m], v = x[f], b = x[d]; x[d] = v, x[f] = b } } } this.nCachedObjects_ = a } uncache() { const e = this._objects, n = this._indicesByUUID, r = this._bindings, i = r.length; let a = this.nCachedObjects_, s = e.length; for (let o = 0, c = arguments.length; o !== c; ++o) { const u = arguments[o], d = u.uuid, f = n[d]; if (f !== void 0) if (delete n[d], f < a) { const h = --a, m = e[h], g = --s, x = e[g]; n[m.uuid] = f, e[f] = m, n[x.uuid] = h, e[h] = x, e.pop(); for (let v = 0, b = i; v !== b; ++v) { const E = r[v], M = E[h], C = E[g]; E[f] = M, E[h] = C, E.pop() } } else { const h = --s, m = e[h]; h > 0 && (n[m.uuid] = f), e[f] = m, e.pop(); for (let g = 0, x = i; g !== x; ++g) { const v = r[g]; v[f] = v[h], v.pop() } } } this.nCachedObjects_ = a } subscribe_(e, n) { const r = this._bindingsIndicesByPath; let i = r[e]; const a = this._bindings; if (i !== void 0) return a[i]; const s = this._paths, o = this._parsedPaths, c = this._objects, u = c.length, d = this.nCachedObjects_, f = new Array(u); i = a.length, r[e] = i, s.push(e), o.push(n), a.push(f); for (let h = d, m = c.length; h !== m; ++h) { const g = c[h]; f[h] = new Pr(g, e, n) } return f } unsubscribe_(e) { const n = this._bindingsIndicesByPath, r = n[e]; if (r !== void 0) { const i = this._paths, a = this._parsedPaths, s = this._bindings, o = s.length - 1, c = s[o], u = e[o]; n[u] = r, s[r] = c, s.pop(), a[r] = a[o], a.pop(), i[r] = i[o], i.pop() } } } class Tse { constructor(e, n, r = null, i = n.blendMode) { this._mixer = e, this._clip = n, this._localRoot = r, this.blendMode = i; const a = n.tracks, s = a.length, o = new Array(s), c = { endingStart: Ym, endingEnd: Ym }; for (let u = 0; u !== s; ++u) { const d = a[u].createInterpolant(null); o[u] = d, d.settings = c } this._interpolantSettings = c, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = uae, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, n) { return this.loop = e, this.repetitions = n, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, n, r = !1) { if (e.fadeOut(n), this.fadeIn(n), r === !0) { const i = this._clip.duration, a = e._clip.duration, s = a / i, o = i / a; e.warp(1, s, n), this.warp(o, 1, n) } return this } crossFadeTo(e, n, r = !1) { return e.crossFadeFrom(this, n, r) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, n, r) { const i = this._mixer, a = i.time, s = this.timeScale; let o = this._timeScaleInterpolant; o === null && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o); const c = o.parameterPositions, u = o.sampleValues; return c[0] = a, c[1] = a + r, u[0] = e / s, u[1] = n / s, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, n, r, i) { if (!this.enabled) { this._updateWeight(e); return } const a = this._startTime; if (a !== null) { const c = (e - a) * r; c < 0 || r === 0 ? n = 0 : (this._startTime = null, n = r * c) } n *= this._updateTimeScale(e); const s = this._updateTime(n), o = this._updateWeight(e); if (o > 0) { const c = this._interpolants, u = this._propertyBindings; switch (this.blendMode) { case ZU: for (let d = 0, f = c.length; d !== f; ++d)c[d].evaluate(s), u[d].accumulateAdditive(o); break; case qA: default: for (let d = 0, f = c.length; d !== f; ++d)c[d].evaluate(s), u[d].accumulate(i, o) } } } _updateWeight(e) { let n = 0; if (this.enabled) { n = this.weight; const r = this._weightInterpolant; if (r !== null) { const i = r.evaluate(e)[0]; n *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1)) } } return this._effectiveWeight = n, n } _updateTimeScale(e) { let n = 0; if (!this.paused) { n = this.timeScale; const r = this._timeScaleInterpolant; if (r !== null) { const i = r.evaluate(e)[0]; n *= i, e > r.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n) } } return this._effectiveTimeScale = n, n } _updateTime(e) { const n = this._clip.duration, r = this.loop; let i = this.time + e, a = this._loopCount; const s = r === dae; if (e === 0) return a === -1 ? i : s && (a & 1) === 1 ? n - i : i; if (r === cae) { a === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (i >= n) i = n; else if (i < 0) i = 0; else { this.time = i; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (a === -1 && (e >= 0 ? (a = 0, this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)), i >= n || i < 0) { const o = Math.floor(i / n); i -= n * o, a += Math.abs(o); const c = this.repetitions - a; if (c <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? n : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (c === 1) { const u = e < 0; this._setEndings(u, !u, s) } else this._setEndings(!1, !1, s); this._loopCount = a, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o }) } } else this.time = i; if (s && (a & 1) === 1) return n - i } return i } _setEndings(e, n, r) { const i = this._interpolantSettings; r ? (i.endingStart = Km, i.endingEnd = Km) : (e ? i.endingStart = this.zeroSlopeAtStart ? Km : Ym : i.endingStart = I1, n ? i.endingEnd = this.zeroSlopeAtEnd ? Km : Ym : i.endingEnd = I1) } _scheduleFading(e, n, r) { const i = this._mixer, a = i.time; let s = this._weightInterpolant; s === null && (s = i._lendControlInterpolant(), this._weightInterpolant = s); const o = s.parameterPositions, c = s.sampleValues; return o[0] = a, c[0] = n, o[1] = a + e, c[1] = r, this } } const q2e = new Float32Array(1); class X2e extends Qu { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, n) { const r = e._localRoot || this._root, i = e._clip.tracks, a = i.length, s = e._propertyBindings, o = e._interpolants, c = r.uuid, u = this._bindingsByRootAndName; let d = u[c]; d === void 0 && (d = {}, u[c] = d); for (let f = 0; f !== a; ++f) { const h = i[f], m = h.name; let g = d[m]; if (g !== void 0) ++g.referenceCount, s[f] = g; else { if (g = s[f], g !== void 0) { g._cacheIndex === null && (++g.referenceCount, this._addInactiveBinding(g, c, m)); continue } const x = n && n._propertyBindings[f].binding.parsedPath; g = new Mse(Pr.create(r, m, x), h.ValueTypeName, h.getValueSize()), ++g.referenceCount, this._addInactiveBinding(g, c, m), s[f] = g } o[f].resultBuffer = g.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, a = this._actionsByClip[i]; this._bindAction(e, a && a.knownActions[0]), this._addInactiveAction(e, i, r) } const n = e._propertyBindings; for (let r = 0, i = n.length; r !== i; ++r) { const a = n[r]; a.useCount++ === 0 && (this._lendBinding(a), a.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const n = e._propertyBindings; for (let r = 0, i = n.length; r !== i; ++r) { const a = n[r]; --a.useCount === 0 && (a.restoreOriginalState(), this._takeBackBinding(a)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const n = e._cacheIndex; return n !== null && n < this._nActiveActions } _addInactiveAction(e, n, r) { const i = this._actions, a = this._actionsByClip; let s = a[n]; if (s === void 0) s = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, a[n] = s; else { const o = s.knownActions; e._byClipCacheIndex = o.length, o.push(e) } e._cacheIndex = i.length, i.push(e), s.actionByRoot[r] = e } _removeInactiveAction(e) { const n = this._actions, r = n[n.length - 1], i = e._cacheIndex; r._cacheIndex = i, n[i] = r, n.pop(), e._cacheIndex = null; const a = e._clip.uuid, s = this._actionsByClip, o = s[a], c = o.knownActions, u = c[c.length - 1], d = e._byClipCacheIndex; u._byClipCacheIndex = d, c[d] = u, c.pop(), e._byClipCacheIndex = null; const f = o.actionByRoot, h = (e._localRoot || this._root).uuid; delete f[h], c.length === 0 && delete s[a], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const n = e._propertyBindings; for (let r = 0, i = n.length; r !== i; ++r) { const a = n[r]; --a.referenceCount === 0 && this._removeInactiveBinding(a) } } _lendAction(e) { const n = this._actions, r = e._cacheIndex, i = this._nActiveActions++, a = n[i]; e._cacheIndex = i, n[i] = e, a._cacheIndex = r, n[r] = a } _takeBackAction(e) { const n = this._actions, r = e._cacheIndex, i = --this._nActiveActions, a = n[i]; e._cacheIndex = i, n[i] = e, a._cacheIndex = r, n[r] = a } _addInactiveBinding(e, n, r) { const i = this._bindingsByRootAndName, a = this._bindings; let s = i[n]; s === void 0 && (s = {}, i[n] = s), s[r] = e, e._cacheIndex = a.length, a.push(e) } _removeInactiveBinding(e) { const n = this._bindings, r = e.binding, i = r.rootNode.uuid, a = r.path, s = this._bindingsByRootAndName, o = s[i], c = n[n.length - 1], u = e._cacheIndex; c._cacheIndex = u, n[u] = c, n.pop(), delete o[a], Object.keys(o).length === 0 && delete s[i] } _lendBinding(e) { const n = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, a = n[i]; e._cacheIndex = i, n[i] = e, a._cacheIndex = r, n[r] = a } _takeBackBinding(e) { const n = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, a = n[i]; e._cacheIndex = i, n[i] = e, a._cacheIndex = r, n[r] = a } _lendControlInterpolant() { const e = this._controlInterpolants, n = this._nActiveControlInterpolants++; let r = e[n]; return r === void 0 && (r = new xB(new Float32Array(2), new Float32Array(2), 1, q2e), r.__cacheIndex = n, e[n] = r), r } _takeBackControlInterpolant(e) { const n = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, a = n[i]; e.__cacheIndex = i, n[i] = e, a.__cacheIndex = r, n[r] = a } clipAction(e, n, r) { const i = n || this._root, a = i.uuid; let s = typeof e == "string" ? H1.findByName(i, e) : e; const o = s !== null ? s.uuid : e, c = this._actionsByClip[o]; let u = null; if (r === void 0 && (s !== null ? r = s.blendMode : r = qA), c !== void 0) { const f = c.actionByRoot[a]; if (f !== void 0 && f.blendMode === r) return f; u = c.knownActions[0], s === null && (s = u._clip) } if (s === null) return null; const d = new Tse(this, s, n, r); return this._bindAction(d, u), this._addInactiveAction(d, o, a), d } existingAction(e, n) { const r = n || this._root, i = r.uuid, a = typeof e == "string" ? H1.findByName(r, e) : e, s = a ? a.uuid : e, o = this._actionsByClip[s]; return o !== void 0 && o.actionByRoot[i] || null } stopAllAction() { const e = this._actions, n = this._nActiveActions; for (let r = n - 1; r >= 0; --r)e[r].stop(); return this } update(e) { e *= this.timeScale; const n = this._actions, r = this._nActiveActions, i = this.time += e, a = Math.sign(e), s = this._accuIndex ^= 1; for (let u = 0; u !== r; ++u)n[u]._update(i, e, a, s); const o = this._bindings, c = this._nActiveBindings; for (let u = 0; u !== c; ++u)o[u].apply(s); return this } setTime(e) { this.time = 0; for (let n = 0; n < this._actions.length; n++)this._actions[n].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const n = this._actions, r = e.uuid, i = this._actionsByClip, a = i[r]; if (a !== void 0) { const s = a.knownActions; for (let o = 0, c = s.length; o !== c; ++o) { const u = s[o]; this._deactivateAction(u); const d = u._cacheIndex, f = n[n.length - 1]; u._cacheIndex = null, u._byClipCacheIndex = null, f._cacheIndex = d, n[d] = f, n.pop(), this._removeInactiveBindingsForAction(u) } delete i[r] } } uncacheRoot(e) { const n = e.uuid, r = this._actionsByClip; for (const s in r) { const o = r[s].actionByRoot, c = o[n]; c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c)) } const i = this._bindingsByRootAndName, a = i[n]; if (a !== void 0) for (const s in a) { const o = a[s]; o.restoreOriginalState(), this._removeInactiveBinding(o) } } uncacheAction(e, n) { const r = this.existingAction(e, n); r !== null && (this._deactivateAction(r), this._removeInactiveAction(r)) } } class Y2e extends eB { constructor(e = 1, n = 1, r = 1, i = {}) { super(e, n, i), this.isRenderTarget3D = !0, this.depth = r, this.texture = new YA(null, e, n, r), this._setTextureOptions(i), this.texture.isRenderTargetTexture = !0 } } class CB { constructor(e) { this.value = e } clone() { return new CB(this.value.clone === void 0 ? this.value : this.value.clone()) } } let K2e = 0; class Z2e extends Qu { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: K2e++ }), this.name = "", this.usage = D1, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const n = this.uniforms.indexOf(e); return n !== -1 && this.uniforms.splice(n, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { this.dispatchEvent({ type: "dispose" }) } copy(e) { this.name = e.name, this.usage = e.usage; const n = e.uniforms; this.uniforms.length = 0; for (let r = 0, i = n.length; r < i; r++) { const a = Array.isArray(n[r]) ? n[r] : [n[r]]; for (let s = 0; s < a.length; s++)this.uniforms.push(a[s].clone()) } return this } clone() { return new this.constructor().copy(this) } } class Q2e extends QA { constructor(e, n, r = 1) { super(e, n), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const n = super.clone(e); return n.meshPerAttribute = this.meshPerAttribute, n } toJSON(e) { const n = super.toJSON(e); return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n } } class J2e { constructor(e, n, r, i, a, s = !1) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = n, this.itemSize = r, this.elementSize = i, this.count = a, this.normalized = s, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, n) { return this.type = e, this.elementSize = n, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } const wW = new Fn; class NB { constructor(e, n, r = 0, i = 1 / 0) { this.ray = new Hg(e, n), this.near = r, this.far = i, this.camera = null, this.layers = new hg, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, n) { this.ray.set(e, n) } setFromCamera(e, n) { n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type) } setFromXRController(e) { return wW.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(wW), this } intersectObject(e, n = !0, r = []) { return YL(e, this, r, n), r.sort(SW), r } intersectObjects(e, n = !0, r = []) { for (let i = 0, a = e.length; i < a; i++)YL(e[i], this, r, n); return r.sort(SW), r } } function SW(t, e) { return t.distance - e.distance } function YL(t, e, n, r) { let i = !0; if (t.layers.test(e.layers) && t.raycast(e, n) === !1 && (i = !1), i === !0 && r === !0) { const a = t.children; for (let s = 0, o = a.length; s < o; s++)YL(a[s], e, n, !0) } } class ePe { constructor() { this._previousTime = 0, this._currentTime = 0, this._startTime = performance.now(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._document = null, this._pageVisibilityHandler = null } connect(e) { this._document = e, e.hidden !== void 0 && (this._pageVisibilityHandler = tPe.bind(this), e.addEventListener("visibilitychange", this._pageVisibilityHandler, !1)) } disconnect() { this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler), this._pageVisibilityHandler = null), this._document = null } getDelta() { return this._delta / 1e3 } getElapsed() { return this._elapsed / 1e3 } getTimescale() { return this._timescale } setTimescale(e) { return this._timescale = e, this } reset() { return this._currentTime = performance.now() - this._startTime, this } dispose() { this.disconnect() } update(e) { return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime, this._currentTime = (e !== void 0 ? e : performance.now()) - this._startTime, this._delta = (this._currentTime - this._previousTime) * this._timescale, this._elapsed += this._delta), this } } function tPe() { this._document.hidden === !1 && this.reset() } class KL { constructor(e = 1, n = 0, r = 0) { this.radius = e, this.phi = n, this.theta = r } set(e, n, r) { return this.radius = e, this.phi = n, this.theta = r, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = In(this.phi, 1e-6, Math.PI - 1e-6), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, n, r) { return this.radius = Math.sqrt(e * e + n * n + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(In(n / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class nPe { constructor(e = 1, n = 0, r = 0) { this.radius = e, this.theta = n, this.y = r } set(e, n, r) { return this.radius = e, this.theta = n, this.y = r, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, n, r) { return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = n, this } clone() { return new this.constructor().copy(this) } } class AB { constructor(e, n, r, i) { AB.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], e !== void 0 && this.set(e, n, r, i) } identity() { return this.set(1, 0, 0, 1), this } fromArray(e, n = 0) { for (let r = 0; r < 4; r++)this.elements[r] = e[r + n]; return this } set(e, n, r, i) { const a = this.elements; return a[0] = e, a[2] = n, a[1] = r, a[3] = i, this } } const _W = new lt; class rPe { constructor(e = new lt(1 / 0, 1 / 0), n = new lt(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = n } set(e, n) { return this.min.copy(e), this.max.copy(n), this } setFromPoints(e) { this.makeEmpty(); for (let n = 0, r = e.length; n < r; n++)this.expandByPoint(e[n]); return this } setFromCenterAndSize(e, n) { const r = _W.copy(n).multiplyScalar(.5); return this.min.copy(e).sub(r), this.max.copy(e).add(r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, n) { return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y } clampPoint(e, n) { return n.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, _W).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const EW = new pe, RM = new pe, yy = new pe, xy = new pe, LR = new pe, iPe = new pe, aPe = new pe; class sPe { constructor(e = new pe, n = new pe) { this.start = e, this.end = n } set(e, n) { return this.start.copy(e), this.end.copy(n), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, n) { return this.delta(n).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, n) { EW.subVectors(e, this.start), RM.subVectors(this.end, this.start); const r = RM.dot(RM); let a = RM.dot(EW) / r; return n && (a = In(a, 0, 1)), a } closestPointToPoint(e, n, r) { const i = this.closestPointToPointParameter(e, n); return this.delta(r).multiplyScalar(i).add(this.start) } distanceSqToLine3(e, n = iPe, r = aPe) { const i = 10000000000000001e-32; let a, s; const o = this.start, c = e.start, u = this.end, d = e.end; yy.subVectors(u, o), xy.subVectors(d, c), LR.subVectors(o, c); const f = yy.dot(yy), h = xy.dot(xy), m = xy.dot(LR); if (f <= i && h <= i) return n.copy(o), r.copy(c), n.sub(r), n.dot(n); if (f <= i) a = 0, s = m / h, s = In(s, 0, 1); else { const g = yy.dot(LR); if (h <= i) s = 0, a = In(-g / f, 0, 1); else { const x = yy.dot(xy), v = f * h - x * x; v !== 0 ? a = In((x * m - g * h) / v, 0, 1) : a = 0, s = (x * a + m) / h, s < 0 ? (s = 0, a = In(-g / f, 0, 1)) : s > 1 && (s = 1, a = In((x - g) / f, 0, 1)) } } return n.copy(o).add(yy.multiplyScalar(a)), r.copy(c).add(xy.multiplyScalar(s)), n.sub(r), n.dot(n) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const MW = new pe; class oPe extends kr { constructor(e, n) { super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper"; const r = new Kn, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let s = 0, o = 1, c = 32; s < c; s++, o++) { const u = s / c * Math.PI * 2, d = o / c * Math.PI * 2; i.push(Math.cos(u), Math.sin(u), 1, Math.cos(d), Math.sin(d), 1) } r.setAttribute("position", new hn(i, 3)); const a = new fo({ fog: !1, toneMapped: !1 }); this.cone = new Ju(r, a), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld); const e = this.light.distance ? this.light.distance : 1e3, n = e * Math.tan(this.light.angle); this.cone.scale.set(n, n, e), MW.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(MW), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const wh = new pe, kM = new Fn, FR = new Fn; class lPe extends Ju { constructor(e) { const n = Cse(e), r = new Kn, i = [], a = []; for (let u = 0; u < n.length; u++) { const d = n[u]; d.parent && d.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), a.push(0, 0, 0), a.push(0, 0, 0)) } r.setAttribute("position", new hn(i, 3)), r.setAttribute("color", new hn(a, 3)); const s = new fo({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(r, s), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = n, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1; const o = new Kt(255), c = new Kt(65280); this.setColors(o, c) } updateMatrixWorld(e) { const n = this.bones, r = this.geometry, i = r.getAttribute("position"); FR.copy(this.root.matrixWorld).invert(); for (let a = 0, s = 0; a < n.length; a++) { const o = n[a]; o.parent && o.parent.isBone && (kM.multiplyMatrices(FR, o.matrixWorld), wh.setFromMatrixPosition(kM), i.setXYZ(s, wh.x, wh.y, wh.z), kM.multiplyMatrices(FR, o.parent.matrixWorld), wh.setFromMatrixPosition(kM), i.setXYZ(s + 1, wh.x, wh.y, wh.z), s += 2) } r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } setColors(e, n) { const i = this.geometry.getAttribute("color"); for (let a = 0; a < i.count; a += 2)i.setXYZ(a, e.r, e.g, e.b), i.setXYZ(a + 1, n.r, n.g, n.b); return i.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } function Cse(t) { const e = []; t.isBone === !0 && e.push(t); for (let n = 0; n < t.children.length; n++)e.push(...Cse(t.children[n])); return e } class cPe extends Bi { constructor(e, n, r) { const i = new p_(n, 4, 2), a = new _f({ wireframe: !0, fog: !1, toneMapped: !1 }); super(i, a), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const uPe = new pe, TW = new Kt, CW = new Kt; class dPe extends kr { constructor(e, n, r) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper"; const i = new h_(n); i.rotateY(Math.PI * .5), this.material = new _f({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const a = i.getAttribute("position"), s = new Float32Array(a.count * 3); i.setAttribute("color", new Lr(s, 3)), this.add(new Bi(i, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const n = e.geometry.getAttribute("color"); TW.copy(this.light.color), CW.copy(this.light.groundColor); for (let r = 0, i = n.count; r < i; r++) { const a = r < i / 2 ? TW : CW; n.setXYZ(r, a.r, a.g, a.b) } n.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(uPe.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class fPe extends Ju { constructor(e = 10, n = 10, r = 4473924, i = 8947848) { r = new Kt(r), i = new Kt(i); const a = n / 2, s = e / n, o = e / 2, c = [], u = []; for (let h = 0, m = 0, g = -o; h <= n; h++, g += s) { c.push(-o, 0, g, o, 0, g), c.push(g, 0, -o, g, 0, o); const x = h === a ? r : i; x.toArray(u, m), m += 3, x.toArray(u, m), m += 3, x.toArray(u, m), m += 3, x.toArray(u, m), m += 3 } const d = new Kn; d.setAttribute("position", new hn(c, 3)), d.setAttribute("color", new hn(u, 3)); const f = new fo({ vertexColors: !0, toneMapped: !1 }); super(d, f), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class hPe extends Ju { constructor(e = 10, n = 16, r = 8, i = 64, a = 4473924, s = 8947848) { a = new Kt(a), s = new Kt(s); const o = [], c = []; if (n > 1) for (let f = 0; f < n; f++) { const h = f / n * (Math.PI * 2), m = Math.sin(h) * e, g = Math.cos(h) * e; o.push(0, 0, 0), o.push(m, 0, g); const x = f & 1 ? a : s; c.push(x.r, x.g, x.b), c.push(x.r, x.g, x.b) } for (let f = 0; f < r; f++) { const h = f & 1 ? a : s, m = e - e / r * f; for (let g = 0; g < i; g++) { let x = g / i * (Math.PI * 2), v = Math.sin(x) * m, b = Math.cos(x) * m; o.push(v, 0, b), c.push(h.r, h.g, h.b), x = (g + 1) / i * (Math.PI * 2), v = Math.sin(x) * m, b = Math.cos(x) * m, o.push(v, 0, b), c.push(h.r, h.g, h.b) } } const u = new Kn; u.setAttribute("position", new hn(o, 3)), u.setAttribute("color", new hn(c, 3)); const d = new fo({ vertexColors: !0, toneMapped: !1 }); super(u, d), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const NW = new pe, IM = new pe, AW = new pe; class pPe extends kr { constructor(e, n, r) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", n === void 0 && (n = 1); let i = new Kn; i.setAttribute("position", new hn([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3)); const a = new fo({ fog: !1, toneMapped: !1 }); this.lightPlane = new ip(i, a), this.add(this.lightPlane), i = new Kn, i.setAttribute("position", new hn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ip(i, a), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), NW.setFromMatrixPosition(this.light.matrixWorld), IM.setFromMatrixPosition(this.light.target.matrixWorld), AW.subVectors(IM, NW), this.lightPlane.lookAt(IM), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(IM), this.targetLine.scale.z = AW.length() } } const OM = new pe, Gi = new o_; class mPe extends Ju { constructor(e) { const n = new Kn, r = new fo({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], a = [], s = {}; o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"); function o(g, x) { c(g), c(x) } function c(g) { i.push(0, 0, 0), a.push(0, 0, 0), s[g] === void 0 && (s[g] = []), s[g].push(i.length / 3 - 1) } n.setAttribute("position", new hn(i, 3)), n.setAttribute("color", new hn(a, 3)), super(n, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update(); const u = new Kt(16755200), d = new Kt(16711680), f = new Kt(43775), h = new Kt(16777215), m = new Kt(3355443); this.setColors(u, d, f, h, m) } setColors(e, n, r, i, a) { const o = this.geometry.getAttribute("color"); return o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, n.r, n.g, n.b), o.setXYZ(25, n.r, n.g, n.b), o.setXYZ(26, n.r, n.g, n.b), o.setXYZ(27, n.r, n.g, n.b), o.setXYZ(28, n.r, n.g, n.b), o.setXYZ(29, n.r, n.g, n.b), o.setXYZ(30, n.r, n.g, n.b), o.setXYZ(31, n.r, n.g, n.b), o.setXYZ(32, r.r, r.g, r.b), o.setXYZ(33, r.r, r.g, r.b), o.setXYZ(34, r.r, r.g, r.b), o.setXYZ(35, r.r, r.g, r.b), o.setXYZ(36, r.r, r.g, r.b), o.setXYZ(37, r.r, r.g, r.b), o.setXYZ(38, i.r, i.g, i.b), o.setXYZ(39, i.r, i.g, i.b), o.setXYZ(40, a.r, a.g, a.b), o.setXYZ(41, a.r, a.g, a.b), o.setXYZ(42, a.r, a.g, a.b), o.setXYZ(43, a.r, a.g, a.b), o.setXYZ(44, a.r, a.g, a.b), o.setXYZ(45, a.r, a.g, a.b), o.setXYZ(46, a.r, a.g, a.b), o.setXYZ(47, a.r, a.g, a.b), o.setXYZ(48, a.r, a.g, a.b), o.setXYZ(49, a.r, a.g, a.b), o.needsUpdate = !0, this } update() { const e = this.geometry, n = this.pointMap, r = 1, i = 1; let a, s; if (Gi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), this.camera.reversedDepth === !0) a = 1, s = 0; else if (this.camera.coordinateSystem === cl) a = -1, s = 1; else if (this.camera.coordinateSystem === Sx) a = 0, s = 1; else throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem); ta("c", n, e, Gi, 0, 0, a), ta("t", n, e, Gi, 0, 0, s), ta("n1", n, e, Gi, -r, -i, a), ta("n2", n, e, Gi, r, -i, a), ta("n3", n, e, Gi, -r, i, a), ta("n4", n, e, Gi, r, i, a), ta("f1", n, e, Gi, -r, -i, s), ta("f2", n, e, Gi, r, -i, s), ta("f3", n, e, Gi, -r, i, s), ta("f4", n, e, Gi, r, i, s), ta("u1", n, e, Gi, r * .7, i * 1.1, a), ta("u2", n, e, Gi, -r * .7, i * 1.1, a), ta("u3", n, e, Gi, 0, i * 2, a), ta("cf1", n, e, Gi, -r, 0, s), ta("cf2", n, e, Gi, r, 0, s), ta("cf3", n, e, Gi, 0, -i, s), ta("cf4", n, e, Gi, 0, i, s), ta("cn1", n, e, Gi, -r, 0, a), ta("cn2", n, e, Gi, r, 0, a), ta("cn3", n, e, Gi, 0, -i, a), ta("cn4", n, e, Gi, 0, i, a), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function ta(t, e, n, r, i, a, s) { OM.set(i, a, s).unproject(r); const o = e[t]; if (o !== void 0) { const c = n.getAttribute("position"); for (let u = 0, d = o.length; u < d; u++)c.setXYZ(o[u], OM.x, OM.y, OM.z) } } const DM = new Ps; class gPe extends Ju { constructor(e, n = 16776960) { const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), a = new Kn; a.setIndex(new Lr(r, 1)), a.setAttribute("position", new Lr(i, 3)), super(a, new fo({ color: n, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update() { if (this.object !== void 0 && DM.setFromObject(this.object), DM.isEmpty()) return; const e = DM.min, n = DM.max, r = this.geometry.attributes.position, i = r.array; i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = e.x, i[4] = n.y, i[5] = n.z, i[6] = e.x, i[7] = e.y, i[8] = n.z, i[9] = n.x, i[10] = e.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = e.z, i[15] = e.x, i[16] = n.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = n.x, i[22] = e.y, i[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, n) { return super.copy(e, n), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class vPe extends Ju { constructor(e, n = 16776960) { const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new Kn; a.setIndex(new Lr(r, 1)), a.setAttribute("position", new hn(i, 3)), super(a, new fo({ color: n, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const n = this.box; n.isEmpty() || (n.getCenter(this.position), n.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class yPe extends ip { constructor(e, n = 1, r = 16776960) { const i = r, a = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new Kn; s.setAttribute("position", new hn(a, 3)), s.computeBoundingSphere(), super(s, new fo({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = n; const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], c = new Kn; c.setAttribute("position", new hn(o, 3)), c.computeBoundingSphere(), this.add(new Bi(c, new _f({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const PW = new pe; let LM, UR; class xPe extends kr { constructor(e = new pe(0, 0, 1), n = new pe(0, 0, 0), r = 1, i = 16776960, a = r * .2, s = a * .2) { super(), this.type = "ArrowHelper", LM === void 0 && (LM = new Kn, LM.setAttribute("position", new hn([0, 0, 0, 0, 1, 0], 3)), UR = new d_(.5, 1, 5, 1), UR.translate(0, -.5, 0)), this.position.copy(n), this.line = new ip(LM, new fo({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Bi(UR, new _f({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, a, s) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { PW.set(e.z, 0, -e.x).normalize(); const n = Math.acos(e.y); this.quaternion.setFromAxisAngle(PW, n) } } setLength(e, n = e * .2, r = n * .2) { this.line.scale.set(1, Math.max(1e-4, e - n), 1), this.line.updateMatrix(), this.cone.scale.set(r, n, r), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class bPe extends Ju { constructor(e = 1) { const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], i = new Kn; i.setAttribute("position", new hn(n, 3)), i.setAttribute("color", new hn(r, 3)); const a = new fo({ vertexColors: !0, toneMapped: !1 }); super(i, a), this.type = "AxesHelper" } setColors(e, n, r) { const i = new Kt, a = this.geometry.attributes.color.array; return i.set(e), i.toArray(a, 0), i.toArray(a, 3), i.set(n), i.toArray(a, 6), i.toArray(a, 9), i.set(r), i.toArray(a, 12), i.toArray(a, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class wPe { constructor() { this.type = "ShapePath", this.color = new Kt, this.subPaths = [], this.currentPath = null } moveTo(e, n) { return this.currentPath = new qC, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, n), this } lineTo(e, n) { return this.currentPath.lineTo(e, n), this } quadraticCurveTo(e, n, r, i) { return this.currentPath.quadraticCurveTo(e, n, r, i), this } bezierCurveTo(e, n, r, i, a, s) { return this.currentPath.bezierCurveTo(e, n, r, i, a, s), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function n(b) { const E = []; for (let M = 0, C = b.length; M < C; M++) { const N = b[M], A = new pg; A.curves = N.curves, E.push(A) } return E } function r(b, E) { const M = E.length; let C = !1; for (let N = M - 1, A = 0; A < M; N = A++) { let j = E[N], O = E[A], I = O.x - j.x, D = O.y - j.y; if (Math.abs(D) > Number.EPSILON) { if (D < 0 && (j = E[A], I = -I, O = E[N], D = -D), b.y < j.y || b.y > O.y) continue; if (b.y === j.y) { if (b.x === j.x) return !0 } else { const F = D * (b.x - j.x) - I * (b.y - j.y); if (F === 0) return !0; if (F < 0) continue; C = !C } } else { if (b.y !== j.y) continue; if (O.x <= b.x && b.x <= j.x || j.x <= b.x && b.x <= O.x) return !0 } } return C } const i = Fc.isClockWise, a = this.subPaths; if (a.length === 0) return []; let s, o, c; const u = []; if (a.length === 1) return o = a[0], c = new pg, c.curves = o.curves, u.push(c), u; let d = !i(a[0].getPoints()); d = e ? !d : d; const f = [], h = []; let m = [], g = 0, x; h[g] = void 0, m[g] = []; for (let b = 0, E = a.length; b < E; b++)o = a[b], x = o.getPoints(), s = i(x), s = e ? !s : s, s ? (!d && h[g] && g++, h[g] = { s: new pg, p: x }, h[g].s.curves = o.curves, d && g++, m[g] = []) : m[g].push({ h: o, p: x[0] }); if (!h[0]) return n(a); if (h.length > 1) { let b = !1, E = 0; for (let M = 0, C = h.length; M < C; M++)f[M] = []; for (let M = 0, C = h.length; M < C; M++) { const N = m[M]; for (let A = 0; A < N.length; A++) { const j = N[A]; let O = !0; for (let I = 0; I < h.length; I++)r(j.p, h[I].p) && (M !== I && E++, O ? (O = !1, f[I].push(j)) : b = !0); O && f[M].push(j) } } E > 0 && b === !1 && (m = f) } let v; for (let b = 0, E = h.length; b < E; b++) { c = h[b].s, u.push(c), v = m[b]; for (let M = 0, C = v.length; M < C; M++)c.holes.push(v[M].h) } return u } } class SPe extends Qu { constructor(e, n = null) { super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null } } connect(e) { if (e === void 0) { console.warn("THREE.Controls: connect() now requires an element."); return } this.domElement !== null && this.disconnect(), this.domElement = e } disconnect() { } dispose() { } update() { } } function _Pe(t, e) { const n = t.image && t.image.width ? t.image.width / t.image.height : 1; return n > e ? (t.repeat.x = 1, t.repeat.y = n / e, t.offset.x = 0, t.offset.y = (1 - t.repeat.y) / 2) : (t.repeat.x = e / n, t.repeat.y = 1, t.offset.x = (1 - t.repeat.x) / 2, t.offset.y = 0), t } function EPe(t, e) { const n = t.image && t.image.width ? t.image.width / t.image.height : 1; return n > e ? (t.repeat.x = e / n, t.repeat.y = 1, t.offset.x = (1 - t.repeat.x) / 2, t.offset.y = 0) : (t.repeat.x = 1, t.repeat.y = n / e, t.offset.x = 0, t.offset.y = (1 - t.repeat.y) / 2), t } function MPe(t) { return t.repeat.x = 1, t.repeat.y = 1, t.offset.x = 0, t.offset.y = 0, t } function ZL(t, e, n, r) { const i = TPe(r); switch (n) { case XU: return t * e; case a_: return t * e / i.components * i.byteLength; case s_: return t * e / i.components * i.byteLength; case KU: return t * e * 2 / i.components * i.byteLength; case WA: return t * e * 2 / i.components * i.byteLength; case YU: return t * e * 3 / i.components * i.byteLength; case ia: return t * e * 4 / i.components * i.byteLength; case GA: return t * e * 4 / i.components * i.byteLength; case qw: case Xw: return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8; case Yw: case Kw: return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16; case gC: case yC: return Math.max(t, 16) * Math.max(e, 8) / 4; case mC: case vC: return Math.max(t, 8) * Math.max(e, 8) / 2; case xC: case bC: return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8; case wC: return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16; case SC: return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16; case _C: return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16; case EC: return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16; case MC: return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16; case TC: return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16; case CC: return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16; case NC: return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16; case AC: return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16; case PC: return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16; case jC: return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16; case RC: return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16; case kC: return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16; case IC: return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16; case OC: return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16; case DC: case LC: case FC: return Math.ceil(t / 4) * Math.ceil(e / 4) * 16; case UC: case BC: return Math.ceil(t / 4) * Math.ceil(e / 4) * 8; case $C: case zC: return Math.ceil(t / 4) * Math.ceil(e / 4) * 16 }throw new Error(`Unable to determine texture byte length for ${n} format.`) } function TPe(t) { switch (t) { case lo: case $A: return { byteLength: 1, components: 1 }; case yx: case zA: case Ya: return { byteLength: 2, components: 1 }; case VA: case HA: return { byteLength: 2, components: 4 }; case zu: case i_: case Ui: return { byteLength: 4, components: 1 }; case GU: case qU: return { byteLength: 4, components: 3 } }throw new Error(`Unknown texture type ${t}.`) } class CPe { static contain(e, n) { return _Pe(e, n) } static cover(e, n) { return EPe(e, n) } static fill(e) { return MPe(e) } static getByteLength(e, n, r, i) { return ZL(e, n, r, i) } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: n_ } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n_);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function Nse() { let t = null, e = !1, n = null, r = null; function i(a, s) { n(a, s), r = t.requestAnimationFrame(i) } return { start: function () { e !== !0 && n !== null && (r = t.requestAnimationFrame(i), e = !0) }, stop: function () { t.cancelAnimationFrame(r), e = !1 }, setAnimationLoop: function (a) { n = a }, setContext: function (a) { t = a } } } function NPe(t) { const e = new WeakMap; function n(o, c) { const u = o.array, d = o.usage, f = u.byteLength, h = t.createBuffer(); t.bindBuffer(c, h), t.bufferData(c, u, d), o.onUploadCallback(); let m; if (u instanceof Float32Array) m = t.FLOAT; else if (typeof Float16Array < "u" && u instanceof Float16Array) m = t.HALF_FLOAT; else if (u instanceof Uint16Array) o.isFloat16BufferAttribute ? m = t.HALF_FLOAT : m = t.UNSIGNED_SHORT; else if (u instanceof Int16Array) m = t.SHORT; else if (u instanceof Uint32Array) m = t.UNSIGNED_INT; else if (u instanceof Int32Array) m = t.INT; else if (u instanceof Int8Array) m = t.BYTE; else if (u instanceof Uint8Array) m = t.UNSIGNED_BYTE; else if (u instanceof Uint8ClampedArray) m = t.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u); return { buffer: h, type: m, bytesPerElement: u.BYTES_PER_ELEMENT, version: o.version, size: f } } function r(o, c, u) { const d = c.array, f = c.updateRanges; if (t.bindBuffer(u, o), f.length === 0) t.bufferSubData(u, 0, d); else { f.sort((m, g) => m.start - g.start); let h = 0; for (let m = 1; m < f.length; m++) { const g = f[h], x = f[m]; x.start <= g.start + g.count + 1 ? g.count = Math.max(g.count, x.start + x.count - g.start) : (++h, f[h] = x) } f.length = h + 1; for (let m = 0, g = f.length; m < g; m++) { const x = f[m]; t.bufferSubData(u, x.start * d.BYTES_PER_ELEMENT, d, x.start, x.count) } c.clearUpdateRanges() } c.onUploadCallback() } function i(o) { return o.isInterleavedBufferAttribute && (o = o.data), e.get(o) } function a(o) { o.isInterleavedBufferAttribute && (o = o.data); const c = e.get(o); c && (t.deleteBuffer(c.buffer), e.delete(o)) } function s(o, c) { if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) { const d = e.get(o); (!d || d.version < o.version) && e.set(o, { buffer: o.buffer, type: o.type, bytesPerElement: o.elementSize, version: o.version }); return } const u = e.get(o); if (u === void 0) e.set(o, n(o, c)); else if (u.version < o.version) { if (u.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); r(u.buffer, o, c), u.version = o.version } } return { get: i, remove: a, update: s } } var APe = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, PPe = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, jPe = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, RPe = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, kPe = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, IPe = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, OPe = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, DPe = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, LPe = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, FPe = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, UPe = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, BPe = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, $Pe = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, zPe = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, VPe = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, HPe = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, WPe = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, GPe = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, qPe = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, XPe = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, YPe = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, KPe = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, ZPe = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, QPe = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, JPe = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, eje = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, tje = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, nje = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, rje = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ije = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, aje = "gl_FragColor = linearToOutputTexel( gl_FragColor );", sje = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, oje = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, lje = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, cje = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, uje = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, dje = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fje = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, hje = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, pje = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, mje = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gje = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, vje = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, yje = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, xje = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, bje = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, wje = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Sje = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, _je = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Eje = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Mje = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Tje = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Cje = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Nje = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Aje = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Pje = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, jje = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Rje = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, kje = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Ije = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Oje = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Dje = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Lje = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Fje = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Uje = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Bje = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, $je = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, zje = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Vje = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Hje = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Wje = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Gje = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, qje = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Xje = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Yje = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Kje = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Zje = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Qje = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Jje = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, eRe = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, tRe = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, nRe = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, rRe = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, iRe = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, aRe = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, sRe = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, oRe = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, lRe = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, cRe = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, uRe = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, dRe = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, fRe = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, hRe = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, pRe = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, mRe = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, gRe = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, vRe = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, yRe = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, xRe = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, bRe = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, wRe = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, SRe = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, _Re = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, ERe = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, MRe = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, TRe = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, CRe = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const NRe = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, ARe = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, PRe = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, jRe = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, RRe = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, kRe = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, IRe = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, ORe = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, DRe = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, LRe = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, FRe = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, URe = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, BRe = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, $Re = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, zRe = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, VRe = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, HRe = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, WRe = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, GRe = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, qRe = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XRe = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, YRe = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, KRe = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ZRe = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, QRe = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, JRe = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, eke = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, tke = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, nke = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, rke = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, ike = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ake = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, ske = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, oke = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, lr = { alphahash_fragment: APe, alphahash_pars_fragment: PPe, alphamap_fragment: jPe, alphamap_pars_fragment: RPe, alphatest_fragment: kPe, alphatest_pars_fragment: IPe, aomap_fragment: OPe, aomap_pars_fragment: DPe, batching_pars_vertex: LPe, batching_vertex: FPe, begin_vertex: UPe, beginnormal_vertex: BPe, bsdfs: $Pe, iridescence_fragment: zPe, bumpmap_pars_fragment: VPe, clipping_planes_fragment: HPe, clipping_planes_pars_fragment: WPe, clipping_planes_pars_vertex: GPe, clipping_planes_vertex: qPe, color_fragment: XPe, color_pars_fragment: YPe, color_pars_vertex: KPe, color_vertex: ZPe, common: QPe, cube_uv_reflection_fragment: JPe, defaultnormal_vertex: eje, displacementmap_pars_vertex: tje, displacementmap_vertex: nje, emissivemap_fragment: rje, emissivemap_pars_fragment: ije, colorspace_fragment: aje, colorspace_pars_fragment: sje, envmap_fragment: oje, envmap_common_pars_fragment: lje, envmap_pars_fragment: cje, envmap_pars_vertex: uje, envmap_physical_pars_fragment: wje, envmap_vertex: dje, fog_vertex: fje, fog_pars_vertex: hje, fog_fragment: pje, fog_pars_fragment: mje, gradientmap_pars_fragment: gje, lightmap_pars_fragment: vje, lights_lambert_fragment: yje, lights_lambert_pars_fragment: xje, lights_pars_begin: bje, lights_toon_fragment: Sje, lights_toon_pars_fragment: _je, lights_phong_fragment: Eje, lights_phong_pars_fragment: Mje, lights_physical_fragment: Tje, lights_physical_pars_fragment: Cje, lights_fragment_begin: Nje, lights_fragment_maps: Aje, lights_fragment_end: Pje, logdepthbuf_fragment: jje, logdepthbuf_pars_fragment: Rje, logdepthbuf_pars_vertex: kje, logdepthbuf_vertex: Ije, map_fragment: Oje, map_pars_fragment: Dje, map_particle_fragment: Lje, map_particle_pars_fragment: Fje, metalnessmap_fragment: Uje, metalnessmap_pars_fragment: Bje, morphinstance_vertex: $je, morphcolor_vertex: zje, morphnormal_vertex: Vje, morphtarget_pars_vertex: Hje, morphtarget_vertex: Wje, normal_fragment_begin: Gje, normal_fragment_maps: qje, normal_pars_fragment: Xje, normal_pars_vertex: Yje, normal_vertex: Kje, normalmap_pars_fragment: Zje, clearcoat_normal_fragment_begin: Qje, clearcoat_normal_fragment_maps: Jje, clearcoat_pars_fragment: eRe, iridescence_pars_fragment: tRe, opaque_fragment: nRe, packing: rRe, premultiplied_alpha_fragment: iRe, project_vertex: aRe, dithering_fragment: sRe, dithering_pars_fragment: oRe, roughnessmap_fragment: lRe, roughnessmap_pars_fragment: cRe, shadowmap_pars_fragment: uRe, shadowmap_pars_vertex: dRe, shadowmap_vertex: fRe, shadowmask_pars_fragment: hRe, skinbase_vertex: pRe, skinning_pars_vertex: mRe, skinning_vertex: gRe, skinnormal_vertex: vRe, specularmap_fragment: yRe, specularmap_pars_fragment: xRe, tonemapping_fragment: bRe, tonemapping_pars_fragment: wRe, transmission_fragment: SRe, transmission_pars_fragment: _Re, uv_pars_fragment: ERe, uv_pars_vertex: MRe, uv_vertex: TRe, worldpos_vertex: CRe, background_vert: NRe, background_frag: ARe, backgroundCube_vert: PRe, backgroundCube_frag: jRe, cube_vert: RRe, cube_frag: kRe, depth_vert: IRe, depth_frag: ORe, distanceRGBA_vert: DRe, distanceRGBA_frag: LRe, equirect_vert: FRe, equirect_frag: URe, linedashed_vert: BRe, linedashed_frag: $Re, meshbasic_vert: zRe, meshbasic_frag: VRe, meshlambert_vert: HRe, meshlambert_frag: WRe, meshmatcap_vert: GRe, meshmatcap_frag: qRe, meshnormal_vert: XRe, meshnormal_frag: YRe, meshphong_vert: KRe, meshphong_frag: ZRe, meshphysical_vert: QRe, meshphysical_frag: JRe, meshtoon_vert: eke, meshtoon_frag: tke, points_vert: nke, points_frag: rke, shadow_vert: ike, shadow_frag: ake, sprite_vert: ske, sprite_frag: oke }, Wt = { common: { diffuse: { value: new Kt(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Qn }, alphaMap: { value: null }, alphaMapTransform: { value: new Qn }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Qn } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Qn }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Qn } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Qn } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Qn }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Qn }, normalScale: { value: new lt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Qn }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Qn } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Qn } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Qn } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Kt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Kt(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Qn }, alphaTest: { value: 0 }, uvTransform: { value: new Qn } }, sprite: { diffuse: { value: new Kt(16777215) }, opacity: { value: 1 }, center: { value: new lt(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Qn }, alphaMap: { value: null }, alphaMapTransform: { value: new Qn }, alphaTest: { value: 0 } } }, Ic = { basic: { uniforms: Ws([Wt.common, Wt.specularmap, Wt.envmap, Wt.aomap, Wt.lightmap, Wt.fog]), vertexShader: lr.meshbasic_vert, fragmentShader: lr.meshbasic_frag }, lambert: { uniforms: Ws([Wt.common, Wt.specularmap, Wt.envmap, Wt.aomap, Wt.lightmap, Wt.emissivemap, Wt.bumpmap, Wt.normalmap, Wt.displacementmap, Wt.fog, Wt.lights, { emissive: { value: new Kt(0) } }]), vertexShader: lr.meshlambert_vert, fragmentShader: lr.meshlambert_frag }, phong: { uniforms: Ws([Wt.common, Wt.specularmap, Wt.envmap, Wt.aomap, Wt.lightmap, Wt.emissivemap, Wt.bumpmap, Wt.normalmap, Wt.displacementmap, Wt.fog, Wt.lights, { emissive: { value: new Kt(0) }, specular: { value: new Kt(1118481) }, shininess: { value: 30 } }]), vertexShader: lr.meshphong_vert, fragmentShader: lr.meshphong_frag }, standard: { uniforms: Ws([Wt.common, Wt.envmap, Wt.aomap, Wt.lightmap, Wt.emissivemap, Wt.bumpmap, Wt.normalmap, Wt.displacementmap, Wt.roughnessmap, Wt.metalnessmap, Wt.fog, Wt.lights, { emissive: { value: new Kt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: lr.meshphysical_vert, fragmentShader: lr.meshphysical_frag }, toon: { uniforms: Ws([Wt.common, Wt.aomap, Wt.lightmap, Wt.emissivemap, Wt.bumpmap, Wt.normalmap, Wt.displacementmap, Wt.gradientmap, Wt.fog, Wt.lights, { emissive: { value: new Kt(0) } }]), vertexShader: lr.meshtoon_vert, fragmentShader: lr.meshtoon_frag }, matcap: { uniforms: Ws([Wt.common, Wt.bumpmap, Wt.normalmap, Wt.displacementmap, Wt.fog, { matcap: { value: null } }]), vertexShader: lr.meshmatcap_vert, fragmentShader: lr.meshmatcap_frag }, points: { uniforms: Ws([Wt.points, Wt.fog]), vertexShader: lr.points_vert, fragmentShader: lr.points_frag }, dashed: { uniforms: Ws([Wt.common, Wt.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: lr.linedashed_vert, fragmentShader: lr.linedashed_frag }, depth: { uniforms: Ws([Wt.common, Wt.displacementmap]), vertexShader: lr.depth_vert, fragmentShader: lr.depth_frag }, normal: { uniforms: Ws([Wt.common, Wt.bumpmap, Wt.normalmap, Wt.displacementmap, { opacity: { value: 1 } }]), vertexShader: lr.meshnormal_vert, fragmentShader: lr.meshnormal_frag }, sprite: { uniforms: Ws([Wt.sprite, Wt.fog]), vertexShader: lr.sprite_vert, fragmentShader: lr.sprite_frag }, background: { uniforms: { uvTransform: { value: new Qn }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: lr.background_vert, fragmentShader: lr.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Qn } }, vertexShader: lr.backgroundCube_vert, fragmentShader: lr.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: lr.cube_vert, fragmentShader: lr.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: lr.equirect_vert, fragmentShader: lr.equirect_frag }, distanceRGBA: { uniforms: Ws([Wt.common, Wt.displacementmap, { referencePosition: { value: new pe }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: lr.distanceRGBA_vert, fragmentShader: lr.distanceRGBA_frag }, shadow: { uniforms: Ws([Wt.lights, Wt.fog, { color: { value: new Kt(0) }, opacity: { value: 1 } }]), vertexShader: lr.shadow_vert, fragmentShader: lr.shadow_frag } }; Ic.physical = { uniforms: Ws([Ic.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Qn }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Qn }, clearcoatNormalScale: { value: new lt(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Qn }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Qn }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Qn }, sheen: { value: 0 }, sheenColor: { value: new Kt(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Qn }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Qn }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Qn }, transmissionSamplerSize: { value: new lt }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Qn }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Kt(0) }, specularColor: { value: new Kt(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Qn }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Qn }, anisotropyVector: { value: new lt }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Qn } }]), vertexShader: lr.meshphysical_vert, fragmentShader: lr.meshphysical_frag }; const FM = { r: 0, b: 0, g: 0 }, Pm = new ml, lke = new Fn; function cke(t, e, n, r, i, a, s) { const o = new Kt(0); let c = a === !0 ? 0 : 1, u, d, f = null, h = 0, m = null; function g(M) { let C = M.isScene === !0 ? M.background : null; return C && C.isTexture && (C = (M.backgroundBlurriness > 0 ? n : e).get(C)), C } function x(M) { let C = !1; const N = g(M); N === null ? b(o, c) : N && N.isColor && (b(N, 1), C = !0); const A = t.xr.getEnvironmentBlendMode(); A === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, s) : A === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s), (t.autoClear || C) && (r.buffers.depth.setTest(!0), r.buffers.depth.setMask(!0), r.buffers.color.setMask(!0), t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil)) } function v(M, C) { const N = g(C); N && (N.isCubeTexture || N.mapping === C0) ? (d === void 0 && (d = new Bi(new Wg(1, 1, 1), new Bo({ name: "BackgroundCubeMaterial", uniforms: Ex(Ic.backgroundCube.uniforms), vertexShader: Ic.backgroundCube.vertexShader, fragmentShader: Ic.backgroundCube.fragmentShader, side: io, depthTest: !1, depthWrite: !1, fog: !1, allowOverride: !1 })), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function (A, j, O) { this.matrixWorld.copyPosition(O.matrixWorld) }, Object.defineProperty(d.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(d)), Pm.copy(C.backgroundRotation), Pm.x *= -1, Pm.y *= -1, Pm.z *= -1, N.isCubeTexture && N.isRenderTargetTexture === !1 && (Pm.y *= -1, Pm.z *= -1), d.material.uniforms.envMap.value = N, d.material.uniforms.flipEnvMap.value = N.isCubeTexture && N.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = C.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = C.backgroundIntensity, d.material.uniforms.backgroundRotation.value.setFromMatrix4(lke.makeRotationFromEuler(Pm)), d.material.toneMapped = Nr.getTransfer(N.colorSpace) !== Wr, (f !== N || h !== N.version || m !== t.toneMapping) && (d.material.needsUpdate = !0, f = N, h = N.version, m = t.toneMapping), d.layers.enableAll(), M.unshift(d, d.geometry, d.material, 0, 0, null)) : N && N.isTexture && (u === void 0 && (u = new Bi(new vp(2, 2), new Bo({ name: "BackgroundMaterial", uniforms: Ex(Ic.background.uniforms), vertexShader: Ic.background.vertexShader, fragmentShader: Ic.background.fragmentShader, side: yf, depthTest: !1, depthWrite: !1, fog: !1, allowOverride: !1 })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(u)), u.material.uniforms.t2D.value = N, u.material.uniforms.backgroundIntensity.value = C.backgroundIntensity, u.material.toneMapped = Nr.getTransfer(N.colorSpace) !== Wr, N.matrixAutoUpdate === !0 && N.updateMatrix(), u.material.uniforms.uvTransform.value.copy(N.matrix), (f !== N || h !== N.version || m !== t.toneMapping) && (u.material.needsUpdate = !0, f = N, h = N.version, m = t.toneMapping), u.layers.enableAll(), M.unshift(u, u.geometry, u.material, 0, 0, null)) } function b(M, C) { M.getRGB(FM, Tae(t)), r.buffers.color.setClear(FM.r, FM.g, FM.b, C, s) } function E() { d !== void 0 && (d.geometry.dispose(), d.material.dispose(), d = void 0), u !== void 0 && (u.geometry.dispose(), u.material.dispose(), u = void 0) } return { getClearColor: function () { return o }, setClearColor: function (M, C = 1) { o.set(M), c = C, b(o, c) }, getClearAlpha: function () { return c }, setClearAlpha: function (M) { c = M, b(o, c) }, render: x, addToRenderList: v, dispose: E } } function uke(t, e) { const n = t.getParameter(t.MAX_VERTEX_ATTRIBS), r = {}, i = h(null); let a = i, s = !1; function o(D, F, B, G, z) { let q = !1; const Y = f(G, B, F); a !== Y && (a = Y, u(a.object)), q = m(D, G, B, z), q && g(D, G, B, z), z !== null && e.update(z, t.ELEMENT_ARRAY_BUFFER), (q || s) && (s = !1, C(D, F, B, G), z !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(z).buffer)) } function c() { return t.createVertexArray() } function u(D) { return t.bindVertexArray(D) } function d(D) { return t.deleteVertexArray(D) } function f(D, F, B) { const G = B.wireframe === !0; let z = r[D.id]; z === void 0 && (z = {}, r[D.id] = z); let q = z[F.id]; q === void 0 && (q = {}, z[F.id] = q); let Y = q[G]; return Y === void 0 && (Y = h(c()), q[G] = Y), Y } function h(D) { const F = [], B = [], G = []; for (let z = 0; z < n; z++)F[z] = 0, B[z] = 0, G[z] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: F, enabledAttributes: B, attributeDivisors: G, object: D, attributes: {}, index: null } } function m(D, F, B, G) { const z = a.attributes, q = F.attributes; let Y = 0; const Z = B.getAttributes(); for (const $ in Z) if (Z[$].location >= 0) { const K = z[$]; let X = q[$]; if (X === void 0 && ($ === "instanceMatrix" && D.instanceMatrix && (X = D.instanceMatrix), $ === "instanceColor" && D.instanceColor && (X = D.instanceColor)), K === void 0 || K.attribute !== X || X && K.data !== X.data) return !0; Y++ } return a.attributesNum !== Y || a.index !== G } function g(D, F, B, G) { const z = {}, q = F.attributes; let Y = 0; const Z = B.getAttributes(); for (const $ in Z) if (Z[$].location >= 0) { let K = q[$]; K === void 0 && ($ === "instanceMatrix" && D.instanceMatrix && (K = D.instanceMatrix), $ === "instanceColor" && D.instanceColor && (K = D.instanceColor)); const X = {}; X.attribute = K, K && K.data && (X.data = K.data), z[$] = X, Y++ } a.attributes = z, a.attributesNum = Y, a.index = G } function x() { const D = a.newAttributes; for (let F = 0, B = D.length; F < B; F++)D[F] = 0 } function v(D) { b(D, 0) } function b(D, F) { const B = a.newAttributes, G = a.enabledAttributes, z = a.attributeDivisors; B[D] = 1, G[D] === 0 && (t.enableVertexAttribArray(D), G[D] = 1), z[D] !== F && (t.vertexAttribDivisor(D, F), z[D] = F) } function E() { const D = a.newAttributes, F = a.enabledAttributes; for (let B = 0, G = F.length; B < G; B++)F[B] !== D[B] && (t.disableVertexAttribArray(B), F[B] = 0) } function M(D, F, B, G, z, q, Y) { Y === !0 ? t.vertexAttribIPointer(D, F, B, z, q) : t.vertexAttribPointer(D, F, B, G, z, q) } function C(D, F, B, G) { x(); const z = G.attributes, q = B.getAttributes(), Y = F.defaultAttributeValues; for (const Z in q) { const $ = q[Z]; if ($.location >= 0) { let V = z[Z]; if (V === void 0 && (Z === "instanceMatrix" && D.instanceMatrix && (V = D.instanceMatrix), Z === "instanceColor" && D.instanceColor && (V = D.instanceColor)), V !== void 0) { const K = V.normalized, X = V.itemSize, Q = e.get(V); if (Q === void 0) continue; const re = Q.buffer, ce = Q.type, be = Q.bytesPerElement, de = ce === t.INT || ce === t.UNSIGNED_INT || V.gpuType === i_; if (V.isInterleavedBufferAttribute) { const ae = V.data, se = ae.stride, he = V.offset; if (ae.isInstancedInterleavedBuffer) { for (let Ae = 0; Ae < $.locationSize; Ae++)b($.location + Ae, ae.meshPerAttribute); D.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = ae.meshPerAttribute * ae.count) } else for (let Ae = 0; Ae < $.locationSize; Ae++)v($.location + Ae); t.bindBuffer(t.ARRAY_BUFFER, re); for (let Ae = 0; Ae < $.locationSize; Ae++)M($.location + Ae, X / $.locationSize, ce, K, se * be, (he + X / $.locationSize * Ae) * be, de) } else { if (V.isInstancedBufferAttribute) { for (let ae = 0; ae < $.locationSize; ae++)b($.location + ae, V.meshPerAttribute); D.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = V.meshPerAttribute * V.count) } else for (let ae = 0; ae < $.locationSize; ae++)v($.location + ae); t.bindBuffer(t.ARRAY_BUFFER, re); for (let ae = 0; ae < $.locationSize; ae++)M($.location + ae, X / $.locationSize, ce, K, X * be, X / $.locationSize * ae * be, de) } } else if (Y !== void 0) { const K = Y[Z]; if (K !== void 0) switch (K.length) { case 2: t.vertexAttrib2fv($.location, K); break; case 3: t.vertexAttrib3fv($.location, K); break; case 4: t.vertexAttrib4fv($.location, K); break; default: t.vertexAttrib1fv($.location, K) } } } } E() } function N() { O(); for (const D in r) { const F = r[D]; for (const B in F) { const G = F[B]; for (const z in G) d(G[z].object), delete G[z]; delete F[B] } delete r[D] } } function A(D) { if (r[D.id] === void 0) return; const F = r[D.id]; for (const B in F) { const G = F[B]; for (const z in G) d(G[z].object), delete G[z]; delete F[B] } delete r[D.id] } function j(D) { for (const F in r) { const B = r[F]; if (B[D.id] === void 0) continue; const G = B[D.id]; for (const z in G) d(G[z].object), delete G[z]; delete B[D.id] } } function O() { I(), s = !0, a !== i && (a = i, u(a.object)) } function I() { i.geometry = null, i.program = null, i.wireframe = !1 } return { setup: o, reset: O, resetDefaultState: I, dispose: N, releaseStatesOfGeometry: A, releaseStatesOfProgram: j, initAttributes: x, enableAttribute: v, disableUnusedAttributes: E } } function dke(t, e, n) { let r; function i(u) { r = u } function a(u, d) { t.drawArrays(r, u, d), n.update(d, r, 1) } function s(u, d, f) { f !== 0 && (t.drawArraysInstanced(r, u, d, f), n.update(d, r, f)) } function o(u, d, f) { if (f === 0) return; e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, u, 0, d, 0, f); let m = 0; for (let g = 0; g < f; g++)m += d[g]; n.update(m, r, 1) } function c(u, d, f, h) { if (f === 0) return; const m = e.get("WEBGL_multi_draw"); if (m === null) for (let g = 0; g < u.length; g++)s(u[g], d[g], h[g]); else { m.multiDrawArraysInstancedWEBGL(r, u, 0, d, 0, h, 0, f); let g = 0; for (let x = 0; x < f; x++)g += d[x] * h[x]; n.update(g, r, 1) } } this.setMode = i, this.render = a, this.renderInstances = s, this.renderMultiDraw = o, this.renderMultiDrawInstances = c } function fke(t, e, n, r) { let i; function a() { if (i !== void 0) return i; if (e.has("EXT_texture_filter_anisotropic") === !0) { const j = e.get("EXT_texture_filter_anisotropic"); i = t.getParameter(j.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i } function s(j) { return !(j !== ia && r.convert(j) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)) } function o(j) { const O = j === Ya && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float")); return !(j !== lo && r.convert(j) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) && j !== Ui && !O) } function c(j) { if (j === "highp") { if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp"; j = "mediump" } return j === "mediump" && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let u = n.precision !== void 0 ? n.precision : "highp"; const d = c(u); d !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", d, "instead."), u = d); const f = n.logarithmicDepthBuffer === !0, h = n.reversedDepthBuffer === !0 && e.has("EXT_clip_control"), m = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), g = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), x = t.getParameter(t.MAX_TEXTURE_SIZE), v = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), b = t.getParameter(t.MAX_VERTEX_ATTRIBS), E = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), M = t.getParameter(t.MAX_VARYING_VECTORS), C = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), N = g > 0, A = t.getParameter(t.MAX_SAMPLES); return { isWebGL2: !0, getMaxAnisotropy: a, getMaxPrecision: c, textureFormatReadable: s, textureTypeReadable: o, precision: u, logarithmicDepthBuffer: f, reversedDepthBuffer: h, maxTextures: m, maxVertexTextures: g, maxTextureSize: x, maxCubemapSize: v, maxAttributes: b, maxVertexUniforms: E, maxVaryings: M, maxFragmentUniforms: C, vertexTextures: N, maxSamples: A } } function hke(t) { const e = this; let n = null, r = 0, i = !1, a = !1; const s = new Yd, o = new Qn, c = { value: null, needsUpdate: !1 }; this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (f, h) { const m = f.length !== 0 || h || r !== 0 || i; return i = h, r = f.length, m }, this.beginShadows = function () { a = !0, d(null) }, this.endShadows = function () { a = !1 }, this.setGlobalState = function (f, h) { n = d(f, h, 0) }, this.setState = function (f, h, m) { const g = f.clippingPlanes, x = f.clipIntersection, v = f.clipShadows, b = t.get(f); if (!i || g === null || g.length === 0 || a && !v) a ? d(null) : u(); else { const E = a ? 0 : r, M = E * 4; let C = b.clippingState || null; c.value = C, C = d(g, h, M, m); for (let N = 0; N !== M; ++N)C[N] = n[N]; b.clippingState = C, this.numIntersection = x ? this.numPlanes : 0, this.numPlanes += E } }; function u() { c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0 } function d(f, h, m, g) { const x = f !== null ? f.length : 0; let v = null; if (x !== 0) { if (v = c.value, g !== !0 || v === null) { const b = m + x * 4, E = h.matrixWorldInverse; o.getNormalMatrix(E), (v === null || v.length < b) && (v = new Float32Array(b)); for (let M = 0, C = m; M !== x; ++M, C += 4)s.copy(f[M]).applyMatrix4(E, o), s.normal.toArray(v, C), v[C + 3] = s.constant } c.value = v, c.needsUpdate = !0 } return e.numPlanes = x, e.numIntersection = 0, v } } function pke(t) { let e = new WeakMap; function n(s, o) { return o === vx ? s.mapping = $u : o === P1 && (s.mapping = rp), s } function r(s) { if (s && s.isTexture) { const o = s.mapping; if (o === vx || o === P1) if (e.has(s)) { const c = e.get(s).texture; return n(c, s.mapping) } else { const c = s.image; if (c && c.height > 0) { const u = new rB(c.height); return u.fromEquirectangularTexture(t, s), e.set(s, u), s.addEventListener("dispose", i), n(u.texture, s.mapping) } else return null } } return s } function i(s) { const o = s.target; o.removeEventListener("dispose", i); const c = e.get(o); c !== void 0 && (e.delete(o), c.dispose()) } function a() { e = new WeakMap } return { get: r, dispose: a } } const $y = 4, jW = [.125, .215, .35, .446, .526, .582], Hm = 20, BR = new of, RW = new Kt; let $R = null, zR = 0, VR = 0, HR = !1; const Bm = (1 + Math.sqrt(5)) / 2, by = 1 / Bm, kW = [new pe(-Bm, by, 0), new pe(Bm, by, 0), new pe(-by, 0, Bm), new pe(by, 0, Bm), new pe(0, Bm, -by), new pe(0, Bm, by), new pe(-1, 1, -1), new pe(1, 1, -1), new pe(-1, 1, 1), new pe(1, 1, 1)], mke = new pe; class QL { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, n = 0, r = .1, i = 100, a = {}) { const { size: s = 256, position: o = mke } = a; $R = this._renderer.getRenderTarget(), zR = this._renderer.getActiveCubeFace(), VR = this._renderer.getActiveMipmapLevel(), HR = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(s); const c = this._allocateTargets(); return c.depthBuffer = !0, this._sceneToCubeUV(e, r, i, c, o), n > 0 && this._blur(c, 0, 0, n), this._applyPMREM(c), this._cleanup(c), c } fromEquirectangular(e, n = null) { return this._fromTexture(e, n) } fromCubemap(e, n = null) { return this._fromTexture(e, n) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = DW(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = OW(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget($R, zR, VR), this._renderer.xr.enabled = HR, e.scissorTest = !1, UM(e, 0, 0, e.width, e.height) } _fromTexture(e, n) { e.mapping === $u || e.mapping === rp ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), $R = this._renderer.getRenderTarget(), zR = this._renderer.getActiveCubeFace(), VR = this._renderer.getActiveMipmapLevel(), HR = this._renderer.xr.enabled, this._renderer.xr.enabled = !1; const r = n || this._allocateTargets(); return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, r = { magFilter: Xr, minFilter: Xr, generateMipmaps: !1, type: Ya, format: ia, colorSpace: Vu, depthBuffer: !1 }, i = IW(e, n, r); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = IW(e, n, r); const { _lodMax: a } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = gke(a)), this._blurMaterial = vke(a, e, n) } return i } _compileMaterial(e) { const n = new Bi(this._lodPlanes[0], e); this._renderer.compile(n, BR) } _sceneToCubeUV(e, n, r, i, a) { const c = new ra(90, 1, n, r), u = [1, -1, 1, 1, 1, 1], d = [1, 1, 1, -1, -1, -1], f = this._renderer, h = f.autoClear, m = f.toneMapping; f.getClearColor(RW), f.toneMapping = ju, f.autoClear = !1, f.state.buffers.depth.getReversed() && (f.setRenderTarget(i), f.clearDepth(), f.setRenderTarget(null)); const x = new _f({ name: "PMREM.Background", side: io, depthWrite: !1, depthTest: !1 }), v = new Bi(new Wg, x); let b = !1; const E = e.background; E ? E.isColor && (x.color.copy(E), e.background = null, b = !0) : (x.color.copy(RW), b = !0); for (let M = 0; M < 6; M++) { const C = M % 3; C === 0 ? (c.up.set(0, u[M], 0), c.position.set(a.x, a.y, a.z), c.lookAt(a.x + d[M], a.y, a.z)) : C === 1 ? (c.up.set(0, 0, u[M]), c.position.set(a.x, a.y, a.z), c.lookAt(a.x, a.y + d[M], a.z)) : (c.up.set(0, u[M], 0), c.position.set(a.x, a.y, a.z), c.lookAt(a.x, a.y, a.z + d[M])); const N = this._cubeSize; UM(i, C * N, M > 2 ? N : 0, N, N), f.setRenderTarget(i), b && f.render(v, c), f.render(e, c) } v.geometry.dispose(), v.material.dispose(), f.toneMapping = m, f.autoClear = h, e.background = E } _textureToCubeUV(e, n) { const r = this._renderer, i = e.mapping === $u || e.mapping === rp; i ? (this._cubemapMaterial === null && (this._cubemapMaterial = DW()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = OW()); const a = i ? this._cubemapMaterial : this._equirectMaterial, s = new Bi(this._lodPlanes[0], a), o = a.uniforms; o.envMap.value = e; const c = this._cubeSize; UM(n, 0, 0, 3 * c, 2 * c), r.setRenderTarget(n), r.render(s, BR) } _applyPMREM(e) { const n = this._renderer, r = n.autoClear; n.autoClear = !1; const i = this._lodPlanes.length; for (let a = 1; a < i; a++) { const s = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), o = kW[(i - a - 1) % kW.length]; this._blur(e, a - 1, a, s, o) } n.autoClear = r } _blur(e, n, r, i, a) { const s = this._pingPongRenderTarget; this._halfBlur(e, s, n, r, i, "latitudinal", a), this._halfBlur(s, e, r, r, i, "longitudinal", a) } _halfBlur(e, n, r, i, a, s, o) { const c = this._renderer, u = this._blurMaterial; s !== "latitudinal" && s !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const d = 3, f = new Bi(this._lodPlanes[i], u), h = u.uniforms, m = this._sizeLods[r] - 1, g = isFinite(a) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Hm - 1), x = a / g, v = isFinite(a) ? 1 + Math.floor(d * x) : Hm; v > Hm && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Hm}`); const b = []; let E = 0; for (let j = 0; j < Hm; ++j) { const O = j / x, I = Math.exp(-O * O / 2); b.push(I), j === 0 ? E += I : j < v && (E += 2 * I) } for (let j = 0; j < b.length; j++)b[j] = b[j] / E; h.envMap.value = e.texture, h.samples.value = v, h.weights.value = b, h.latitudinal.value = s === "latitudinal", o && (h.poleAxis.value = o); const { _lodMax: M } = this; h.dTheta.value = g, h.mipInt.value = M - r; const C = this._sizeLods[i], N = 3 * C * (i > M - $y ? i - M + $y : 0), A = 4 * (this._cubeSize - C); UM(n, N, A, 3 * C, 2 * C), c.setRenderTarget(n), c.render(f, BR) } } function gke(t) { const e = [], n = [], r = []; let i = t; const a = t - $y + 1 + jW.length; for (let s = 0; s < a; s++) { const o = Math.pow(2, i); n.push(o); let c = 1 / o; s > t - $y ? c = jW[s - t + $y - 1] : s === 0 && (c = 0), r.push(c); const u = 1 / (o - 2), d = -u, f = 1 + u, h = [d, d, f, d, f, f, d, d, f, f, d, f], m = 6, g = 6, x = 3, v = 2, b = 1, E = new Float32Array(x * g * m), M = new Float32Array(v * g * m), C = new Float32Array(b * g * m); for (let A = 0; A < m; A++) { const j = A % 3 * 2 / 3 - 1, O = A > 2 ? 0 : -1, I = [j, O, 0, j + 2 / 3, O, 0, j + 2 / 3, O + 1, 0, j, O, 0, j + 2 / 3, O + 1, 0, j, O + 1, 0]; E.set(I, x * g * A), M.set(h, v * g * A); const D = [A, A, A, A, A, A]; C.set(D, b * g * A) } const N = new Kn; N.setAttribute("position", new Lr(E, x)), N.setAttribute("uv", new Lr(M, v)), N.setAttribute("faceIndex", new Lr(C, b)), e.push(N), i > $y && i-- } return { lodPlanes: e, sizeLods: n, sigmas: r } } function IW(t, e, n) { const r = new Hl(t, e, n); return r.texture.mapping = C0, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r } function UM(t, e, n, r, i) { t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i) } function vke(t, e, n) {
	const r = new Float32Array(Hm), i = new pe(0, 1, 0); return new Bo({
		name: "SphericalGaussianBlur", defines: { n: Hm, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${t}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: PB(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Pu, depthTest: !1, depthWrite: !1
	})
} function OW() {
	return new Bo({
		name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: PB(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Pu, depthTest: !1, depthWrite: !1
	})
} function DW() {
	return new Bo({
		name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: PB(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Pu, depthTest: !1, depthWrite: !1
	})
} function PB() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function yke(t) { let e = new WeakMap, n = null; function r(o) { if (o && o.isTexture) { const c = o.mapping, u = c === vx || c === P1, d = c === $u || c === rp; if (u || d) { let f = e.get(o); const h = f !== void 0 ? f.texture.pmremVersion : 0; if (o.isRenderTargetTexture && o.pmremVersion !== h) return n === null && (n = new QL(t)), f = u ? n.fromEquirectangular(o, f) : n.fromCubemap(o, f), f.texture.pmremVersion = o.pmremVersion, e.set(o, f), f.texture; if (f !== void 0) return f.texture; { const m = o.image; return u && m && m.height > 0 || d && m && i(m) ? (n === null && (n = new QL(t)), f = u ? n.fromEquirectangular(o) : n.fromCubemap(o), f.texture.pmremVersion = o.pmremVersion, e.set(o, f), o.addEventListener("dispose", a), f.texture) : null } } } return o } function i(o) { let c = 0; const u = 6; for (let d = 0; d < u; d++)o[d] !== void 0 && c++; return c === u } function a(o) { const c = o.target; c.removeEventListener("dispose", a); const u = e.get(c); u !== void 0 && (e.delete(c), u.dispose()) } function s() { e = new WeakMap, n !== null && (n.dispose(), n = null) } return { get: r, dispose: s } } function xke(t) { const e = {}; function n(r) { if (e[r] !== void 0) return e[r]; let i; switch (r) { case "WEBGL_depth_texture": i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = t.getExtension(r) }return e[r] = i, i } return { has: function (r) { return n(r) !== null }, init: function () { n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent") }, get: function (r) { const i = n(r); return i === null && F1("THREE.WebGLRenderer: " + r + " extension not supported."), i } } } function bke(t, e, n, r) { const i = {}, a = new WeakMap; function s(f) { const h = f.target; h.index !== null && e.remove(h.index); for (const g in h.attributes) e.remove(h.attributes[g]); h.removeEventListener("dispose", s), delete i[h.id]; const m = a.get(h); m && (e.remove(m), a.delete(h)), r.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount, n.memory.geometries-- } function o(f, h) { return i[h.id] === !0 || (h.addEventListener("dispose", s), i[h.id] = !0, n.memory.geometries++), h } function c(f) { const h = f.attributes; for (const m in h) e.update(h[m], t.ARRAY_BUFFER) } function u(f) { const h = [], m = f.index, g = f.attributes.position; let x = 0; if (m !== null) { const E = m.array; x = m.version; for (let M = 0, C = E.length; M < C; M += 3) { const N = E[M + 0], A = E[M + 1], j = E[M + 2]; h.push(N, A, A, j, j, N) } } else if (g !== void 0) { const E = g.array; x = g.version; for (let M = 0, C = E.length / 3 - 1; M < C; M += 3) { const N = M + 0, A = M + 1, j = M + 2; h.push(N, A, A, j, j, N) } } else return; const v = new (Sae(h) ? nB : tB)(h, 1); v.version = x; const b = a.get(f); b && e.remove(b), a.set(f, v) } function d(f) { const h = a.get(f); if (h) { const m = f.index; m !== null && h.version < m.version && u(f) } else u(f); return a.get(f) } return { get: o, update: c, getWireframeAttribute: d } } function wke(t, e, n) { let r; function i(h) { r = h } let a, s; function o(h) { a = h.type, s = h.bytesPerElement } function c(h, m) { t.drawElements(r, m, a, h * s), n.update(m, r, 1) } function u(h, m, g) { g !== 0 && (t.drawElementsInstanced(r, m, a, h * s, g), n.update(m, r, g)) } function d(h, m, g) { if (g === 0) return; e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, m, 0, a, h, 0, g); let v = 0; for (let b = 0; b < g; b++)v += m[b]; n.update(v, r, 1) } function f(h, m, g, x) { if (g === 0) return; const v = e.get("WEBGL_multi_draw"); if (v === null) for (let b = 0; b < h.length; b++)u(h[b] / s, m[b], x[b]); else { v.multiDrawElementsInstancedWEBGL(r, m, 0, a, h, 0, x, 0, g); let b = 0; for (let E = 0; E < g; E++)b += m[E] * x[E]; n.update(b, r, 1) } } this.setMode = i, this.setIndex = o, this.render = c, this.renderInstances = u, this.renderMultiDraw = d, this.renderMultiDrawInstances = f } function Ske(t) { const e = { geometries: 0, textures: 0 }, n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function r(a, s, o) { switch (n.calls++, s) { case t.TRIANGLES: n.triangles += o * (a / 3); break; case t.LINES: n.lines += o * (a / 2); break; case t.LINE_STRIP: n.lines += o * (a - 1); break; case t.LINE_LOOP: n.lines += o * a; break; case t.POINTS: n.points += o * a; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", s); break } } function i() { n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0 } return { memory: e, render: n, programs: null, autoReset: !0, reset: i, update: r } } function _ke(t, e, n) { const r = new WeakMap, i = new jr; function a(s, o, c) { const u = s.morphTargetInfluences, d = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, f = d !== void 0 ? d.length : 0; let h = r.get(o); if (h === void 0 || h.count !== f) { let D = function () { O.dispose(), r.delete(o), o.removeEventListener("dispose", D) }; var m = D; h !== void 0 && h.texture.dispose(); const g = o.morphAttributes.position !== void 0, x = o.morphAttributes.normal !== void 0, v = o.morphAttributes.color !== void 0, b = o.morphAttributes.position || [], E = o.morphAttributes.normal || [], M = o.morphAttributes.color || []; let C = 0; g === !0 && (C = 1), x === !0 && (C = 2), v === !0 && (C = 3); let N = o.attributes.position.count * C, A = 1; N > e.maxTextureSize && (A = Math.ceil(N / e.maxTextureSize), N = e.maxTextureSize); const j = new Float32Array(N * A * 4 * f), O = new XA(j, N, A, f); O.type = Ui, O.needsUpdate = !0; const I = C * 4; for (let F = 0; F < f; F++) { const B = b[F], G = E[F], z = M[F], q = N * A * 4 * F; for (let Y = 0; Y < B.count; Y++) { const Z = Y * I; g === !0 && (i.fromBufferAttribute(B, Y), j[q + Z + 0] = i.x, j[q + Z + 1] = i.y, j[q + Z + 2] = i.z, j[q + Z + 3] = 0), x === !0 && (i.fromBufferAttribute(G, Y), j[q + Z + 4] = i.x, j[q + Z + 5] = i.y, j[q + Z + 6] = i.z, j[q + Z + 7] = 0), v === !0 && (i.fromBufferAttribute(z, Y), j[q + Z + 8] = i.x, j[q + Z + 9] = i.y, j[q + Z + 10] = i.z, j[q + Z + 11] = z.itemSize === 4 ? i.w : 1) } } h = { count: f, texture: O, size: new lt(N, A) }, r.set(o, h), o.addEventListener("dispose", D) } if (s.isInstancedMesh === !0 && s.morphTexture !== null) c.getUniforms().setValue(t, "morphTexture", s.morphTexture, n); else { let g = 0; for (let v = 0; v < u.length; v++)g += u[v]; const x = o.morphTargetsRelative ? 1 : 1 - g; c.getUniforms().setValue(t, "morphTargetBaseInfluence", x), c.getUniforms().setValue(t, "morphTargetInfluences", u) } c.getUniforms().setValue(t, "morphTargetsTexture", h.texture, n), c.getUniforms().setValue(t, "morphTargetsTextureSize", h.size) } return { update: a } } function Eke(t, e, n, r) { let i = new WeakMap; function a(c) { const u = r.render.frame, d = c.geometry, f = e.get(c, d); if (i.get(f) !== u && (e.update(f), i.set(f, u)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === !1 && c.addEventListener("dispose", o), i.get(c) !== u && (n.update(c.instanceMatrix, t.ARRAY_BUFFER), c.instanceColor !== null && n.update(c.instanceColor, t.ARRAY_BUFFER), i.set(c, u))), c.isSkinnedMesh) { const h = c.skeleton; i.get(h) !== u && (h.update(), i.set(h, u)) } return f } function s() { i = new WeakMap } function o(c) { const u = c.target; u.removeEventListener("dispose", o), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor) } return { update: a, dispose: s } } const Ase = new ti, LW = new oB(1, 1), Pse = new XA, jse = new YA, Rse = new l_, FW = [], UW = [], BW = new Float32Array(16), $W = new Float32Array(9), zW = new Float32Array(4); function A0(t, e, n) { const r = t[0]; if (r <= 0 || r > 0) return t; const i = e * n; let a = FW[i]; if (a === void 0 && (a = new Float32Array(i), FW[i] = a), e !== 0) { r.toArray(a, 0); for (let s = 1, o = 0; s !== e; ++s)o += n, t[s].toArray(a, o) } return a } function Oa(t, e) { if (t.length !== e.length) return !1; for (let n = 0, r = t.length; n < r; n++)if (t[n] !== e[n]) return !1; return !0 } function Da(t, e) { for (let n = 0, r = e.length; n < r; n++)t[n] = e[n] } function m2(t, e) { let n = UW[e]; n === void 0 && (n = new Int32Array(e), UW[e] = n); for (let r = 0; r !== e; ++r)n[r] = t.allocateTextureUnit(); return n } function Mke(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function Tke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (Oa(n, e)) return; t.uniform2fv(this.addr, e), Da(n, e) } } function Cke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (e.r !== void 0) (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (Oa(n, e)) return; t.uniform3fv(this.addr, e), Da(n, e) } } function Nke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (Oa(n, e)) return; t.uniform4fv(this.addr, e), Da(n, e) } } function Ake(t, e) { const n = this.cache, r = e.elements; if (r === void 0) { if (Oa(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), Da(n, e) } else { if (Oa(n, r)) return; zW.set(r), t.uniformMatrix2fv(this.addr, !1, zW), Da(n, r) } } function Pke(t, e) { const n = this.cache, r = e.elements; if (r === void 0) { if (Oa(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), Da(n, e) } else { if (Oa(n, r)) return; $W.set(r), t.uniformMatrix3fv(this.addr, !1, $W), Da(n, r) } } function jke(t, e) { const n = this.cache, r = e.elements; if (r === void 0) { if (Oa(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), Da(n, e) } else { if (Oa(n, r)) return; BW.set(r), t.uniformMatrix4fv(this.addr, !1, BW), Da(n, r) } } function Rke(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function kke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (Oa(n, e)) return; t.uniform2iv(this.addr, e), Da(n, e) } } function Ike(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else { if (Oa(n, e)) return; t.uniform3iv(this.addr, e), Da(n, e) } } function Oke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (Oa(n, e)) return; t.uniform4iv(this.addr, e), Da(n, e) } } function Dke(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function Lke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (Oa(n, e)) return; t.uniform2uiv(this.addr, e), Da(n, e) } } function Fke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else { if (Oa(n, e)) return; t.uniform3uiv(this.addr, e), Da(n, e) } } function Uke(t, e) { const n = this.cache; if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (Oa(n, e)) return; t.uniform4uiv(this.addr, e), Da(n, e) } } function Bke(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i); let a; this.type === t.SAMPLER_2D_SHADOW ? (LW.compareFunction = QU, a = LW) : a = Ase, n.setTexture2D(e || a, i) } function $ke(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || jse, i) } function zke(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || Rse, i) } function Vke(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || Pse, i) } function Hke(t) { switch (t) { case 5126: return Mke; case 35664: return Tke; case 35665: return Cke; case 35666: return Nke; case 35674: return Ake; case 35675: return Pke; case 35676: return jke; case 5124: case 35670: return Rke; case 35667: case 35671: return kke; case 35668: case 35672: return Ike; case 35669: case 35673: return Oke; case 5125: return Dke; case 36294: return Lke; case 36295: return Fke; case 36296: return Uke; case 35678: case 36198: case 36298: case 36306: case 35682: return Bke; case 35679: case 36299: case 36307: return $ke; case 35680: case 36300: case 36308: case 36293: return zke; case 36289: case 36303: case 36311: case 36292: return Vke } } function Wke(t, e) { t.uniform1fv(this.addr, e) } function Gke(t, e) { const n = A0(e, this.size, 2); t.uniform2fv(this.addr, n) } function qke(t, e) { const n = A0(e, this.size, 3); t.uniform3fv(this.addr, n) } function Xke(t, e) { const n = A0(e, this.size, 4); t.uniform4fv(this.addr, n) } function Yke(t, e) { const n = A0(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function Kke(t, e) { const n = A0(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function Zke(t, e) { const n = A0(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function Qke(t, e) { t.uniform1iv(this.addr, e) } function Jke(t, e) { t.uniform2iv(this.addr, e) } function eIe(t, e) { t.uniform3iv(this.addr, e) } function tIe(t, e) { t.uniform4iv(this.addr, e) } function nIe(t, e) { t.uniform1uiv(this.addr, e) } function rIe(t, e) { t.uniform2uiv(this.addr, e) } function iIe(t, e) { t.uniform3uiv(this.addr, e) } function aIe(t, e) { t.uniform4uiv(this.addr, e) } function sIe(t, e, n) { const r = this.cache, i = e.length, a = m2(n, i); Oa(r, a) || (t.uniform1iv(this.addr, a), Da(r, a)); for (let s = 0; s !== i; ++s)n.setTexture2D(e[s] || Ase, a[s]) } function oIe(t, e, n) { const r = this.cache, i = e.length, a = m2(n, i); Oa(r, a) || (t.uniform1iv(this.addr, a), Da(r, a)); for (let s = 0; s !== i; ++s)n.setTexture3D(e[s] || jse, a[s]) } function lIe(t, e, n) { const r = this.cache, i = e.length, a = m2(n, i); Oa(r, a) || (t.uniform1iv(this.addr, a), Da(r, a)); for (let s = 0; s !== i; ++s)n.setTextureCube(e[s] || Rse, a[s]) } function cIe(t, e, n) { const r = this.cache, i = e.length, a = m2(n, i); Oa(r, a) || (t.uniform1iv(this.addr, a), Da(r, a)); for (let s = 0; s !== i; ++s)n.setTexture2DArray(e[s] || Pse, a[s]) } function uIe(t) { switch (t) { case 5126: return Wke; case 35664: return Gke; case 35665: return qke; case 35666: return Xke; case 35674: return Yke; case 35675: return Kke; case 35676: return Zke; case 5124: case 35670: return Qke; case 35667: case 35671: return Jke; case 35668: case 35672: return eIe; case 35669: case 35673: return tIe; case 5125: return nIe; case 36294: return rIe; case 36295: return iIe; case 36296: return aIe; case 35678: case 36198: case 36298: case 36306: case 35682: return sIe; case 35679: case 36299: case 36307: return oIe; case 35680: case 36300: case 36308: case 36293: return lIe; case 36289: case 36303: case 36311: case 36292: return cIe } } class dIe { constructor(e, n, r) { this.id = e, this.addr = r, this.cache = [], this.type = n.type, this.setValue = Hke(n.type) } } class fIe { constructor(e, n, r) { this.id = e, this.addr = r, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = uIe(n.type) } } class hIe { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, n, r) { const i = this.seq; for (let a = 0, s = i.length; a !== s; ++a) { const o = i[a]; o.setValue(e, n[o.id], r) } } } const WR = /(\w+)(\])?(\[|\.)?/g; function VW(t, e) { t.seq.push(e), t.map[e.id] = e } function pIe(t, e, n) { const r = t.name, i = r.length; for (WR.lastIndex = 0; ;) { const a = WR.exec(r), s = WR.lastIndex; let o = a[1]; const c = a[2] === "]", u = a[3]; if (c && (o = o | 0), u === void 0 || u === "[" && s + 2 === i) { VW(n, u === void 0 ? new dIe(o, t, e) : new fIe(o, t, e)); break } else { let f = n.map[o]; f === void 0 && (f = new hIe(o), VW(n, f)), n = f } } } class RT { constructor(e, n) { this.seq = [], this.map = {}; const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS); for (let i = 0; i < r; ++i) { const a = e.getActiveUniform(n, i), s = e.getUniformLocation(n, a.name); pIe(a, s, this) } } setValue(e, n, r, i) { const a = this.map[n]; a !== void 0 && a.setValue(e, r, i) } setOptional(e, n, r) { const i = n[r]; i !== void 0 && this.setValue(e, r, i) } static upload(e, n, r, i) { for (let a = 0, s = n.length; a !== s; ++a) { const o = n[a], c = r[o.id]; c.needsUpdate !== !1 && o.setValue(e, c.value, i) } } static seqWithValue(e, n) { const r = []; for (let i = 0, a = e.length; i !== a; ++i) { const s = e[i]; s.id in n && r.push(s) } return r } } function HW(t, e, n) { const r = t.createShader(e); return t.shaderSource(r, n), t.compileShader(r), r } const mIe = 37297; let gIe = 0; function vIe(t, e) {
	const n = t.split(`
`), r = [], i = Math.max(e - 6, 0), a = Math.min(e + 6, n.length); for (let s = i; s < a; s++) { const o = s + 1; r.push(`${o === e ? ">" : " "} ${o}: ${n[s]}`) } return r.join(`
`)
} const WW = new Qn; function yIe(t) { Nr._getMatrix(WW, Nr.workingColorSpace, t); const e = `mat3( ${WW.elements.map(n => n.toFixed(4))} )`; switch (Nr.getTransfer(t)) { case O1: return [e, "LinearTransferOETF"]; case Wr: return [e, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space: ", t), [e, "LinearTransferOETF"] } } function GW(t, e, n) {
	const r = t.getShaderParameter(e, t.COMPILE_STATUS), a = (t.getShaderInfoLog(e) || "").trim(); if (r && a === "") return ""; const s = /ERROR: 0:(\d+)/.exec(a); if (s) {
		const o = parseInt(s[1]); return n.toUpperCase() + `

`+ a + `

`+ vIe(t.getShaderSource(e), o)
	} else return a
} function xIe(t, e) {
	const n = yIe(e); return [`vec4 ${t}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
} function bIe(t, e) { let n; switch (e) { case nae: n = "Linear"; break; case rae: n = "Reinhard"; break; case iae: n = "Cineon"; break; case HU: n = "ACESFilmic"; break; case sae: n = "AgX"; break; case oae: n = "Neutral"; break; case aae: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } const BM = new pe; function wIe() {
	Nr.getLuminanceCoefficients(BM); const t = BM.x.toFixed(4), e = BM.y.toFixed(4), n = BM.z.toFixed(4); return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${t}, ${e}, ${n} );`, "	return dot( weights, rgb );", "}"].join(`
`)
} function SIe(t) {
	return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Iw).join(`
`)
} function _Ie(t) {
	const e = []; for (const n in t) { const r = t[n]; r !== !1 && e.push("#define " + n + " " + r) } return e.join(`
`)
} function EIe(t, e) { const n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES); for (let i = 0; i < r; i++) { const a = t.getActiveAttrib(e, i), s = a.name; let o = 1; a.type === t.FLOAT_MAT2 && (o = 2), a.type === t.FLOAT_MAT3 && (o = 3), a.type === t.FLOAT_MAT4 && (o = 4), n[s] = { type: a.type, location: t.getAttribLocation(e, s), locationSize: o } } return n } function Iw(t) { return t !== "" } function qW(t, e) { const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function XW(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const MIe = /^[ \t]*#include +<([\w\d./]+)>/gm; function JL(t) { return t.replace(MIe, CIe) } const TIe = new Map; function CIe(t, e) { let n = lr[e]; if (n === void 0) { const r = TIe.get(e); if (r !== void 0) n = lr[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r); else throw new Error("Can not resolve #include <" + e + ">") } return JL(n) } const NIe = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function YW(t) { return t.replace(NIe, AIe) } function AIe(t, e, n, r) { let i = ""; for (let a = parseInt(e); a < parseInt(n); a++)i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a); return i } function KW(t) {
	let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`; return t.precision === "highp" ? e += `
#define HIGH_PRECISION`: t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function PIe(t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === BA ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === Ww ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Pc && (e = "SHADOWMAP_TYPE_VSM"), e } function jIe(t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case $u: case rp: e = "ENVMAP_TYPE_CUBE"; break; case C0: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function RIe(t) { let e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case rp: e = "ENVMAP_MODE_REFRACTION"; break }return e } function kIe(t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case r_: e = "ENVMAP_BLENDING_MULTIPLY"; break; case eae: e = "ENVMAP_BLENDING_MIX"; break; case tae: e = "ENVMAP_BLENDING_ADD"; break }return e } function IIe(t) { const e = t.envMapCubeUVHeight; if (e === null) return null; const n = Math.log2(e) - 2, r = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: r, maxMip: n } } function OIe(t, e, n, r) {
	const i = t.getContext(), a = n.defines; let s = n.vertexShader, o = n.fragmentShader; const c = PIe(n), u = jIe(n), d = RIe(n), f = kIe(n), h = IIe(n), m = SIe(n), g = _Ie(a), x = i.createProgram(); let v, b, E = n.glslVersion ? "#version " + n.glslVersion + `
`: ""; n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, g].filter(Iw).join(`
`), v.length > 0 && (v += `
`), b = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, g].filter(Iw).join(`
`), b.length > 0 && (b += `
`)) : (v = [KW(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, g, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Iw).join(`
`), b = [KW(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + f : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== ju ? "#define TONE_MAPPING" : "", n.toneMapping !== ju ? lr.tonemapping_pars_fragment : "", n.toneMapping !== ju ? bIe("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", lr.colorspace_pars_fragment, xIe("linearToOutputTexel", n.outputColorSpace), wIe(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(Iw).join(`
`)), s = JL(s), s = qW(s, n), s = XW(s, n), o = JL(o), o = qW(o, n), o = XW(o, n), s = YW(s), o = YW(o), n.isRawShaderMaterial !== !0 && (E = `#version 300 es
`, v = [m, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ v, b = ["#define varying in", n.glslVersion === VL ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === VL ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ b); const M = E + v + s, C = E + b + o, N = HW(i, i.VERTEX_SHADER, M), A = HW(i, i.FRAGMENT_SHADER, C); i.attachShader(x, N), i.attachShader(x, A), n.index0AttributeName !== void 0 ? i.bindAttribLocation(x, 0, n.index0AttributeName) : n.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"), i.linkProgram(x); function j(F) {
		if (t.debug.checkShaderErrors) {
			const B = i.getProgramInfoLog(x) || "", G = i.getShaderInfoLog(N) || "", z = i.getShaderInfoLog(A) || "", q = B.trim(), Y = G.trim(), Z = z.trim(); let $ = !0, V = !0; if (i.getProgramParameter(x, i.LINK_STATUS) === !1) if ($ = !1, typeof t.debug.onShaderError == "function") t.debug.onShaderError(i, x, N, A); else {
				const K = GW(i, N, "vertex"), X = GW(i, A, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(x, i.VALIDATE_STATUS) + `

Material Name: `+ F.name + `
Material Type: `+ F.type + `

Program Info Log: `+ q + `
`+ K + `
`+ X)
			} else q !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", q) : (Y === "" || Z === "") && (V = !1); V && (F.diagnostics = { runnable: $, programLog: q, vertexShader: { log: Y, prefix: v }, fragmentShader: { log: Z, prefix: b } })
		} i.deleteShader(N), i.deleteShader(A), O = new RT(i, x), I = EIe(i, x)
	} let O; this.getUniforms = function () { return O === void 0 && j(this), O }; let I; this.getAttributes = function () { return I === void 0 && j(this), I }; let D = n.rendererExtensionParallelShaderCompile === !1; return this.isReady = function () { return D === !1 && (D = i.getProgramParameter(x, mIe)), D }, this.destroy = function () { r.releaseStatesOfProgram(this), i.deleteProgram(x), this.program = void 0 }, this.type = n.shaderType, this.name = n.shaderName, this.id = gIe++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = N, this.fragmentShader = A, this
} let DIe = 0; class LIe { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const n = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(n), a = this._getShaderStage(r), s = this._getShaderCacheForMaterial(e); return s.has(i) === !1 && (s.add(i), i.usedTimes++), s.has(a) === !1 && (s.add(a), a.usedTimes++), this } remove(e) { const n = this.materialCache.get(e); for (const r of n) r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const n = this.materialCache; let r = n.get(e); return r === void 0 && (r = new Set, n.set(e, r)), r } _getShaderStage(e) { const n = this.shaderCache; let r = n.get(e); return r === void 0 && (r = new FIe(e), n.set(e, r)), r } } class FIe { constructor(e) { this.id = DIe++, this.code = e, this.usedTimes = 0 } } function UIe(t, e, n, r, i, a, s) { const o = new hg, c = new LIe, u = new Set, d = [], f = i.logarithmicDepthBuffer, h = i.vertexTextures; let m = i.precision; const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function x(I) { return u.add(I), I === 0 ? "uv" : `uv${I}` } function v(I, D, F, B, G) { const z = B.fog, q = G.geometry, Y = I.isMeshStandardMaterial ? B.environment : null, Z = (I.isMeshStandardMaterial ? n : e).get(I.envMap || Y), $ = Z && Z.mapping === C0 ? Z.image.height : null, V = g[I.type]; I.precision !== null && (m = i.getMaxPrecision(I.precision), m !== I.precision && console.warn("THREE.WebGLProgram.getParameters:", I.precision, "not supported, using", m, "instead.")); const K = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color, X = K !== void 0 ? K.length : 0; let Q = 0; q.morphAttributes.position !== void 0 && (Q = 1), q.morphAttributes.normal !== void 0 && (Q = 2), q.morphAttributes.color !== void 0 && (Q = 3); let re, ce, be, de; if (V) { const wn = Ic[V]; re = wn.vertexShader, ce = wn.fragmentShader } else re = I.vertexShader, ce = I.fragmentShader, c.update(I), be = c.getVertexShaderID(I), de = c.getFragmentShaderID(I); const ae = t.getRenderTarget(), se = t.state.buffers.depth.getReversed(), he = G.isInstancedMesh === !0, Ae = G.isBatchedMesh === !0, Ce = !!I.map, fe = !!I.matcap, oe = !!Z, xe = !!I.aoMap, _e = !!I.lightMap, je = !!I.bumpMap, ke = !!I.normalMap, Ze = !!I.displacementMap, Xe = !!I.emissiveMap, nt = !!I.metalnessMap, Tt = !!I.roughnessMap, St = I.anisotropy > 0, ee = I.clearcoat > 0, ne = I.dispersion > 0, Re = I.iridescence > 0, Ue = I.sheen > 0, et = I.transmission > 0, Ge = St && !!I.anisotropyMap, Xt = ee && !!I.clearcoatMap, yt = ee && !!I.clearcoatNormalMap, Yt = ee && !!I.clearcoatRoughnessMap, en = Re && !!I.iridescenceMap, pt = Re && !!I.iridescenceThicknessMap, bt = Ue && !!I.sheenColorMap, pn = Ue && !!I.sheenRoughnessMap, Se = !!I.specularMap, Fe = !!I.specularColorMap, ht = !!I.specularIntensityMap, Ee = et && !!I.transmissionMap, De = et && !!I.thicknessMap, gt = !!I.gradientMap, Bt = !!I.alphaMap, mt = I.alphaTest > 0, ot = !!I.alphaHash, it = !!I.extensions; let Ft = ju; I.toneMapped && (ae === null || ae.isXRRenderTarget === !0) && (Ft = t.toneMapping); const un = { shaderID: V, shaderType: I.type, shaderName: I.name, vertexShader: re, fragmentShader: ce, defines: I.defines, customVertexShaderID: be, customFragmentShaderID: de, isRawShaderMaterial: I.isRawShaderMaterial === !0, glslVersion: I.glslVersion, precision: m, batching: Ae, batchingColor: Ae && G._colorsTexture !== null, instancing: he, instancingColor: he && G.instanceColor !== null, instancingMorph: he && G.morphTexture !== null, supportsVertexTextures: h, outputColorSpace: ae === null ? t.outputColorSpace : ae.isXRRenderTarget === !0 ? ae.texture.colorSpace : Vu, alphaToCoverage: !!I.alphaToCoverage, map: Ce, matcap: fe, envMap: oe, envMapMode: oe && Z.mapping, envMapCubeUVHeight: $, aoMap: xe, lightMap: _e, bumpMap: je, normalMap: ke, displacementMap: h && Ze, emissiveMap: Xe, normalMapObjectSpace: ke && I.normalMapType === pae, normalMapTangentSpace: ke && I.normalMapType === mp, metalnessMap: nt, roughnessMap: Tt, anisotropy: St, anisotropyMap: Ge, clearcoat: ee, clearcoatMap: Xt, clearcoatNormalMap: yt, clearcoatRoughnessMap: Yt, dispersion: ne, iridescence: Re, iridescenceMap: en, iridescenceThicknessMap: pt, sheen: Ue, sheenColorMap: bt, sheenRoughnessMap: pn, specularMap: Se, specularColorMap: Fe, specularIntensityMap: ht, transmission: et, transmissionMap: Ee, thicknessMap: De, gradientMap: gt, opaque: I.transparent === !1 && I.blending === dg && I.alphaToCoverage === !1, alphaMap: Bt, alphaTest: mt, alphaHash: ot, combine: I.combine, mapUv: Ce && x(I.map.channel), aoMapUv: xe && x(I.aoMap.channel), lightMapUv: _e && x(I.lightMap.channel), bumpMapUv: je && x(I.bumpMap.channel), normalMapUv: ke && x(I.normalMap.channel), displacementMapUv: Ze && x(I.displacementMap.channel), emissiveMapUv: Xe && x(I.emissiveMap.channel), metalnessMapUv: nt && x(I.metalnessMap.channel), roughnessMapUv: Tt && x(I.roughnessMap.channel), anisotropyMapUv: Ge && x(I.anisotropyMap.channel), clearcoatMapUv: Xt && x(I.clearcoatMap.channel), clearcoatNormalMapUv: yt && x(I.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: Yt && x(I.clearcoatRoughnessMap.channel), iridescenceMapUv: en && x(I.iridescenceMap.channel), iridescenceThicknessMapUv: pt && x(I.iridescenceThicknessMap.channel), sheenColorMapUv: bt && x(I.sheenColorMap.channel), sheenRoughnessMapUv: pn && x(I.sheenRoughnessMap.channel), specularMapUv: Se && x(I.specularMap.channel), specularColorMapUv: Fe && x(I.specularColorMap.channel), specularIntensityMapUv: ht && x(I.specularIntensityMap.channel), transmissionMapUv: Ee && x(I.transmissionMap.channel), thicknessMapUv: De && x(I.thicknessMap.channel), alphaMapUv: Bt && x(I.alphaMap.channel), vertexTangents: !!q.attributes.tangent && (ke || St), vertexColors: I.vertexColors, vertexAlphas: I.vertexColors === !0 && !!q.attributes.color && q.attributes.color.itemSize === 4, pointsUvs: G.isPoints === !0 && !!q.attributes.uv && (Ce || Bt), fog: !!z, useFog: I.fog === !0, fogExp2: !!z && z.isFogExp2, flatShading: I.flatShading === !0 && I.wireframe === !1, sizeAttenuation: I.sizeAttenuation === !0, logarithmicDepthBuffer: f, reversedDepthBuffer: se, skinning: G.isSkinnedMesh === !0, morphTargets: q.morphAttributes.position !== void 0, morphNormals: q.morphAttributes.normal !== void 0, morphColors: q.morphAttributes.color !== void 0, morphTargetsCount: X, morphTextureStride: Q, numDirLights: D.directional.length, numPointLights: D.point.length, numSpotLights: D.spot.length, numSpotLightMaps: D.spotLightMap.length, numRectAreaLights: D.rectArea.length, numHemiLights: D.hemi.length, numDirLightShadows: D.directionalShadowMap.length, numPointLightShadows: D.pointShadowMap.length, numSpotLightShadows: D.spotShadowMap.length, numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps, numLightProbes: D.numLightProbes, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: I.dithering, shadowMapEnabled: t.shadowMap.enabled && F.length > 0, shadowMapType: t.shadowMap.type, toneMapping: Ft, decodeVideoTexture: Ce && I.map.isVideoTexture === !0 && Nr.getTransfer(I.map.colorSpace) === Wr, decodeVideoTextureEmissive: Xe && I.emissiveMap.isVideoTexture === !0 && Nr.getTransfer(I.emissiveMap.colorSpace) === Wr, premultipliedAlpha: I.premultipliedAlpha, doubleSided: I.side === Oc, flipSided: I.side === io, useDepthPacking: I.depthPacking >= 0, depthPacking: I.depthPacking || 0, index0AttributeName: I.index0AttributeName, extensionClipCullDistance: it && I.extensions.clipCullDistance === !0 && r.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (it && I.extensions.multiDraw === !0 || Ae) && r.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"), customProgramCacheKey: I.customProgramCacheKey() }; return un.vertexUv1s = u.has(1), un.vertexUv2s = u.has(2), un.vertexUv3s = u.has(3), u.clear(), un } function b(I) { const D = []; if (I.shaderID ? D.push(I.shaderID) : (D.push(I.customVertexShaderID), D.push(I.customFragmentShaderID)), I.defines !== void 0) for (const F in I.defines) D.push(F), D.push(I.defines[F]); return I.isRawShaderMaterial === !1 && (E(D, I), M(D, I), D.push(t.outputColorSpace)), D.push(I.customProgramCacheKey), D.join() } function E(I, D) { I.push(D.precision), I.push(D.outputColorSpace), I.push(D.envMapMode), I.push(D.envMapCubeUVHeight), I.push(D.mapUv), I.push(D.alphaMapUv), I.push(D.lightMapUv), I.push(D.aoMapUv), I.push(D.bumpMapUv), I.push(D.normalMapUv), I.push(D.displacementMapUv), I.push(D.emissiveMapUv), I.push(D.metalnessMapUv), I.push(D.roughnessMapUv), I.push(D.anisotropyMapUv), I.push(D.clearcoatMapUv), I.push(D.clearcoatNormalMapUv), I.push(D.clearcoatRoughnessMapUv), I.push(D.iridescenceMapUv), I.push(D.iridescenceThicknessMapUv), I.push(D.sheenColorMapUv), I.push(D.sheenRoughnessMapUv), I.push(D.specularMapUv), I.push(D.specularColorMapUv), I.push(D.specularIntensityMapUv), I.push(D.transmissionMapUv), I.push(D.thicknessMapUv), I.push(D.combine), I.push(D.fogExp2), I.push(D.sizeAttenuation), I.push(D.morphTargetsCount), I.push(D.morphAttributeCount), I.push(D.numDirLights), I.push(D.numPointLights), I.push(D.numSpotLights), I.push(D.numSpotLightMaps), I.push(D.numHemiLights), I.push(D.numRectAreaLights), I.push(D.numDirLightShadows), I.push(D.numPointLightShadows), I.push(D.numSpotLightShadows), I.push(D.numSpotLightShadowsWithMaps), I.push(D.numLightProbes), I.push(D.shadowMapType), I.push(D.toneMapping), I.push(D.numClippingPlanes), I.push(D.numClipIntersection), I.push(D.depthPacking) } function M(I, D) { o.disableAll(), D.supportsVertexTextures && o.enable(0), D.instancing && o.enable(1), D.instancingColor && o.enable(2), D.instancingMorph && o.enable(3), D.matcap && o.enable(4), D.envMap && o.enable(5), D.normalMapObjectSpace && o.enable(6), D.normalMapTangentSpace && o.enable(7), D.clearcoat && o.enable(8), D.iridescence && o.enable(9), D.alphaTest && o.enable(10), D.vertexColors && o.enable(11), D.vertexAlphas && o.enable(12), D.vertexUv1s && o.enable(13), D.vertexUv2s && o.enable(14), D.vertexUv3s && o.enable(15), D.vertexTangents && o.enable(16), D.anisotropy && o.enable(17), D.alphaHash && o.enable(18), D.batching && o.enable(19), D.dispersion && o.enable(20), D.batchingColor && o.enable(21), D.gradientMap && o.enable(22), I.push(o.mask), o.disableAll(), D.fog && o.enable(0), D.useFog && o.enable(1), D.flatShading && o.enable(2), D.logarithmicDepthBuffer && o.enable(3), D.reversedDepthBuffer && o.enable(4), D.skinning && o.enable(5), D.morphTargets && o.enable(6), D.morphNormals && o.enable(7), D.morphColors && o.enable(8), D.premultipliedAlpha && o.enable(9), D.shadowMapEnabled && o.enable(10), D.doubleSided && o.enable(11), D.flipSided && o.enable(12), D.useDepthPacking && o.enable(13), D.dithering && o.enable(14), D.transmission && o.enable(15), D.sheen && o.enable(16), D.opaque && o.enable(17), D.pointsUvs && o.enable(18), D.decodeVideoTexture && o.enable(19), D.decodeVideoTextureEmissive && o.enable(20), D.alphaToCoverage && o.enable(21), I.push(o.mask) } function C(I) { const D = g[I.type]; let F; if (D) { const B = Ic[D]; F = Cae.clone(B.uniforms) } else F = I.uniforms; return F } function N(I, D) { let F; for (let B = 0, G = d.length; B < G; B++) { const z = d[B]; if (z.cacheKey === D) { F = z, ++F.usedTimes; break } } return F === void 0 && (F = new OIe(t, D, I, a), d.push(F)), F } function A(I) { if (--I.usedTimes === 0) { const D = d.indexOf(I); d[D] = d[d.length - 1], d.pop(), I.destroy() } } function j(I) { c.remove(I) } function O() { c.dispose() } return { getParameters: v, getProgramCacheKey: b, getUniforms: C, acquireProgram: N, releaseProgram: A, releaseShaderCache: j, programs: d, dispose: O } } function BIe() { let t = new WeakMap; function e(s) { return t.has(s) } function n(s) { let o = t.get(s); return o === void 0 && (o = {}, t.set(s, o)), o } function r(s) { t.delete(s) } function i(s, o, c) { t.get(s)[o] = c } function a() { t = new WeakMap } return { has: e, get: n, remove: r, update: i, dispose: a } } function $Ie(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function ZW(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function QW() { const t = []; let e = 0; const n = [], r = [], i = []; function a() { e = 0, n.length = 0, r.length = 0, i.length = 0 } function s(f, h, m, g, x, v) { let b = t[e]; return b === void 0 ? (b = { id: f.id, object: f, geometry: h, material: m, groupOrder: g, renderOrder: f.renderOrder, z: x, group: v }, t[e] = b) : (b.id = f.id, b.object = f, b.geometry = h, b.material = m, b.groupOrder = g, b.renderOrder = f.renderOrder, b.z = x, b.group = v), e++, b } function o(f, h, m, g, x, v) { const b = s(f, h, m, g, x, v); m.transmission > 0 ? r.push(b) : m.transparent === !0 ? i.push(b) : n.push(b) } function c(f, h, m, g, x, v) { const b = s(f, h, m, g, x, v); m.transmission > 0 ? r.unshift(b) : m.transparent === !0 ? i.unshift(b) : n.unshift(b) } function u(f, h) { n.length > 1 && n.sort(f || $Ie), r.length > 1 && r.sort(h || ZW), i.length > 1 && i.sort(h || ZW) } function d() { for (let f = e, h = t.length; f < h; f++) { const m = t[f]; if (m.id === null) break; m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null } } return { opaque: n, transmissive: r, transparent: i, init: a, push: o, unshift: c, finish: d, sort: u } } function zIe() { let t = new WeakMap; function e(r, i) { const a = t.get(r); let s; return a === void 0 ? (s = new QW, t.set(r, [s])) : i >= a.length ? (s = new QW, a.push(s)) : s = a[i], s } function n() { t = new WeakMap } return { get: e, dispose: n } } function VIe() { const t = {}; return { get: function (e) { if (t[e.id] !== void 0) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new pe, color: new Kt }; break; case "SpotLight": n = { position: new pe, direction: new pe, color: new Kt, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new pe, color: new Kt, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new pe, skyColor: new Kt, groundColor: new Kt }; break; case "RectAreaLight": n = { color: new Kt, position: new pe, halfWidth: new pe, halfHeight: new pe }; break }return t[e.id] = n, n } } } function HIe() { const t = {}; return { get: function (e) { if (t[e.id] !== void 0) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new lt }; break; case "SpotLight": n = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new lt }; break; case "PointLight": n = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new lt, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return t[e.id] = n, n } } } let WIe = 0; function GIe(t, e) { return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0) } function qIe(t) { const e = new VIe, n = HIe(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let u = 0; u < 9; u++)r.probe.push(new pe); const i = new pe, a = new Fn, s = new Fn; function o(u) { let d = 0, f = 0, h = 0; for (let I = 0; I < 9; I++)r.probe[I].set(0, 0, 0); let m = 0, g = 0, x = 0, v = 0, b = 0, E = 0, M = 0, C = 0, N = 0, A = 0, j = 0; u.sort(GIe); for (let I = 0, D = u.length; I < D; I++) { const F = u[I], B = F.color, G = F.intensity, z = F.distance, q = F.shadow && F.shadow.map ? F.shadow.map.texture : null; if (F.isAmbientLight) d += B.r * G, f += B.g * G, h += B.b * G; else if (F.isLightProbe) { for (let Y = 0; Y < 9; Y++)r.probe[Y].addScaledVector(F.sh.coefficients[Y], G); j++ } else if (F.isDirectionalLight) { const Y = e.get(F); if (Y.color.copy(F.color).multiplyScalar(F.intensity), F.castShadow) { const Z = F.shadow, $ = n.get(F); $.shadowIntensity = Z.intensity, $.shadowBias = Z.bias, $.shadowNormalBias = Z.normalBias, $.shadowRadius = Z.radius, $.shadowMapSize = Z.mapSize, r.directionalShadow[m] = $, r.directionalShadowMap[m] = q, r.directionalShadowMatrix[m] = F.shadow.matrix, E++ } r.directional[m] = Y, m++ } else if (F.isSpotLight) { const Y = e.get(F); Y.position.setFromMatrixPosition(F.matrixWorld), Y.color.copy(B).multiplyScalar(G), Y.distance = z, Y.coneCos = Math.cos(F.angle), Y.penumbraCos = Math.cos(F.angle * (1 - F.penumbra)), Y.decay = F.decay, r.spot[x] = Y; const Z = F.shadow; if (F.map && (r.spotLightMap[N] = F.map, N++, Z.updateMatrices(F), F.castShadow && A++), r.spotLightMatrix[x] = Z.matrix, F.castShadow) { const $ = n.get(F); $.shadowIntensity = Z.intensity, $.shadowBias = Z.bias, $.shadowNormalBias = Z.normalBias, $.shadowRadius = Z.radius, $.shadowMapSize = Z.mapSize, r.spotShadow[x] = $, r.spotShadowMap[x] = q, C++ } x++ } else if (F.isRectAreaLight) { const Y = e.get(F); Y.color.copy(B).multiplyScalar(G), Y.halfWidth.set(F.width * .5, 0, 0), Y.halfHeight.set(0, F.height * .5, 0), r.rectArea[v] = Y, v++ } else if (F.isPointLight) { const Y = e.get(F); if (Y.color.copy(F.color).multiplyScalar(F.intensity), Y.distance = F.distance, Y.decay = F.decay, F.castShadow) { const Z = F.shadow, $ = n.get(F); $.shadowIntensity = Z.intensity, $.shadowBias = Z.bias, $.shadowNormalBias = Z.normalBias, $.shadowRadius = Z.radius, $.shadowMapSize = Z.mapSize, $.shadowCameraNear = Z.camera.near, $.shadowCameraFar = Z.camera.far, r.pointShadow[g] = $, r.pointShadowMap[g] = q, r.pointShadowMatrix[g] = F.shadow.matrix, M++ } r.point[g] = Y, g++ } else if (F.isHemisphereLight) { const Y = e.get(F); Y.skyColor.copy(F.color).multiplyScalar(G), Y.groundColor.copy(F.groundColor).multiplyScalar(G), r.hemi[b] = Y, b++ } } v > 0 && (t.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Wt.LTC_FLOAT_1, r.rectAreaLTC2 = Wt.LTC_FLOAT_2) : (r.rectAreaLTC1 = Wt.LTC_HALF_1, r.rectAreaLTC2 = Wt.LTC_HALF_2)), r.ambient[0] = d, r.ambient[1] = f, r.ambient[2] = h; const O = r.hash; (O.directionalLength !== m || O.pointLength !== g || O.spotLength !== x || O.rectAreaLength !== v || O.hemiLength !== b || O.numDirectionalShadows !== E || O.numPointShadows !== M || O.numSpotShadows !== C || O.numSpotMaps !== N || O.numLightProbes !== j) && (r.directional.length = m, r.spot.length = x, r.rectArea.length = v, r.point.length = g, r.hemi.length = b, r.directionalShadow.length = E, r.directionalShadowMap.length = E, r.pointShadow.length = M, r.pointShadowMap.length = M, r.spotShadow.length = C, r.spotShadowMap.length = C, r.directionalShadowMatrix.length = E, r.pointShadowMatrix.length = M, r.spotLightMatrix.length = C + N - A, r.spotLightMap.length = N, r.numSpotLightShadowsWithMaps = A, r.numLightProbes = j, O.directionalLength = m, O.pointLength = g, O.spotLength = x, O.rectAreaLength = v, O.hemiLength = b, O.numDirectionalShadows = E, O.numPointShadows = M, O.numSpotShadows = C, O.numSpotMaps = N, O.numLightProbes = j, r.version = WIe++) } function c(u, d) { let f = 0, h = 0, m = 0, g = 0, x = 0; const v = d.matrixWorldInverse; for (let b = 0, E = u.length; b < E; b++) { const M = u[b]; if (M.isDirectionalLight) { const C = r.directional[f]; C.direction.setFromMatrixPosition(M.matrixWorld), i.setFromMatrixPosition(M.target.matrixWorld), C.direction.sub(i), C.direction.transformDirection(v), f++ } else if (M.isSpotLight) { const C = r.spot[m]; C.position.setFromMatrixPosition(M.matrixWorld), C.position.applyMatrix4(v), C.direction.setFromMatrixPosition(M.matrixWorld), i.setFromMatrixPosition(M.target.matrixWorld), C.direction.sub(i), C.direction.transformDirection(v), m++ } else if (M.isRectAreaLight) { const C = r.rectArea[g]; C.position.setFromMatrixPosition(M.matrixWorld), C.position.applyMatrix4(v), s.identity(), a.copy(M.matrixWorld), a.premultiply(v), s.extractRotation(a), C.halfWidth.set(M.width * .5, 0, 0), C.halfHeight.set(0, M.height * .5, 0), C.halfWidth.applyMatrix4(s), C.halfHeight.applyMatrix4(s), g++ } else if (M.isPointLight) { const C = r.point[h]; C.position.setFromMatrixPosition(M.matrixWorld), C.position.applyMatrix4(v), h++ } else if (M.isHemisphereLight) { const C = r.hemi[x]; C.direction.setFromMatrixPosition(M.matrixWorld), C.direction.transformDirection(v), x++ } } } return { setup: o, setupView: c, state: r } } function JW(t) { const e = new qIe(t), n = [], r = []; function i(d) { u.camera = d, n.length = 0, r.length = 0 } function a(d) { n.push(d) } function s(d) { r.push(d) } function o() { e.setup(n) } function c(d) { e.setupView(n, d) } const u = { lightsArray: n, shadowsArray: r, camera: null, lights: e, transmissionRenderTarget: {} }; return { init: i, state: u, setupLights: o, setupLightsView: c, pushLight: a, pushShadow: s } } function XIe(t) { let e = new WeakMap; function n(i, a = 0) { const s = e.get(i); let o; return s === void 0 ? (o = new JW(t), e.set(i, [o])) : a >= s.length ? (o = new JW(t), s.push(o)) : o = s[a], o } function r() { e = new WeakMap } return { get: n, dispose: r } } const YIe = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, KIe = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function ZIe(t, e, n) { let r = new N0; const i = new lt, a = new lt, s = new jr, o = new gB({ depthPacking: hae }), c = new vB, u = {}, d = n.maxTextureSize, f = { [yf]: io, [io]: yf, [Oc]: Oc }, h = new Bo({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new lt }, radius: { value: 4 } }, vertexShader: YIe, fragmentShader: KIe }), m = h.clone(); m.defines.HORIZONTAL_PASS = 1; const g = new Kn; g.setAttribute("position", new Lr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const x = new Bi(g, h), v = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = BA; let b = this.type; this.render = function (A, j, O) { if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || A.length === 0) return; const I = t.getRenderTarget(), D = t.getActiveCubeFace(), F = t.getActiveMipmapLevel(), B = t.state; B.setBlending(Pu), B.buffers.depth.getReversed() === !0 ? B.buffers.color.setClear(0, 0, 0, 0) : B.buffers.color.setClear(1, 1, 1, 1), B.buffers.depth.setTest(!0), B.setScissorTest(!1); const G = b !== Pc && this.type === Pc, z = b === Pc && this.type !== Pc; for (let q = 0, Y = A.length; q < Y; q++) { const Z = A[q], $ = Z.shadow; if ($ === void 0) { console.warn("THREE.WebGLShadowMap:", Z, "has no shadow."); continue } if ($.autoUpdate === !1 && $.needsUpdate === !1) continue; i.copy($.mapSize); const V = $.getFrameExtents(); if (i.multiply(V), a.copy($.mapSize), (i.x > d || i.y > d) && (i.x > d && (a.x = Math.floor(d / V.x), i.x = a.x * V.x, $.mapSize.x = a.x), i.y > d && (a.y = Math.floor(d / V.y), i.y = a.y * V.y, $.mapSize.y = a.y)), $.map === null || G === !0 || z === !0) { const X = this.type !== Pc ? { minFilter: cs, magFilter: cs } : {}; $.map !== null && $.map.dispose(), $.map = new Hl(i.x, i.y, X), $.map.texture.name = Z.name + ".shadowMap", $.camera.updateProjectionMatrix() } t.setRenderTarget($.map), t.clear(); const K = $.getViewportCount(); for (let X = 0; X < K; X++) { const Q = $.getViewport(X); s.set(a.x * Q.x, a.y * Q.y, a.x * Q.z, a.y * Q.w), B.viewport(s), $.updateMatrices(Z, X), r = $.getFrustum(), C(j, O, $.camera, Z, this.type) } $.isPointLightShadow !== !0 && this.type === Pc && E($, O), $.needsUpdate = !1 } b = this.type, v.needsUpdate = !1, t.setRenderTarget(I, D, F) }; function E(A, j) { const O = e.update(x); h.defines.VSM_SAMPLES !== A.blurSamples && (h.defines.VSM_SAMPLES = A.blurSamples, m.defines.VSM_SAMPLES = A.blurSamples, h.needsUpdate = !0, m.needsUpdate = !0), A.mapPass === null && (A.mapPass = new Hl(i.x, i.y)), h.uniforms.shadow_pass.value = A.map.texture, h.uniforms.resolution.value = A.mapSize, h.uniforms.radius.value = A.radius, t.setRenderTarget(A.mapPass), t.clear(), t.renderBufferDirect(j, null, O, h, x, null), m.uniforms.shadow_pass.value = A.mapPass.texture, m.uniforms.resolution.value = A.mapSize, m.uniforms.radius.value = A.radius, t.setRenderTarget(A.map), t.clear(), t.renderBufferDirect(j, null, O, m, x, null) } function M(A, j, O, I) { let D = null; const F = O.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial; if (F !== void 0) D = F; else if (D = O.isPointLight === !0 ? c : o, t.localClippingEnabled && j.clipShadows === !0 && Array.isArray(j.clippingPlanes) && j.clippingPlanes.length !== 0 || j.displacementMap && j.displacementScale !== 0 || j.alphaMap && j.alphaTest > 0 || j.map && j.alphaTest > 0 || j.alphaToCoverage === !0) { const B = D.uuid, G = j.uuid; let z = u[B]; z === void 0 && (z = {}, u[B] = z); let q = z[G]; q === void 0 && (q = D.clone(), z[G] = q, j.addEventListener("dispose", N)), D = q } if (D.visible = j.visible, D.wireframe = j.wireframe, I === Pc ? D.side = j.shadowSide !== null ? j.shadowSide : j.side : D.side = j.shadowSide !== null ? j.shadowSide : f[j.side], D.alphaMap = j.alphaMap, D.alphaTest = j.alphaToCoverage === !0 ? .5 : j.alphaTest, D.map = j.map, D.clipShadows = j.clipShadows, D.clippingPlanes = j.clippingPlanes, D.clipIntersection = j.clipIntersection, D.displacementMap = j.displacementMap, D.displacementScale = j.displacementScale, D.displacementBias = j.displacementBias, D.wireframeLinewidth = j.wireframeLinewidth, D.linewidth = j.linewidth, O.isPointLight === !0 && D.isMeshDistanceMaterial === !0) { const B = t.properties.get(D); B.light = O } return D } function C(A, j, O, I, D) { if (A.visible === !1) return; if (A.layers.test(j.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && D === Pc) && (!A.frustumCulled || r.intersectsObject(A))) { A.modelViewMatrix.multiplyMatrices(O.matrixWorldInverse, A.matrixWorld); const G = e.update(A), z = A.material; if (Array.isArray(z)) { const q = G.groups; for (let Y = 0, Z = q.length; Y < Z; Y++) { const $ = q[Y], V = z[$.materialIndex]; if (V && V.visible) { const K = M(A, V, I, D); A.onBeforeShadow(t, A, j, O, G, K, $), t.renderBufferDirect(O, null, G, K, A, $), A.onAfterShadow(t, A, j, O, G, K, $) } } } else if (z.visible) { const q = M(A, z, I, D); A.onBeforeShadow(t, A, j, O, G, q, null), t.renderBufferDirect(O, null, G, q, A, null), A.onAfterShadow(t, A, j, O, G, q, null) } } const B = A.children; for (let G = 0, z = B.length; G < z; G++)C(B[G], j, O, I, D) } function N(A) { A.target.removeEventListener("dispose", N); for (const O in u) { const I = u[O], D = A.target.uuid; D in I && (I[D].dispose(), delete I[D]) } } } const QIe = { [lC]: cC, [uC]: hC, [dC]: pC, [Eg]: fC, [cC]: lC, [hC]: uC, [pC]: dC, [fC]: Eg }; function JIe(t, e) { function n() { let Ee = !1; const De = new jr; let gt = null; const Bt = new jr(0, 0, 0, 0); return { setMask: function (mt) { gt !== mt && !Ee && (t.colorMask(mt, mt, mt, mt), gt = mt) }, setLocked: function (mt) { Ee = mt }, setClear: function (mt, ot, it, Ft, un) { un === !0 && (mt *= Ft, ot *= Ft, it *= Ft), De.set(mt, ot, it, Ft), Bt.equals(De) === !1 && (t.clearColor(mt, ot, it, Ft), Bt.copy(De)) }, reset: function () { Ee = !1, gt = null, Bt.set(-1, 0, 0, 0) } } } function r() { let Ee = !1, De = !1, gt = null, Bt = null, mt = null; return { setReversed: function (ot) { if (De !== ot) { const it = e.get("EXT_clip_control"); ot ? it.clipControlEXT(it.LOWER_LEFT_EXT, it.ZERO_TO_ONE_EXT) : it.clipControlEXT(it.LOWER_LEFT_EXT, it.NEGATIVE_ONE_TO_ONE_EXT), De = ot; const Ft = mt; mt = null, this.setClear(Ft) } }, getReversed: function () { return De }, setTest: function (ot) { ot ? ae(t.DEPTH_TEST) : se(t.DEPTH_TEST) }, setMask: function (ot) { gt !== ot && !Ee && (t.depthMask(ot), gt = ot) }, setFunc: function (ot) { if (De && (ot = QIe[ot]), Bt !== ot) { switch (ot) { case lC: t.depthFunc(t.NEVER); break; case cC: t.depthFunc(t.ALWAYS); break; case uC: t.depthFunc(t.LESS); break; case Eg: t.depthFunc(t.LEQUAL); break; case dC: t.depthFunc(t.EQUAL); break; case fC: t.depthFunc(t.GEQUAL); break; case hC: t.depthFunc(t.GREATER); break; case pC: t.depthFunc(t.NOTEQUAL); break; default: t.depthFunc(t.LEQUAL) }Bt = ot } }, setLocked: function (ot) { Ee = ot }, setClear: function (ot) { mt !== ot && (De && (ot = 1 - ot), t.clearDepth(ot), mt = ot) }, reset: function () { Ee = !1, gt = null, Bt = null, mt = null, De = !1 } } } function i() { let Ee = !1, De = null, gt = null, Bt = null, mt = null, ot = null, it = null, Ft = null, un = null; return { setTest: function (wn) { Ee || (wn ? ae(t.STENCIL_TEST) : se(t.STENCIL_TEST)) }, setMask: function (wn) { De !== wn && !Ee && (t.stencilMask(wn), De = wn) }, setFunc: function (wn, wr, Tr) { (gt !== wn || Bt !== wr || mt !== Tr) && (t.stencilFunc(wn, wr, Tr), gt = wn, Bt = wr, mt = Tr) }, setOp: function (wn, wr, Tr) { (ot !== wn || it !== wr || Ft !== Tr) && (t.stencilOp(wn, wr, Tr), ot = wn, it = wr, Ft = Tr) }, setLocked: function (wn) { Ee = wn }, setClear: function (wn) { un !== wn && (t.clearStencil(wn), un = wn) }, reset: function () { Ee = !1, De = null, gt = null, Bt = null, mt = null, ot = null, it = null, Ft = null, un = null } } } const a = new n, s = new r, o = new i, c = new WeakMap, u = new WeakMap; let d = {}, f = {}, h = new WeakMap, m = [], g = null, x = !1, v = null, b = null, E = null, M = null, C = null, N = null, A = null, j = new Kt(0, 0, 0), O = 0, I = !1, D = null, F = null, B = null, G = null, z = null; const q = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let Y = !1, Z = 0; const $ = t.getParameter(t.VERSION); $.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec($)[1]), Y = Z >= 1) : $.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec($)[1]), Y = Z >= 2); let V = null, K = {}; const X = t.getParameter(t.SCISSOR_BOX), Q = t.getParameter(t.VIEWPORT), re = new jr().fromArray(X), ce = new jr().fromArray(Q); function be(Ee, De, gt, Bt) { const mt = new Uint8Array(4), ot = t.createTexture(); t.bindTexture(Ee, ot), t.texParameteri(Ee, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(Ee, t.TEXTURE_MAG_FILTER, t.NEAREST); for (let it = 0; it < gt; it++)Ee === t.TEXTURE_3D || Ee === t.TEXTURE_2D_ARRAY ? t.texImage3D(De, 0, t.RGBA, 1, 1, Bt, 0, t.RGBA, t.UNSIGNED_BYTE, mt) : t.texImage2D(De + it, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, mt); return ot } const de = {}; de[t.TEXTURE_2D] = be(t.TEXTURE_2D, t.TEXTURE_2D, 1), de[t.TEXTURE_CUBE_MAP] = be(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), de[t.TEXTURE_2D_ARRAY] = be(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), de[t.TEXTURE_3D] = be(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), ae(t.DEPTH_TEST), s.setFunc(Eg), je(!1), ke(DL), ae(t.CULL_FACE), xe(Pu); function ae(Ee) { d[Ee] !== !0 && (t.enable(Ee), d[Ee] = !0) } function se(Ee) { d[Ee] !== !1 && (t.disable(Ee), d[Ee] = !1) } function he(Ee, De) { return f[Ee] !== De ? (t.bindFramebuffer(Ee, De), f[Ee] = De, Ee === t.DRAW_FRAMEBUFFER && (f[t.FRAMEBUFFER] = De), Ee === t.FRAMEBUFFER && (f[t.DRAW_FRAMEBUFFER] = De), !0) : !1 } function Ae(Ee, De) { let gt = m, Bt = !1; if (Ee) { gt = h.get(De), gt === void 0 && (gt = [], h.set(De, gt)); const mt = Ee.textures; if (gt.length !== mt.length || gt[0] !== t.COLOR_ATTACHMENT0) { for (let ot = 0, it = mt.length; ot < it; ot++)gt[ot] = t.COLOR_ATTACHMENT0 + ot; gt.length = mt.length, Bt = !0 } } else gt[0] !== t.BACK && (gt[0] = t.BACK, Bt = !0); Bt && t.drawBuffers(gt) } function Ce(Ee) { return g !== Ee ? (t.useProgram(Ee), g = Ee, !0) : !1 } const fe = { [jh]: t.FUNC_ADD, [Lie]: t.FUNC_SUBTRACT, [Fie]: t.FUNC_REVERSE_SUBTRACT }; fe[Uie] = t.MIN, fe[Bie] = t.MAX; const oe = { [$ie]: t.ZERO, [zie]: t.ONE, [Vie]: t.SRC_COLOR, [sC]: t.SRC_ALPHA, [Yie]: t.SRC_ALPHA_SATURATE, [qie]: t.DST_COLOR, [Wie]: t.DST_ALPHA, [Hie]: t.ONE_MINUS_SRC_COLOR, [oC]: t.ONE_MINUS_SRC_ALPHA, [Xie]: t.ONE_MINUS_DST_COLOR, [Gie]: t.ONE_MINUS_DST_ALPHA, [Kie]: t.CONSTANT_COLOR, [Zie]: t.ONE_MINUS_CONSTANT_COLOR, [Qie]: t.CONSTANT_ALPHA, [Jie]: t.ONE_MINUS_CONSTANT_ALPHA }; function xe(Ee, De, gt, Bt, mt, ot, it, Ft, un, wn) { if (Ee === Pu) { x === !0 && (se(t.BLEND), x = !1); return } if (x === !1 && (ae(t.BLEND), x = !0), Ee !== Die) { if (Ee !== v || wn !== I) { if ((b !== jh || C !== jh) && (t.blendEquation(t.FUNC_ADD), b = jh, C = jh), wn) switch (Ee) { case dg: t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA); break; case LL: t.blendFunc(t.ONE, t.ONE); break; case FL: t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE); break; case UL: t.blendFuncSeparate(t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ZERO, t.ONE); break; default: console.error("THREE.WebGLState: Invalid blending: ", Ee); break } else switch (Ee) { case dg: t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA); break; case LL: t.blendFuncSeparate(t.SRC_ALPHA, t.ONE, t.ONE, t.ONE); break; case FL: console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true"); break; case UL: console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true"); break; default: console.error("THREE.WebGLState: Invalid blending: ", Ee); break }E = null, M = null, N = null, A = null, j.set(0, 0, 0), O = 0, v = Ee, I = wn } return } mt = mt || De, ot = ot || gt, it = it || Bt, (De !== b || mt !== C) && (t.blendEquationSeparate(fe[De], fe[mt]), b = De, C = mt), (gt !== E || Bt !== M || ot !== N || it !== A) && (t.blendFuncSeparate(oe[gt], oe[Bt], oe[ot], oe[it]), E = gt, M = Bt, N = ot, A = it), (Ft.equals(j) === !1 || un !== O) && (t.blendColor(Ft.r, Ft.g, Ft.b, un), j.copy(Ft), O = un), v = Ee, I = !1 } function _e(Ee, De) { Ee.side === Oc ? se(t.CULL_FACE) : ae(t.CULL_FACE); let gt = Ee.side === io; De && (gt = !gt), je(gt), Ee.blending === dg && Ee.transparent === !1 ? xe(Pu) : xe(Ee.blending, Ee.blendEquation, Ee.blendSrc, Ee.blendDst, Ee.blendEquationAlpha, Ee.blendSrcAlpha, Ee.blendDstAlpha, Ee.blendColor, Ee.blendAlpha, Ee.premultipliedAlpha), s.setFunc(Ee.depthFunc), s.setTest(Ee.depthTest), s.setMask(Ee.depthWrite), a.setMask(Ee.colorWrite); const Bt = Ee.stencilWrite; o.setTest(Bt), Bt && (o.setMask(Ee.stencilWriteMask), o.setFunc(Ee.stencilFunc, Ee.stencilRef, Ee.stencilFuncMask), o.setOp(Ee.stencilFail, Ee.stencilZFail, Ee.stencilZPass)), Xe(Ee.polygonOffset, Ee.polygonOffsetFactor, Ee.polygonOffsetUnits), Ee.alphaToCoverage === !0 ? ae(t.SAMPLE_ALPHA_TO_COVERAGE) : se(t.SAMPLE_ALPHA_TO_COVERAGE) } function je(Ee) { D !== Ee && (Ee ? t.frontFace(t.CW) : t.frontFace(t.CCW), D = Ee) } function ke(Ee) { Ee !== kie ? (ae(t.CULL_FACE), Ee !== F && (Ee === DL ? t.cullFace(t.BACK) : Ee === Iie ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : se(t.CULL_FACE), F = Ee } function Ze(Ee) { Ee !== B && (Y && t.lineWidth(Ee), B = Ee) } function Xe(Ee, De, gt) { Ee ? (ae(t.POLYGON_OFFSET_FILL), (G !== De || z !== gt) && (t.polygonOffset(De, gt), G = De, z = gt)) : se(t.POLYGON_OFFSET_FILL) } function nt(Ee) { Ee ? ae(t.SCISSOR_TEST) : se(t.SCISSOR_TEST) } function Tt(Ee) { Ee === void 0 && (Ee = t.TEXTURE0 + q - 1), V !== Ee && (t.activeTexture(Ee), V = Ee) } function St(Ee, De, gt) { gt === void 0 && (V === null ? gt = t.TEXTURE0 + q - 1 : gt = V); let Bt = K[gt]; Bt === void 0 && (Bt = { type: void 0, texture: void 0 }, K[gt] = Bt), (Bt.type !== Ee || Bt.texture !== De) && (V !== gt && (t.activeTexture(gt), V = gt), t.bindTexture(Ee, De || de[Ee]), Bt.type = Ee, Bt.texture = De) } function ee() { const Ee = K[V]; Ee !== void 0 && Ee.type !== void 0 && (t.bindTexture(Ee.type, null), Ee.type = void 0, Ee.texture = void 0) } function ne() { try { t.compressedTexImage2D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function Re() { try { t.compressedTexImage3D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function Ue() { try { t.texSubImage2D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function et() { try { t.texSubImage3D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function Ge() { try { t.compressedTexSubImage2D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function Xt() { try { t.compressedTexSubImage3D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function yt() { try { t.texStorage2D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function Yt() { try { t.texStorage3D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function en() { try { t.texImage2D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function pt() { try { t.texImage3D(...arguments) } catch (Ee) { console.error("THREE.WebGLState:", Ee) } } function bt(Ee) { re.equals(Ee) === !1 && (t.scissor(Ee.x, Ee.y, Ee.z, Ee.w), re.copy(Ee)) } function pn(Ee) { ce.equals(Ee) === !1 && (t.viewport(Ee.x, Ee.y, Ee.z, Ee.w), ce.copy(Ee)) } function Se(Ee, De) { let gt = u.get(De); gt === void 0 && (gt = new WeakMap, u.set(De, gt)); let Bt = gt.get(Ee); Bt === void 0 && (Bt = t.getUniformBlockIndex(De, Ee.name), gt.set(Ee, Bt)) } function Fe(Ee, De) { const Bt = u.get(De).get(Ee); c.get(De) !== Bt && (t.uniformBlockBinding(De, Bt, Ee.__bindingPointIndex), c.set(De, Bt)) } function ht() { t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), s.setReversed(!1), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), d = {}, V = null, K = {}, f = {}, h = new WeakMap, m = [], g = null, x = !1, v = null, b = null, E = null, M = null, C = null, N = null, A = null, j = new Kt(0, 0, 0), O = 0, I = !1, D = null, F = null, B = null, G = null, z = null, re.set(0, 0, t.canvas.width, t.canvas.height), ce.set(0, 0, t.canvas.width, t.canvas.height), a.reset(), s.reset(), o.reset() } return { buffers: { color: a, depth: s, stencil: o }, enable: ae, disable: se, bindFramebuffer: he, drawBuffers: Ae, useProgram: Ce, setBlending: xe, setMaterial: _e, setFlipSided: je, setCullFace: ke, setLineWidth: Ze, setPolygonOffset: Xe, setScissorTest: nt, activeTexture: Tt, bindTexture: St, unbindTexture: ee, compressedTexImage2D: ne, compressedTexImage3D: Re, texImage2D: en, texImage3D: pt, updateUBOMapping: Se, uniformBlockBinding: Fe, texStorage2D: yt, texStorage3D: Yt, texSubImage2D: Ue, texSubImage3D: et, compressedTexSubImage2D: Ge, compressedTexSubImage3D: Xt, scissor: bt, viewport: pn, reset: ht } } function eOe(t, e, n, r, i, a, s) { const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new lt, d = new WeakMap; let f; const h = new WeakMap; let m = !1; try { m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function g(ee, ne) { return m ? new OffscreenCanvas(ee, ne) : L1("canvas") } function x(ee, ne, Re) { let Ue = 1; const et = St(ee); if ((et.width > Re || et.height > Re) && (Ue = Re / Math.max(et.width, et.height)), Ue < 1) if (typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && ee instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && ee instanceof ImageBitmap || typeof VideoFrame < "u" && ee instanceof VideoFrame) { const Ge = Math.floor(Ue * et.width), Xt = Math.floor(Ue * et.height); f === void 0 && (f = g(Ge, Xt)); const yt = ne ? g(Ge, Xt) : f; return yt.width = Ge, yt.height = Xt, yt.getContext("2d").drawImage(ee, 0, 0, Ge, Xt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + et.width + "x" + et.height + ") to (" + Ge + "x" + Xt + ")."), yt } else return "data" in ee && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + et.width + "x" + et.height + ")."), ee; return ee } function v(ee) { return ee.generateMipmaps } function b(ee) { t.generateMipmap(ee) } function E(ee) { return ee.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : ee.isWebGL3DRenderTarget ? t.TEXTURE_3D : ee.isWebGLArrayRenderTarget || ee.isCompressedArrayTexture ? t.TEXTURE_2D_ARRAY : t.TEXTURE_2D } function M(ee, ne, Re, Ue, et = !1) { if (ee !== null) { if (t[ee] !== void 0) return t[ee]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + ee + "'") } let Ge = ne; if (ne === t.RED && (Re === t.FLOAT && (Ge = t.R32F), Re === t.HALF_FLOAT && (Ge = t.R16F), Re === t.UNSIGNED_BYTE && (Ge = t.R8)), ne === t.RED_INTEGER && (Re === t.UNSIGNED_BYTE && (Ge = t.R8UI), Re === t.UNSIGNED_SHORT && (Ge = t.R16UI), Re === t.UNSIGNED_INT && (Ge = t.R32UI), Re === t.BYTE && (Ge = t.R8I), Re === t.SHORT && (Ge = t.R16I), Re === t.INT && (Ge = t.R32I)), ne === t.RG && (Re === t.FLOAT && (Ge = t.RG32F), Re === t.HALF_FLOAT && (Ge = t.RG16F), Re === t.UNSIGNED_BYTE && (Ge = t.RG8)), ne === t.RG_INTEGER && (Re === t.UNSIGNED_BYTE && (Ge = t.RG8UI), Re === t.UNSIGNED_SHORT && (Ge = t.RG16UI), Re === t.UNSIGNED_INT && (Ge = t.RG32UI), Re === t.BYTE && (Ge = t.RG8I), Re === t.SHORT && (Ge = t.RG16I), Re === t.INT && (Ge = t.RG32I)), ne === t.RGB_INTEGER && (Re === t.UNSIGNED_BYTE && (Ge = t.RGB8UI), Re === t.UNSIGNED_SHORT && (Ge = t.RGB16UI), Re === t.UNSIGNED_INT && (Ge = t.RGB32UI), Re === t.BYTE && (Ge = t.RGB8I), Re === t.SHORT && (Ge = t.RGB16I), Re === t.INT && (Ge = t.RGB32I)), ne === t.RGBA_INTEGER && (Re === t.UNSIGNED_BYTE && (Ge = t.RGBA8UI), Re === t.UNSIGNED_SHORT && (Ge = t.RGBA16UI), Re === t.UNSIGNED_INT && (Ge = t.RGBA32UI), Re === t.BYTE && (Ge = t.RGBA8I), Re === t.SHORT && (Ge = t.RGBA16I), Re === t.INT && (Ge = t.RGBA32I)), ne === t.RGB && (Re === t.UNSIGNED_INT_5_9_9_9_REV && (Ge = t.RGB9_E5), Re === t.UNSIGNED_INT_10F_11F_11F_REV && (Ge = t.R11F_G11F_B10F)), ne === t.RGBA) { const Xt = et ? O1 : Nr.getTransfer(Ue); Re === t.FLOAT && (Ge = t.RGBA32F), Re === t.HALF_FLOAT && (Ge = t.RGBA16F), Re === t.UNSIGNED_BYTE && (Ge = Xt === Wr ? t.SRGB8_ALPHA8 : t.RGBA8), Re === t.UNSIGNED_SHORT_4_4_4_4 && (Ge = t.RGBA4), Re === t.UNSIGNED_SHORT_5_5_5_1 && (Ge = t.RGB5_A1) } return (Ge === t.R16F || Ge === t.R32F || Ge === t.RG16F || Ge === t.RG32F || Ge === t.RGBA16F || Ge === t.RGBA32F) && e.get("EXT_color_buffer_float"), Ge } function C(ee, ne) { let Re; return ee ? ne === null || ne === zu || ne === xx ? Re = t.DEPTH24_STENCIL8 : ne === Ui ? Re = t.DEPTH32F_STENCIL8 : ne === yx && (Re = t.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : ne === null || ne === zu || ne === xx ? Re = t.DEPTH_COMPONENT24 : ne === Ui ? Re = t.DEPTH_COMPONENT32F : ne === yx && (Re = t.DEPTH_COMPONENT16), Re } function N(ee, ne) { return v(ee) === !0 || ee.isFramebufferTexture && ee.minFilter !== cs && ee.minFilter !== Xr ? Math.log2(Math.max(ne.width, ne.height)) + 1 : ee.mipmaps !== void 0 && ee.mipmaps.length > 0 ? ee.mipmaps.length : ee.isCompressedTexture && Array.isArray(ee.image) ? ne.mipmaps.length : 1 } function A(ee) { const ne = ee.target; ne.removeEventListener("dispose", A), O(ne), ne.isVideoTexture && d.delete(ne) } function j(ee) { const ne = ee.target; ne.removeEventListener("dispose", j), D(ne) } function O(ee) { const ne = r.get(ee); if (ne.__webglInit === void 0) return; const Re = ee.source, Ue = h.get(Re); if (Ue) { const et = Ue[ne.__cacheKey]; et.usedTimes--, et.usedTimes === 0 && I(ee), Object.keys(Ue).length === 0 && h.delete(Re) } r.remove(ee) } function I(ee) { const ne = r.get(ee); t.deleteTexture(ne.__webglTexture); const Re = ee.source, Ue = h.get(Re); delete Ue[ne.__cacheKey], s.memory.textures-- } function D(ee) { const ne = r.get(ee); if (ee.depthTexture && (ee.depthTexture.dispose(), r.remove(ee.depthTexture)), ee.isWebGLCubeRenderTarget) for (let Ue = 0; Ue < 6; Ue++) { if (Array.isArray(ne.__webglFramebuffer[Ue])) for (let et = 0; et < ne.__webglFramebuffer[Ue].length; et++)t.deleteFramebuffer(ne.__webglFramebuffer[Ue][et]); else t.deleteFramebuffer(ne.__webglFramebuffer[Ue]); ne.__webglDepthbuffer && t.deleteRenderbuffer(ne.__webglDepthbuffer[Ue]) } else { if (Array.isArray(ne.__webglFramebuffer)) for (let Ue = 0; Ue < ne.__webglFramebuffer.length; Ue++)t.deleteFramebuffer(ne.__webglFramebuffer[Ue]); else t.deleteFramebuffer(ne.__webglFramebuffer); if (ne.__webglDepthbuffer && t.deleteRenderbuffer(ne.__webglDepthbuffer), ne.__webglMultisampledFramebuffer && t.deleteFramebuffer(ne.__webglMultisampledFramebuffer), ne.__webglColorRenderbuffer) for (let Ue = 0; Ue < ne.__webglColorRenderbuffer.length; Ue++)ne.__webglColorRenderbuffer[Ue] && t.deleteRenderbuffer(ne.__webglColorRenderbuffer[Ue]); ne.__webglDepthRenderbuffer && t.deleteRenderbuffer(ne.__webglDepthRenderbuffer) } const Re = ee.textures; for (let Ue = 0, et = Re.length; Ue < et; Ue++) { const Ge = r.get(Re[Ue]); Ge.__webglTexture && (t.deleteTexture(Ge.__webglTexture), s.memory.textures--), r.remove(Re[Ue]) } r.remove(ee) } let F = 0; function B() { F = 0 } function G() { const ee = F; return ee >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + ee + " texture units while this GPU supports only " + i.maxTextures), F += 1, ee } function z(ee) { const ne = []; return ne.push(ee.wrapS), ne.push(ee.wrapT), ne.push(ee.wrapR || 0), ne.push(ee.magFilter), ne.push(ee.minFilter), ne.push(ee.anisotropy), ne.push(ee.internalFormat), ne.push(ee.format), ne.push(ee.type), ne.push(ee.generateMipmaps), ne.push(ee.premultiplyAlpha), ne.push(ee.flipY), ne.push(ee.unpackAlignment), ne.push(ee.colorSpace), ne.join() } function q(ee, ne) { const Re = r.get(ee); if (ee.isVideoTexture && nt(ee), ee.isRenderTargetTexture === !1 && ee.isExternalTexture !== !0 && ee.version > 0 && Re.__version !== ee.version) { const Ue = ee.image; if (Ue === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (Ue.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { de(Re, ee, ne); return } } else ee.isExternalTexture && (Re.__webglTexture = ee.sourceTexture ? ee.sourceTexture : null); n.bindTexture(t.TEXTURE_2D, Re.__webglTexture, t.TEXTURE0 + ne) } function Y(ee, ne) { const Re = r.get(ee); if (ee.isRenderTargetTexture === !1 && ee.version > 0 && Re.__version !== ee.version) { de(Re, ee, ne); return } n.bindTexture(t.TEXTURE_2D_ARRAY, Re.__webglTexture, t.TEXTURE0 + ne) } function Z(ee, ne) { const Re = r.get(ee); if (ee.isRenderTargetTexture === !1 && ee.version > 0 && Re.__version !== ee.version) { de(Re, ee, ne); return } n.bindTexture(t.TEXTURE_3D, Re.__webglTexture, t.TEXTURE0 + ne) } function $(ee, ne) { const Re = r.get(ee); if (ee.version > 0 && Re.__version !== ee.version) { ae(Re, ee, ne); return } n.bindTexture(t.TEXTURE_CUBE_MAP, Re.__webglTexture, t.TEXTURE0 + ne) } const V = { [j1]: t.REPEAT, [va]: t.CLAMP_TO_EDGE, [R1]: t.MIRRORED_REPEAT }, K = { [cs]: t.NEAREST, [WU]: t.NEAREST_MIPMAP_NEAREST, [Fy]: t.NEAREST_MIPMAP_LINEAR, [Xr]: t.LINEAR, [Gw]: t.LINEAR_MIPMAP_NEAREST, [bu]: t.LINEAR_MIPMAP_LINEAR }, X = { [mae]: t.NEVER, [wae]: t.ALWAYS, [gae]: t.LESS, [QU]: t.LEQUAL, [vae]: t.EQUAL, [bae]: t.GEQUAL, [yae]: t.GREATER, [xae]: t.NOTEQUAL }; function Q(ee, ne) { if (ne.type === Ui && e.has("OES_texture_float_linear") === !1 && (ne.magFilter === Xr || ne.magFilter === Gw || ne.magFilter === Fy || ne.magFilter === bu || ne.minFilter === Xr || ne.minFilter === Gw || ne.minFilter === Fy || ne.minFilter === bu) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), t.texParameteri(ee, t.TEXTURE_WRAP_S, V[ne.wrapS]), t.texParameteri(ee, t.TEXTURE_WRAP_T, V[ne.wrapT]), (ee === t.TEXTURE_3D || ee === t.TEXTURE_2D_ARRAY) && t.texParameteri(ee, t.TEXTURE_WRAP_R, V[ne.wrapR]), t.texParameteri(ee, t.TEXTURE_MAG_FILTER, K[ne.magFilter]), t.texParameteri(ee, t.TEXTURE_MIN_FILTER, K[ne.minFilter]), ne.compareFunction && (t.texParameteri(ee, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(ee, t.TEXTURE_COMPARE_FUNC, X[ne.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) { if (ne.magFilter === cs || ne.minFilter !== Fy && ne.minFilter !== bu || ne.type === Ui && e.has("OES_texture_float_linear") === !1) return; if (ne.anisotropy > 1 || r.get(ne).__currentAnisotropy) { const Re = e.get("EXT_texture_filter_anisotropic"); t.texParameterf(ee, Re.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(ne.anisotropy, i.getMaxAnisotropy())), r.get(ne).__currentAnisotropy = ne.anisotropy } } } function re(ee, ne) { let Re = !1; ee.__webglInit === void 0 && (ee.__webglInit = !0, ne.addEventListener("dispose", A)); const Ue = ne.source; let et = h.get(Ue); et === void 0 && (et = {}, h.set(Ue, et)); const Ge = z(ne); if (Ge !== ee.__cacheKey) { et[Ge] === void 0 && (et[Ge] = { texture: t.createTexture(), usedTimes: 0 }, s.memory.textures++, Re = !0), et[Ge].usedTimes++; const Xt = et[ee.__cacheKey]; Xt !== void 0 && (et[ee.__cacheKey].usedTimes--, Xt.usedTimes === 0 && I(ne)), ee.__cacheKey = Ge, ee.__webglTexture = et[Ge].texture } return Re } function ce(ee, ne, Re) { return Math.floor(Math.floor(ee / Re) / ne) } function be(ee, ne, Re, Ue) { const Ge = ee.updateRanges; if (Ge.length === 0) n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, ne.width, ne.height, Re, Ue, ne.data); else { Ge.sort((pt, bt) => pt.start - bt.start); let Xt = 0; for (let pt = 1; pt < Ge.length; pt++) { const bt = Ge[Xt], pn = Ge[pt], Se = bt.start + bt.count, Fe = ce(pn.start, ne.width, 4), ht = ce(bt.start, ne.width, 4); pn.start <= Se + 1 && Fe === ht && ce(pn.start + pn.count - 1, ne.width, 4) === Fe ? bt.count = Math.max(bt.count, pn.start + pn.count - bt.start) : (++Xt, Ge[Xt] = pn) } Ge.length = Xt + 1; const yt = t.getParameter(t.UNPACK_ROW_LENGTH), Yt = t.getParameter(t.UNPACK_SKIP_PIXELS), en = t.getParameter(t.UNPACK_SKIP_ROWS); t.pixelStorei(t.UNPACK_ROW_LENGTH, ne.width); for (let pt = 0, bt = Ge.length; pt < bt; pt++) { const pn = Ge[pt], Se = Math.floor(pn.start / 4), Fe = Math.ceil(pn.count / 4), ht = Se % ne.width, Ee = Math.floor(Se / ne.width), De = Fe, gt = 1; t.pixelStorei(t.UNPACK_SKIP_PIXELS, ht), t.pixelStorei(t.UNPACK_SKIP_ROWS, Ee), n.texSubImage2D(t.TEXTURE_2D, 0, ht, Ee, De, gt, Re, Ue, ne.data) } ee.clearUpdateRanges(), t.pixelStorei(t.UNPACK_ROW_LENGTH, yt), t.pixelStorei(t.UNPACK_SKIP_PIXELS, Yt), t.pixelStorei(t.UNPACK_SKIP_ROWS, en) } } function de(ee, ne, Re) { let Ue = t.TEXTURE_2D; (ne.isDataArrayTexture || ne.isCompressedArrayTexture) && (Ue = t.TEXTURE_2D_ARRAY), ne.isData3DTexture && (Ue = t.TEXTURE_3D); const et = re(ee, ne), Ge = ne.source; n.bindTexture(Ue, ee.__webglTexture, t.TEXTURE0 + Re); const Xt = r.get(Ge); if (Ge.version !== Xt.__version || et === !0) { n.activeTexture(t.TEXTURE0 + Re); const yt = Nr.getPrimaries(Nr.workingColorSpace), Yt = ne.colorSpace === Kd ? null : Nr.getPrimaries(ne.colorSpace), en = ne.colorSpace === Kd || yt === Yt ? t.NONE : t.BROWSER_DEFAULT_WEBGL; t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, ne.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, ne.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, en); let pt = x(ne.image, !1, i.maxTextureSize); pt = Tt(ne, pt); const bt = a.convert(ne.format, ne.colorSpace), pn = a.convert(ne.type); let Se = M(ne.internalFormat, bt, pn, ne.colorSpace, ne.isVideoTexture); Q(Ue, ne); let Fe; const ht = ne.mipmaps, Ee = ne.isVideoTexture !== !0, De = Xt.__version === void 0 || et === !0, gt = Ge.dataReady, Bt = N(ne, pt); if (ne.isDepthTexture) Se = C(ne.format === wx, ne.type), De && (Ee ? n.texStorage2D(t.TEXTURE_2D, 1, Se, pt.width, pt.height) : n.texImage2D(t.TEXTURE_2D, 0, Se, pt.width, pt.height, 0, bt, pn, null)); else if (ne.isDataTexture) if (ht.length > 0) { Ee && De && n.texStorage2D(t.TEXTURE_2D, Bt, Se, ht[0].width, ht[0].height); for (let mt = 0, ot = ht.length; mt < ot; mt++)Fe = ht[mt], Ee ? gt && n.texSubImage2D(t.TEXTURE_2D, mt, 0, 0, Fe.width, Fe.height, bt, pn, Fe.data) : n.texImage2D(t.TEXTURE_2D, mt, Se, Fe.width, Fe.height, 0, bt, pn, Fe.data); ne.generateMipmaps = !1 } else Ee ? (De && n.texStorage2D(t.TEXTURE_2D, Bt, Se, pt.width, pt.height), gt && be(ne, pt, bt, pn)) : n.texImage2D(t.TEXTURE_2D, 0, Se, pt.width, pt.height, 0, bt, pn, pt.data); else if (ne.isCompressedTexture) if (ne.isCompressedArrayTexture) { Ee && De && n.texStorage3D(t.TEXTURE_2D_ARRAY, Bt, Se, ht[0].width, ht[0].height, pt.depth); for (let mt = 0, ot = ht.length; mt < ot; mt++)if (Fe = ht[mt], ne.format !== ia) if (bt !== null) if (Ee) { if (gt) if (ne.layerUpdates.size > 0) { const it = ZL(Fe.width, Fe.height, ne.format, ne.type); for (const Ft of ne.layerUpdates) { const un = Fe.data.subarray(Ft * it / Fe.data.BYTES_PER_ELEMENT, (Ft + 1) * it / Fe.data.BYTES_PER_ELEMENT); n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, mt, 0, 0, Ft, Fe.width, Fe.height, 1, bt, un) } ne.clearLayerUpdates() } else n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, mt, 0, 0, 0, Fe.width, Fe.height, pt.depth, bt, Fe.data) } else n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, mt, Se, Fe.width, Fe.height, pt.depth, 0, Fe.data, 0, 0); else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"); else Ee ? gt && n.texSubImage3D(t.TEXTURE_2D_ARRAY, mt, 0, 0, 0, Fe.width, Fe.height, pt.depth, bt, pn, Fe.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, mt, Se, Fe.width, Fe.height, pt.depth, 0, bt, pn, Fe.data) } else { Ee && De && n.texStorage2D(t.TEXTURE_2D, Bt, Se, ht[0].width, ht[0].height); for (let mt = 0, ot = ht.length; mt < ot; mt++)Fe = ht[mt], ne.format !== ia ? bt !== null ? Ee ? gt && n.compressedTexSubImage2D(t.TEXTURE_2D, mt, 0, 0, Fe.width, Fe.height, bt, Fe.data) : n.compressedTexImage2D(t.TEXTURE_2D, mt, Se, Fe.width, Fe.height, 0, Fe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ee ? gt && n.texSubImage2D(t.TEXTURE_2D, mt, 0, 0, Fe.width, Fe.height, bt, pn, Fe.data) : n.texImage2D(t.TEXTURE_2D, mt, Se, Fe.width, Fe.height, 0, bt, pn, Fe.data) } else if (ne.isDataArrayTexture) if (Ee) { if (De && n.texStorage3D(t.TEXTURE_2D_ARRAY, Bt, Se, pt.width, pt.height, pt.depth), gt) if (ne.layerUpdates.size > 0) { const mt = ZL(pt.width, pt.height, ne.format, ne.type); for (const ot of ne.layerUpdates) { const it = pt.data.subarray(ot * mt / pt.data.BYTES_PER_ELEMENT, (ot + 1) * mt / pt.data.BYTES_PER_ELEMENT); n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, ot, pt.width, pt.height, 1, bt, pn, it) } ne.clearLayerUpdates() } else n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pt.width, pt.height, pt.depth, bt, pn, pt.data) } else n.texImage3D(t.TEXTURE_2D_ARRAY, 0, Se, pt.width, pt.height, pt.depth, 0, bt, pn, pt.data); else if (ne.isData3DTexture) Ee ? (De && n.texStorage3D(t.TEXTURE_3D, Bt, Se, pt.width, pt.height, pt.depth), gt && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, pt.width, pt.height, pt.depth, bt, pn, pt.data)) : n.texImage3D(t.TEXTURE_3D, 0, Se, pt.width, pt.height, pt.depth, 0, bt, pn, pt.data); else if (ne.isFramebufferTexture) { if (De) if (Ee) n.texStorage2D(t.TEXTURE_2D, Bt, Se, pt.width, pt.height); else { let mt = pt.width, ot = pt.height; for (let it = 0; it < Bt; it++)n.texImage2D(t.TEXTURE_2D, it, Se, mt, ot, 0, bt, pn, null), mt >>= 1, ot >>= 1 } } else if (ht.length > 0) { if (Ee && De) { const mt = St(ht[0]); n.texStorage2D(t.TEXTURE_2D, Bt, Se, mt.width, mt.height) } for (let mt = 0, ot = ht.length; mt < ot; mt++)Fe = ht[mt], Ee ? gt && n.texSubImage2D(t.TEXTURE_2D, mt, 0, 0, bt, pn, Fe) : n.texImage2D(t.TEXTURE_2D, mt, Se, bt, pn, Fe); ne.generateMipmaps = !1 } else if (Ee) { if (De) { const mt = St(pt); n.texStorage2D(t.TEXTURE_2D, Bt, Se, mt.width, mt.height) } gt && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, bt, pn, pt) } else n.texImage2D(t.TEXTURE_2D, 0, Se, bt, pn, pt); v(ne) && b(Ue), Xt.__version = Ge.version, ne.onUpdate && ne.onUpdate(ne) } ee.__version = ne.version } function ae(ee, ne, Re) { if (ne.image.length !== 6) return; const Ue = re(ee, ne), et = ne.source; n.bindTexture(t.TEXTURE_CUBE_MAP, ee.__webglTexture, t.TEXTURE0 + Re); const Ge = r.get(et); if (et.version !== Ge.__version || Ue === !0) { n.activeTexture(t.TEXTURE0 + Re); const Xt = Nr.getPrimaries(Nr.workingColorSpace), yt = ne.colorSpace === Kd ? null : Nr.getPrimaries(ne.colorSpace), Yt = ne.colorSpace === Kd || Xt === yt ? t.NONE : t.BROWSER_DEFAULT_WEBGL; t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, ne.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, ne.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Yt); const en = ne.isCompressedTexture || ne.image[0].isCompressedTexture, pt = ne.image[0] && ne.image[0].isDataTexture, bt = []; for (let ot = 0; ot < 6; ot++)!en && !pt ? bt[ot] = x(ne.image[ot], !0, i.maxCubemapSize) : bt[ot] = pt ? ne.image[ot].image : ne.image[ot], bt[ot] = Tt(ne, bt[ot]); const pn = bt[0], Se = a.convert(ne.format, ne.colorSpace), Fe = a.convert(ne.type), ht = M(ne.internalFormat, Se, Fe, ne.colorSpace), Ee = ne.isVideoTexture !== !0, De = Ge.__version === void 0 || Ue === !0, gt = et.dataReady; let Bt = N(ne, pn); Q(t.TEXTURE_CUBE_MAP, ne); let mt; if (en) { Ee && De && n.texStorage2D(t.TEXTURE_CUBE_MAP, Bt, ht, pn.width, pn.height); for (let ot = 0; ot < 6; ot++) { mt = bt[ot].mipmaps; for (let it = 0; it < mt.length; it++) { const Ft = mt[it]; ne.format !== ia ? Se !== null ? Ee ? gt && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it, 0, 0, Ft.width, Ft.height, Se, Ft.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it, ht, Ft.width, Ft.height, 0, Ft.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ee ? gt && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it, 0, 0, Ft.width, Ft.height, Se, Fe, Ft.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it, ht, Ft.width, Ft.height, 0, Se, Fe, Ft.data) } } } else { if (mt = ne.mipmaps, Ee && De) { mt.length > 0 && Bt++; const ot = St(bt[0]); n.texStorage2D(t.TEXTURE_CUBE_MAP, Bt, ht, ot.width, ot.height) } for (let ot = 0; ot < 6; ot++)if (pt) { Ee ? gt && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, 0, 0, bt[ot].width, bt[ot].height, Se, Fe, bt[ot].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, ht, bt[ot].width, bt[ot].height, 0, Se, Fe, bt[ot].data); for (let it = 0; it < mt.length; it++) { const un = mt[it].image[ot].image; Ee ? gt && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it + 1, 0, 0, un.width, un.height, Se, Fe, un.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it + 1, ht, un.width, un.height, 0, Se, Fe, un.data) } } else { Ee ? gt && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, 0, 0, Se, Fe, bt[ot]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, ht, Se, Fe, bt[ot]); for (let it = 0; it < mt.length; it++) { const Ft = mt[it]; Ee ? gt && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it + 1, 0, 0, Se, Fe, Ft.image[ot]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + ot, it + 1, ht, Se, Fe, Ft.image[ot]) } } } v(ne) && b(t.TEXTURE_CUBE_MAP), Ge.__version = et.version, ne.onUpdate && ne.onUpdate(ne) } ee.__version = ne.version } function se(ee, ne, Re, Ue, et, Ge) { const Xt = a.convert(Re.format, Re.colorSpace), yt = a.convert(Re.type), Yt = M(Re.internalFormat, Xt, yt, Re.colorSpace), en = r.get(ne), pt = r.get(Re); if (pt.__renderTarget = ne, !en.__hasExternalTextures) { const bt = Math.max(1, ne.width >> Ge), pn = Math.max(1, ne.height >> Ge); et === t.TEXTURE_3D || et === t.TEXTURE_2D_ARRAY ? n.texImage3D(et, Ge, Yt, bt, pn, ne.depth, 0, Xt, yt, null) : n.texImage2D(et, Ge, Yt, bt, pn, 0, Xt, yt, null) } n.bindFramebuffer(t.FRAMEBUFFER, ee), Xe(ne) ? o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, Ue, et, pt.__webglTexture, 0, Ze(ne)) : (et === t.TEXTURE_2D || et >= t.TEXTURE_CUBE_MAP_POSITIVE_X && et <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, Ue, et, pt.__webglTexture, Ge), n.bindFramebuffer(t.FRAMEBUFFER, null) } function he(ee, ne, Re) { if (t.bindRenderbuffer(t.RENDERBUFFER, ee), ne.depthBuffer) { const Ue = ne.depthTexture, et = Ue && Ue.isDepthTexture ? Ue.type : null, Ge = C(ne.stencilBuffer, et), Xt = ne.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT, yt = Ze(ne); Xe(ne) ? o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, yt, Ge, ne.width, ne.height) : Re ? t.renderbufferStorageMultisample(t.RENDERBUFFER, yt, Ge, ne.width, ne.height) : t.renderbufferStorage(t.RENDERBUFFER, Ge, ne.width, ne.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, Xt, t.RENDERBUFFER, ee) } else { const Ue = ne.textures; for (let et = 0; et < Ue.length; et++) { const Ge = Ue[et], Xt = a.convert(Ge.format, Ge.colorSpace), yt = a.convert(Ge.type), Yt = M(Ge.internalFormat, Xt, yt, Ge.colorSpace), en = Ze(ne); Re && Xe(ne) === !1 ? t.renderbufferStorageMultisample(t.RENDERBUFFER, en, Yt, ne.width, ne.height) : Xe(ne) ? o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, en, Yt, ne.width, ne.height) : t.renderbufferStorage(t.RENDERBUFFER, Yt, ne.width, ne.height) } } t.bindRenderbuffer(t.RENDERBUFFER, null) } function Ae(ee, ne) { if (ne && ne.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(t.FRAMEBUFFER, ee), !(ne.depthTexture && ne.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); const Ue = r.get(ne.depthTexture); Ue.__renderTarget = ne, (!Ue.__webglTexture || ne.depthTexture.image.width !== ne.width || ne.depthTexture.image.height !== ne.height) && (ne.depthTexture.image.width = ne.width, ne.depthTexture.image.height = ne.height, ne.depthTexture.needsUpdate = !0), q(ne.depthTexture, 0); const et = Ue.__webglTexture, Ge = Ze(ne); if (ne.depthTexture.format === bx) Xe(ne) ? o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, et, 0, Ge) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, et, 0); else if (ne.depthTexture.format === wx) Xe(ne) ? o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, et, 0, Ge) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, et, 0); else throw new Error("Unknown depthTexture format") } function Ce(ee) { const ne = r.get(ee), Re = ee.isWebGLCubeRenderTarget === !0; if (ne.__boundDepthTexture !== ee.depthTexture) { const Ue = ee.depthTexture; if (ne.__depthDisposeCallback && ne.__depthDisposeCallback(), Ue) { const et = () => { delete ne.__boundDepthTexture, delete ne.__depthDisposeCallback, Ue.removeEventListener("dispose", et) }; Ue.addEventListener("dispose", et), ne.__depthDisposeCallback = et } ne.__boundDepthTexture = Ue } if (ee.depthTexture && !ne.__autoAllocateDepthBuffer) { if (Re) throw new Error("target.depthTexture not supported in Cube render targets"); const Ue = ee.texture.mipmaps; Ue && Ue.length > 0 ? Ae(ne.__webglFramebuffer[0], ee) : Ae(ne.__webglFramebuffer, ee) } else if (Re) { ne.__webglDepthbuffer = []; for (let Ue = 0; Ue < 6; Ue++)if (n.bindFramebuffer(t.FRAMEBUFFER, ne.__webglFramebuffer[Ue]), ne.__webglDepthbuffer[Ue] === void 0) ne.__webglDepthbuffer[Ue] = t.createRenderbuffer(), he(ne.__webglDepthbuffer[Ue], ee, !1); else { const et = ee.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT, Ge = ne.__webglDepthbuffer[Ue]; t.bindRenderbuffer(t.RENDERBUFFER, Ge), t.framebufferRenderbuffer(t.FRAMEBUFFER, et, t.RENDERBUFFER, Ge) } } else { const Ue = ee.texture.mipmaps; if (Ue && Ue.length > 0 ? n.bindFramebuffer(t.FRAMEBUFFER, ne.__webglFramebuffer[0]) : n.bindFramebuffer(t.FRAMEBUFFER, ne.__webglFramebuffer), ne.__webglDepthbuffer === void 0) ne.__webglDepthbuffer = t.createRenderbuffer(), he(ne.__webglDepthbuffer, ee, !1); else { const et = ee.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT, Ge = ne.__webglDepthbuffer; t.bindRenderbuffer(t.RENDERBUFFER, Ge), t.framebufferRenderbuffer(t.FRAMEBUFFER, et, t.RENDERBUFFER, Ge) } } n.bindFramebuffer(t.FRAMEBUFFER, null) } function fe(ee, ne, Re) { const Ue = r.get(ee); ne !== void 0 && se(Ue.__webglFramebuffer, ee, ee.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), Re !== void 0 && Ce(ee) } function oe(ee) { const ne = ee.texture, Re = r.get(ee), Ue = r.get(ne); ee.addEventListener("dispose", j); const et = ee.textures, Ge = ee.isWebGLCubeRenderTarget === !0, Xt = et.length > 1; if (Xt || (Ue.__webglTexture === void 0 && (Ue.__webglTexture = t.createTexture()), Ue.__version = ne.version, s.memory.textures++), Ge) { Re.__webglFramebuffer = []; for (let yt = 0; yt < 6; yt++)if (ne.mipmaps && ne.mipmaps.length > 0) { Re.__webglFramebuffer[yt] = []; for (let Yt = 0; Yt < ne.mipmaps.length; Yt++)Re.__webglFramebuffer[yt][Yt] = t.createFramebuffer() } else Re.__webglFramebuffer[yt] = t.createFramebuffer() } else { if (ne.mipmaps && ne.mipmaps.length > 0) { Re.__webglFramebuffer = []; for (let yt = 0; yt < ne.mipmaps.length; yt++)Re.__webglFramebuffer[yt] = t.createFramebuffer() } else Re.__webglFramebuffer = t.createFramebuffer(); if (Xt) for (let yt = 0, Yt = et.length; yt < Yt; yt++) { const en = r.get(et[yt]); en.__webglTexture === void 0 && (en.__webglTexture = t.createTexture(), s.memory.textures++) } if (ee.samples > 0 && Xe(ee) === !1) { Re.__webglMultisampledFramebuffer = t.createFramebuffer(), Re.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, Re.__webglMultisampledFramebuffer); for (let yt = 0; yt < et.length; yt++) { const Yt = et[yt]; Re.__webglColorRenderbuffer[yt] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, Re.__webglColorRenderbuffer[yt]); const en = a.convert(Yt.format, Yt.colorSpace), pt = a.convert(Yt.type), bt = M(Yt.internalFormat, en, pt, Yt.colorSpace, ee.isXRRenderTarget === !0), pn = Ze(ee); t.renderbufferStorageMultisample(t.RENDERBUFFER, pn, bt, ee.width, ee.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + yt, t.RENDERBUFFER, Re.__webglColorRenderbuffer[yt]) } t.bindRenderbuffer(t.RENDERBUFFER, null), ee.depthBuffer && (Re.__webglDepthRenderbuffer = t.createRenderbuffer(), he(Re.__webglDepthRenderbuffer, ee, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null) } } if (Ge) { n.bindTexture(t.TEXTURE_CUBE_MAP, Ue.__webglTexture), Q(t.TEXTURE_CUBE_MAP, ne); for (let yt = 0; yt < 6; yt++)if (ne.mipmaps && ne.mipmaps.length > 0) for (let Yt = 0; Yt < ne.mipmaps.length; Yt++)se(Re.__webglFramebuffer[yt][Yt], ee, ne, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + yt, Yt); else se(Re.__webglFramebuffer[yt], ee, ne, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + yt, 0); v(ne) && b(t.TEXTURE_CUBE_MAP), n.unbindTexture() } else if (Xt) { for (let yt = 0, Yt = et.length; yt < Yt; yt++) { const en = et[yt], pt = r.get(en); let bt = t.TEXTURE_2D; (ee.isWebGL3DRenderTarget || ee.isWebGLArrayRenderTarget) && (bt = ee.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY), n.bindTexture(bt, pt.__webglTexture), Q(bt, en), se(Re.__webglFramebuffer, ee, en, t.COLOR_ATTACHMENT0 + yt, bt, 0), v(en) && b(bt) } n.unbindTexture() } else { let yt = t.TEXTURE_2D; if ((ee.isWebGL3DRenderTarget || ee.isWebGLArrayRenderTarget) && (yt = ee.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY), n.bindTexture(yt, Ue.__webglTexture), Q(yt, ne), ne.mipmaps && ne.mipmaps.length > 0) for (let Yt = 0; Yt < ne.mipmaps.length; Yt++)se(Re.__webglFramebuffer[Yt], ee, ne, t.COLOR_ATTACHMENT0, yt, Yt); else se(Re.__webglFramebuffer, ee, ne, t.COLOR_ATTACHMENT0, yt, 0); v(ne) && b(yt), n.unbindTexture() } ee.depthBuffer && Ce(ee) } function xe(ee) { const ne = ee.textures; for (let Re = 0, Ue = ne.length; Re < Ue; Re++) { const et = ne[Re]; if (v(et)) { const Ge = E(ee), Xt = r.get(et).__webglTexture; n.bindTexture(Ge, Xt), b(Ge), n.unbindTexture() } } } const _e = [], je = []; function ke(ee) { if (ee.samples > 0) { if (Xe(ee) === !1) { const ne = ee.textures, Re = ee.width, Ue = ee.height; let et = t.COLOR_BUFFER_BIT; const Ge = ee.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT, Xt = r.get(ee), yt = ne.length > 1; if (yt) for (let en = 0; en < ne.length; en++)n.bindFramebuffer(t.FRAMEBUFFER, Xt.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + en, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, Xt.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + en, t.TEXTURE_2D, null, 0); n.bindFramebuffer(t.READ_FRAMEBUFFER, Xt.__webglMultisampledFramebuffer); const Yt = ee.texture.mipmaps; Yt && Yt.length > 0 ? n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Xt.__webglFramebuffer[0]) : n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Xt.__webglFramebuffer); for (let en = 0; en < ne.length; en++) { if (ee.resolveDepthBuffer && (ee.depthBuffer && (et |= t.DEPTH_BUFFER_BIT), ee.stencilBuffer && ee.resolveStencilBuffer && (et |= t.STENCIL_BUFFER_BIT)), yt) { t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, Xt.__webglColorRenderbuffer[en]); const pt = r.get(ne[en]).__webglTexture; t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, pt, 0) } t.blitFramebuffer(0, 0, Re, Ue, 0, 0, Re, Ue, et, t.NEAREST), c === !0 && (_e.length = 0, je.length = 0, _e.push(t.COLOR_ATTACHMENT0 + en), ee.depthBuffer && ee.resolveDepthBuffer === !1 && (_e.push(Ge), je.push(Ge), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, je)), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, _e)) } if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), yt) for (let en = 0; en < ne.length; en++) { n.bindFramebuffer(t.FRAMEBUFFER, Xt.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + en, t.RENDERBUFFER, Xt.__webglColorRenderbuffer[en]); const pt = r.get(ne[en]).__webglTexture; n.bindFramebuffer(t.FRAMEBUFFER, Xt.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + en, t.TEXTURE_2D, pt, 0) } n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Xt.__webglMultisampledFramebuffer) } else if (ee.depthBuffer && ee.resolveDepthBuffer === !1 && c) { const ne = ee.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT; t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [ne]) } } } function Ze(ee) { return Math.min(i.maxSamples, ee.samples) } function Xe(ee) { const ne = r.get(ee); return ee.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && ne.__useRenderToTexture !== !1 } function nt(ee) { const ne = s.render.frame; d.get(ee) !== ne && (d.set(ee, ne), ee.update()) } function Tt(ee, ne) { const Re = ee.colorSpace, Ue = ee.format, et = ee.type; return ee.isCompressedTexture === !0 || ee.isVideoTexture === !0 || Re !== Vu && Re !== Kd && (Nr.getTransfer(Re) === Wr ? (Ue !== ia || et !== lo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Re)), ne } function St(ee) { return typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement ? (u.width = ee.naturalWidth || ee.width, u.height = ee.naturalHeight || ee.height) : typeof VideoFrame < "u" && ee instanceof VideoFrame ? (u.width = ee.displayWidth, u.height = ee.displayHeight) : (u.width = ee.width, u.height = ee.height), u } this.allocateTextureUnit = G, this.resetTextureUnits = B, this.setTexture2D = q, this.setTexture2DArray = Y, this.setTexture3D = Z, this.setTextureCube = $, this.rebindTextures = fe, this.setupRenderTarget = oe, this.updateRenderTargetMipmap = xe, this.updateMultisampleRenderTarget = ke, this.setupDepthRenderbuffer = Ce, this.setupFrameBufferTexture = se, this.useMultisampledRTT = Xe } function kse(t, e) { function n(r, i = Kd) { let a; const s = Nr.getTransfer(i); if (r === lo) return t.UNSIGNED_BYTE; if (r === VA) return t.UNSIGNED_SHORT_4_4_4_4; if (r === HA) return t.UNSIGNED_SHORT_5_5_5_1; if (r === GU) return t.UNSIGNED_INT_5_9_9_9_REV; if (r === qU) return t.UNSIGNED_INT_10F_11F_11F_REV; if (r === $A) return t.BYTE; if (r === zA) return t.SHORT; if (r === yx) return t.UNSIGNED_SHORT; if (r === i_) return t.INT; if (r === zu) return t.UNSIGNED_INT; if (r === Ui) return t.FLOAT; if (r === Ya) return t.HALF_FLOAT; if (r === XU) return t.ALPHA; if (r === YU) return t.RGB; if (r === ia) return t.RGBA; if (r === bx) return t.DEPTH_COMPONENT; if (r === wx) return t.DEPTH_STENCIL; if (r === a_) return t.RED; if (r === s_) return t.RED_INTEGER; if (r === KU) return t.RG; if (r === WA) return t.RG_INTEGER; if (r === GA) return t.RGBA_INTEGER; if (r === qw || r === Xw || r === Yw || r === Kw) if (s === Wr) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (r === qw) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (r === Xw) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (r === Yw) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (r === Kw) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (r === qw) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (r === Xw) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (r === Yw) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (r === Kw) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (r === mC || r === gC || r === vC || r === yC) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (r === mC) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (r === gC) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (r === vC) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (r === yC) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (r === xC || r === bC || r === wC) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) { if (r === xC || r === bC) return s === Wr ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (r === wC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (r === SC || r === _C || r === EC || r === MC || r === TC || r === CC || r === NC || r === AC || r === PC || r === jC || r === RC || r === kC || r === IC || r === OC) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) { if (r === SC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (r === _C) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (r === EC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (r === MC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (r === TC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (r === CC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (r === NC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (r === AC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (r === PC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (r === jC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (r === RC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (r === kC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (r === IC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (r === OC) return s === Wr ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (r === DC || r === LC || r === FC) if (a = e.get("EXT_texture_compression_bptc"), a !== null) { if (r === DC) return s === Wr ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (r === LC) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (r === FC) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } else return null; if (r === UC || r === BC || r === $C || r === zC) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) { if (r === UC) return a.COMPRESSED_RED_RGTC1_EXT; if (r === BC) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (r === $C) return a.COMPRESSED_RED_GREEN_RGTC2_EXT; if (r === zC) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return r === xx ? t.UNSIGNED_INT_24_8 : t[r] !== void 0 ? t[r] : null } return { convert: n } } const tOe = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, nOe = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`; class rOe { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(e, n) { if (this.texture === null) { const r = new lB(e.texture); (e.depthNear !== n.depthNear || e.depthFar !== n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = r } } getMesh(e) { if (this.texture !== null && this.mesh === null) { const n = e.cameras[0].viewport, r = new Bo({ vertexShader: tOe, fragmentShader: nOe, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: n.z }, depthHeight: { value: n.w } } }); this.mesh = new Bi(new vp(20, 20), r) } return this.mesh } reset() { this.texture = null, this.mesh = null } getDepthTexture() { return this.texture } } class iOe extends Qu { constructor(e, n) { super(); const r = this; let i = null, a = 1, s = null, o = "local-floor", c = 1, u = null, d = null, f = null, h = null, m = null, g = null; const x = typeof XRWebGLBinding < "u", v = new rOe, b = {}, E = n.getContextAttributes(); let M = null, C = null; const N = [], A = [], j = new lt; let O = null; const I = new ra; I.viewport = new jr; const D = new ra; D.viewport = new jr; const F = [I, D], B = new _se; let G = null, z = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (de) { let ae = N[de]; return ae === void 0 && (ae = new jT, N[de] = ae), ae.getTargetRaySpace() }, this.getControllerGrip = function (de) { let ae = N[de]; return ae === void 0 && (ae = new jT, N[de] = ae), ae.getGripSpace() }, this.getHand = function (de) { let ae = N[de]; return ae === void 0 && (ae = new jT, N[de] = ae), ae.getHandSpace() }; function q(de) { const ae = A.indexOf(de.inputSource); if (ae === -1) return; const se = N[ae]; se !== void 0 && (se.update(de.inputSource, de.frame, u || s), se.dispatchEvent({ type: de.type, data: de.inputSource })) } function Y() { i.removeEventListener("select", q), i.removeEventListener("selectstart", q), i.removeEventListener("selectend", q), i.removeEventListener("squeeze", q), i.removeEventListener("squeezestart", q), i.removeEventListener("squeezeend", q), i.removeEventListener("end", Y), i.removeEventListener("inputsourceschange", Z); for (let de = 0; de < N.length; de++) { const ae = A[de]; ae !== null && (A[de] = null, N[de].disconnect(ae)) } G = null, z = null, v.reset(); for (const de in b) delete b[de]; e.setRenderTarget(M), m = null, h = null, f = null, i = null, C = null, be.stop(), r.isPresenting = !1, e.setPixelRatio(O), e.setSize(j.width, j.height, !1), r.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (de) { a = de, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (de) { o = de, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return u || s }, this.setReferenceSpace = function (de) { u = de }, this.getBaseLayer = function () { return h !== null ? h : m }, this.getBinding = function () { return f === null && x && (f = new XRWebGLBinding(i, n)), f }, this.getFrame = function () { return g }, this.getSession = function () { return i }, this.setSession = async function (de) { if (i = de, i !== null) { if (M = e.getRenderTarget(), i.addEventListener("select", q), i.addEventListener("selectstart", q), i.addEventListener("selectend", q), i.addEventListener("squeeze", q), i.addEventListener("squeezestart", q), i.addEventListener("squeezeend", q), i.addEventListener("end", Y), i.addEventListener("inputsourceschange", Z), E.xrCompatible !== !0 && await n.makeXRCompatible(), O = e.getPixelRatio(), e.getSize(j), x && "createProjectionLayer" in XRWebGLBinding.prototype) { let se = null, he = null, Ae = null; E.depth && (Ae = E.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, se = E.stencil ? wx : bx, he = E.stencil ? xx : zu); const Ce = { colorFormat: n.RGBA8, depthFormat: Ae, scaleFactor: a }; f = this.getBinding(), h = f.createProjectionLayer(Ce), i.updateRenderState({ layers: [h] }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), C = new Hl(h.textureWidth, h.textureHeight, { format: ia, type: lo, depthTexture: new oB(h.textureWidth, h.textureHeight, he, void 0, void 0, void 0, void 0, void 0, void 0, se), stencilBuffer: E.stencil, colorSpace: e.outputColorSpace, samples: E.antialias ? 4 : 0, resolveDepthBuffer: h.ignoreDepthValues === !1, resolveStencilBuffer: h.ignoreDepthValues === !1 }) } else { const se = { antialias: E.antialias, alpha: !0, depth: E.depth, stencil: E.stencil, framebufferScaleFactor: a }; m = new XRWebGLLayer(i, n, se), i.updateRenderState({ baseLayer: m }), e.setPixelRatio(1), e.setSize(m.framebufferWidth, m.framebufferHeight, !1), C = new Hl(m.framebufferWidth, m.framebufferHeight, { format: ia, type: lo, colorSpace: e.outputColorSpace, stencilBuffer: E.stencil, resolveDepthBuffer: m.ignoreDepthValues === !1, resolveStencilBuffer: m.ignoreDepthValues === !1 }) } C.isXRRenderTarget = !0, this.setFoveation(c), u = null, s = await i.requestReferenceSpace(o), be.setContext(i), be.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (i !== null) return i.environmentBlendMode }, this.getDepthTexture = function () { return v.getDepthTexture() }; function Z(de) { for (let ae = 0; ae < de.removed.length; ae++) { const se = de.removed[ae], he = A.indexOf(se); he >= 0 && (A[he] = null, N[he].disconnect(se)) } for (let ae = 0; ae < de.added.length; ae++) { const se = de.added[ae]; let he = A.indexOf(se); if (he === -1) { for (let Ce = 0; Ce < N.length; Ce++)if (Ce >= A.length) { A.push(se), he = Ce; break } else if (A[Ce] === null) { A[Ce] = se, he = Ce; break } if (he === -1) break } const Ae = N[he]; Ae && Ae.connect(se) } } const $ = new pe, V = new pe; function K(de, ae, se) { $.setFromMatrixPosition(ae.matrixWorld), V.setFromMatrixPosition(se.matrixWorld); const he = $.distanceTo(V), Ae = ae.projectionMatrix.elements, Ce = se.projectionMatrix.elements, fe = Ae[14] / (Ae[10] - 1), oe = Ae[14] / (Ae[10] + 1), xe = (Ae[9] + 1) / Ae[5], _e = (Ae[9] - 1) / Ae[5], je = (Ae[8] - 1) / Ae[0], ke = (Ce[8] + 1) / Ce[0], Ze = fe * je, Xe = fe * ke, nt = he / (-je + ke), Tt = nt * -je; if (ae.matrixWorld.decompose(de.position, de.quaternion, de.scale), de.translateX(Tt), de.translateZ(nt), de.matrixWorld.compose(de.position, de.quaternion, de.scale), de.matrixWorldInverse.copy(de.matrixWorld).invert(), Ae[10] === -1) de.projectionMatrix.copy(ae.projectionMatrix), de.projectionMatrixInverse.copy(ae.projectionMatrixInverse); else { const St = fe + nt, ee = oe + nt, ne = Ze - Tt, Re = Xe + (he - Tt), Ue = xe * oe / ee * St, et = _e * oe / ee * St; de.projectionMatrix.makePerspective(ne, Re, Ue, et, St, ee), de.projectionMatrixInverse.copy(de.projectionMatrix).invert() } } function X(de, ae) { ae === null ? de.matrixWorld.copy(de.matrix) : de.matrixWorld.multiplyMatrices(ae.matrixWorld, de.matrix), de.matrixWorldInverse.copy(de.matrixWorld).invert() } this.updateCamera = function (de) { if (i === null) return; let ae = de.near, se = de.far; v.texture !== null && (v.depthNear > 0 && (ae = v.depthNear), v.depthFar > 0 && (se = v.depthFar)), B.near = D.near = I.near = ae, B.far = D.far = I.far = se, (G !== B.near || z !== B.far) && (i.updateRenderState({ depthNear: B.near, depthFar: B.far }), G = B.near, z = B.far), B.layers.mask = de.layers.mask | 6, I.layers.mask = B.layers.mask & 3, D.layers.mask = B.layers.mask & 5; const he = de.parent, Ae = B.cameras; X(B, he); for (let Ce = 0; Ce < Ae.length; Ce++)X(Ae[Ce], he); Ae.length === 2 ? K(B, I, D) : B.projectionMatrix.copy(I.projectionMatrix), Q(de, B, he) }; function Q(de, ae, se) { se === null ? de.matrix.copy(ae.matrixWorld) : (de.matrix.copy(se.matrixWorld), de.matrix.invert(), de.matrix.multiply(ae.matrixWorld)), de.matrix.decompose(de.position, de.quaternion, de.scale), de.updateMatrixWorld(!0), de.projectionMatrix.copy(ae.projectionMatrix), de.projectionMatrixInverse.copy(ae.projectionMatrixInverse), de.isPerspectiveCamera && (de.fov = _x * 2 * Math.atan(1 / de.projectionMatrix.elements[5]), de.zoom = 1) } this.getCamera = function () { return B }, this.getFoveation = function () { if (!(h === null && m === null)) return c }, this.setFoveation = function (de) { c = de, h !== null && (h.fixedFoveation = de), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = de) }, this.hasDepthSensing = function () { return v.texture !== null }, this.getDepthSensingMesh = function () { return v.getMesh(B) }, this.getCameraTexture = function (de) { return b[de] }; let re = null; function ce(de, ae) { if (d = ae.getViewerPose(u || s), g = ae, d !== null) { const se = d.views; m !== null && (e.setRenderTargetFramebuffer(C, m.framebuffer), e.setRenderTarget(C)); let he = !1; se.length !== B.cameras.length && (B.cameras.length = 0, he = !0); for (let oe = 0; oe < se.length; oe++) { const xe = se[oe]; let _e = null; if (m !== null) _e = m.getViewport(xe); else { const ke = f.getViewSubImage(h, xe); _e = ke.viewport, oe === 0 && (e.setRenderTargetTextures(C, ke.colorTexture, ke.depthStencilTexture), e.setRenderTarget(C)) } let je = F[oe]; je === void 0 && (je = new ra, je.layers.enable(oe), je.viewport = new jr, F[oe] = je), je.matrix.fromArray(xe.transform.matrix), je.matrix.decompose(je.position, je.quaternion, je.scale), je.projectionMatrix.fromArray(xe.projectionMatrix), je.projectionMatrixInverse.copy(je.projectionMatrix).invert(), je.viewport.set(_e.x, _e.y, _e.width, _e.height), oe === 0 && (B.matrix.copy(je.matrix), B.matrix.decompose(B.position, B.quaternion, B.scale)), he === !0 && B.cameras.push(je) } const Ae = i.enabledFeatures; if (Ae && Ae.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && x) { f = r.getBinding(); const oe = f.getDepthInformation(se[0]); oe && oe.isValid && oe.texture && v.init(oe, i.renderState) } if (Ae && Ae.includes("camera-access") && x) { e.state.unbindTexture(), f = r.getBinding(); for (let oe = 0; oe < se.length; oe++) { const xe = se[oe].camera; if (xe) { let _e = b[xe]; _e || (_e = new lB, b[xe] = _e); const je = f.getCameraImage(xe); _e.sourceTexture = je } } } } for (let se = 0; se < N.length; se++) { const he = A[se], Ae = N[se]; he !== null && Ae !== void 0 && Ae.update(he, ae, u || s) } re && re(de, ae), ae.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: ae }), g = null } const be = new Nse; be.setAnimationLoop(ce), this.setAnimationLoop = function (de) { re = de }, this.dispose = function () { } } } const jm = new ml, aOe = new Fn; function sOe(t, e) { function n(v, b) { v.matrixAutoUpdate === !0 && v.updateMatrix(), b.value.copy(v.matrix) } function r(v, b) { b.color.getRGB(v.fogColor.value, Tae(t)), b.isFog ? (v.fogNear.value = b.near, v.fogFar.value = b.far) : b.isFogExp2 && (v.fogDensity.value = b.density) } function i(v, b, E, M, C) { b.isMeshBasicMaterial || b.isMeshLambertMaterial ? a(v, b) : b.isMeshToonMaterial ? (a(v, b), f(v, b)) : b.isMeshPhongMaterial ? (a(v, b), d(v, b)) : b.isMeshStandardMaterial ? (a(v, b), h(v, b), b.isMeshPhysicalMaterial && m(v, b, C)) : b.isMeshMatcapMaterial ? (a(v, b), g(v, b)) : b.isMeshDepthMaterial ? a(v, b) : b.isMeshDistanceMaterial ? (a(v, b), x(v, b)) : b.isMeshNormalMaterial ? a(v, b) : b.isLineBasicMaterial ? (s(v, b), b.isLineDashedMaterial && o(v, b)) : b.isPointsMaterial ? c(v, b, E, M) : b.isSpriteMaterial ? u(v, b) : b.isShadowMaterial ? (v.color.value.copy(b.color), v.opacity.value = b.opacity) : b.isShaderMaterial && (b.uniformsNeedUpdate = !1) } function a(v, b) { v.opacity.value = b.opacity, b.color && v.diffuse.value.copy(b.color), b.emissive && v.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity), b.map && (v.map.value = b.map, n(b.map, v.mapTransform)), b.alphaMap && (v.alphaMap.value = b.alphaMap, n(b.alphaMap, v.alphaMapTransform)), b.bumpMap && (v.bumpMap.value = b.bumpMap, n(b.bumpMap, v.bumpMapTransform), v.bumpScale.value = b.bumpScale, b.side === io && (v.bumpScale.value *= -1)), b.normalMap && (v.normalMap.value = b.normalMap, n(b.normalMap, v.normalMapTransform), v.normalScale.value.copy(b.normalScale), b.side === io && v.normalScale.value.negate()), b.displacementMap && (v.displacementMap.value = b.displacementMap, n(b.displacementMap, v.displacementMapTransform), v.displacementScale.value = b.displacementScale, v.displacementBias.value = b.displacementBias), b.emissiveMap && (v.emissiveMap.value = b.emissiveMap, n(b.emissiveMap, v.emissiveMapTransform)), b.specularMap && (v.specularMap.value = b.specularMap, n(b.specularMap, v.specularMapTransform)), b.alphaTest > 0 && (v.alphaTest.value = b.alphaTest); const E = e.get(b), M = E.envMap, C = E.envMapRotation; M && (v.envMap.value = M, jm.copy(C), jm.x *= -1, jm.y *= -1, jm.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === !1 && (jm.y *= -1, jm.z *= -1), v.envMapRotation.value.setFromMatrix4(aOe.makeRotationFromEuler(jm)), v.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = b.reflectivity, v.ior.value = b.ior, v.refractionRatio.value = b.refractionRatio), b.lightMap && (v.lightMap.value = b.lightMap, v.lightMapIntensity.value = b.lightMapIntensity, n(b.lightMap, v.lightMapTransform)), b.aoMap && (v.aoMap.value = b.aoMap, v.aoMapIntensity.value = b.aoMapIntensity, n(b.aoMap, v.aoMapTransform)) } function s(v, b) { v.diffuse.value.copy(b.color), v.opacity.value = b.opacity, b.map && (v.map.value = b.map, n(b.map, v.mapTransform)) } function o(v, b) { v.dashSize.value = b.dashSize, v.totalSize.value = b.dashSize + b.gapSize, v.scale.value = b.scale } function c(v, b, E, M) { v.diffuse.value.copy(b.color), v.opacity.value = b.opacity, v.size.value = b.size * E, v.scale.value = M * .5, b.map && (v.map.value = b.map, n(b.map, v.uvTransform)), b.alphaMap && (v.alphaMap.value = b.alphaMap, n(b.alphaMap, v.alphaMapTransform)), b.alphaTest > 0 && (v.alphaTest.value = b.alphaTest) } function u(v, b) { v.diffuse.value.copy(b.color), v.opacity.value = b.opacity, v.rotation.value = b.rotation, b.map && (v.map.value = b.map, n(b.map, v.mapTransform)), b.alphaMap && (v.alphaMap.value = b.alphaMap, n(b.alphaMap, v.alphaMapTransform)), b.alphaTest > 0 && (v.alphaTest.value = b.alphaTest) } function d(v, b) { v.specular.value.copy(b.specular), v.shininess.value = Math.max(b.shininess, 1e-4) } function f(v, b) { b.gradientMap && (v.gradientMap.value = b.gradientMap) } function h(v, b) { v.metalness.value = b.metalness, b.metalnessMap && (v.metalnessMap.value = b.metalnessMap, n(b.metalnessMap, v.metalnessMapTransform)), v.roughness.value = b.roughness, b.roughnessMap && (v.roughnessMap.value = b.roughnessMap, n(b.roughnessMap, v.roughnessMapTransform)), b.envMap && (v.envMapIntensity.value = b.envMapIntensity) } function m(v, b, E) { v.ior.value = b.ior, b.sheen > 0 && (v.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen), v.sheenRoughness.value = b.sheenRoughness, b.sheenColorMap && (v.sheenColorMap.value = b.sheenColorMap, n(b.sheenColorMap, v.sheenColorMapTransform)), b.sheenRoughnessMap && (v.sheenRoughnessMap.value = b.sheenRoughnessMap, n(b.sheenRoughnessMap, v.sheenRoughnessMapTransform))), b.clearcoat > 0 && (v.clearcoat.value = b.clearcoat, v.clearcoatRoughness.value = b.clearcoatRoughness, b.clearcoatMap && (v.clearcoatMap.value = b.clearcoatMap, n(b.clearcoatMap, v.clearcoatMapTransform)), b.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap, n(b.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), b.clearcoatNormalMap && (v.clearcoatNormalMap.value = b.clearcoatNormalMap, n(b.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(b.clearcoatNormalScale), b.side === io && v.clearcoatNormalScale.value.negate())), b.dispersion > 0 && (v.dispersion.value = b.dispersion), b.iridescence > 0 && (v.iridescence.value = b.iridescence, v.iridescenceIOR.value = b.iridescenceIOR, v.iridescenceThicknessMinimum.value = b.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = b.iridescenceThicknessRange[1], b.iridescenceMap && (v.iridescenceMap.value = b.iridescenceMap, n(b.iridescenceMap, v.iridescenceMapTransform)), b.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = b.iridescenceThicknessMap, n(b.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), b.transmission > 0 && (v.transmission.value = b.transmission, v.transmissionSamplerMap.value = E.texture, v.transmissionSamplerSize.value.set(E.width, E.height), b.transmissionMap && (v.transmissionMap.value = b.transmissionMap, n(b.transmissionMap, v.transmissionMapTransform)), v.thickness.value = b.thickness, b.thicknessMap && (v.thicknessMap.value = b.thicknessMap, n(b.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = b.attenuationDistance, v.attenuationColor.value.copy(b.attenuationColor)), b.anisotropy > 0 && (v.anisotropyVector.value.set(b.anisotropy * Math.cos(b.anisotropyRotation), b.anisotropy * Math.sin(b.anisotropyRotation)), b.anisotropyMap && (v.anisotropyMap.value = b.anisotropyMap, n(b.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = b.specularIntensity, v.specularColor.value.copy(b.specularColor), b.specularColorMap && (v.specularColorMap.value = b.specularColorMap, n(b.specularColorMap, v.specularColorMapTransform)), b.specularIntensityMap && (v.specularIntensityMap.value = b.specularIntensityMap, n(b.specularIntensityMap, v.specularIntensityMapTransform)) } function g(v, b) { b.matcap && (v.matcap.value = b.matcap) } function x(v, b) { const E = e.get(b).light; v.referencePosition.value.setFromMatrixPosition(E.matrixWorld), v.nearDistance.value = E.shadow.camera.near, v.farDistance.value = E.shadow.camera.far } return { refreshFogUniforms: r, refreshMaterialUniforms: i } } function oOe(t, e, n, r) { let i = {}, a = {}, s = []; const o = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS); function c(E, M) { const C = M.program; r.uniformBlockBinding(E, C) } function u(E, M) { let C = i[E.id]; C === void 0 && (g(E), C = d(E), i[E.id] = C, E.addEventListener("dispose", v)); const N = M.program; r.updateUBOMapping(E, N); const A = e.render.frame; a[E.id] !== A && (h(E), a[E.id] = A) } function d(E) { const M = f(); E.__bindingPointIndex = M; const C = t.createBuffer(), N = E.__size, A = E.usage; return t.bindBuffer(t.UNIFORM_BUFFER, C), t.bufferData(t.UNIFORM_BUFFER, N, A), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, M, C), C } function f() { for (let E = 0; E < o; E++)if (s.indexOf(E) === -1) return s.push(E), E; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function h(E) { const M = i[E.id], C = E.uniforms, N = E.__cache; t.bindBuffer(t.UNIFORM_BUFFER, M); for (let A = 0, j = C.length; A < j; A++) { const O = Array.isArray(C[A]) ? C[A] : [C[A]]; for (let I = 0, D = O.length; I < D; I++) { const F = O[I]; if (m(F, A, I, N) === !0) { const B = F.__offset, G = Array.isArray(F.value) ? F.value : [F.value]; let z = 0; for (let q = 0; q < G.length; q++) { const Y = G[q], Z = x(Y); typeof Y == "number" || typeof Y == "boolean" ? (F.__data[0] = Y, t.bufferSubData(t.UNIFORM_BUFFER, B + z, F.__data)) : Y.isMatrix3 ? (F.__data[0] = Y.elements[0], F.__data[1] = Y.elements[1], F.__data[2] = Y.elements[2], F.__data[3] = 0, F.__data[4] = Y.elements[3], F.__data[5] = Y.elements[4], F.__data[6] = Y.elements[5], F.__data[7] = 0, F.__data[8] = Y.elements[6], F.__data[9] = Y.elements[7], F.__data[10] = Y.elements[8], F.__data[11] = 0) : (Y.toArray(F.__data, z), z += Z.storage / Float32Array.BYTES_PER_ELEMENT) } t.bufferSubData(t.UNIFORM_BUFFER, B, F.__data) } } } t.bindBuffer(t.UNIFORM_BUFFER, null) } function m(E, M, C, N) { const A = E.value, j = M + "_" + C; if (N[j] === void 0) return typeof A == "number" || typeof A == "boolean" ? N[j] = A : N[j] = A.clone(), !0; { const O = N[j]; if (typeof A == "number" || typeof A == "boolean") { if (O !== A) return N[j] = A, !0 } else if (O.equals(A) === !1) return O.copy(A), !0 } return !1 } function g(E) { const M = E.uniforms; let C = 0; const N = 16; for (let j = 0, O = M.length; j < O; j++) { const I = Array.isArray(M[j]) ? M[j] : [M[j]]; for (let D = 0, F = I.length; D < F; D++) { const B = I[D], G = Array.isArray(B.value) ? B.value : [B.value]; for (let z = 0, q = G.length; z < q; z++) { const Y = G[z], Z = x(Y), $ = C % N, V = $ % Z.boundary, K = $ + V; C += V, K !== 0 && N - K < Z.storage && (C += N - K), B.__data = new Float32Array(Z.storage / Float32Array.BYTES_PER_ELEMENT), B.__offset = C, C += Z.storage } } } const A = C % N; return A > 0 && (C += N - A), E.__size = C, E.__cache = {}, this } function x(E) { const M = { boundary: 0, storage: 0 }; return typeof E == "number" || typeof E == "boolean" ? (M.boundary = 4, M.storage = 4) : E.isVector2 ? (M.boundary = 8, M.storage = 8) : E.isVector3 || E.isColor ? (M.boundary = 16, M.storage = 12) : E.isVector4 ? (M.boundary = 16, M.storage = 16) : E.isMatrix3 ? (M.boundary = 48, M.storage = 48) : E.isMatrix4 ? (M.boundary = 64, M.storage = 64) : E.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E), M } function v(E) { const M = E.target; M.removeEventListener("dispose", v); const C = s.indexOf(M.__bindingPointIndex); s.splice(C, 1), t.deleteBuffer(i[M.id]), delete i[M.id], delete a[M.id] } function b() { for (const E in i) t.deleteBuffer(i[E]); s = [], i = {}, a = {} } return { bind: c, update: u, dispose: b } } class jB { constructor(e = {}) { const { canvas: n = _ae(), context: r = null, depth: i = !0, stencil: a = !1, alpha: s = !1, antialias: o = !1, premultipliedAlpha: c = !0, preserveDrawingBuffer: u = !1, powerPreference: d = "default", failIfMajorPerformanceCaveat: f = !1, reversedDepthBuffer: h = !1 } = e; this.isWebGLRenderer = !0; let m; if (r !== null) { if (typeof WebGLRenderingContext < "u" && r instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163."); m = r.getContextAttributes().alpha } else m = s; const g = new Uint32Array(4), x = new Int32Array(4); let v = null, b = null; const E = [], M = []; this.domElement = n, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = ju, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1; const C = this; let N = !1; this._outputColorSpace = qs; let A = 0, j = 0, O = null, I = -1, D = null; const F = new jr, B = new jr; let G = null; const z = new Kt(0); let q = 0, Y = n.width, Z = n.height, $ = 1, V = null, K = null; const X = new jr(0, 0, Y, Z), Q = new jr(0, 0, Y, Z); let re = !1; const ce = new N0; let be = !1, de = !1; const ae = new Fn, se = new pe, he = new jr, Ae = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; let Ce = !1; function fe() { return O === null ? $ : 1 } let oe = r; function xe(te, ye) { return n.getContext(te, ye) } try { const te = { alpha: !0, depth: i, stencil: a, antialias: o, premultipliedAlpha: c, preserveDrawingBuffer: u, powerPreference: d, failIfMajorPerformanceCaveat: f }; if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${n_}`), n.addEventListener("webglcontextlost", gt, !1), n.addEventListener("webglcontextrestored", Bt, !1), n.addEventListener("webglcontextcreationerror", mt, !1), oe === null) { const ye = "webgl2"; if (oe = xe(ye, te), oe === null) throw xe(ye) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } } catch (te) { throw console.error("THREE.WebGLRenderer: " + te.message), te } let _e, je, ke, Ze, Xe, nt, Tt, St, ee, ne, Re, Ue, et, Ge, Xt, yt, Yt, en, pt, bt, pn, Se, Fe, ht; function Ee() { _e = new xke(oe), _e.init(), Se = new kse(oe, _e), je = new fke(oe, _e, e, Se), ke = new JIe(oe, _e), je.reversedDepthBuffer && h && ke.buffers.depth.setReversed(!0), Ze = new Ske(oe), Xe = new BIe, nt = new eOe(oe, _e, ke, Xe, je, Se, Ze), Tt = new pke(C), St = new yke(C), ee = new NPe(oe), Fe = new uke(oe, ee), ne = new bke(oe, ee, Ze, Fe), Re = new Eke(oe, ne, ee, Ze), pt = new _ke(oe, je, nt), yt = new hke(Xe), Ue = new UIe(C, Tt, St, _e, je, Fe, yt), et = new sOe(C, Xe), Ge = new zIe, Xt = new XIe(_e), en = new cke(C, Tt, St, ke, Re, m, c), Yt = new ZIe(C, Re, je), ht = new oOe(oe, Ze, je, ke), bt = new dke(oe, _e, Ze), pn = new wke(oe, _e, Ze), Ze.programs = Ue.programs, C.capabilities = je, C.extensions = _e, C.properties = Xe, C.renderLists = Ge, C.shadowMap = Yt, C.state = ke, C.info = Ze } Ee(); const De = new iOe(C, oe); this.xr = De, this.getContext = function () { return oe }, this.getContextAttributes = function () { return oe.getContextAttributes() }, this.forceContextLoss = function () { const te = _e.get("WEBGL_lose_context"); te && te.loseContext() }, this.forceContextRestore = function () { const te = _e.get("WEBGL_lose_context"); te && te.restoreContext() }, this.getPixelRatio = function () { return $ }, this.setPixelRatio = function (te) { te !== void 0 && ($ = te, this.setSize(Y, Z, !1)) }, this.getSize = function (te) { return te.set(Y, Z) }, this.setSize = function (te, ye, Me = !0) { if (De.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } Y = te, Z = ye, n.width = Math.floor(te * $), n.height = Math.floor(ye * $), Me === !0 && (n.style.width = te + "px", n.style.height = ye + "px"), this.setViewport(0, 0, te, ye) }, this.getDrawingBufferSize = function (te) { return te.set(Y * $, Z * $).floor() }, this.setDrawingBufferSize = function (te, ye, Me) { Y = te, Z = ye, $ = Me, n.width = Math.floor(te * Me), n.height = Math.floor(ye * Me), this.setViewport(0, 0, te, ye) }, this.getCurrentViewport = function (te) { return te.copy(F) }, this.getViewport = function (te) { return te.copy(X) }, this.setViewport = function (te, ye, Me, Te) { te.isVector4 ? X.set(te.x, te.y, te.z, te.w) : X.set(te, ye, Me, Te), ke.viewport(F.copy(X).multiplyScalar($).round()) }, this.getScissor = function (te) { return te.copy(Q) }, this.setScissor = function (te, ye, Me, Te) { te.isVector4 ? Q.set(te.x, te.y, te.z, te.w) : Q.set(te, ye, Me, Te), ke.scissor(B.copy(Q).multiplyScalar($).round()) }, this.getScissorTest = function () { return re }, this.setScissorTest = function (te) { ke.setScissorTest(re = te) }, this.setOpaqueSort = function (te) { V = te }, this.setTransparentSort = function (te) { K = te }, this.getClearColor = function (te) { return te.copy(en.getClearColor()) }, this.setClearColor = function () { en.setClearColor(...arguments) }, this.getClearAlpha = function () { return en.getClearAlpha() }, this.setClearAlpha = function () { en.setClearAlpha(...arguments) }, this.clear = function (te = !0, ye = !0, Me = !0) { let Te = 0; if (te) { let ge = !1; if (O !== null) { const at = O.texture.format; ge = at === GA || at === WA || at === s_ } if (ge) { const at = O.texture.type, Ke = at === lo || at === zu || at === yx || at === xx || at === VA || at === HA, st = en.getClearColor(), ft = en.getClearAlpha(), At = st.r, $t = st.g, Pt = st.b; Ke ? (g[0] = At, g[1] = $t, g[2] = Pt, g[3] = ft, oe.clearBufferuiv(oe.COLOR, 0, g)) : (x[0] = At, x[1] = $t, x[2] = Pt, x[3] = ft, oe.clearBufferiv(oe.COLOR, 0, x)) } else Te |= oe.COLOR_BUFFER_BIT } ye && (Te |= oe.DEPTH_BUFFER_BIT), Me && (Te |= oe.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), oe.clear(Te) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { n.removeEventListener("webglcontextlost", gt, !1), n.removeEventListener("webglcontextrestored", Bt, !1), n.removeEventListener("webglcontextcreationerror", mt, !1), en.dispose(), Ge.dispose(), Xt.dispose(), Xe.dispose(), Tt.dispose(), St.dispose(), Re.dispose(), Fe.dispose(), ht.dispose(), Ue.dispose(), De.dispose(), De.removeEventListener("sessionstart", Tr), De.removeEventListener("sessionend", Ua), Vr.stop() }; function gt(te) { te.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), N = !0 } function Bt() { console.log("THREE.WebGLRenderer: Context Restored."), N = !1; const te = Ze.autoReset, ye = Yt.enabled, Me = Yt.autoUpdate, Te = Yt.needsUpdate, ge = Yt.type; Ee(), Ze.autoReset = te, Yt.enabled = ye, Yt.autoUpdate = Me, Yt.needsUpdate = Te, Yt.type = ge } function mt(te) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", te.statusMessage) } function ot(te) { const ye = te.target; ye.removeEventListener("dispose", ot), it(ye) } function it(te) { Ft(te), Xe.remove(te) } function Ft(te) { const ye = Xe.get(te).programs; ye !== void 0 && (ye.forEach(function (Me) { Ue.releaseProgram(Me) }), te.isShaderMaterial && Ue.releaseShaderCache(te)) } this.renderBufferDirect = function (te, ye, Me, Te, ge, at) { ye === null && (ye = Ae); const Ke = ge.isMesh && ge.matrixWorld.determinant() < 0, st = ue(te, ye, Me, Te, ge); ke.setMaterial(Te, Ke); let ft = Me.index, At = 1; if (Te.wireframe === !0) { if (ft = ne.getWireframeAttribute(Me), ft === void 0) return; At = 2 } const $t = Me.drawRange, Pt = Me.attributes.position; let kt = $t.start * At, Zt = ($t.start + $t.count) * At; at !== null && (kt = Math.max(kt, at.start * At), Zt = Math.min(Zt, (at.start + at.count) * At)), ft !== null ? (kt = Math.max(kt, 0), Zt = Math.min(Zt, ft.count)) : Pt != null && (kt = Math.max(kt, 0), Zt = Math.min(Zt, Pt.count)); const tn = Zt - kt; if (tn < 0 || tn === 1 / 0) return; Fe.setup(ge, Te, st, Me, ft); let _n, nn = bt; if (ft !== null && (_n = ee.get(ft), nn = pn, nn.setIndex(_n)), ge.isMesh) Te.wireframe === !0 ? (ke.setLineWidth(Te.wireframeLinewidth * fe()), nn.setMode(oe.LINES)) : nn.setMode(oe.TRIANGLES); else if (ge.isLine) { let Vt = Te.linewidth; Vt === void 0 && (Vt = 1), ke.setLineWidth(Vt * fe()), ge.isLineSegments ? nn.setMode(oe.LINES) : ge.isLineLoop ? nn.setMode(oe.LINE_LOOP) : nn.setMode(oe.LINE_STRIP) } else ge.isPoints ? nn.setMode(oe.POINTS) : ge.isSprite && nn.setMode(oe.TRIANGLES); if (ge.isBatchedMesh) if (ge._multiDrawInstances !== null) F1("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), nn.renderMultiDrawInstances(ge._multiDrawStarts, ge._multiDrawCounts, ge._multiDrawCount, ge._multiDrawInstances); else if (_e.get("WEBGL_multi_draw")) nn.renderMultiDraw(ge._multiDrawStarts, ge._multiDrawCounts, ge._multiDrawCount); else { const Vt = ge._multiDrawStarts, Vn = ge._multiDrawCounts, bn = ge._multiDrawCount, gr = ft ? ee.get(ft).bytesPerElement : 1, tr = Xe.get(Te).currentProgram.getUniforms(); for (let Sr = 0; Sr < bn; Sr++)tr.setValue(oe, "_gl_DrawID", Sr), nn.render(Vt[Sr] / gr, Vn[Sr]) } else if (ge.isInstancedMesh) nn.renderInstances(kt, tn, ge.count); else if (Me.isInstancedBufferGeometry) { const Vt = Me._maxInstanceCount !== void 0 ? Me._maxInstanceCount : 1 / 0, Vn = Math.min(Me.instanceCount, Vt); nn.renderInstances(kt, tn, Vn) } else nn.render(kt, tn) }; function un(te, ye, Me) { te.transparent === !0 && te.side === Oc && te.forceSinglePass === !1 ? (te.side = io, te.needsUpdate = !0, Ql(te, ye, Me), te.side = yf, te.needsUpdate = !0, Ql(te, ye, Me), te.side = Oc) : Ql(te, ye, Me) } this.compile = function (te, ye, Me = null) { Me === null && (Me = te), b = Xt.get(Me), b.init(ye), M.push(b), Me.traverseVisible(function (ge) { ge.isLight && ge.layers.test(ye.layers) && (b.pushLight(ge), ge.castShadow && b.pushShadow(ge)) }), te !== Me && te.traverseVisible(function (ge) { ge.isLight && ge.layers.test(ye.layers) && (b.pushLight(ge), ge.castShadow && b.pushShadow(ge)) }), b.setupLights(); const Te = new Set; return te.traverse(function (ge) { if (!(ge.isMesh || ge.isPoints || ge.isLine || ge.isSprite)) return; const at = ge.material; if (at) if (Array.isArray(at)) for (let Ke = 0; Ke < at.length; Ke++) { const st = at[Ke]; un(st, Me, ge), Te.add(st) } else un(at, Me, ge), Te.add(at) }), b = M.pop(), Te }, this.compileAsync = function (te, ye, Me = null) { const Te = this.compile(te, ye, Me); return new Promise(ge => { function at() { if (Te.forEach(function (Ke) { Xe.get(Ke).currentProgram.isReady() && Te.delete(Ke) }), Te.size === 0) { ge(te); return } setTimeout(at, 10) } _e.get("KHR_parallel_shader_compile") !== null ? at() : setTimeout(at, 10) }) }; let wn = null; function wr(te) { wn && wn(te) } function Tr() { Vr.stop() } function Ua() { Vr.start() } const Vr = new Nse; Vr.setAnimationLoop(wr), typeof self < "u" && Vr.setContext(self), this.setAnimationLoop = function (te) { wn = te, De.setAnimationLoop(te), te === null ? Vr.stop() : Vr.start() }, De.addEventListener("sessionstart", Tr), De.addEventListener("sessionend", Ua), this.render = function (te, ye) { if (ye !== void 0 && ye.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (N === !0) return; if (te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(), ye.parent === null && ye.matrixWorldAutoUpdate === !0 && ye.updateMatrixWorld(), De.enabled === !0 && De.isPresenting === !0 && (De.cameraAutoUpdate === !0 && De.updateCamera(ye), ye = De.getCamera()), te.isScene === !0 && te.onBeforeRender(C, te, ye, O), b = Xt.get(te, M.length), b.init(ye), M.push(b), ae.multiplyMatrices(ye.projectionMatrix, ye.matrixWorldInverse), ce.setFromProjectionMatrix(ae, cl, ye.reversedDepth), de = this.localClippingEnabled, be = yt.init(this.clippingPlanes, de), v = Ge.get(te, E.length), v.init(), E.push(v), De.enabled === !0 && De.isPresenting === !0) { const at = C.xr.getDepthSensingMesh(); at !== null && zi(at, ye, -1 / 0, C.sortObjects) } zi(te, ye, 0, C.sortObjects), v.finish(), C.sortObjects === !0 && v.sort(V, K), Ce = De.enabled === !1 || De.isPresenting === !1 || De.hasDepthSensing() === !1, Ce && en.addToRenderList(v, te), this.info.render.frame++, be === !0 && yt.beginShadows(); const Me = b.state.shadowsArray; Yt.render(Me, te, ye), be === !0 && yt.endShadows(), this.info.autoReset === !0 && this.info.reset(); const Te = v.opaque, ge = v.transmissive; if (b.setupLights(), ye.isArrayCamera) { const at = ye.cameras; if (ge.length > 0) for (let Ke = 0, st = at.length; Ke < st; Ke++) { const ft = at[Ke]; ks(Te, ge, te, ft) } Ce && en.render(te); for (let Ke = 0, st = at.length; Ke < st; Ke++) { const ft = at[Ke]; po(v, te, ft, ft.viewport) } } else ge.length > 0 && ks(Te, ge, te, ye), Ce && en.render(te), po(v, te, ye); O !== null && j === 0 && (nt.updateMultisampleRenderTarget(O), nt.updateRenderTargetMipmap(O)), te.isScene === !0 && te.onAfterRender(C, te, ye), Fe.resetDefaultState(), I = -1, D = null, M.pop(), M.length > 0 ? (b = M[M.length - 1], be === !0 && yt.setGlobalState(C.clippingPlanes, b.state.camera)) : b = null, E.pop(), E.length > 0 ? v = E[E.length - 1] : v = null }; function zi(te, ye, Me, Te) { if (te.visible === !1) return; if (te.layers.test(ye.layers)) { if (te.isGroup) Me = te.renderOrder; else if (te.isLOD) te.autoUpdate === !0 && te.update(ye); else if (te.isLight) b.pushLight(te), te.castShadow && b.pushShadow(te); else if (te.isSprite) { if (!te.frustumCulled || ce.intersectsSprite(te)) { Te && he.setFromMatrixPosition(te.matrixWorld).applyMatrix4(ae); const Ke = Re.update(te), st = te.material; st.visible && v.push(te, Ke, st, Me, he.z, null) } } else if ((te.isMesh || te.isLine || te.isPoints) && (!te.frustumCulled || ce.intersectsObject(te))) { const Ke = Re.update(te), st = te.material; if (Te && (te.boundingSphere !== void 0 ? (te.boundingSphere === null && te.computeBoundingSphere(), he.copy(te.boundingSphere.center)) : (Ke.boundingSphere === null && Ke.computeBoundingSphere(), he.copy(Ke.boundingSphere.center)), he.applyMatrix4(te.matrixWorld).applyMatrix4(ae)), Array.isArray(st)) { const ft = Ke.groups; for (let At = 0, $t = ft.length; At < $t; At++) { const Pt = ft[At], kt = st[Pt.materialIndex]; kt && kt.visible && v.push(te, Ke, kt, Me, he.z, Pt) } } else st.visible && v.push(te, Ke, st, Me, he.z, null) } } const at = te.children; for (let Ke = 0, st = at.length; Ke < st; Ke++)zi(at[Ke], ye, Me, Te) } function po(te, ye, Me, Te) { const ge = te.opaque, at = te.transmissive, Ke = te.transparent; b.setupLightsView(Me), be === !0 && yt.setGlobalState(C.clippingPlanes, Me), Te && ke.viewport(F.copy(Te)), ge.length > 0 && Zi(ge, ye, Me), at.length > 0 && Zi(at, ye, Me), Ke.length > 0 && Zi(Ke, ye, Me), ke.buffers.depth.setTest(!0), ke.buffers.depth.setMask(!0), ke.buffers.color.setMask(!0), ke.setPolygonOffset(!1) } function ks(te, ye, Me, Te) { if ((Me.isScene === !0 ? Me.overrideMaterial : null) !== null) return; b.state.transmissionRenderTarget[Te.id] === void 0 && (b.state.transmissionRenderTarget[Te.id] = new Hl(1, 1, { generateMipmaps: !0, type: _e.has("EXT_color_buffer_half_float") || _e.has("EXT_color_buffer_float") ? Ya : lo, minFilter: bu, samples: 4, stencilBuffer: a, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: Nr.workingColorSpace })); const at = b.state.transmissionRenderTarget[Te.id], Ke = Te.viewport || F; at.setSize(Ke.z * C.transmissionResolutionScale, Ke.w * C.transmissionResolutionScale); const st = C.getRenderTarget(), ft = C.getActiveCubeFace(), At = C.getActiveMipmapLevel(); C.setRenderTarget(at), C.getClearColor(z), q = C.getClearAlpha(), q < 1 && C.setClearColor(16777215, .5), C.clear(), Ce && en.render(Me); const $t = C.toneMapping; C.toneMapping = ju; const Pt = Te.viewport; if (Te.viewport !== void 0 && (Te.viewport = void 0), b.setupLightsView(Te), be === !0 && yt.setGlobalState(C.clippingPlanes, Te), Zi(te, Me, Te), nt.updateMultisampleRenderTarget(at), nt.updateRenderTargetMipmap(at), _e.has("WEBGL_multisampled_render_to_texture") === !1) { let kt = !1; for (let Zt = 0, tn = ye.length; Zt < tn; Zt++) { const _n = ye[Zt], nn = _n.object, Vt = _n.geometry, Vn = _n.material, bn = _n.group; if (Vn.side === Oc && nn.layers.test(Te.layers)) { const gr = Vn.side; Vn.side = io, Vn.needsUpdate = !0, Hn(nn, Me, Te, Vt, Vn, bn), Vn.side = gr, Vn.needsUpdate = !0, kt = !0 } } kt === !0 && (nt.updateMultisampleRenderTarget(at), nt.updateRenderTargetMipmap(at)) } C.setRenderTarget(st, ft, At), C.setClearColor(z, q), Pt !== void 0 && (Te.viewport = Pt), C.toneMapping = $t } function Zi(te, ye, Me) { const Te = ye.isScene === !0 ? ye.overrideMaterial : null; for (let ge = 0, at = te.length; ge < at; ge++) { const Ke = te[ge], st = Ke.object, ft = Ke.geometry, At = Ke.group; let $t = Ke.material; $t.allowOverride === !0 && Te !== null && ($t = Te), st.layers.test(Me.layers) && Hn(st, ye, Me, ft, $t, At) } } function Hn(te, ye, Me, Te, ge, at) { te.onBeforeRender(C, ye, Me, Te, ge, at), te.modelViewMatrix.multiplyMatrices(Me.matrixWorldInverse, te.matrixWorld), te.normalMatrix.getNormalMatrix(te.modelViewMatrix), ge.onBeforeRender(C, ye, Me, Te, te, at), ge.transparent === !0 && ge.side === Oc && ge.forceSinglePass === !1 ? (ge.side = io, ge.needsUpdate = !0, C.renderBufferDirect(Me, ye, Te, ge, te, at), ge.side = yf, ge.needsUpdate = !0, C.renderBufferDirect(Me, ye, Te, ge, te, at), ge.side = Oc) : C.renderBufferDirect(Me, ye, Te, ge, te, at), te.onAfterRender(C, ye, Me, Te, ge, at) } function Ql(te, ye, Me) { ye.isScene !== !0 && (ye = Ae); const Te = Xe.get(te), ge = b.state.lights, at = b.state.shadowsArray, Ke = ge.state.version, st = Ue.getParameters(te, ge.state, at, ye, Me), ft = Ue.getProgramCacheKey(st); let At = Te.programs; Te.environment = te.isMeshStandardMaterial ? ye.environment : null, Te.fog = ye.fog, Te.envMap = (te.isMeshStandardMaterial ? St : Tt).get(te.envMap || Te.environment), Te.envMapRotation = Te.environment !== null && te.envMap === null ? ye.environmentRotation : te.envMapRotation, At === void 0 && (te.addEventListener("dispose", ot), At = new Map, Te.programs = At); let $t = At.get(ft); if ($t !== void 0) { if (Te.currentProgram === $t && Te.lightsStateVersion === Ke) return ie(te, st), $t } else st.uniforms = Ue.getUniforms(te), te.onBeforeCompile(st, C), $t = Ue.acquireProgram(st, ft), At.set(ft, $t), Te.uniforms = st.uniforms; const Pt = Te.uniforms; return (!te.isShaderMaterial && !te.isRawShaderMaterial || te.clipping === !0) && (Pt.clippingPlanes = yt.uniform), ie(te, st), Te.needsLights = He(te), Te.lightsStateVersion = Ke, Te.needsLights && (Pt.ambientLightColor.value = ge.state.ambient, Pt.lightProbe.value = ge.state.probe, Pt.directionalLights.value = ge.state.directional, Pt.directionalLightShadows.value = ge.state.directionalShadow, Pt.spotLights.value = ge.state.spot, Pt.spotLightShadows.value = ge.state.spotShadow, Pt.rectAreaLights.value = ge.state.rectArea, Pt.ltc_1.value = ge.state.rectAreaLTC1, Pt.ltc_2.value = ge.state.rectAreaLTC2, Pt.pointLights.value = ge.state.point, Pt.pointLightShadows.value = ge.state.pointShadow, Pt.hemisphereLights.value = ge.state.hemi, Pt.directionalShadowMap.value = ge.state.directionalShadowMap, Pt.directionalShadowMatrix.value = ge.state.directionalShadowMatrix, Pt.spotShadowMap.value = ge.state.spotShadowMap, Pt.spotLightMatrix.value = ge.state.spotLightMatrix, Pt.spotLightMap.value = ge.state.spotLightMap, Pt.pointShadowMap.value = ge.state.pointShadowMap, Pt.pointShadowMatrix.value = ge.state.pointShadowMatrix), Te.currentProgram = $t, Te.uniformsList = null, $t } function Of(te) { if (te.uniformsList === null) { const ye = te.currentProgram.getUniforms(); te.uniformsList = RT.seqWithValue(ye.seq, te.uniforms) } return te.uniformsList } function ie(te, ye) { const Me = Xe.get(te); Me.outputColorSpace = ye.outputColorSpace, Me.batching = ye.batching, Me.batchingColor = ye.batchingColor, Me.instancing = ye.instancing, Me.instancingColor = ye.instancingColor, Me.instancingMorph = ye.instancingMorph, Me.skinning = ye.skinning, Me.morphTargets = ye.morphTargets, Me.morphNormals = ye.morphNormals, Me.morphColors = ye.morphColors, Me.morphTargetsCount = ye.morphTargetsCount, Me.numClippingPlanes = ye.numClippingPlanes, Me.numIntersection = ye.numClipIntersection, Me.vertexAlphas = ye.vertexAlphas, Me.vertexTangents = ye.vertexTangents, Me.toneMapping = ye.toneMapping } function ue(te, ye, Me, Te, ge) { ye.isScene !== !0 && (ye = Ae), nt.resetTextureUnits(); const at = ye.fog, Ke = Te.isMeshStandardMaterial ? ye.environment : null, st = O === null ? C.outputColorSpace : O.isXRRenderTarget === !0 ? O.texture.colorSpace : Vu, ft = (Te.isMeshStandardMaterial ? St : Tt).get(Te.envMap || Ke), At = Te.vertexColors === !0 && !!Me.attributes.color && Me.attributes.color.itemSize === 4, $t = !!Me.attributes.tangent && (!!Te.normalMap || Te.anisotropy > 0), Pt = !!Me.morphAttributes.position, kt = !!Me.morphAttributes.normal, Zt = !!Me.morphAttributes.color; let tn = ju; Te.toneMapped && (O === null || O.isXRRenderTarget === !0) && (tn = C.toneMapping); const _n = Me.morphAttributes.position || Me.morphAttributes.normal || Me.morphAttributes.color, nn = _n !== void 0 ? _n.length : 0, Vt = Xe.get(Te), Vn = b.state.lights; if (be === !0 && (de === !0 || te !== D)) { const yr = te === D && Te.id === I; yt.setState(Te, te, yr) } let bn = !1; Te.version === Vt.__version ? (Vt.needsLights && Vt.lightsStateVersion !== Vn.state.version || Vt.outputColorSpace !== st || ge.isBatchedMesh && Vt.batching === !1 || !ge.isBatchedMesh && Vt.batching === !0 || ge.isBatchedMesh && Vt.batchingColor === !0 && ge.colorTexture === null || ge.isBatchedMesh && Vt.batchingColor === !1 && ge.colorTexture !== null || ge.isInstancedMesh && Vt.instancing === !1 || !ge.isInstancedMesh && Vt.instancing === !0 || ge.isSkinnedMesh && Vt.skinning === !1 || !ge.isSkinnedMesh && Vt.skinning === !0 || ge.isInstancedMesh && Vt.instancingColor === !0 && ge.instanceColor === null || ge.isInstancedMesh && Vt.instancingColor === !1 && ge.instanceColor !== null || ge.isInstancedMesh && Vt.instancingMorph === !0 && ge.morphTexture === null || ge.isInstancedMesh && Vt.instancingMorph === !1 && ge.morphTexture !== null || Vt.envMap !== ft || Te.fog === !0 && Vt.fog !== at || Vt.numClippingPlanes !== void 0 && (Vt.numClippingPlanes !== yt.numPlanes || Vt.numIntersection !== yt.numIntersection) || Vt.vertexAlphas !== At || Vt.vertexTangents !== $t || Vt.morphTargets !== Pt || Vt.morphNormals !== kt || Vt.morphColors !== Zt || Vt.toneMapping !== tn || Vt.morphTargetsCount !== nn) && (bn = !0) : (bn = !0, Vt.__version = Te.version); let gr = Vt.currentProgram; bn === !0 && (gr = Ql(Te, ye, ge)); let tr = !1, Sr = !1, vr = !1; const yn = gr.getUniforms(), ur = Vt.uniforms; if (ke.useProgram(gr.program) && (tr = !0, Sr = !0, vr = !0), Te.id !== I && (I = Te.id, Sr = !0), tr || D !== te) { ke.buffers.depth.getReversed() && te.reversedDepth !== !0 && (te._reversedDepth = !0, te.updateProjectionMatrix()), yn.setValue(oe, "projectionMatrix", te.projectionMatrix), yn.setValue(oe, "viewMatrix", te.matrixWorldInverse); const ri = yn.map.cameraPosition; ri !== void 0 && ri.setValue(oe, se.setFromMatrixPosition(te.matrixWorld)), je.logarithmicDepthBuffer && yn.setValue(oe, "logDepthBufFC", 2 / (Math.log(te.far + 1) / Math.LN2)), (Te.isMeshPhongMaterial || Te.isMeshToonMaterial || Te.isMeshLambertMaterial || Te.isMeshBasicMaterial || Te.isMeshStandardMaterial || Te.isShaderMaterial) && yn.setValue(oe, "isOrthographic", te.isOrthographicCamera === !0), D !== te && (D = te, Sr = !0, vr = !0) } if (ge.isSkinnedMesh) { yn.setOptional(oe, ge, "bindMatrix"), yn.setOptional(oe, ge, "bindMatrixInverse"); const yr = ge.skeleton; yr && (yr.boneTexture === null && yr.computeBoneTexture(), yn.setValue(oe, "boneTexture", yr.boneTexture, nt)) } ge.isBatchedMesh && (yn.setOptional(oe, ge, "batchingTexture"), yn.setValue(oe, "batchingTexture", ge._matricesTexture, nt), yn.setOptional(oe, ge, "batchingIdTexture"), yn.setValue(oe, "batchingIdTexture", ge._indirectTexture, nt), yn.setOptional(oe, ge, "batchingColorTexture"), ge._colorsTexture !== null && yn.setValue(oe, "batchingColorTexture", ge._colorsTexture, nt)); const di = Me.morphAttributes; if ((di.position !== void 0 || di.normal !== void 0 || di.color !== void 0) && pt.update(ge, Me, gr), (Sr || Vt.receiveShadow !== ge.receiveShadow) && (Vt.receiveShadow = ge.receiveShadow, yn.setValue(oe, "receiveShadow", ge.receiveShadow)), Te.isMeshGouraudMaterial && Te.envMap !== null && (ur.envMap.value = ft, ur.flipEnvMap.value = ft.isCubeTexture && ft.isRenderTargetTexture === !1 ? -1 : 1), Te.isMeshStandardMaterial && Te.envMap === null && ye.environment !== null && (ur.envMapIntensity.value = ye.environmentIntensity), Sr && (yn.setValue(oe, "toneMappingExposure", C.toneMappingExposure), Vt.needsLights && Ne(ur, vr), at && Te.fog === !0 && et.refreshFogUniforms(ur, at), et.refreshMaterialUniforms(ur, Te, $, Z, b.state.transmissionRenderTarget[te.id]), RT.upload(oe, Of(Vt), ur, nt)), Te.isShaderMaterial && Te.uniformsNeedUpdate === !0 && (RT.upload(oe, Of(Vt), ur, nt), Te.uniformsNeedUpdate = !1), Te.isSpriteMaterial && yn.setValue(oe, "center", ge.center), yn.setValue(oe, "modelViewMatrix", ge.modelViewMatrix), yn.setValue(oe, "normalMatrix", ge.normalMatrix), yn.setValue(oe, "modelMatrix", ge.matrixWorld), Te.isShaderMaterial || Te.isRawShaderMaterial) { const yr = Te.uniformsGroups; for (let ri = 0, yl = yr.length; ri < yl; ri++) { const nr = yr[ri]; ht.update(nr, gr), ht.bind(nr, gr) } } return gr } function Ne(te, ye) { te.ambientLightColor.needsUpdate = ye, te.lightProbe.needsUpdate = ye, te.directionalLights.needsUpdate = ye, te.directionalLightShadows.needsUpdate = ye, te.pointLights.needsUpdate = ye, te.pointLightShadows.needsUpdate = ye, te.spotLights.needsUpdate = ye, te.spotLightShadows.needsUpdate = ye, te.rectAreaLights.needsUpdate = ye, te.hemisphereLights.needsUpdate = ye } function He(te) { return te.isMeshLambertMaterial || te.isMeshToonMaterial || te.isMeshPhongMaterial || te.isMeshStandardMaterial || te.isShadowMaterial || te.isShaderMaterial && te.lights === !0 } this.getActiveCubeFace = function () { return A }, this.getActiveMipmapLevel = function () { return j }, this.getRenderTarget = function () { return O }, this.setRenderTargetTextures = function (te, ye, Me) { const Te = Xe.get(te); Te.__autoAllocateDepthBuffer = te.resolveDepthBuffer === !1, Te.__autoAllocateDepthBuffer === !1 && (Te.__useRenderToTexture = !1), Xe.get(te.texture).__webglTexture = ye, Xe.get(te.depthTexture).__webglTexture = Te.__autoAllocateDepthBuffer ? void 0 : Me, Te.__hasExternalTextures = !0 }, this.setRenderTargetFramebuffer = function (te, ye) { const Me = Xe.get(te); Me.__webglFramebuffer = ye, Me.__useDefaultFramebuffer = ye === void 0 }; const Qe = oe.createFramebuffer(); this.setRenderTarget = function (te, ye = 0, Me = 0) { O = te, A = ye, j = Me; let Te = !0, ge = null, at = !1, Ke = !1; if (te) { const ft = Xe.get(te); if (ft.__useDefaultFramebuffer !== void 0) ke.bindFramebuffer(oe.FRAMEBUFFER, null), Te = !1; else if (ft.__webglFramebuffer === void 0) nt.setupRenderTarget(te); else if (ft.__hasExternalTextures) nt.rebindTextures(te, Xe.get(te.texture).__webglTexture, Xe.get(te.depthTexture).__webglTexture); else if (te.depthBuffer) { const Pt = te.depthTexture; if (ft.__boundDepthTexture !== Pt) { if (Pt !== null && Xe.has(Pt) && (te.width !== Pt.image.width || te.height !== Pt.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."); nt.setupDepthRenderbuffer(te) } } const At = te.texture; (At.isData3DTexture || At.isDataArrayTexture || At.isCompressedArrayTexture) && (Ke = !0); const $t = Xe.get(te).__webglFramebuffer; te.isWebGLCubeRenderTarget ? (Array.isArray($t[ye]) ? ge = $t[ye][Me] : ge = $t[ye], at = !0) : te.samples > 0 && nt.useMultisampledRTT(te) === !1 ? ge = Xe.get(te).__webglMultisampledFramebuffer : Array.isArray($t) ? ge = $t[Me] : ge = $t, F.copy(te.viewport), B.copy(te.scissor), G = te.scissorTest } else F.copy(X).multiplyScalar($).floor(), B.copy(Q).multiplyScalar($).floor(), G = re; if (Me !== 0 && (ge = Qe), ke.bindFramebuffer(oe.FRAMEBUFFER, ge) && Te && ke.drawBuffers(te, ge), ke.viewport(F), ke.scissor(B), ke.setScissorTest(G), at) { const ft = Xe.get(te.texture); oe.framebufferTexture2D(oe.FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_CUBE_MAP_POSITIVE_X + ye, ft.__webglTexture, Me) } else if (Ke) { const ft = ye; for (let At = 0; At < te.textures.length; At++) { const $t = Xe.get(te.textures[At]); oe.framebufferTextureLayer(oe.FRAMEBUFFER, oe.COLOR_ATTACHMENT0 + At, $t.__webglTexture, Me, ft) } } else if (te !== null && Me !== 0) { const ft = Xe.get(te.texture); oe.framebufferTexture2D(oe.FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_2D, ft.__webglTexture, Me) } I = -1 }, this.readRenderTargetPixels = function (te, ye, Me, Te, ge, at, Ke, st = 0) { if (!(te && te.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let ft = Xe.get(te).__webglFramebuffer; if (te.isWebGLCubeRenderTarget && Ke !== void 0 && (ft = ft[Ke]), ft) { ke.bindFramebuffer(oe.FRAMEBUFFER, ft); try { const At = te.textures[st], $t = At.format, Pt = At.type; if (!je.textureFormatReadable($t)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } if (!je.textureTypeReadable(Pt)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ye >= 0 && ye <= te.width - Te && Me >= 0 && Me <= te.height - ge && (te.textures.length > 1 && oe.readBuffer(oe.COLOR_ATTACHMENT0 + st), oe.readPixels(ye, Me, Te, ge, Se.convert($t), Se.convert(Pt), at)) } finally { const At = O !== null ? Xe.get(O).__webglFramebuffer : null; ke.bindFramebuffer(oe.FRAMEBUFFER, At) } } }, this.readRenderTargetPixelsAsync = async function (te, ye, Me, Te, ge, at, Ke, st = 0) { if (!(te && te.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let ft = Xe.get(te).__webglFramebuffer; if (te.isWebGLCubeRenderTarget && Ke !== void 0 && (ft = ft[Ke]), ft) if (ye >= 0 && ye <= te.width - Te && Me >= 0 && Me <= te.height - ge) { ke.bindFramebuffer(oe.FRAMEBUFFER, ft); const At = te.textures[st], $t = At.format, Pt = At.type; if (!je.textureFormatReadable($t)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."); if (!je.textureTypeReadable(Pt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."); const kt = oe.createBuffer(); oe.bindBuffer(oe.PIXEL_PACK_BUFFER, kt), oe.bufferData(oe.PIXEL_PACK_BUFFER, at.byteLength, oe.STREAM_READ), te.textures.length > 1 && oe.readBuffer(oe.COLOR_ATTACHMENT0 + st), oe.readPixels(ye, Me, Te, ge, Se.convert($t), Se.convert(Pt), 0); const Zt = O !== null ? Xe.get(O).__webglFramebuffer : null; ke.bindFramebuffer(oe.FRAMEBUFFER, Zt); const tn = oe.fenceSync(oe.SYNC_GPU_COMMANDS_COMPLETE, 0); return oe.flush(), await YNe(oe, tn, 4), oe.bindBuffer(oe.PIXEL_PACK_BUFFER, kt), oe.getBufferSubData(oe.PIXEL_PACK_BUFFER, 0, at), oe.deleteBuffer(kt), oe.deleteSync(tn), at } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.") }, this.copyFramebufferToTexture = function (te, ye = null, Me = 0) { const Te = Math.pow(2, -Me), ge = Math.floor(te.image.width * Te), at = Math.floor(te.image.height * Te), Ke = ye !== null ? ye.x : 0, st = ye !== null ? ye.y : 0; nt.setTexture2D(te, 0), oe.copyTexSubImage2D(oe.TEXTURE_2D, Me, 0, 0, Ke, st, ge, at), ke.unbindTexture() }; const Je = oe.createFramebuffer(), Nt = oe.createFramebuffer(); this.copyTextureToTexture = function (te, ye, Me = null, Te = null, ge = 0, at = null) { at === null && (ge !== 0 ? (F1("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), at = ge, ge = 0) : at = 0); let Ke, st, ft, At, $t, Pt, kt, Zt, tn; const _n = te.isCompressedTexture ? te.mipmaps[at] : te.image; if (Me !== null) Ke = Me.max.x - Me.min.x, st = Me.max.y - Me.min.y, ft = Me.isBox3 ? Me.max.z - Me.min.z : 1, At = Me.min.x, $t = Me.min.y, Pt = Me.isBox3 ? Me.min.z : 0; else { const di = Math.pow(2, -ge); Ke = Math.floor(_n.width * di), st = Math.floor(_n.height * di), te.isDataArrayTexture ? ft = _n.depth : te.isData3DTexture ? ft = Math.floor(_n.depth * di) : ft = 1, At = 0, $t = 0, Pt = 0 } Te !== null ? (kt = Te.x, Zt = Te.y, tn = Te.z) : (kt = 0, Zt = 0, tn = 0); const nn = Se.convert(ye.format), Vt = Se.convert(ye.type); let Vn; ye.isData3DTexture ? (nt.setTexture3D(ye, 0), Vn = oe.TEXTURE_3D) : ye.isDataArrayTexture || ye.isCompressedArrayTexture ? (nt.setTexture2DArray(ye, 0), Vn = oe.TEXTURE_2D_ARRAY) : (nt.setTexture2D(ye, 0), Vn = oe.TEXTURE_2D), oe.pixelStorei(oe.UNPACK_FLIP_Y_WEBGL, ye.flipY), oe.pixelStorei(oe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ye.premultiplyAlpha), oe.pixelStorei(oe.UNPACK_ALIGNMENT, ye.unpackAlignment); const bn = oe.getParameter(oe.UNPACK_ROW_LENGTH), gr = oe.getParameter(oe.UNPACK_IMAGE_HEIGHT), tr = oe.getParameter(oe.UNPACK_SKIP_PIXELS), Sr = oe.getParameter(oe.UNPACK_SKIP_ROWS), vr = oe.getParameter(oe.UNPACK_SKIP_IMAGES); oe.pixelStorei(oe.UNPACK_ROW_LENGTH, _n.width), oe.pixelStorei(oe.UNPACK_IMAGE_HEIGHT, _n.height), oe.pixelStorei(oe.UNPACK_SKIP_PIXELS, At), oe.pixelStorei(oe.UNPACK_SKIP_ROWS, $t), oe.pixelStorei(oe.UNPACK_SKIP_IMAGES, Pt); const yn = te.isDataArrayTexture || te.isData3DTexture, ur = ye.isDataArrayTexture || ye.isData3DTexture; if (te.isDepthTexture) { const di = Xe.get(te), yr = Xe.get(ye), ri = Xe.get(di.__renderTarget), yl = Xe.get(yr.__renderTarget); ke.bindFramebuffer(oe.READ_FRAMEBUFFER, ri.__webglFramebuffer), ke.bindFramebuffer(oe.DRAW_FRAMEBUFFER, yl.__webglFramebuffer); for (let nr = 0; nr < ft; nr++)yn && (oe.framebufferTextureLayer(oe.READ_FRAMEBUFFER, oe.COLOR_ATTACHMENT0, Xe.get(te).__webglTexture, ge, Pt + nr), oe.framebufferTextureLayer(oe.DRAW_FRAMEBUFFER, oe.COLOR_ATTACHMENT0, Xe.get(ye).__webglTexture, at, tn + nr)), oe.blitFramebuffer(At, $t, Ke, st, kt, Zt, Ke, st, oe.DEPTH_BUFFER_BIT, oe.NEAREST); ke.bindFramebuffer(oe.READ_FRAMEBUFFER, null), ke.bindFramebuffer(oe.DRAW_FRAMEBUFFER, null) } else if (ge !== 0 || te.isRenderTargetTexture || Xe.has(te)) { const di = Xe.get(te), yr = Xe.get(ye); ke.bindFramebuffer(oe.READ_FRAMEBUFFER, Je), ke.bindFramebuffer(oe.DRAW_FRAMEBUFFER, Nt); for (let ri = 0; ri < ft; ri++)yn ? oe.framebufferTextureLayer(oe.READ_FRAMEBUFFER, oe.COLOR_ATTACHMENT0, di.__webglTexture, ge, Pt + ri) : oe.framebufferTexture2D(oe.READ_FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_2D, di.__webglTexture, ge), ur ? oe.framebufferTextureLayer(oe.DRAW_FRAMEBUFFER, oe.COLOR_ATTACHMENT0, yr.__webglTexture, at, tn + ri) : oe.framebufferTexture2D(oe.DRAW_FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_2D, yr.__webglTexture, at), ge !== 0 ? oe.blitFramebuffer(At, $t, Ke, st, kt, Zt, Ke, st, oe.COLOR_BUFFER_BIT, oe.NEAREST) : ur ? oe.copyTexSubImage3D(Vn, at, kt, Zt, tn + ri, At, $t, Ke, st) : oe.copyTexSubImage2D(Vn, at, kt, Zt, At, $t, Ke, st); ke.bindFramebuffer(oe.READ_FRAMEBUFFER, null), ke.bindFramebuffer(oe.DRAW_FRAMEBUFFER, null) } else ur ? te.isDataTexture || te.isData3DTexture ? oe.texSubImage3D(Vn, at, kt, Zt, tn, Ke, st, ft, nn, Vt, _n.data) : ye.isCompressedArrayTexture ? oe.compressedTexSubImage3D(Vn, at, kt, Zt, tn, Ke, st, ft, nn, _n.data) : oe.texSubImage3D(Vn, at, kt, Zt, tn, Ke, st, ft, nn, Vt, _n) : te.isDataTexture ? oe.texSubImage2D(oe.TEXTURE_2D, at, kt, Zt, Ke, st, nn, Vt, _n.data) : te.isCompressedTexture ? oe.compressedTexSubImage2D(oe.TEXTURE_2D, at, kt, Zt, _n.width, _n.height, nn, _n.data) : oe.texSubImage2D(oe.TEXTURE_2D, at, kt, Zt, Ke, st, nn, Vt, _n); oe.pixelStorei(oe.UNPACK_ROW_LENGTH, bn), oe.pixelStorei(oe.UNPACK_IMAGE_HEIGHT, gr), oe.pixelStorei(oe.UNPACK_SKIP_PIXELS, tr), oe.pixelStorei(oe.UNPACK_SKIP_ROWS, Sr), oe.pixelStorei(oe.UNPACK_SKIP_IMAGES, vr), at === 0 && ye.generateMipmaps && oe.generateMipmap(Vn), ke.unbindTexture() }, this.initRenderTarget = function (te) { Xe.get(te).__webglFramebuffer === void 0 && nt.setupRenderTarget(te) }, this.initTexture = function (te) { te.isCubeTexture ? nt.setTextureCube(te, 0) : te.isData3DTexture ? nt.setTexture3D(te, 0) : te.isDataArrayTexture || te.isCompressedArrayTexture ? nt.setTexture2DArray(te, 0) : nt.setTexture2D(te, 0), ke.unbindTexture() }, this.resetState = function () { A = 0, j = 0, O = null, ke.reset(), Fe.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return cl } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; const n = this.getContext(); n.drawingBufferColorSpace = Nr._getDrawingBufferColorSpace(e), n.unpackColorSpace = Nr._getUnpackColorSpace() } } const lOe = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: HU, AddEquation: jh, AddOperation: tae, AdditiveAnimationBlendMode: ZU, AdditiveBlending: LL, AgXToneMapping: sae, AlphaFormat: XU, AlwaysCompare: wae, AlwaysDepth: cC, AlwaysStencilFunc: zL, AmbientLight: vse, AnimationAction: Tse, AnimationClip: H1, AnimationLoader: w2e, AnimationMixer: X2e, AnimationObjectGroup: G2e, AnimationUtils: v2e, ArcCurve: $ae, ArrayCamera: _se, ArrowHelper: xPe, AttachedBindMode: BL, Audio: Ese, AudioAnalyser: D2e, AudioContext: _B, AudioListener: k2e, AudioLoader: P2e, AxesHelper: bPe, BackSide: io, BasicDepthPacking: fae, BasicShadowMap: Oie, BatchedMesh: Dae, Bone: aB, BooleanKeyframeTrack: Gg, Box2: rPe, Box3: Ps, Box3Helper: vPe, BoxGeometry: Wg, BoxHelper: gPe, BufferAttribute: Lr, BufferGeometry: Kn, BufferGeometryLoader: Sse, ByteType: $A, Cache: wu, Camera: o_, CameraHelper: mPe, CanvasTexture: BAe, CapsuleGeometry: t2, CatmullRomCurve3: zae, CineonToneMapping: iae, CircleGeometry: n2, ClampToEdgeWrapping: va, Clock: EB, Color: Kt, ColorKeyframeTrack: bB, ColorManagement: Nr, CompressedArrayTexture: FAe, CompressedCubeTexture: UAe, CompressedTexture: e2, CompressedTextureLoader: S2e, ConeGeometry: d_, ConstantAlphaFactor: Qie, ConstantColorFactor: Kie, Controls: SPe, CubeCamera: Nae, CubeReflectionMapping: $u, CubeRefractionMapping: rp, CubeTexture: l_, CubeTextureLoader: fse, CubeUVReflectionMapping: C0, CubicBezierCurve: uB, CubicBezierCurve3: Vae, CubicInterpolant: lse, CullFaceBack: DL, CullFaceFront: Iie, CullFaceFrontBack: KCe, CullFaceNone: kie, Curve: Kc, CurvePath: Wae, CustomBlending: Die, CustomToneMapping: aae, CylinderGeometry: u_, Cylindrical: nPe, Data3DTexture: YA, DataArrayTexture: XA, DataTexture: Uc, DataTextureLoader: wB, DataUtils: Zm, DecrementStencilOp: cNe, DecrementWrapStencilOp: dNe, DefaultLoadingManager: dse, DepthFormat: bx, DepthStencilFormat: wx, DepthTexture: oB, DetachedBindMode: lae, DirectionalLight: gse, DirectionalLightHelper: pPe, DiscreteInterpolant: cse, DodecahedronGeometry: r2, DoubleSide: Oc, DstAlphaFactor: Wie, DstColorFactor: qie, DynamicCopyUsage: TNe, DynamicDrawUsage: bNe, DynamicReadUsage: _Ne, EdgesGeometry: Bae, EllipseCurve: i2, EqualCompare: vae, EqualDepth: dC, EqualStencilFunc: mNe, EquirectangularReflectionMapping: vx, EquirectangularRefractionMapping: P1, Euler: ml, EventDispatcher: Qu, ExternalTexture: lB, ExtrudeGeometry: a2, FileLoader: hl, Float16BufferAttribute: gAe, Float32BufferAttribute: hn, FloatType: Ui, Fog: ZA, FogExp2: KA, FramebufferTexture: LAe, FrontSide: yf, Frustum: N0, FrustumArray: JA, GLBufferAttribute: J2e, GLSL1: NNe, GLSL3: VL, GreaterCompare: yae, GreaterDepth: hC, GreaterEqualCompare: bae, GreaterEqualDepth: fC, GreaterEqualStencilFunc: xNe, GreaterStencilFunc: vNe, GridHelper: fPe, Group: By, HalfFloatType: Ya, HemisphereLight: hse, HemisphereLightHelper: dPe, IcosahedronGeometry: f_, ImageBitmapLoader: A2e, ImageLoader: W1, ImageUtils: Eae, IncrementStencilOp: lNe, IncrementWrapStencilOp: uNe, InstancedBufferAttribute: Mx, InstancedBufferGeometry: wse, InstancedInterleavedBuffer: Q2e, InstancedMesh: Oae, Int16BufferAttribute: pAe, Int32BufferAttribute: mAe, Int8BufferAttribute: dAe, IntType: i_, InterleavedBuffer: QA, InterleavedBufferAttribute: Mg, Interpolant: m_, InterpolateDiscrete: k1, InterpolateLinear: VC, InterpolateSmooth: PT, InterpolationSamplingMode: jNe, InterpolationSamplingType: PNe, InvertStencilOp: fNe, KeepStencilOp: Um, KeyframeTrack: Kl, LOD: jae, LatheGeometry: s2, Layers: hg, LessCompare: gae, LessDepth: uC, LessEqualCompare: QU, LessEqualDepth: Eg, LessEqualStencilFunc: gNe, LessStencilFunc: pNe, Light: yp, LightProbe: bse, Line: ip, Line3: sPe, LineBasicMaterial: fo, LineCurve: dB, LineCurve3: Hae, LineDashedMaterial: ase, LineLoop: Lae, LineSegments: Ju, LinearFilter: Xr, LinearInterpolant: xB, LinearMipMapLinearFilter: $L, LinearMipMapNearestFilter: JCe, LinearMipmapLinearFilter: bu, LinearMipmapNearestFilter: Gw, LinearSRGBColorSpace: Vu, LinearToneMapping: nae, LinearTransfer: O1, Loader: ho, LoaderUtils: XL, LoadingManager: h2, LoopOnce: cae, LoopPingPong: dae, LoopRepeat: uae, MOUSE: Lm, Material: Rs, MaterialLoader: p2, MathUtils: Io, Matrix2: AB, Matrix3: Qn, Matrix4: Fn, MaxEquation: Bie, Mesh: Bi, MeshBasicMaterial: _f, MeshDepthMaterial: gB, MeshDistanceMaterial: vB, MeshLambertMaterial: rse, MeshMatcapMaterial: ise, MeshNormalMaterial: nse, MeshPhongMaterial: ese, MeshPhysicalMaterial: Jae, MeshStandardMaterial: mB, MeshToonMaterial: tse, MinEquation: Uie, MirroredRepeatWrapping: R1, MixOperation: eae, MultiplyBlending: UL, MultiplyOperation: r_, NearestFilter: cs, NearestMipMapLinearFilter: QCe, NearestMipMapNearestFilter: ZCe, NearestMipmapLinearFilter: Fy, NearestMipmapNearestFilter: WU, NeutralToneMapping: oae, NeverCompare: mae, NeverDepth: lC, NeverStencilFunc: hNe, NoBlending: Pu, NoColorSpace: Kd, NoToneMapping: ju, NormalAnimationBlendMode: qA, NormalBlending: dg, NotEqualCompare: xae, NotEqualDepth: pC, NotEqualStencilFunc: yNe, NumberKeyframeTrack: z1, Object3D: kr, ObjectLoader: C2e, ObjectSpaceNormalMap: pae, OctahedronGeometry: h_, OneFactor: zie, OneMinusConstantAlphaFactor: Jie, OneMinusConstantColorFactor: Zie, OneMinusDstAlphaFactor: Gie, OneMinusDstColorFactor: Xie, OneMinusSrcAlphaFactor: oC, OneMinusSrcColorFactor: Hie, OrthographicCamera: of, PCFShadowMap: BA, PCFSoftShadowMap: Ww, PMREMGenerator: QL, Path: qC, PerspectiveCamera: ra, Plane: Yd, PlaneGeometry: vp, PlaneHelper: yPe, PointLight: mse, PointLightHelper: cPe, Points: Fae, PointsMaterial: sB, PolarGridHelper: hPe, PolyhedronGeometry: gp, PositionalAudio: O2e, PropertyBinding: Pr, PropertyMixer: Mse, QuadraticBezierCurve: fB, QuadraticBezierCurve3: hB, Quaternion: As, QuaternionKeyframeTrack: g_, QuaternionLinearInterpolant: use, RED_GREEN_RGTC2_Format: $C, RED_RGTC1_Format: UC, REVISION: n_, RGBADepthPacking: hae, RGBAFormat: ia, RGBAIntegerFormat: GA, RGBA_ASTC_10x10_Format: kC, RGBA_ASTC_10x5_Format: PC, RGBA_ASTC_10x6_Format: jC, RGBA_ASTC_10x8_Format: RC, RGBA_ASTC_12x10_Format: IC, RGBA_ASTC_12x12_Format: OC, RGBA_ASTC_4x4_Format: SC, RGBA_ASTC_5x4_Format: _C, RGBA_ASTC_5x5_Format: EC, RGBA_ASTC_6x5_Format: MC, RGBA_ASTC_6x6_Format: TC, RGBA_ASTC_8x5_Format: CC, RGBA_ASTC_8x6_Format: NC, RGBA_ASTC_8x8_Format: AC, RGBA_BPTC_Format: DC, RGBA_ETC2_EAC_Format: wC, RGBA_PVRTC_2BPPV1_Format: yC, RGBA_PVRTC_4BPPV1_Format: vC, RGBA_S3TC_DXT1_Format: Xw, RGBA_S3TC_DXT3_Format: Yw, RGBA_S3TC_DXT5_Format: Kw, RGBDepthPacking: iNe, RGBFormat: YU, RGBIntegerFormat: eNe, RGB_BPTC_SIGNED_Format: LC, RGB_BPTC_UNSIGNED_Format: FC, RGB_ETC1_Format: xC, RGB_ETC2_Format: bC, RGB_PVRTC_2BPPV1_Format: gC, RGB_PVRTC_4BPPV1_Format: mC, RGB_S3TC_DXT1_Format: qw, RGDepthPacking: aNe, RGFormat: KU, RGIntegerFormat: WA, RawShaderMaterial: Qae, Ray: Hg, Raycaster: NB, RectAreaLight: yse, RedFormat: a_, RedIntegerFormat: s_, ReinhardToneMapping: rae, RenderTarget: eB, RenderTarget3D: Y2e, RepeatWrapping: j1, ReplaceStencilOp: oNe, ReverseSubtractEquation: Fie, RingGeometry: o2, SIGNED_RED_GREEN_RGTC2_Format: zC, SIGNED_RED_RGTC1_Format: BC, SRGBColorSpace: qs, SRGBTransfer: Wr, Scene: c_, ShaderChunk: lr, ShaderLib: Ic, ShaderMaterial: Bo, ShadowMaterial: Zae, Shape: pg, ShapeGeometry: l2, ShapePath: wPe, ShapeUtils: Fc, ShortType: zA, Skeleton: kae, SkeletonHelper: lPe, SkinnedMesh: Rae, Source: Oh, Sphere: us, SphereGeometry: p_, Spherical: KL, SphericalHarmonics3: xse, SplineCurve: pB, SpotLight: pse, SpotLightHelper: oPe, Sprite: Pae, SpriteMaterial: iB, SrcAlphaFactor: sC, SrcAlphaSaturateFactor: Yie, SrcColorFactor: Vie, StaticCopyUsage: MNe, StaticDrawUsage: D1, StaticReadUsage: SNe, StereoCamera: j2e, StreamCopyUsage: CNe, StreamDrawUsage: wNe, StreamReadUsage: ENe, StringKeyframeTrack: qg, SubtractEquation: Lie, SubtractiveBlending: FL, TOUCH: Fm, TangentSpaceNormalMap: mp, TetrahedronGeometry: c2, Texture: ti, TextureLoader: _2e, TextureUtils: CPe, Timer: ePe, TimestampQuery: ANe, TorusGeometry: u2, TorusKnotGeometry: d2, Triangle: Oo, TriangleFanDrawMode: rNe, TriangleStripDrawMode: nNe, TrianglesDrawMode: tNe, TubeGeometry: f2, UVMapping: np, Uint16BufferAttribute: tB, Uint32BufferAttribute: nB, Uint8BufferAttribute: fAe, Uint8ClampedBufferAttribute: hAe, Uniform: CB, UniformsGroup: Z2e, UniformsLib: Wt, UniformsUtils: Cae, UnsignedByteType: lo, UnsignedInt101111Type: qU, UnsignedInt248Type: xx, UnsignedInt5999Type: GU, UnsignedIntType: zu, UnsignedShort4444Type: VA, UnsignedShort5551Type: HA, UnsignedShortType: yx, VSMShadowMap: Pc, Vector2: lt, Vector3: pe, Vector4: jr, VectorKeyframeTrack: V1, VideoFrameTexture: DAe, VideoTexture: Uae, WebGL3DRenderTarget: eAe, WebGLArrayRenderTarget: JNe, WebGLCoordinateSystem: cl, WebGLCubeRenderTarget: rB, WebGLRenderTarget: Hl, WebGLRenderer: jB, WebGLUtils: kse, WebGPUCoordinateSystem: Sx, WebXRController: jT, WireframeGeometry: Kae, WrapAroundEnding: I1, ZeroCurvatureEnding: Ym, ZeroFactor: $ie, ZeroSlopeEnding: Km, ZeroStencilOp: sNe, createCanvasElement: _ae }, Symbol.toStringTag, { value: "Module" })); var GR = { exports: {} }, Sh = {};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var e7; function cOe() { return e7 || (e7 = 1, Sh.ConcurrentRoot = 1, Sh.ContinuousEventPriority = 4, Sh.DefaultEventPriority = 16, Sh.DiscreteEventPriority = 1, Sh.IdleEventPriority = 536870912, Sh.LegacyRoot = 0), Sh } var t7; function uOe() { return t7 || (t7 = 1, GR.exports = cOe()), GR.exports } var zy = uOe(); function dOe(t) { let e; const n = new Set, r = (u, d) => { const f = typeof u == "function" ? u(e) : u; if (f !== e) { const h = e; e = d ? f : Object.assign({}, e, f), n.forEach(m => m(e, h)) } }, i = () => e, a = (u, d = i, f = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let h = d(e); function m() { const g = d(e); if (!f(h, g)) { const x = h; u(h = g, x) } } return n.add(m), () => n.delete(m) }, c = { setState: r, getState: i, subscribe: (u, d, f) => d || f ? a(u, d, f) : (n.add(u), () => n.delete(u)), destroy: () => n.clear() }; return e = t(r, i, c), c } const fOe = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), n7 = fOe ? S.useEffect : S.useLayoutEffect; function Ise(t) { const e = typeof t == "function" ? dOe(t) : t, n = (r = e.getState, i = Object.is) => { const [, a] = S.useReducer(v => v + 1, 0), s = e.getState(), o = S.useRef(s), c = S.useRef(r), u = S.useRef(i), d = S.useRef(!1), f = S.useRef(); f.current === void 0 && (f.current = r(s)); let h, m = !1; (o.current !== s || c.current !== r || u.current !== i || d.current) && (h = r(s), m = !i(f.current, h)), n7(() => { m && (f.current = h), o.current = s, c.current = r, u.current = i, d.current = !1 }); const g = S.useRef(s); n7(() => { const v = () => { try { const E = e.getState(), M = c.current(E); u.current(f.current, M) || (o.current = E, f.current = M, a()) } catch { d.current = !0, a() } }, b = e.subscribe(v); return e.getState() !== g.current && v(), b }, []); const x = m ? h : f.current; return S.useDebugValue(x), x }; return Object.assign(n, e), n[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const r = [n, e]; return { next() { const i = r.length <= 0; return { value: r.shift(), done: i } } } }, n } const hOe = t => typeof t == "object" && typeof t.then == "function", Jm = []; function Ose(t, e, n = (r, i) => r === i) { if (t === e) return !0; if (!t || !e) return !1; const r = t.length; if (e.length !== r) return !1; for (let i = 0; i < r; i++)if (!n(t[i], e[i])) return !1; return !0 } function Dse(t, e = null, n = !1, r = {}) { e === null && (e = [t]); for (const a of Jm) if (Ose(e, a.keys, a.equal)) { if (n) return; if (Object.prototype.hasOwnProperty.call(a, "error")) throw a.error; if (Object.prototype.hasOwnProperty.call(a, "response")) return r.lifespan && r.lifespan > 0 && (a.timeout && clearTimeout(a.timeout), a.timeout = setTimeout(a.remove, r.lifespan)), a.response; if (!n) throw a.promise } const i = { keys: e, equal: r.equal, remove: () => { const a = Jm.indexOf(i); a !== -1 && Jm.splice(a, 1) }, promise: (hOe(t) ? t : t(...e)).then(a => { i.response = a, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan)) }).catch(a => i.error = a) }; if (Jm.push(i), !n) throw i.promise } const pOe = (t, e, n) => Dse(t, e, !1, n), mOe = (t, e, n) => void Dse(t, e, !0, n), gOe = t => { if (t === void 0 || t.length === 0) Jm.splice(0, Jm.length); else { const e = Jm.find(n => Ose(t, n.keys, n.equal)); e && e.remove() } }; var qR = { exports: {} }, XR = { exports: {} }, YR = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var r7; function vOe() { return r7 || (r7 = 1, (function (t) { function e($, V) { var K = $.length; $.push(V); e: for (; 0 < K;) { var X = K - 1 >>> 1, Q = $[X]; if (0 < i(Q, V)) $[X] = V, $[K] = Q, K = X; else break e } } function n($) { return $.length === 0 ? null : $[0] } function r($) { if ($.length === 0) return null; var V = $[0], K = $.pop(); if (K !== V) { $[0] = K; e: for (var X = 0, Q = $.length, re = Q >>> 1; X < re;) { var ce = 2 * (X + 1) - 1, be = $[ce], de = ce + 1, ae = $[de]; if (0 > i(be, K)) de < Q && 0 > i(ae, be) ? ($[X] = ae, $[de] = K, X = de) : ($[X] = be, $[ce] = K, X = ce); else if (de < Q && 0 > i(ae, K)) $[X] = ae, $[de] = K, X = de; else break e } } return V } function i($, V) { var K = $.sortIndex - V.sortIndex; return K !== 0 ? K : $.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var a = performance; t.unstable_now = function () { return a.now() } } else { var s = Date, o = s.now(); t.unstable_now = function () { return s.now() - o } } var c = [], u = [], d = 1, f = null, h = 3, m = !1, g = !1, x = !1, v = typeof setTimeout == "function" ? setTimeout : null, b = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M($) { for (var V = n(u); V !== null;) { if (V.callback === null) r(u); else if (V.startTime <= $) r(u), V.sortIndex = V.expirationTime, e(c, V); else break; V = n(u) } } function C($) { if (x = !1, M($), !g) if (n(c) !== null) g = !0, Y(N); else { var V = n(u); V !== null && Z(C, V.startTime - $) } } function N($, V) { g = !1, x && (x = !1, b(O), O = -1), m = !0; var K = h; try { for (M(V), f = n(c); f !== null && (!(f.expirationTime > V) || $ && !F());) { var X = f.callback; if (typeof X == "function") { f.callback = null, h = f.priorityLevel; var Q = X(f.expirationTime <= V); V = t.unstable_now(), typeof Q == "function" ? f.callback = Q : f === n(c) && r(c), M(V) } else r(c); f = n(c) } if (f !== null) var re = !0; else { var ce = n(u); ce !== null && Z(C, ce.startTime - V), re = !1 } return re } finally { f = null, h = K, m = !1 } } var A = !1, j = null, O = -1, I = 5, D = -1; function F() { return !(t.unstable_now() - D < I) } function B() { if (j !== null) { var $ = t.unstable_now(); D = $; var V = !0; try { V = j(!0, $) } finally { V ? G() : (A = !1, j = null) } } else A = !1 } var G; if (typeof E == "function") G = function () { E(B) }; else if (typeof MessageChannel < "u") { var z = new MessageChannel, q = z.port2; z.port1.onmessage = B, G = function () { q.postMessage(null) } } else G = function () { v(B, 0) }; function Y($) { j = $, A || (A = !0, G()) } function Z($, V) { O = v(function () { $(t.unstable_now()) }, V) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function ($) { $.callback = null }, t.unstable_continueExecution = function () { g || m || (g = !0, Y(N)) }, t.unstable_forceFrameRate = function ($) { 0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < $ ? Math.floor(1e3 / $) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(c) }, t.unstable_next = function ($) { switch (h) { case 1: case 2: case 3: var V = 3; break; default: V = h }var K = h; h = V; try { return $() } finally { h = K } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function ($, V) { switch ($) { case 1: case 2: case 3: case 4: case 5: break; default: $ = 3 }var K = h; h = $; try { return V() } finally { h = K } }, t.unstable_scheduleCallback = function ($, V, K) { var X = t.unstable_now(); switch (typeof K == "object" && K !== null ? (K = K.delay, K = typeof K == "number" && 0 < K ? X + K : X) : K = X, $) { case 1: var Q = -1; break; case 2: Q = 250; break; case 5: Q = 1073741823; break; case 4: Q = 1e4; break; default: Q = 5e3 }return Q = K + Q, $ = { id: d++, callback: V, priorityLevel: $, startTime: K, expirationTime: Q, sortIndex: -1 }, K > X ? ($.sortIndex = K, e(u, $), n(c) === null && $ === n(u) && (x ? (b(O), O = -1) : x = !0, Z(C, K - X))) : ($.sortIndex = Q, e(c, $), g || m || (g = !0, Y(N))), $ }, t.unstable_shouldYield = F, t.unstable_wrapCallback = function ($) { var V = h; return function () { var K = h; h = V; try { return $.apply(this, arguments) } finally { h = K } } } })(YR)), YR } var i7; function yOe() { return i7 || (i7 = 1, XR.exports = vOe()), XR.exports }/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var KR, a7; function xOe() {
	return a7 || (a7 = 1, KR = function (e) {
		var n = {}, r = IS(), i = yOe(), a = Object.assign; function s(w) { for (var _ = "https://reactjs.org/docs/error-decoder.html?invariant=" + w, R = 1; R < arguments.length; R++)_ += "&args[]=" + encodeURIComponent(arguments[R]); return "Minified React error #" + w + "; visit " + _ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var o = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, c = Symbol.for("react.element"), u = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), g = Symbol.for("react.context"), x = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), b = Symbol.for("react.suspense_list"), E = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), N = Symbol.iterator; function A(w) { return w === null || typeof w != "object" ? null : (w = N && w[N] || w["@@iterator"], typeof w == "function" ? w : null) } function j(w) { if (w == null) return null; if (typeof w == "function") return w.displayName || w.name || null; if (typeof w == "string") return w; switch (w) { case d: return "Fragment"; case u: return "Portal"; case h: return "Profiler"; case f: return "StrictMode"; case v: return "Suspense"; case b: return "SuspenseList" }if (typeof w == "object") switch (w.$$typeof) { case g: return (w.displayName || "Context") + ".Consumer"; case m: return (w._context.displayName || "Context") + ".Provider"; case x: var _ = w.render; return w = w.displayName, w || (w = _.displayName || _.name || "", w = w !== "" ? "ForwardRef(" + w + ")" : "ForwardRef"), w; case E: return _ = w.displayName || null, _ !== null ? _ : j(w.type) || "Memo"; case M: _ = w._payload, w = w._init; try { return j(w(_)) } catch { } }return null } function O(w) { var _ = w.type; switch (w.tag) { case 24: return "Cache"; case 9: return (_.displayName || "Context") + ".Consumer"; case 10: return (_._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return w = _.render, w = w.displayName || w.name || "", _.displayName || (w !== "" ? "ForwardRef(" + w + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return _; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return j(_); case 8: return _ === f ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof _ == "function") return _.displayName || _.name || null; if (typeof _ == "string") return _ }return null } function I(w) { var _ = w, R = w; if (w.alternate) for (; _.return;)_ = _.return; else { w = _; do _ = w, (_.flags & 4098) !== 0 && (R = _.return), w = _.return; while (w) } return _.tag === 3 ? R : null } function D(w) { if (I(w) !== w) throw Error(s(188)) } function F(w) { var _ = w.alternate; if (!_) { if (_ = I(w), _ === null) throw Error(s(188)); return _ !== w ? null : w } for (var R = w, L = _; ;) { var H = R.return; if (H === null) break; var J = H.alternate; if (J === null) { if (L = H.return, L !== null) { R = L; continue } break } if (H.child === J.child) { for (J = H.child; J;) { if (J === R) return D(H), w; if (J === L) return D(H), _; J = J.sibling } throw Error(s(188)) } if (R.return !== L.return) R = H, L = J; else { for (var ve = !1, Oe = H.child; Oe;) { if (Oe === R) { ve = !0, R = H, L = J; break } if (Oe === L) { ve = !0, L = H, R = J; break } Oe = Oe.sibling } if (!ve) { for (Oe = J.child; Oe;) { if (Oe === R) { ve = !0, R = J, L = H; break } if (Oe === L) { ve = !0, L = J, R = H; break } Oe = Oe.sibling } if (!ve) throw Error(s(189)) } } if (R.alternate !== L) throw Error(s(190)) } if (R.tag !== 3) throw Error(s(188)); return R.stateNode.current === R ? w : _ } function B(w) { return w = F(w), w !== null ? G(w) : null } function G(w) { if (w.tag === 5 || w.tag === 6) return w; for (w = w.child; w !== null;) { var _ = G(w); if (_ !== null) return _; w = w.sibling } return null } function z(w) { if (w.tag === 5 || w.tag === 6) return w; for (w = w.child; w !== null;) { if (w.tag !== 4) { var _ = z(w); if (_ !== null) return _ } w = w.sibling } return null } var q = Array.isArray, Y = e.getPublicInstance, Z = e.getRootHostContext, $ = e.getChildHostContext, V = e.prepareForCommit, K = e.resetAfterCommit, X = e.createInstance, Q = e.appendInitialChild, re = e.finalizeInitialChildren, ce = e.prepareUpdate, be = e.shouldSetTextContent, de = e.createTextInstance, ae = e.scheduleTimeout, se = e.cancelTimeout, he = e.noTimeout, Ae = e.isPrimaryRenderer, Ce = e.supportsMutation, fe = e.supportsPersistence, oe = e.supportsHydration, xe = e.getInstanceFromNode, _e = e.preparePortalMount, je = e.getCurrentEventPriority, ke = e.detachDeletedInstance, Ze = e.supportsMicrotasks, Xe = e.scheduleMicrotask, nt = e.supportsTestSelectors, Tt = e.findFiberRoot, St = e.getBoundingRect, ee = e.getTextContent, ne = e.isHiddenSubtree, Re = e.matchAccessibilityRole, Ue = e.setFocusIfFocusable, et = e.setupIntersectionObserver, Ge = e.appendChild, Xt = e.appendChildToContainer, yt = e.commitTextUpdate, Yt = e.commitMount, en = e.commitUpdate, pt = e.insertBefore, bt = e.insertInContainerBefore, pn = e.removeChild, Se = e.removeChildFromContainer, Fe = e.resetTextContent, ht = e.hideInstance, Ee = e.hideTextInstance, De = e.unhideInstance, gt = e.unhideTextInstance, Bt = e.clearContainer, mt = e.cloneInstance, ot = e.createContainerChildSet, it = e.appendChildToContainerChildSet, Ft = e.finalizeContainerChildren, un = e.replaceContainerChildren, wn = e.cloneHiddenInstance, wr = e.cloneHiddenTextInstance, Tr = e.canHydrateInstance, Ua = e.canHydrateTextInstance, Vr = e.canHydrateSuspenseInstance, zi = e.isSuspenseInstancePending, po = e.isSuspenseInstanceFallback, ks = e.registerSuspenseInstanceRetry, Zi = e.getNextHydratableSibling, Hn = e.getFirstHydratableChild, Ql = e.getFirstHydratableChildWithinContainer, Of = e.getFirstHydratableChildWithinSuspenseInstance, ie = e.hydrateInstance, ue = e.hydrateTextInstance, Ne = e.hydrateSuspenseInstance, He = e.getNextHydratableInstanceAfterSuspenseInstance, Qe = e.commitHydratedContainer, Je = e.commitHydratedSuspenseInstance, Nt = e.clearSuspenseBoundary, te = e.clearSuspenseBoundaryFromContainer, ye = e.shouldDeleteUnhydratedTailInstances, Me = e.didNotMatchHydratedContainerTextInstance, Te = e.didNotMatchHydratedTextInstance, ge; function at(w) {
			if (ge === void 0) try { throw Error() } catch (R) { var _ = R.stack.trim().match(/\n( *(at )?)/); ge = _ && _[1] || "" } return `
`+ ge + w
		} var Ke = !1; function st(w, _) {
			if (!w || Ke) return ""; Ke = !0; var R = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (_) if (_ = function () { throw Error() }, Object.defineProperty(_.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(_, []) } catch (Ot) { var L = Ot } Reflect.construct(w, [], _) } else { try { _.call() } catch (Ot) { L = Ot } w.call(_.prototype) } else { try { throw Error() } catch (Ot) { L = Ot } w() } } catch (Ot) {
				if (Ot && L && typeof Ot.stack == "string") {
					for (var H = Ot.stack.split(`
`), J = L.stack.split(`
`), ve = H.length - 1, Oe = J.length - 1; 1 <= ve && 0 <= Oe && H[ve] !== J[Oe];)Oe--; for (; 1 <= ve && 0 <= Oe; ve--, Oe--)if (H[ve] !== J[Oe]) {
						if (ve !== 1 || Oe !== 1) do if (ve--, Oe--, 0 > Oe || H[ve] !== J[Oe]) {
							var tt = `
`+ H[ve].replace(" at new ", " at "); return w.displayName && tt.includes("<anonymous>") && (tt = tt.replace("<anonymous>", w.displayName)), tt
						} while (1 <= ve && 0 <= Oe); break
					}
				}
			} finally { Ke = !1, Error.prepareStackTrace = R } return (w = w ? w.displayName || w.name : "") ? at(w) : ""
		} var ft = Object.prototype.hasOwnProperty, At = [], $t = -1; function Pt(w) { return { current: w } } function kt(w) { 0 > $t || (w.current = At[$t], At[$t] = null, $t--) } function Zt(w, _) { $t++, At[$t] = w.current, w.current = _ } var tn = {}, _n = Pt(tn), nn = Pt(!1), Vt = tn; function Vn(w, _) { var R = w.type.contextTypes; if (!R) return tn; var L = w.stateNode; if (L && L.__reactInternalMemoizedUnmaskedChildContext === _) return L.__reactInternalMemoizedMaskedChildContext; var H = {}, J; for (J in R) H[J] = _[J]; return L && (w = w.stateNode, w.__reactInternalMemoizedUnmaskedChildContext = _, w.__reactInternalMemoizedMaskedChildContext = H), H } function bn(w) { return w = w.childContextTypes, w != null } function gr() { kt(nn), kt(_n) } function tr(w, _, R) { if (_n.current !== tn) throw Error(s(168)); Zt(_n, _), Zt(nn, R) } function Sr(w, _, R) { var L = w.stateNode; if (_ = _.childContextTypes, typeof L.getChildContext != "function") return R; L = L.getChildContext(); for (var H in L) if (!(H in _)) throw Error(s(108, O(w) || "Unknown", H)); return a({}, R, L) } function vr(w) { return w = (w = w.stateNode) && w.__reactInternalMemoizedMergedChildContext || tn, Vt = _n.current, Zt(_n, w), Zt(nn, nn.current), !0 } function yn(w, _, R) { var L = w.stateNode; if (!L) throw Error(s(169)); R ? (w = Sr(w, _, Vt), L.__reactInternalMemoizedMergedChildContext = w, kt(nn), kt(_n), Zt(_n, w)) : kt(nn), Zt(nn, R) } var ur = Math.clz32 ? Math.clz32 : ri, di = Math.log, yr = Math.LN2; function ri(w) { return w >>>= 0, w === 0 ? 32 : 31 - (di(w) / yr | 0) | 0 } var yl = 64, nr = 4194304; function Df(w) { switch (w & -w) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return w & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return w & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return w } } function Rp(w, _) { var R = w.pendingLanes; if (R === 0) return 0; var L = 0, H = w.suspendedLanes, J = w.pingedLanes, ve = R & 268435455; if (ve !== 0) { var Oe = ve & ~H; Oe !== 0 ? L = Df(Oe) : (J &= ve, J !== 0 && (L = Df(J))) } else ve = R & ~H, ve !== 0 ? L = Df(ve) : J !== 0 && (L = Df(J)); if (L === 0) return 0; if (_ !== 0 && _ !== L && (_ & H) === 0 && (H = L & -L, J = _ & -_, H >= J || H === 16 && (J & 4194240) !== 0)) return _; if ((L & 4) !== 0 && (L |= R & 16), _ = w.entangledLanes, _ !== 0) for (w = w.entanglements, _ &= L; 0 < _;)R = 31 - ur(_), H = 1 << R, L |= w[R], _ &= ~H; return L } function J0(w, _) { switch (w) { case 1: case 2: case 4: return _ + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return _ + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function V_(w, _) { for (var R = w.suspendedLanes, L = w.pingedLanes, H = w.expirationTimes, J = w.pendingLanes; 0 < J;) { var ve = 31 - ur(J), Oe = 1 << ve, tt = H[ve]; tt === -1 ? ((Oe & R) === 0 || (Oe & L) !== 0) && (H[ve] = J0(Oe, _)) : tt <= _ && (w.expiredLanes |= Oe), J &= ~Oe } } function ev(w) { return w = w.pendingLanes & -1073741825, w !== 0 ? w : w & 1073741824 ? 1073741824 : 0 } function tv(w) { for (var _ = [], R = 0; 31 > R; R++)_.push(w); return _ } function ad(w, _, R) { w.pendingLanes |= _, _ !== 536870912 && (w.suspendedLanes = 0, w.pingedLanes = 0), w = w.eventTimes, _ = 31 - ur(_), w[_] = R } function nv(w, _) { var R = w.pendingLanes & ~_; w.pendingLanes = _, w.suspendedLanes = 0, w.pingedLanes = 0, w.expiredLanes &= _, w.mutableReadLanes &= _, w.entangledLanes &= _, _ = w.entanglements; var L = w.eventTimes; for (w = w.expirationTimes; 0 < R;) { var H = 31 - ur(R), J = 1 << H; _[H] = 0, L[H] = -1, w[H] = -1, R &= ~J } } function xl(w, _) { var R = w.entangledLanes |= _; for (w = w.entanglements; R;) { var L = 31 - ur(R), H = 1 << L; H & _ | w[L] & _ && (w[L] |= _), R &= ~H } } var sr = 0; function Jl(w) { return w &= -w, 1 < w ? 4 < w ? (w & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var sd = i.unstable_scheduleCallback, Lf = i.unstable_cancelCallback, eu = i.unstable_shouldYield, HP = i.unstable_requestPaint, Qi = i.unstable_now, od = i.unstable_ImmediatePriority, WP = i.unstable_UserBlockingPriority, rv = i.unstable_NormalPriority, iv = i.unstable_IdlePriority, kp = null, bl = null; function Ip(w) { if (bl && typeof bl.onCommitFiberRoot == "function") try { bl.onCommitFiberRoot(kp, w, void 0, (w.current.flags & 128) === 128) } catch { } } function Op(w, _) { return w === _ && (w !== 0 || 1 / w === 1 / _) || w !== w && _ !== _ } var Qa = typeof Object.is == "function" ? Object.is : Op, mo = null, av = !1, eb = !1; function sv(w) { mo === null ? mo = [w] : mo.push(w) } function ov(w) { av = !0, sv(w) } function go() { if (!eb && mo !== null) { eb = !0; var w = 0, _ = sr; try { var R = mo; for (sr = 1; w < R.length; w++) { var L = R[w]; do L = L(!0); while (L !== null) } mo = null, av = !1 } catch (H) { throw mo !== null && (mo = mo.slice(w + 1)), sd(od, go), H } finally { sr = _, eb = !1 } } return null } var H_ = o.ReactCurrentBatchConfig; function Ho(w, _) { if (Qa(w, _)) return !0; if (typeof w != "object" || w === null || typeof _ != "object" || _ === null) return !1; var R = Object.keys(w), L = Object.keys(_); if (R.length !== L.length) return !1; for (L = 0; L < R.length; L++) { var H = R[L]; if (!ft.call(_, H) || !Qa(w[H], _[H])) return !1 } return !0 } function tb(w) { switch (w.tag) { case 5: return at(w.type); case 16: return at("Lazy"); case 13: return at("Suspense"); case 19: return at("SuspenseList"); case 0: case 2: case 15: return w = st(w.type, !1), w; case 11: return w = st(w.type.render, !1), w; case 1: return w = st(w.type, !0), w; default: return "" } } function hs(w, _) { if (w && w.defaultProps) { _ = a({}, _), w = w.defaultProps; for (var R in w) _[R] === void 0 && (_[R] = w[R]); return _ } return _ } var Dp = Pt(null), ld = null, ec = null, lv = null; function Ja() { lv = ec = ld = null } function cd(w, _, R) { Ae ? (Zt(Dp, _._currentValue), _._currentValue = R) : (Zt(Dp, _._currentValue2), _._currentValue2 = R) } function Lp(w) { var _ = Dp.current; kt(Dp), Ae ? w._currentValue = _ : w._currentValue2 = _ } function ud(w, _, R) { for (; w !== null;) { var L = w.alternate; if ((w.childLanes & _) !== _ ? (w.childLanes |= _, L !== null && (L.childLanes |= _)) : L !== null && (L.childLanes & _) !== _ && (L.childLanes |= _), w === R) break; w = w.return } } function Ff(w, _) { ld = w, lv = ec = null, w = w.dependencies, w !== null && w.firstContext !== null && ((w.lanes & _) !== 0 && (da = !0), w.firstContext = null) } function ps(w) { var _ = Ae ? w._currentValue : w._currentValue2; if (lv !== w) if (w = { context: w, memoizedValue: _, next: null }, ec === null) { if (ld === null) throw Error(s(308)); ec = w, ld.dependencies = { lanes: 0, firstContext: w } } else ec = ec.next = w; return _ } var vo = null, yo = !1; function Uf(w) { w.updateQueue = { baseState: w.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function nb(w, _) { w = w.updateQueue, _.updateQueue === w && (_.updateQueue = { baseState: w.baseState, firstBaseUpdate: w.firstBaseUpdate, lastBaseUpdate: w.lastBaseUpdate, shared: w.shared, effects: w.effects }) } function tc(w, _) { return { eventTime: w, lane: _, tag: 0, payload: null, callback: null, next: null } } function tu(w, _) { var R = w.updateQueue; R !== null && (R = R.shared, Oi !== null && (w.mode & 1) !== 0 && (Zn & 2) === 0 ? (w = R.interleaved, w === null ? (_.next = _, vo === null ? vo = [R] : vo.push(R)) : (_.next = w.next, w.next = _), R.interleaved = _) : (w = R.pending, w === null ? _.next = _ : (_.next = w.next, w.next = _), R.pending = _)) } function cv(w, _, R) { if (_ = _.updateQueue, _ !== null && (_ = _.shared, (R & 4194240) !== 0)) { var L = _.lanes; L &= w.pendingLanes, R |= L, _.lanes = R, xl(w, R) } } function uv(w, _) { var R = w.updateQueue, L = w.alternate; if (L !== null && (L = L.updateQueue, R === L)) { var H = null, J = null; if (R = R.firstBaseUpdate, R !== null) { do { var ve = { eventTime: R.eventTime, lane: R.lane, tag: R.tag, payload: R.payload, callback: R.callback, next: null }; J === null ? H = J = ve : J = J.next = ve, R = R.next } while (R !== null); J === null ? H = J = _ : J = J.next = _ } else H = J = _; R = { baseState: L.baseState, firstBaseUpdate: H, lastBaseUpdate: J, shared: L.shared, effects: L.effects }, w.updateQueue = R; return } w = R.lastBaseUpdate, w === null ? R.firstBaseUpdate = _ : w.next = _, R.lastBaseUpdate = _ } function dv(w, _, R, L) { var H = w.updateQueue; yo = !1; var J = H.firstBaseUpdate, ve = H.lastBaseUpdate, Oe = H.shared.pending; if (Oe !== null) { H.shared.pending = null; var tt = Oe, Ot = tt.next; tt.next = null, ve === null ? J = Ot : ve.next = Ot, ve = tt; var an = w.alternate; an !== null && (an = an.updateQueue, Oe = an.lastBaseUpdate, Oe !== ve && (Oe === null ? an.firstBaseUpdate = Ot : Oe.next = Ot, an.lastBaseUpdate = tt)) } if (J !== null) { var Bn = H.baseState; ve = 0, an = Ot = tt = null, Oe = J; do { var En = Oe.lane, rr = Oe.eventTime; if ((L & En) === En) { an !== null && (an = an.next = { eventTime: rr, lane: 0, tag: Oe.tag, payload: Oe.payload, callback: Oe.callback, next: null }); e: { var Qt = w, Ea = Oe; switch (En = _, rr = R, Ea.tag) { case 1: if (Qt = Ea.payload, typeof Qt == "function") { Bn = Qt.call(rr, Bn, En); break e } Bn = Qt; break e; case 3: Qt.flags = Qt.flags & -65537 | 128; case 0: if (Qt = Ea.payload, En = typeof Qt == "function" ? Qt.call(rr, Bn, En) : Qt, En == null) break e; Bn = a({}, Bn, En); break e; case 2: yo = !0 } } Oe.callback !== null && Oe.lane !== 0 && (w.flags |= 64, En = H.effects, En === null ? H.effects = [Oe] : En.push(Oe)) } else rr = { eventTime: rr, lane: En, tag: Oe.tag, payload: Oe.payload, callback: Oe.callback, next: null }, an === null ? (Ot = an = rr, tt = Bn) : an = an.next = rr, ve |= En; if (Oe = Oe.next, Oe === null) { if (Oe = H.shared.pending, Oe === null) break; En = Oe, Oe = En.next, En.next = null, H.lastBaseUpdate = En, H.shared.pending = null } } while (!0); if (an === null && (tt = Bn), H.baseState = tt, H.firstBaseUpdate = Ot, H.lastBaseUpdate = an, _ = H.shared.interleaved, _ !== null) { H = _; do ve |= H.lane, H = H.next; while (H !== _) } else J === null && (H.shared.lanes = 0); El |= ve, w.lanes = ve, w.memoizedState = Bn } } function W_(w, _, R) { if (w = _.effects, _.effects = null, w !== null) for (_ = 0; _ < w.length; _++) { var L = w[_], H = L.callback; if (H !== null) { if (L.callback = null, L = R, typeof H != "function") throw Error(s(191, H)); H.call(L) } } } var G_ = new r.Component().refs; function rb(w, _, R, L) { _ = w.memoizedState, R = R(L, _), R = R == null ? _ : a({}, _, R), w.memoizedState = R, w.lanes === 0 && (w.updateQueue.baseState = R) } var fv = { isMounted: function (w) { return (w = w._reactInternals) ? I(w) === w : !1 }, enqueueSetState: function (w, _, R) { w = w._reactInternals; var L = Cr(), H = Zo(w), J = tc(L, H); J.payload = _, R != null && (J.callback = R), tu(w, J), _ = za(w, H, L), _ !== null && cv(_, w, H) }, enqueueReplaceState: function (w, _, R) { w = w._reactInternals; var L = Cr(), H = Zo(w), J = tc(L, H); J.tag = 1, J.payload = _, R != null && (J.callback = R), tu(w, J), _ = za(w, H, L), _ !== null && cv(_, w, H) }, enqueueForceUpdate: function (w, _) { w = w._reactInternals; var R = Cr(), L = Zo(w), H = tc(R, L); H.tag = 2, _ != null && (H.callback = _), tu(w, H), _ = za(w, L, R), _ !== null && cv(_, w, L) } }; function ib(w, _, R, L, H, J, ve) { return w = w.stateNode, typeof w.shouldComponentUpdate == "function" ? w.shouldComponentUpdate(L, J, ve) : _.prototype && _.prototype.isPureReactComponent ? !Ho(R, L) || !Ho(H, J) : !0 } function q_(w, _, R) { var L = !1, H = tn, J = _.contextType; return typeof J == "object" && J !== null ? J = ps(J) : (H = bn(_) ? Vt : _n.current, L = _.contextTypes, J = (L = L != null) ? Vn(w, H) : tn), _ = new _(R, J), w.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null, _.updater = fv, w.stateNode = _, _._reactInternals = w, L && (w = w.stateNode, w.__reactInternalMemoizedUnmaskedChildContext = H, w.__reactInternalMemoizedMaskedChildContext = J), _ } function X_(w, _, R, L) { w = _.state, typeof _.componentWillReceiveProps == "function" && _.componentWillReceiveProps(R, L), typeof _.UNSAFE_componentWillReceiveProps == "function" && _.UNSAFE_componentWillReceiveProps(R, L), _.state !== w && fv.enqueueReplaceState(_, _.state, null) } function ab(w, _, R, L) { var H = w.stateNode; H.props = R, H.state = w.memoizedState, H.refs = G_, Uf(w); var J = _.contextType; typeof J == "object" && J !== null ? H.context = ps(J) : (J = bn(_) ? Vt : _n.current, H.context = Vn(w, J)), H.state = w.memoizedState, J = _.getDerivedStateFromProps, typeof J == "function" && (rb(w, _, J, R), H.state = w.memoizedState), typeof _.getDerivedStateFromProps == "function" || typeof H.getSnapshotBeforeUpdate == "function" || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (_ = H.state, typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount(), _ !== H.state && fv.enqueueReplaceState(H, H.state, null), dv(w, R, H, L), H.state = w.memoizedState), typeof H.componentDidMount == "function" && (w.flags |= 4194308) } var Bf = [], nu = 0, hv = null, pv = 0, xo = [], Is = 0, dd = null, nc = 1, rc = ""; function fd(w, _) { Bf[nu++] = pv, Bf[nu++] = hv, hv = w, pv = _ } function Y_(w, _, R) { xo[Is++] = nc, xo[Is++] = rc, xo[Is++] = dd, dd = w; var L = nc; w = rc; var H = 32 - ur(L) - 1; L &= ~(1 << H), R += 1; var J = 32 - ur(_) + H; if (30 < J) { var ve = H - H % 5; J = (L & (1 << ve) - 1).toString(32), L >>= ve, H -= ve, nc = 1 << 32 - ur(_) + H | R << H | L, rc = J + w } else nc = 1 << J | R << H | L, rc = w } function sb(w) { w.return !== null && (fd(w, 1), Y_(w, 1, 0)) } function ob(w) { for (; w === hv;)hv = Bf[--nu], Bf[nu] = null, pv = Bf[--nu], Bf[nu] = null; for (; w === dd;)dd = xo[--Is], xo[Is] = null, rc = xo[--Is], xo[Is] = null, nc = xo[--Is], xo[Is] = null } var es = null, xa = null, fi = !1, $f = !1, bo = null; function lb(w, _) { var R = $s(5, null, null, 0); R.elementType = "DELETED", R.stateNode = _, R.return = w, _ = w.deletions, _ === null ? (w.deletions = [R], w.flags |= 16) : _.push(R) } function cb(w, _) { switch (w.tag) { case 5: return _ = Tr(_, w.type, w.pendingProps), _ !== null ? (w.stateNode = _, es = w, xa = Hn(_), !0) : !1; case 6: return _ = Ua(_, w.pendingProps), _ !== null ? (w.stateNode = _, es = w, xa = null, !0) : !1; case 13: if (_ = Vr(_), _ !== null) { var R = dd !== null ? { id: nc, overflow: rc } : null; return w.memoizedState = { dehydrated: _, treeContext: R, retryLane: 1073741824 }, R = $s(18, null, null, 0), R.stateNode = _, R.return = w, w.child = R, es = w, xa = null, !0 } return !1; default: return !1 } } function mv(w) { return (w.mode & 1) !== 0 && (w.flags & 128) === 0 } function ru(w) { if (fi) { var _ = xa; if (_) { var R = _; if (!cb(w, _)) { if (mv(w)) throw Error(s(418)); _ = Zi(R); var L = es; _ && cb(w, _) ? lb(L, R) : (w.flags = w.flags & -4097 | 2, fi = !1, es = w) } } else { if (mv(w)) throw Error(s(418)); w.flags = w.flags & -4097 | 2, fi = !1, es = w } } } function K_(w) { for (w = w.return; w !== null && w.tag !== 5 && w.tag !== 3 && w.tag !== 13;)w = w.return; es = w } function Fp(w) { if (!oe || w !== es) return !1; if (!fi) return K_(w), fi = !0, !1; if (w.tag !== 3 && (w.tag !== 5 || ye(w.type) && !be(w.type, w.memoizedProps))) { var _ = xa; if (_) { if (mv(w)) { for (w = xa; w;)w = Zi(w); throw Error(s(418)) } for (; _;)lb(w, _), _ = Zi(_) } } if (K_(w), w.tag === 13) { if (!oe) throw Error(s(316)); if (w = w.memoizedState, w = w !== null ? w.dehydrated : null, !w) throw Error(s(317)); xa = He(w) } else xa = es ? Zi(w.stateNode) : null; return !0 } function zf() { oe && (xa = es = null, $f = fi = !1) } function gv(w) { bo === null ? bo = [w] : bo.push(w) } function Vf(w, _, R) { if (w = R.ref, w !== null && typeof w != "function" && typeof w != "object") { if (R._owner) { if (R = R._owner, R) { if (R.tag !== 1) throw Error(s(309)); var L = R.stateNode } if (!L) throw Error(s(147, w)); var H = L, J = "" + w; return _ !== null && _.ref !== null && typeof _.ref == "function" && _.ref._stringRef === J ? _.ref : (_ = function (ve) { var Oe = H.refs; Oe === G_ && (Oe = H.refs = {}), ve === null ? delete Oe[J] : Oe[J] = ve }, _._stringRef = J, _) } if (typeof w != "string") throw Error(s(284)); if (!R._owner) throw Error(s(290, w)) } return w } function iu(w, _) { throw w = Object.prototype.toString.call(_), Error(s(31, w === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : w)) } function Hf(w) { var _ = w._init; return _(w._payload) } function Z_(w) { function _(Ve, Le) { if (w) { var Ye = Ve.deletions; Ye === null ? (Ve.deletions = [Le], Ve.flags |= 16) : Ye.push(Le) } } function R(Ve, Le) { if (!w) return null; for (; Le !== null;)_(Ve, Le), Le = Le.sibling; return null } function L(Ve, Le) { for (Ve = new Map; Le !== null;)Le.key !== null ? Ve.set(Le.key, Le) : Ve.set(Le.index, Le), Le = Le.sibling; return Ve } function H(Ve, Le) { return Ve = vc(Ve, Le), Ve.index = 0, Ve.sibling = null, Ve } function J(Ve, Le, Ye) { return Ve.index = Ye, w ? (Ye = Ve.alternate, Ye !== null ? (Ye = Ye.index, Ye < Le ? (Ve.flags |= 2, Le) : Ye) : (Ve.flags |= 2, Le)) : (Ve.flags |= 1048576, Le) } function ve(Ve) { return w && Ve.alternate === null && (Ve.flags |= 2), Ve } function Oe(Ve, Le, Ye, Ht) { return Le === null || Le.tag !== 6 ? (Le = Vv(Ye, Ve.mode, Ht), Le.return = Ve, Le) : (Le = H(Le, Ye), Le.return = Ve, Le) } function tt(Ve, Le, Ye, Ht) { var gn = Ye.type; return gn === d ? an(Ve, Le, Ye.props.children, Ht, Ye.key) : Le !== null && (Le.elementType === gn || typeof gn == "object" && gn !== null && gn.$$typeof === M && Hf(gn) === Le.type) ? (Ht = H(Le, Ye.props), Ht.ref = Vf(Ve, Le, Ye), Ht.return = Ve, Ht) : (Ht = zv(Ye.type, Ye.key, Ye.props, null, Ve.mode, Ht), Ht.ref = Vf(Ve, Le, Ye), Ht.return = Ve, Ht) } function Ot(Ve, Le, Ye, Ht) { return Le === null || Le.tag !== 4 || Le.stateNode.containerInfo !== Ye.containerInfo || Le.stateNode.implementation !== Ye.implementation ? (Le = Hv(Ye, Ve.mode, Ht), Le.return = Ve, Le) : (Le = H(Le, Ye.children || []), Le.return = Ve, Le) } function an(Ve, Le, Ye, Ht, gn) { return Le === null || Le.tag !== 7 ? (Le = Id(Ye, Ve.mode, Ht, gn), Le.return = Ve, Le) : (Le = H(Le, Ye), Le.return = Ve, Le) } function Bn(Ve, Le, Ye) { if (typeof Le == "string" && Le !== "" || typeof Le == "number") return Le = Vv("" + Le, Ve.mode, Ye), Le.return = Ve, Le; if (typeof Le == "object" && Le !== null) { switch (Le.$$typeof) { case c: return Ye = zv(Le.type, Le.key, Le.props, null, Ve.mode, Ye), Ye.ref = Vf(Ve, null, Le), Ye.return = Ve, Ye; case u: return Le = Hv(Le, Ve.mode, Ye), Le.return = Ve, Le; case M: var Ht = Le._init; return Bn(Ve, Ht(Le._payload), Ye) }if (q(Le) || A(Le)) return Le = Id(Le, Ve.mode, Ye, null), Le.return = Ve, Le; iu(Ve, Le) } return null } function En(Ve, Le, Ye, Ht) { var gn = Le !== null ? Le.key : null; if (typeof Ye == "string" && Ye !== "" || typeof Ye == "number") return gn !== null ? null : Oe(Ve, Le, "" + Ye, Ht); if (typeof Ye == "object" && Ye !== null) { switch (Ye.$$typeof) { case c: return Ye.key === gn ? tt(Ve, Le, Ye, Ht) : null; case u: return Ye.key === gn ? Ot(Ve, Le, Ye, Ht) : null; case M: return gn = Ye._init, En(Ve, Le, gn(Ye._payload), Ht) }if (q(Ye) || A(Ye)) return gn !== null ? null : an(Ve, Le, Ye, Ht, null); iu(Ve, Ye) } return null } function rr(Ve, Le, Ye, Ht, gn) { if (typeof Ht == "string" && Ht !== "" || typeof Ht == "number") return Ve = Ve.get(Ye) || null, Oe(Le, Ve, "" + Ht, gn); if (typeof Ht == "object" && Ht !== null) { switch (Ht.$$typeof) { case c: return Ve = Ve.get(Ht.key === null ? Ye : Ht.key) || null, tt(Le, Ve, Ht, gn); case u: return Ve = Ve.get(Ht.key === null ? Ye : Ht.key) || null, Ot(Le, Ve, Ht, gn); case M: var Wn = Ht._init; return rr(Ve, Le, Ye, Wn(Ht._payload), gn) }if (q(Ht) || A(Ht)) return Ve = Ve.get(Ye) || null, an(Le, Ve, Ht, gn, null); iu(Le, Ht) } return null } function Qt(Ve, Le, Ye, Ht) { for (var gn = null, Wn = null, $n = Le, _r = Le = 0, Hi = null; $n !== null && _r < Ye.length; _r++) { $n.index > _r ? (Hi = $n, $n = null) : Hi = $n.sibling; var br = En(Ve, $n, Ye[_r], Ht); if (br === null) { $n === null && ($n = Hi); break } w && $n && br.alternate === null && _(Ve, $n), Le = J(br, Le, _r), Wn === null ? gn = br : Wn.sibling = br, Wn = br, $n = Hi } if (_r === Ye.length) return R(Ve, $n), fi && fd(Ve, _r), gn; if ($n === null) { for (; _r < Ye.length; _r++)$n = Bn(Ve, Ye[_r], Ht), $n !== null && (Le = J($n, Le, _r), Wn === null ? gn = $n : Wn.sibling = $n, Wn = $n); return fi && fd(Ve, _r), gn } for ($n = L(Ve, $n); _r < Ye.length; _r++)Hi = rr($n, Ve, _r, Ye[_r], Ht), Hi !== null && (w && Hi.alternate !== null && $n.delete(Hi.key === null ? _r : Hi.key), Le = J(Hi, Le, _r), Wn === null ? gn = Hi : Wn.sibling = Hi, Wn = Hi); return w && $n.forEach(function (yc) { return _(Ve, yc) }), fi && fd(Ve, _r), gn } function Ea(Ve, Le, Ye, Ht) { var gn = A(Ye); if (typeof gn != "function") throw Error(s(150)); if (Ye = gn.call(Ye), Ye == null) throw Error(s(151)); for (var Wn = gn = null, $n = Le, _r = Le = 0, Hi = null, br = Ye.next(); $n !== null && !br.done; _r++, br = Ye.next()) { $n.index > _r ? (Hi = $n, $n = null) : Hi = $n.sibling; var yc = En(Ve, $n, br.value, Ht); if (yc === null) { $n === null && ($n = Hi); break } w && $n && yc.alternate === null && _(Ve, $n), Le = J(yc, Le, _r), Wn === null ? gn = yc : Wn.sibling = yc, Wn = yc, $n = Hi } if (br.done) return R(Ve, $n), fi && fd(Ve, _r), gn; if ($n === null) { for (; !br.done; _r++, br = Ye.next())br = Bn(Ve, br.value, Ht), br !== null && (Le = J(br, Le, _r), Wn === null ? gn = br : Wn.sibling = br, Wn = br); return fi && fd(Ve, _r), gn } for ($n = L(Ve, $n); !br.done; _r++, br = Ye.next())br = rr($n, Ve, _r, br.value, Ht), br !== null && (w && br.alternate !== null && $n.delete(br.key === null ? _r : br.key), Le = J(br, Le, _r), Wn === null ? gn = br : Wn.sibling = br, Wn = br); return w && $n.forEach(function (Bb) { return _(Ve, Bb) }), fi && fd(Ve, _r), gn } function zs(Ve, Le, Ye, Ht) { if (typeof Ye == "object" && Ye !== null && Ye.type === d && Ye.key === null && (Ye = Ye.props.children), typeof Ye == "object" && Ye !== null) { switch (Ye.$$typeof) { case c: e: { for (var gn = Ye.key, Wn = Le; Wn !== null;) { if (Wn.key === gn) { if (gn = Ye.type, gn === d) { if (Wn.tag === 7) { R(Ve, Wn.sibling), Le = H(Wn, Ye.props.children), Le.return = Ve, Ve = Le; break e } } else if (Wn.elementType === gn || typeof gn == "object" && gn !== null && gn.$$typeof === M && Hf(gn) === Wn.type) { R(Ve, Wn.sibling), Le = H(Wn, Ye.props), Le.ref = Vf(Ve, Wn, Ye), Le.return = Ve, Ve = Le; break e } R(Ve, Wn); break } else _(Ve, Wn); Wn = Wn.sibling } Ye.type === d ? (Le = Id(Ye.props.children, Ve.mode, Ht, Ye.key), Le.return = Ve, Ve = Le) : (Ht = zv(Ye.type, Ye.key, Ye.props, null, Ve.mode, Ht), Ht.ref = Vf(Ve, Le, Ye), Ht.return = Ve, Ve = Ht) } return ve(Ve); case u: e: { for (Wn = Ye.key; Le !== null;) { if (Le.key === Wn) if (Le.tag === 4 && Le.stateNode.containerInfo === Ye.containerInfo && Le.stateNode.implementation === Ye.implementation) { R(Ve, Le.sibling), Le = H(Le, Ye.children || []), Le.return = Ve, Ve = Le; break e } else { R(Ve, Le); break } else _(Ve, Le); Le = Le.sibling } Le = Hv(Ye, Ve.mode, Ht), Le.return = Ve, Ve = Le } return ve(Ve); case M: return Wn = Ye._init, zs(Ve, Le, Wn(Ye._payload), Ht) }if (q(Ye)) return Qt(Ve, Le, Ye, Ht); if (A(Ye)) return Ea(Ve, Le, Ye, Ht); iu(Ve, Ye) } return typeof Ye == "string" && Ye !== "" || typeof Ye == "number" ? (Ye = "" + Ye, Le !== null && Le.tag === 6 ? (R(Ve, Le.sibling), Le = H(Le, Ye), Le.return = Ve, Ve = Le) : (R(Ve, Le), Le = Vv(Ye, Ve.mode, Ht), Le.return = Ve, Ve = Le), ve(Ve)) : R(Ve, Le) } return zs } var ic = Z_(!0), Q_ = Z_(!1), Wf = {}, ms = Pt(Wf), hd = Pt(Wf), pd = Pt(Wf); function Wo(w) { if (w === Wf) throw Error(s(174)); return w } function vv(w, _) { Zt(pd, _), Zt(hd, w), Zt(ms, Wf), w = Z(_), kt(ms), Zt(ms, w) } function Gf() { kt(ms), kt(hd), kt(pd) } function J_(w) { var _ = Wo(pd.current), R = Wo(ms.current); _ = $(R, w.type, _), R !== _ && (Zt(hd, w), Zt(ms, _)) } function ub(w) { hd.current === w && (kt(ms), kt(hd)) } var Si = Pt(0); function yv(w) { for (var _ = w; _ !== null;) { if (_.tag === 13) { var R = _.memoizedState; if (R !== null && (R = R.dehydrated, R === null || zi(R) || po(R))) return _ } else if (_.tag === 19 && _.memoizedProps.revealOrder !== void 0) { if ((_.flags & 128) !== 0) return _ } else if (_.child !== null) { _.child.return = _, _ = _.child; continue } if (_ === w) break; for (; _.sibling === null;) { if (_.return === null || _.return === w) return null; _ = _.return } _.sibling.return = _.return, _ = _.sibling } return null } var Os = []; function md() { for (var w = 0; w < Os.length; w++) { var _ = Os[w]; Ae ? _._workInProgressVersionPrimary = null : _._workInProgressVersionSecondary = null } Os.length = 0 } var Up = o.ReactCurrentDispatcher, Ds = o.ReactCurrentBatchConfig, gd = 0, _i = null, la = null, ca = null, xv = !1, wl = !1, vd = 0, Bp = 0; function ua() { throw Error(s(321)) } function bv(w, _) { if (_ === null) return !1; for (var R = 0; R < _.length && R < w.length; R++)if (!Qa(w[R], _[R])) return !1; return !0 } function qf(w, _, R, L, H, J) { if (gd = J, _i = _, _.memoizedState = null, _.updateQueue = null, _.lanes = 0, Up.current = w === null || w.memoizedState === null ? gb : vb, w = R(L, H), wl) { J = 0; do { if (wl = !1, vd = 0, 25 <= J) throw Error(s(301)); J += 1, ca = la = null, _.updateQueue = null, Up.current = yb, w = R(L, H) } while (wl) } if (Up.current = Zf, _ = la !== null && la.next !== null, gd = 0, ca = la = _i = null, xv = !1, _) throw Error(s(300)); return w } function au() { var w = vd !== 0; return vd = 0, w } function Go() { var w = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return ca === null ? _i.memoizedState = ca = w : ca = ca.next = w, ca } function qo() { if (la === null) { var w = _i.alternate; w = w !== null ? w.memoizedState : null } else w = la.next; var _ = ca === null ? _i.memoizedState : ca.next; if (_ !== null) ca = _, la = w; else { if (w === null) throw Error(s(310)); la = w, w = { memoizedState: la.memoizedState, baseState: la.baseState, baseQueue: la.baseQueue, queue: la.queue, next: null }, ca === null ? _i.memoizedState = ca = w : ca = ca.next = w } return ca } function Sl(w, _) { return typeof _ == "function" ? _(w) : _ } function $p(w) { var _ = qo(), R = _.queue; if (R === null) throw Error(s(311)); R.lastRenderedReducer = w; var L = la, H = L.baseQueue, J = R.pending; if (J !== null) { if (H !== null) { var ve = H.next; H.next = J.next, J.next = ve } L.baseQueue = H = J, R.pending = null } if (H !== null) { J = H.next, L = L.baseState; var Oe = ve = null, tt = null, Ot = J; do { var an = Ot.lane; if ((gd & an) === an) tt !== null && (tt = tt.next = { lane: 0, action: Ot.action, hasEagerState: Ot.hasEagerState, eagerState: Ot.eagerState, next: null }), L = Ot.hasEagerState ? Ot.eagerState : w(L, Ot.action); else { var Bn = { lane: an, action: Ot.action, hasEagerState: Ot.hasEagerState, eagerState: Ot.eagerState, next: null }; tt === null ? (Oe = tt = Bn, ve = L) : tt = tt.next = Bn, _i.lanes |= an, El |= an } Ot = Ot.next } while (Ot !== null && Ot !== J); tt === null ? ve = L : tt.next = Oe, Qa(L, _.memoizedState) || (da = !0), _.memoizedState = L, _.baseState = ve, _.baseQueue = tt, R.lastRenderedState = L } if (w = R.interleaved, w !== null) { H = w; do J = H.lane, _i.lanes |= J, El |= J, H = H.next; while (H !== w) } else H === null && (R.lanes = 0); return [_.memoizedState, R.dispatch] } function zp(w) { var _ = qo(), R = _.queue; if (R === null) throw Error(s(311)); R.lastRenderedReducer = w; var L = R.dispatch, H = R.pending, J = _.memoizedState; if (H !== null) { R.pending = null; var ve = H = H.next; do J = w(J, ve.action), ve = ve.next; while (ve !== H); Qa(J, _.memoizedState) || (da = !0), _.memoizedState = J, _.baseQueue === null && (_.baseState = J), R.lastRenderedState = J } return [J, L] } function db() { } function fb(w, _) { var R = _i, L = qo(), H = _(), J = !Qa(L.memoizedState, H); if (J && (L.memoizedState = H, da = !0), L = L.queue, Xf(ac.bind(null, R, L, w), [w]), L.getSnapshot !== _ || J || ca !== null && ca.memoizedState.tag & 1) { if (R.flags |= 2048, Hp(9, pb.bind(null, R, L, H, _), void 0, null), Oi === null) throw Error(s(349)); (gd & 30) !== 0 || hb(R, _, H) } return H } function hb(w, _, R) { w.flags |= 16384, w = { getSnapshot: _, value: R }, _ = _i.updateQueue, _ === null ? (_ = { lastEffect: null, stores: null }, _i.updateQueue = _, _.stores = [w]) : (R = _.stores, R === null ? _.stores = [w] : R.push(w)) } function pb(w, _, R, L) { _.value = R, _.getSnapshot = L, wv(_) && za(w, 1, -1) } function ac(w, _, R) { return R(function () { wv(_) && za(w, 1, -1) }) } function wv(w) { var _ = w.getSnapshot; w = w.value; try { var R = _(); return !Qa(w, R) } catch { return !0 } } function Vp(w) { var _ = Go(); return typeof w == "function" && (w = w()), _.memoizedState = _.baseState = w, w = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Sl, lastRenderedState: w }, _.queue = w, w = w.dispatch = GP.bind(null, _i, w), [_.memoizedState, w] } function Hp(w, _, R, L) { return w = { tag: w, create: _, destroy: R, deps: L, next: null }, _ = _i.updateQueue, _ === null ? (_ = { lastEffect: null, stores: null }, _i.updateQueue = _, _.lastEffect = w.next = w) : (R = _.lastEffect, R === null ? _.lastEffect = w.next = w : (L = R.next, R.next = w, w.next = L, _.lastEffect = w)), w } function eE() { return qo().memoizedState } function su(w, _, R, L) { var H = Go(); _i.flags |= w, H.memoizedState = Hp(1 | _, R, void 0, L === void 0 ? null : L) } function Sv(w, _, R, L) { var H = qo(); L = L === void 0 ? null : L; var J = void 0; if (la !== null) { var ve = la.memoizedState; if (J = ve.destroy, L !== null && bv(L, ve.deps)) { H.memoizedState = Hp(_, R, J, L); return } } _i.flags |= w, H.memoizedState = Hp(1 | _, R, J, L) } function _v(w, _) { return su(8390656, 8, w, _) } function Xf(w, _) { return Sv(2048, 8, w, _) } function Kr(w, _) { return Sv(4, 2, w, _) } function Ev(w, _) { return Sv(4, 4, w, _) } function Wp(w, _) { if (typeof _ == "function") return w = w(), _(w), function () { _(null) }; if (_ != null) return w = w(), _.current = w, function () { _.current = null } } function Yf(w, _, R) { return R = R != null ? R.concat([w]) : null, Sv(4, 4, Wp.bind(null, _, w), R) } function Mv() { } function Tv(w, _) { var R = qo(); _ = _ === void 0 ? null : _; var L = R.memoizedState; return L !== null && _ !== null && bv(_, L[1]) ? L[0] : (R.memoizedState = [w, _], w) } function Kf(w, _) { var R = qo(); _ = _ === void 0 ? null : _; var L = R.memoizedState; return L !== null && _ !== null && bv(_, L[1]) ? L[0] : (w = w(), R.memoizedState = [w, _], w) } function Cv(w, _) { var R = sr; sr = R !== 0 && 4 > R ? R : 4, w(!0); var L = Ds.transition; Ds.transition = {}; try { w(!1), _() } finally { sr = R, Ds.transition = L } } function yd() { return qo().memoizedState } function tE(w, _, R) { var L = Zo(w); R = { lane: L, action: R, hasEagerState: !1, eagerState: null, next: null }, nE(w) ? mb(_, R) : (Gp(w, _, R), R = Cr(), w = za(w, L, R), w !== null && qp(w, _, L)) } function GP(w, _, R) { var L = Zo(w), H = { lane: L, action: R, hasEagerState: !1, eagerState: null, next: null }; if (nE(w)) mb(_, H); else { Gp(w, _, H); var J = w.alternate; if (w.lanes === 0 && (J === null || J.lanes === 0) && (J = _.lastRenderedReducer, J !== null)) try { var ve = _.lastRenderedState, Oe = J(ve, R); if (H.hasEagerState = !0, H.eagerState = Oe, Qa(Oe, ve)) return } catch { } finally { } R = Cr(), w = za(w, L, R), w !== null && qp(w, _, L) } } function nE(w) { var _ = w.alternate; return w === _i || _ !== null && _ === _i } function mb(w, _) { wl = xv = !0; var R = w.pending; R === null ? _.next = _ : (_.next = R.next, R.next = _), w.pending = _ } function Gp(w, _, R) { Oi !== null && (w.mode & 1) !== 0 && (Zn & 2) === 0 ? (w = _.interleaved, w === null ? (R.next = R, vo === null ? vo = [_] : vo.push(_)) : (R.next = w.next, w.next = R), _.interleaved = R) : (w = _.pending, w === null ? R.next = R : (R.next = w.next, w.next = R), _.pending = R) } function qp(w, _, R) { if ((R & 4194240) !== 0) { var L = _.lanes; L &= w.pendingLanes, R |= L, _.lanes = R, xl(w, R) } } var Zf = { readContext: ps, useCallback: ua, useContext: ua, useEffect: ua, useImperativeHandle: ua, useInsertionEffect: ua, useLayoutEffect: ua, useMemo: ua, useReducer: ua, useRef: ua, useState: ua, useDebugValue: ua, useDeferredValue: ua, useTransition: ua, useMutableSource: ua, useSyncExternalStore: ua, useId: ua, unstable_isNewReconciler: !1 }, gb = { readContext: ps, useCallback: function (w, _) { return Go().memoizedState = [w, _ === void 0 ? null : _], w }, useContext: ps, useEffect: _v, useImperativeHandle: function (w, _, R) { return R = R != null ? R.concat([w]) : null, su(4194308, 4, Wp.bind(null, _, w), R) }, useLayoutEffect: function (w, _) { return su(4194308, 4, w, _) }, useInsertionEffect: function (w, _) { return su(4, 2, w, _) }, useMemo: function (w, _) { var R = Go(); return _ = _ === void 0 ? null : _, w = w(), R.memoizedState = [w, _], w }, useReducer: function (w, _, R) { var L = Go(); return _ = R !== void 0 ? R(_) : _, L.memoizedState = L.baseState = _, w = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: w, lastRenderedState: _ }, L.queue = w, w = w.dispatch = tE.bind(null, _i, w), [L.memoizedState, w] }, useRef: function (w) { var _ = Go(); return w = { current: w }, _.memoizedState = w }, useState: Vp, useDebugValue: Mv, useDeferredValue: function (w) { var _ = Vp(w), R = _[0], L = _[1]; return _v(function () { var H = Ds.transition; Ds.transition = {}; try { L(w) } finally { Ds.transition = H } }, [w]), R }, useTransition: function () { var w = Vp(!1), _ = w[0]; return w = Cv.bind(null, w[1]), Go().memoizedState = w, [_, w] }, useMutableSource: function () { }, useSyncExternalStore: function (w, _, R) { var L = _i, H = Go(); if (fi) { if (R === void 0) throw Error(s(407)); R = R() } else { if (R = _(), Oi === null) throw Error(s(349)); (gd & 30) !== 0 || hb(L, _, R) } H.memoizedState = R; var J = { value: R, getSnapshot: _ }; return H.queue = J, _v(ac.bind(null, L, J, w), [w]), L.flags |= 2048, Hp(9, pb.bind(null, L, J, R, _), void 0, null), R }, useId: function () { var w = Go(), _ = Oi.identifierPrefix; if (fi) { var R = rc, L = nc; R = (L & ~(1 << 32 - ur(L) - 1)).toString(32) + R, _ = ":" + _ + "R" + R, R = vd++, 0 < R && (_ += "H" + R.toString(32)), _ += ":" } else R = Bp++, _ = ":" + _ + "r" + R.toString(32) + ":"; return w.memoizedState = _ }, unstable_isNewReconciler: !1 }, vb = { readContext: ps, useCallback: Tv, useContext: ps, useEffect: Xf, useImperativeHandle: Yf, useInsertionEffect: Kr, useLayoutEffect: Ev, useMemo: Kf, useReducer: $p, useRef: eE, useState: function () { return $p(Sl) }, useDebugValue: Mv, useDeferredValue: function (w) { var _ = $p(Sl), R = _[0], L = _[1]; return Xf(function () { var H = Ds.transition; Ds.transition = {}; try { L(w) } finally { Ds.transition = H } }, [w]), R }, useTransition: function () { var w = $p(Sl)[0], _ = qo().memoizedState; return [w, _] }, useMutableSource: db, useSyncExternalStore: fb, useId: yd, unstable_isNewReconciler: !1 }, yb = { readContext: ps, useCallback: Tv, useContext: ps, useEffect: Xf, useImperativeHandle: Yf, useInsertionEffect: Kr, useLayoutEffect: Ev, useMemo: Kf, useReducer: zp, useRef: eE, useState: function () { return zp(Sl) }, useDebugValue: Mv, useDeferredValue: function (w) { var _ = zp(Sl), R = _[0], L = _[1]; return Xf(function () { var H = Ds.transition; Ds.transition = {}; try { L(w) } finally { Ds.transition = H } }, [w]), R }, useTransition: function () { var w = zp(Sl)[0], _ = qo().memoizedState; return [w, _] }, useMutableSource: db, useSyncExternalStore: fb, useId: yd, unstable_isNewReconciler: !1 }; function xb(w, _) {
			try { var R = "", L = _; do R += tb(L), L = L.return; while (L); var H = R } catch (J) {
				H = `
Error generating stack: `+ J.message + `
`+ J.stack
			} return { value: w, source: _, stack: H }
		} function Nv(w, _) { try { console.error(_.value) } catch (R) { setTimeout(function () { throw R }) } } var qP = typeof WeakMap == "function" ? WeakMap : Map; function rE(w, _, R) { R = tc(-1, R), R.tag = 3, R.payload = { element: null }; var L = _.value; return R.callback = function () { rh || (rh = !0, ai = L), Nv(w, _) }, R } function Av(w, _, R) { R = tc(-1, R), R.tag = 3; var L = w.type.getDerivedStateFromError; if (typeof L == "function") { var H = _.value; R.payload = function () { return L(H) }, R.callback = function () { Nv(w, _) } } var J = w.stateNode; return J !== null && typeof J.componentDidCatch == "function" && (R.callback = function () { Nv(w, _), typeof L != "function" && (Ko === null ? Ko = new Set([this]) : Ko.add(this)); var ve = _.stack; this.componentDidCatch(_.value, { componentStack: ve !== null ? ve : "" }) }), R } function sc(w, _, R) { var L = w.pingCache; if (L === null) { L = w.pingCache = new qP; var H = new Set; L.set(_, H) } else H = L.get(_), H === void 0 && (H = new Set, L.set(_, H)); H.has(R) || (H.add(R), w = Lb.bind(null, w, _, R), _.then(w, w)) } function bb(w) { do { var _; if ((_ = w.tag === 13) && (_ = w.memoizedState, _ = _ !== null ? _.dehydrated !== null : !0), _) return w; w = w.return } while (w !== null); return null } function xd(w, _, R, L, H) { return (w.mode & 1) === 0 ? (w === _ ? w.flags |= 65536 : (w.flags |= 128, R.flags |= 131072, R.flags &= -52805, R.tag === 1 && (R.alternate === null ? R.tag = 17 : (_ = tc(-1, 1), _.tag = 2, tu(R, _))), R.lanes |= 1), w) : (w.flags |= 65536, w.lanes = H, w) } function Ji(w) { w.flags |= 4 } function Qf(w, _) { if (w !== null && w.child === _.child) return !0; if ((_.flags & 16) !== 0) return !1; for (w = _.child; w !== null;) { if ((w.flags & 12854) !== 0 || (w.subtreeFlags & 12854) !== 0) return !1; w = w.sibling } return !0 } var Ls, bd, Pv, jv; if (Ce) Ls = function (w, _) { for (var R = _.child; R !== null;) { if (R.tag === 5 || R.tag === 6) Q(w, R.stateNode); else if (R.tag !== 4 && R.child !== null) { R.child.return = R, R = R.child; continue } if (R === _) break; for (; R.sibling === null;) { if (R.return === null || R.return === _) return; R = R.return } R.sibling.return = R.return, R = R.sibling } }, bd = function () { }, Pv = function (w, _, R, L, H) { if (w = w.memoizedProps, w !== L) { var J = _.stateNode, ve = Wo(ms.current); R = ce(J, R, w, L, H, ve), (_.updateQueue = R) && Ji(_) } }, jv = function (w, _, R, L) { R !== L && Ji(_) }; else if (fe) { Ls = function (w, _, R, L) { for (var H = _.child; H !== null;) { if (H.tag === 5) { var J = H.stateNode; R && L && (J = wn(J, H.type, H.memoizedProps, H)), Q(w, J) } else if (H.tag === 6) J = H.stateNode, R && L && (J = wr(J, H.memoizedProps, H)), Q(w, J); else if (H.tag !== 4) { if (H.tag === 22 && H.memoizedState !== null) J = H.child, J !== null && (J.return = H), Ls(w, H, !0, !0); else if (H.child !== null) { H.child.return = H, H = H.child; continue } } if (H === _) break; for (; H.sibling === null;) { if (H.return === null || H.return === _) return; H = H.return } H.sibling.return = H.return, H = H.sibling } }; var ou = function (w, _, R, L) { for (var H = _.child; H !== null;) { if (H.tag === 5) { var J = H.stateNode; R && L && (J = wn(J, H.type, H.memoizedProps, H)), it(w, J) } else if (H.tag === 6) J = H.stateNode, R && L && (J = wr(J, H.memoizedProps, H)), it(w, J); else if (H.tag !== 4) { if (H.tag === 22 && H.memoizedState !== null) J = H.child, J !== null && (J.return = H), ou(w, H, !0, !0); else if (H.child !== null) { H.child.return = H, H = H.child; continue } } if (H === _) break; for (; H.sibling === null;) { if (H.return === null || H.return === _) return; H = H.return } H.sibling.return = H.return, H = H.sibling } }; bd = function (w, _) { var R = _.stateNode; if (!Qf(w, _)) { w = R.containerInfo; var L = ot(w); ou(L, _, !1, !1), R.pendingChildren = L, Ji(_), Ft(w, L) } }, Pv = function (w, _, R, L, H) { var J = w.stateNode, ve = w.memoizedProps; if ((w = Qf(w, _)) && ve === L) _.stateNode = J; else { var Oe = _.stateNode, tt = Wo(ms.current), Ot = null; ve !== L && (Ot = ce(Oe, R, ve, L, H, tt)), w && Ot === null ? _.stateNode = J : (J = mt(J, Ot, R, ve, L, _, w, Oe), re(J, R, L, H, tt) && Ji(_), _.stateNode = J, w ? Ji(_) : Ls(J, _, !1, !1)) } }, jv = function (w, _, R, L) { R !== L ? (w = Wo(pd.current), R = Wo(ms.current), _.stateNode = de(L, w, R, _), Ji(_)) : _.stateNode = w.stateNode } } else bd = function () { }, Pv = function () { }, jv = function () { }; function oc(w, _) { if (!fi) switch (w.tailMode) { case "hidden": _ = w.tail; for (var R = null; _ !== null;)_.alternate !== null && (R = _), _ = _.sibling; R === null ? w.tail = null : R.sibling = null; break; case "collapsed": R = w.tail; for (var L = null; R !== null;)R.alternate !== null && (L = R), R = R.sibling; L === null ? _ || w.tail === null ? w.tail = null : w.tail.sibling = null : L.sibling = null } } function Ii(w) { var _ = w.alternate !== null && w.alternate.child === w.child, R = 0, L = 0; if (_) for (var H = w.child; H !== null;)R |= H.lanes | H.childLanes, L |= H.subtreeFlags & 14680064, L |= H.flags & 14680064, H.return = w, H = H.sibling; else for (H = w.child; H !== null;)R |= H.lanes | H.childLanes, L |= H.subtreeFlags, L |= H.flags, H.return = w, H = H.sibling; return w.subtreeFlags |= L, w.childLanes = R, _ } function Rv(w, _, R) { var L = _.pendingProps; switch (ob(_), _.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ii(_), null; case 1: return bn(_.type) && gr(), Ii(_), null; case 3: return L = _.stateNode, Gf(), kt(nn), kt(_n), md(), L.pendingContext && (L.context = L.pendingContext, L.pendingContext = null), (w === null || w.child === null) && (Fp(_) ? Ji(_) : w === null || w.memoizedState.isDehydrated && (_.flags & 256) === 0 || (_.flags |= 1024, bo !== null && (sm(bo), bo = null))), bd(w, _), Ii(_), null; case 5: ub(_), R = Wo(pd.current); var H = _.type; if (w !== null && _.stateNode != null) Pv(w, _, H, L, R), w.ref !== _.ref && (_.flags |= 512, _.flags |= 2097152); else { if (!L) { if (_.stateNode === null) throw Error(s(166)); return Ii(_), null } if (w = Wo(ms.current), Fp(_)) { if (!oe) throw Error(s(175)); w = ie(_.stateNode, _.type, _.memoizedProps, R, w, _, !$f), _.updateQueue = w, w !== null && Ji(_) } else { var J = X(H, L, R, w, _); Ls(J, _, !1, !1), _.stateNode = J, re(J, H, L, R, w) && Ji(_) } _.ref !== null && (_.flags |= 512, _.flags |= 2097152) } return Ii(_), null; case 6: if (w && _.stateNode != null) jv(w, _, w.memoizedProps, L); else { if (typeof L != "string" && _.stateNode === null) throw Error(s(166)); if (w = Wo(pd.current), R = Wo(ms.current), Fp(_)) { if (!oe) throw Error(s(176)); if (w = _.stateNode, L = _.memoizedProps, (R = ue(w, L, _, !$f)) && (H = es, H !== null)) switch (J = (H.mode & 1) !== 0, H.tag) { case 3: Me(H.stateNode.containerInfo, w, L, J); break; case 5: Te(H.type, H.memoizedProps, H.stateNode, w, L, J) }R && Ji(_) } else _.stateNode = de(L, w, R, _) } return Ii(_), null; case 13: if (kt(Si), L = _.memoizedState, fi && xa !== null && (_.mode & 1) !== 0 && (_.flags & 128) === 0) { for (w = xa; w;)w = Zi(w); return zf(), _.flags |= 98560, _ } if (L !== null && L.dehydrated !== null) { if (L = Fp(_), w === null) { if (!L) throw Error(s(318)); if (!oe) throw Error(s(344)); if (w = _.memoizedState, w = w !== null ? w.dehydrated : null, !w) throw Error(s(317)); Ne(w, _) } else zf(), (_.flags & 128) === 0 && (_.memoizedState = null), _.flags |= 4; return Ii(_), null } return bo !== null && (sm(bo), bo = null), (_.flags & 128) !== 0 ? (_.lanes = R, _) : (L = L !== null, R = !1, w === null ? Fp(_) : R = w.memoizedState !== null, L && !R && (_.child.flags |= 8192, (_.mode & 1) !== 0 && (w === null || (Si.current & 1) !== 0 ? Ai === 0 && (Ai = 3) : Uv())), _.updateQueue !== null && (_.flags |= 4), Ii(_), null); case 4: return Gf(), bd(w, _), w === null && _e(_.stateNode.containerInfo), Ii(_), null; case 10: return Lp(_.type._context), Ii(_), null; case 17: return bn(_.type) && gr(), Ii(_), null; case 19: if (kt(Si), H = _.memoizedState, H === null) return Ii(_), null; if (L = (_.flags & 128) !== 0, J = H.rendering, J === null) if (L) oc(H, !1); else { if (Ai !== 0 || w !== null && (w.flags & 128) !== 0) for (w = _.child; w !== null;) { if (J = yv(w), J !== null) { for (_.flags |= 128, oc(H, !1), w = J.updateQueue, w !== null && (_.updateQueue = w, _.flags |= 4), _.subtreeFlags = 0, w = R, L = _.child; L !== null;)R = L, H = w, R.flags &= 14680066, J = R.alternate, J === null ? (R.childLanes = 0, R.lanes = H, R.child = null, R.subtreeFlags = 0, R.memoizedProps = null, R.memoizedState = null, R.updateQueue = null, R.dependencies = null, R.stateNode = null) : (R.childLanes = J.childLanes, R.lanes = J.lanes, R.child = J.child, R.subtreeFlags = 0, R.deletions = null, R.memoizedProps = J.memoizedProps, R.memoizedState = J.memoizedState, R.updateQueue = J.updateQueue, R.type = J.type, H = J.dependencies, R.dependencies = H === null ? null : { lanes: H.lanes, firstContext: H.firstContext }), L = L.sibling; return Zt(Si, Si.current & 1 | 2), _.child } w = w.sibling } H.tail !== null && Qi() > uu && (_.flags |= 128, L = !0, oc(H, !1), _.lanes = 4194304) } else { if (!L) if (w = yv(J), w !== null) { if (_.flags |= 128, L = !0, w = w.updateQueue, w !== null && (_.updateQueue = w, _.flags |= 4), oc(H, !0), H.tail === null && H.tailMode === "hidden" && !J.alternate && !fi) return Ii(_), null } else 2 * Qi() - H.renderingStartTime > uu && R !== 1073741824 && (_.flags |= 128, L = !0, oc(H, !1), _.lanes = 4194304); H.isBackwards ? (J.sibling = _.child, _.child = J) : (w = H.last, w !== null ? w.sibling = J : _.child = J, H.last = J) } return H.tail !== null ? (_ = H.tail, H.rendering = _, H.tail = _.sibling, H.renderingStartTime = Qi(), _.sibling = null, w = Si.current, Zt(Si, L ? w & 1 | 2 : w & 1), _) : (Ii(_), null); case 22: case 23: return om(), L = _.memoizedState !== null, w !== null && w.memoizedState !== null !== L && (_.flags |= 8192), L && (_.mode & 1) !== 0 ? ($a & 1073741824) !== 0 && (Ii(_), Ce && _.subtreeFlags & 6 && (_.flags |= 8192)) : Ii(_), null; case 24: return null; case 25: return null }throw Error(s(156, _.tag)) } var wb = o.ReactCurrentOwner, da = !1; function Ni(w, _, R, L) { _.child = w === null ? Q_(_, null, R, L) : ic(_, w.child, R, L) } function Zr(w, _, R, L, H) { R = R.render; var J = _.ref; return Ff(_, H), L = qf(w, _, R, L, J, H), R = au(), w !== null && !da ? (_.updateQueue = w.updateQueue, _.flags &= -2053, w.lanes &= ~H, gs(w, _, H)) : (fi && R && sb(_), _.flags |= 1, Ni(w, _, L, H), _.child) } function Hr(w, _, R, L, H) { if (w === null) { var J = R.type; return typeof J == "function" && !$v(J) && J.defaultProps === void 0 && R.compare === null && R.defaultProps === void 0 ? (_.tag = 15, _.type = J, lc(w, _, J, L, H)) : (w = zv(R.type, null, L, _, _.mode, H), w.ref = _.ref, w.return = _, _.child = w) } if (J = w.child, (w.lanes & H) === 0) { var ve = J.memoizedProps; if (R = R.compare, R = R !== null ? R : Ho, R(ve, L) && w.ref === _.ref) return gs(w, _, H) } return _.flags |= 1, w = vc(J, L), w.ref = _.ref, w.return = _, _.child = w } function lc(w, _, R, L, H) { if (w !== null && Ho(w.memoizedProps, L) && w.ref === _.ref) if (da = !1, (w.lanes & H) !== 0) (w.flags & 131072) !== 0 && (da = !0); else return _.lanes = w.lanes, gs(w, _, H); return cc(w, _, R, L, H) } function ba(w, _, R) { var L = _.pendingProps, H = L.children, J = w !== null ? w.memoizedState : null; if (L.mode === "hidden") if ((_.mode & 1) === 0) _.memoizedState = { baseLanes: 0, cachePool: null }, Zt(Ad, $a), $a |= R; else if ((R & 1073741824) !== 0) _.memoizedState = { baseLanes: 0, cachePool: null }, L = J !== null ? J.baseLanes : R, Zt(Ad, $a), $a |= L; else return w = J !== null ? J.baseLanes | R : R, _.lanes = _.childLanes = 1073741824, _.memoizedState = { baseLanes: w, cachePool: null }, _.updateQueue = null, Zt(Ad, $a), $a |= w, null; else J !== null ? (L = J.baseLanes | R, _.memoizedState = null) : L = R, Zt(Ad, $a), $a |= L; return Ni(w, _, H, R), _.child } function ts(w, _) { var R = _.ref; (w === null && R !== null || w !== null && w.ref !== R) && (_.flags |= 512, _.flags |= 2097152) } function cc(w, _, R, L, H) { var J = bn(R) ? Vt : _n.current; return J = Vn(_, J), Ff(_, H), R = qf(w, _, R, L, J, H), L = au(), w !== null && !da ? (_.updateQueue = w.updateQueue, _.flags &= -2053, w.lanes &= ~H, gs(w, _, H)) : (fi && L && sb(_), _.flags |= 1, Ni(w, _, R, H), _.child) } function wd(w, _, R, L, H) { if (bn(R)) { var J = !0; vr(_) } else J = !1; if (Ff(_, H), _.stateNode === null) w !== null && (w.alternate = null, _.alternate = null, _.flags |= 2), q_(_, R, L), ab(_, R, L, H), L = !0; else if (w === null) { var ve = _.stateNode, Oe = _.memoizedProps; ve.props = Oe; var tt = ve.context, Ot = R.contextType; typeof Ot == "object" && Ot !== null ? Ot = ps(Ot) : (Ot = bn(R) ? Vt : _n.current, Ot = Vn(_, Ot)); var an = R.getDerivedStateFromProps, Bn = typeof an == "function" || typeof ve.getSnapshotBeforeUpdate == "function"; Bn || typeof ve.UNSAFE_componentWillReceiveProps != "function" && typeof ve.componentWillReceiveProps != "function" || (Oe !== L || tt !== Ot) && X_(_, ve, L, Ot), yo = !1; var En = _.memoizedState; ve.state = En, dv(_, L, ve, H), tt = _.memoizedState, Oe !== L || En !== tt || nn.current || yo ? (typeof an == "function" && (rb(_, R, an, L), tt = _.memoizedState), (Oe = yo || ib(_, R, Oe, L, En, tt, Ot)) ? (Bn || typeof ve.UNSAFE_componentWillMount != "function" && typeof ve.componentWillMount != "function" || (typeof ve.componentWillMount == "function" && ve.componentWillMount(), typeof ve.UNSAFE_componentWillMount == "function" && ve.UNSAFE_componentWillMount()), typeof ve.componentDidMount == "function" && (_.flags |= 4194308)) : (typeof ve.componentDidMount == "function" && (_.flags |= 4194308), _.memoizedProps = L, _.memoizedState = tt), ve.props = L, ve.state = tt, ve.context = Ot, L = Oe) : (typeof ve.componentDidMount == "function" && (_.flags |= 4194308), L = !1) } else { ve = _.stateNode, nb(w, _), Oe = _.memoizedProps, Ot = _.type === _.elementType ? Oe : hs(_.type, Oe), ve.props = Ot, Bn = _.pendingProps, En = ve.context, tt = R.contextType, typeof tt == "object" && tt !== null ? tt = ps(tt) : (tt = bn(R) ? Vt : _n.current, tt = Vn(_, tt)); var rr = R.getDerivedStateFromProps; (an = typeof rr == "function" || typeof ve.getSnapshotBeforeUpdate == "function") || typeof ve.UNSAFE_componentWillReceiveProps != "function" && typeof ve.componentWillReceiveProps != "function" || (Oe !== Bn || En !== tt) && X_(_, ve, L, tt), yo = !1, En = _.memoizedState, ve.state = En, dv(_, L, ve, H); var Qt = _.memoizedState; Oe !== Bn || En !== Qt || nn.current || yo ? (typeof rr == "function" && (rb(_, R, rr, L), Qt = _.memoizedState), (Ot = yo || ib(_, R, Ot, L, En, Qt, tt) || !1) ? (an || typeof ve.UNSAFE_componentWillUpdate != "function" && typeof ve.componentWillUpdate != "function" || (typeof ve.componentWillUpdate == "function" && ve.componentWillUpdate(L, Qt, tt), typeof ve.UNSAFE_componentWillUpdate == "function" && ve.UNSAFE_componentWillUpdate(L, Qt, tt)), typeof ve.componentDidUpdate == "function" && (_.flags |= 4), typeof ve.getSnapshotBeforeUpdate == "function" && (_.flags |= 1024)) : (typeof ve.componentDidUpdate != "function" || Oe === w.memoizedProps && En === w.memoizedState || (_.flags |= 4), typeof ve.getSnapshotBeforeUpdate != "function" || Oe === w.memoizedProps && En === w.memoizedState || (_.flags |= 1024), _.memoizedProps = L, _.memoizedState = Qt), ve.props = L, ve.state = Qt, ve.context = tt, L = Ot) : (typeof ve.componentDidUpdate != "function" || Oe === w.memoizedProps && En === w.memoizedState || (_.flags |= 4), typeof ve.getSnapshotBeforeUpdate != "function" || Oe === w.memoizedProps && En === w.memoizedState || (_.flags |= 1024), L = !1) } return Ba(w, _, R, L, J, H) } function Ba(w, _, R, L, H, J) { ts(w, _); var ve = (_.flags & 128) !== 0; if (!L && !ve) return H && yn(_, R, !1), gs(w, _, J); L = _.stateNode, wb.current = _; var Oe = ve && typeof R.getDerivedStateFromError != "function" ? null : L.render(); return _.flags |= 1, w !== null && ve ? (_.child = ic(_, w.child, null, J), _.child = ic(_, null, Oe, J)) : Ni(w, _, Oe, J), _.memoizedState = L.state, H && yn(_, R, !0), _.child } function Xp(w) { var _ = w.stateNode; _.pendingContext ? tr(w, _.pendingContext, _.pendingContext !== _.context) : _.context && tr(w, _.context, !1), vv(w, _.containerInfo) } function Sb(w, _, R, L, H) { return zf(), gv(H), _.flags |= 256, Ni(w, _, R, L), _.child } var Yp = { dehydrated: null, treeContext: null, retryLane: 0 }; function Sd(w) { return { baseLanes: w, cachePool: null } } function _b(w, _, R) { var L = _.pendingProps, H = Si.current, J = !1, ve = (_.flags & 128) !== 0, Oe; if ((Oe = ve) || (Oe = w !== null && w.memoizedState === null ? !1 : (H & 2) !== 0), Oe ? (J = !0, _.flags &= -129) : (w === null || w.memoizedState !== null) && (H |= 1), Zt(Si, H & 1), w === null) return ru(_), w = _.memoizedState, w !== null && (w = w.dehydrated, w !== null) ? ((_.mode & 1) === 0 ? _.lanes = 1 : po(w) ? _.lanes = 8 : _.lanes = 1073741824, null) : (H = L.children, w = L.fallback, J ? (L = _.mode, J = _.child, H = { mode: "hidden", children: H }, (L & 1) === 0 && J !== null ? (J.childLanes = 0, J.pendingProps = H) : J = um(H, L, 0, null), w = Id(w, L, R, null), J.return = _, w.return = _, J.sibling = w, _.child = J, _.child.memoizedState = Sd(R), _.memoizedState = Yp, w) : Xo(_, H)); if (H = w.memoizedState, H !== null) { if (Oe = H.dehydrated, Oe !== null) { if (ve) return _.flags & 256 ? (_.flags &= -257, Zp(w, _, R, Error(s(422)))) : _.memoizedState !== null ? (_.child = w.child, _.flags |= 128, null) : (J = L.fallback, H = _.mode, L = um({ mode: "visible", children: L.children }, H, 0, null), J = Id(J, H, R, null), J.flags |= 2, L.return = _, J.return = _, L.sibling = J, _.child = L, (_.mode & 1) !== 0 && ic(_, w.child, null, R), _.child.memoizedState = Sd(R), _.memoizedState = Yp, J); if ((_.mode & 1) === 0) _ = Zp(w, _, R, null); else if (po(Oe)) _ = Zp(w, _, R, Error(s(419))); else if (L = (R & w.childLanes) !== 0, da || L) { if (L = Oi, L !== null) { switch (R & -R) { case 4: J = 2; break; case 16: J = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: J = 32; break; case 536870912: J = 268435456; break; default: J = 0 }L = (J & (L.suspendedLanes | R)) !== 0 ? 0 : J, L !== 0 && L !== H.retryLane && (H.retryLane = L, za(w, L, -1)) } Uv(), _ = Zp(w, _, R, Error(s(421))) } else zi(Oe) ? (_.flags |= 128, _.child = w.child, _ = lE.bind(null, w), ks(Oe, _), _ = null) : (R = H.treeContext, oe && (xa = Of(Oe), es = _, fi = !0, bo = null, $f = !1, R !== null && (xo[Is++] = nc, xo[Is++] = rc, xo[Is++] = dd, nc = R.id, rc = R.overflow, dd = _)), _ = Xo(_, _.pendingProps.children), _.flags |= 4096); return _ } return J ? (L = kv(w, _, L.children, L.fallback, R), J = _.child, H = w.child.memoizedState, J.memoizedState = H === null ? Sd(R) : { baseLanes: H.baseLanes | R, cachePool: null }, J.childLanes = w.childLanes & ~R, _.memoizedState = Yp, L) : (R = Kp(w, _, L.children, R), _.memoizedState = null, R) } return J ? (L = kv(w, _, L.children, L.fallback, R), J = _.child, H = w.child.memoizedState, J.memoizedState = H === null ? Sd(R) : { baseLanes: H.baseLanes | R, cachePool: null }, J.childLanes = w.childLanes & ~R, _.memoizedState = Yp, L) : (R = Kp(w, _, L.children, R), _.memoizedState = null, R) } function Xo(w, _) { return _ = um({ mode: "visible", children: _ }, w.mode, 0, null), _.return = w, w.child = _ } function Kp(w, _, R, L) { var H = w.child; return w = H.sibling, R = vc(H, { mode: "visible", children: R }), (_.mode & 1) === 0 && (R.lanes = L), R.return = _, R.sibling = null, w !== null && (L = _.deletions, L === null ? (_.deletions = [w], _.flags |= 16) : L.push(w)), _.child = R } function kv(w, _, R, L, H) { var J = _.mode; w = w.child; var ve = w.sibling, Oe = { mode: "hidden", children: R }; return (J & 1) === 0 && _.child !== w ? (R = _.child, R.childLanes = 0, R.pendingProps = Oe, _.deletions = null) : (R = vc(w, Oe), R.subtreeFlags = w.subtreeFlags & 14680064), ve !== null ? L = vc(ve, L) : (L = Id(L, J, H, null), L.flags |= 2), L.return = _, R.return = _, R.sibling = L, _.child = R, L } function Zp(w, _, R, L) { return L !== null && gv(L), ic(_, w.child, null, R), w = Xo(_, _.pendingProps.children), w.flags |= 2, _.memoizedState = null, w } function iE(w, _, R) { w.lanes |= _; var L = w.alternate; L !== null && (L.lanes |= _), ud(w.return, _, R) } function _l(w, _, R, L, H) { var J = w.memoizedState; J === null ? w.memoizedState = { isBackwards: _, rendering: null, renderingStartTime: 0, last: L, tail: R, tailMode: H } : (J.isBackwards = _, J.rendering = null, J.renderingStartTime = 0, J.last = L, J.tail = R, J.tailMode = H) } function _d(w, _, R) { var L = _.pendingProps, H = L.revealOrder, J = L.tail; if (Ni(w, _, L.children, R), L = Si.current, (L & 2) !== 0) L = L & 1 | 2, _.flags |= 128; else { if (w !== null && (w.flags & 128) !== 0) e: for (w = _.child; w !== null;) { if (w.tag === 13) w.memoizedState !== null && iE(w, R, _); else if (w.tag === 19) iE(w, R, _); else if (w.child !== null) { w.child.return = w, w = w.child; continue } if (w === _) break e; for (; w.sibling === null;) { if (w.return === null || w.return === _) break e; w = w.return } w.sibling.return = w.return, w = w.sibling } L &= 1 } if (Zt(Si, L), (_.mode & 1) === 0) _.memoizedState = null; else switch (H) { case "forwards": for (R = _.child, H = null; R !== null;)w = R.alternate, w !== null && yv(w) === null && (H = R), R = R.sibling; R = H, R === null ? (H = _.child, _.child = null) : (H = R.sibling, R.sibling = null), _l(_, !1, H, R, J); break; case "backwards": for (R = null, H = _.child, _.child = null; H !== null;) { if (w = H.alternate, w !== null && yv(w) === null) { _.child = H; break } w = H.sibling, H.sibling = R, R = H, H = w } _l(_, !0, R, null, J); break; case "together": _l(_, !1, null, null, void 0); break; default: _.memoizedState = null }return _.child } function gs(w, _, R) { if (w !== null && (_.dependencies = w.dependencies), El |= _.lanes, (R & _.childLanes) === 0) return null; if (w !== null && _.child !== w.child) throw Error(s(153)); if (_.child !== null) { for (w = _.child, R = vc(w, w.pendingProps), _.child = R, R.return = _; w.sibling !== null;)w = w.sibling, R = R.sibling = vc(w, w.pendingProps), R.return = _; R.sibling = null } return _.child } function Iv(w, _, R) { switch (_.tag) { case 3: Xp(_), zf(); break; case 5: J_(_); break; case 1: bn(_.type) && vr(_); break; case 4: vv(_, _.stateNode.containerInfo); break; case 10: cd(_, _.type._context, _.memoizedProps.value); break; case 13: var L = _.memoizedState; if (L !== null) return L.dehydrated !== null ? (Zt(Si, Si.current & 1), _.flags |= 128, null) : (R & _.child.childLanes) !== 0 ? _b(w, _, R) : (Zt(Si, Si.current & 1), w = gs(w, _, R), w !== null ? w.sibling : null); Zt(Si, Si.current & 1); break; case 19: if (L = (R & _.childLanes) !== 0, (w.flags & 128) !== 0) { if (L) return _d(w, _, R); _.flags |= 128 } var H = _.memoizedState; if (H !== null && (H.rendering = null, H.tail = null, H.lastEffect = null), Zt(Si, Si.current), L) break; return null; case 22: case 23: return _.lanes = 0, ba(w, _, R) }return gs(w, _, R) } function Ov(w, _) { switch (ob(_), _.tag) { case 1: return bn(_.type) && gr(), w = _.flags, w & 65536 ? (_.flags = w & -65537 | 128, _) : null; case 3: return Gf(), kt(nn), kt(_n), md(), w = _.flags, (w & 65536) !== 0 && (w & 128) === 0 ? (_.flags = w & -65537 | 128, _) : null; case 5: return ub(_), null; case 13: if (kt(Si), w = _.memoizedState, w !== null && w.dehydrated !== null) { if (_.alternate === null) throw Error(s(340)); zf() } return w = _.flags, w & 65536 ? (_.flags = w & -65537 | 128, _) : null; case 19: return kt(Si), null; case 4: return Gf(), null; case 10: return Lp(_.type._context), null; case 22: case 23: return om(), null; case 24: return null; default: return null } } var ns = !1, fa = !1, Ed = typeof WeakSet == "function" ? WeakSet : Set, zt = null; function wo(w, _) { var R = w.ref; if (R !== null) if (typeof R == "function") try { R(null) } catch (L) { is(w, _, L) } else R.current = null } function uc(w, _, R) { try { R() } catch (L) { is(w, _, L) } } var Eb = !1; function Mb(w, _) { for (V(w.containerInfo), zt = _; zt !== null;)if (w = zt, _ = w.child, (w.subtreeFlags & 1028) !== 0 && _ !== null) _.return = w, zt = _; else for (; zt !== null;) { w = zt; try { var R = w.alternate; if ((w.flags & 1024) !== 0) switch (w.tag) { case 0: case 11: case 15: break; case 1: if (R !== null) { var L = R.memoizedProps, H = R.memoizedState, J = w.stateNode, ve = J.getSnapshotBeforeUpdate(w.elementType === w.type ? L : hs(w.type, L), H); J.__reactInternalSnapshotBeforeUpdate = ve } break; case 3: Ce && Bt(w.stateNode.containerInfo); break; case 5: case 6: case 4: case 17: break; default: throw Error(s(163)) } } catch (Oe) { is(w, w.return, Oe) } if (_ = w.sibling, _ !== null) { _.return = w.return, zt = _; break } zt = w.return } return R = Eb, Eb = !1, R } function dc(w, _, R) { var L = _.updateQueue; if (L = L !== null ? L.lastEffect : null, L !== null) { var H = L = L.next; do { if ((H.tag & w) === w) { var J = H.destroy; H.destroy = void 0, J !== void 0 && uc(_, R, J) } H = H.next } while (H !== L) } } function wa(w, _) { if (_ = _.updateQueue, _ = _ !== null ? _.lastEffect : null, _ !== null) { var R = _ = _.next; do { if ((R.tag & w) === w) { var L = R.create; R.destroy = L() } R = R.next } while (R !== _) } } function rs(w) { var _ = w.ref; if (_ !== null) { var R = w.stateNode; switch (w.tag) { case 5: w = Y(R); break; default: w = R }typeof _ == "function" ? _(w) : _.current = w } } function ii(w, _, R) { if (bl && typeof bl.onCommitFiberUnmount == "function") try { bl.onCommitFiberUnmount(kp, _) } catch { } switch (_.tag) { case 0: case 11: case 14: case 15: if (w = _.updateQueue, w !== null && (w = w.lastEffect, w !== null)) { var L = w = w.next; do { var H = L, J = H.destroy; H = H.tag, J !== void 0 && ((H & 2) !== 0 || (H & 4) !== 0) && uc(_, R, J), L = L.next } while (L !== w) } break; case 1: if (wo(_, R), w = _.stateNode, typeof w.componentWillUnmount == "function") try { w.props = _.memoizedProps, w.state = _.memoizedState, w.componentWillUnmount() } catch (ve) { is(_, R, ve) } break; case 5: wo(_, R); break; case 4: Ce ? Nb(w, _, R) : fe && fe && (_ = _.stateNode.containerInfo, R = ot(_), un(_, R)) } } function So(w, _, R) { for (var L = _; ;)if (ii(w, L, R), L.child === null || Ce && L.tag === 4) { if (L === _) break; for (; L.sibling === null;) { if (L.return === null || L.return === _) return; L = L.return } L.sibling.return = L.return, L = L.sibling } else L.child.return = L, L = L.child } function Tb(w) { var _ = w.alternate; _ !== null && (w.alternate = null, Tb(_)), w.child = null, w.deletions = null, w.sibling = null, w.tag === 5 && (_ = w.stateNode, _ !== null && ke(_)), w.stateNode = null, w.return = null, w.dependencies = null, w.memoizedProps = null, w.memoizedState = null, w.pendingProps = null, w.stateNode = null, w.updateQueue = null } function Cb(w) { return w.tag === 5 || w.tag === 3 || w.tag === 4 } function Dv(w) { e: for (; ;) { for (; w.sibling === null;) { if (w.return === null || Cb(w.return)) return null; w = w.return } for (w.sibling.return = w.return, w = w.sibling; w.tag !== 5 && w.tag !== 6 && w.tag !== 18;) { if (w.flags & 2 || w.child === null || w.tag === 4) continue e; w.child.return = w, w = w.child } if (!(w.flags & 2)) return w.stateNode } } function Lv(w) { if (Ce) { e: { for (var _ = w.return; _ !== null;) { if (Cb(_)) break e; _ = _.return } throw Error(s(160)) } var R = _; switch (R.tag) { case 5: _ = R.stateNode, R.flags & 32 && (Fe(_), R.flags &= -33), R = Dv(w), Jf(w, R, _); break; case 3: case 4: _ = R.stateNode.containerInfo, R = Dv(w), Fv(w, R, _); break; default: throw Error(s(161)) } } } function Fv(w, _, R) { var L = w.tag; if (L === 5 || L === 6) w = w.stateNode, _ ? bt(R, w, _) : Xt(R, w); else if (L !== 4 && (w = w.child, w !== null)) for (Fv(w, _, R), w = w.sibling; w !== null;)Fv(w, _, R), w = w.sibling } function Jf(w, _, R) { var L = w.tag; if (L === 5 || L === 6) w = w.stateNode, _ ? pt(R, w, _) : Ge(R, w); else if (L !== 4 && (w = w.child, w !== null)) for (Jf(w, _, R), w = w.sibling; w !== null;)Jf(w, _, R), w = w.sibling } function Nb(w, _, R) { for (var L = _, H = !1, J, ve; ;) { if (!H) { H = L.return; e: for (; ;) { if (H === null) throw Error(s(160)); switch (J = H.stateNode, H.tag) { case 5: ve = !1; break e; case 3: J = J.containerInfo, ve = !0; break e; case 4: J = J.containerInfo, ve = !0; break e }H = H.return } H = !0 } if (L.tag === 5 || L.tag === 6) So(w, L, R), ve ? Se(J, L.stateNode) : pn(J, L.stateNode); else if (L.tag === 18) ve ? te(J, L.stateNode) : Nt(J, L.stateNode); else if (L.tag === 4) { if (L.child !== null) { J = L.stateNode.containerInfo, ve = !0, L.child.return = L, L = L.child; continue } } else if (ii(w, L, R), L.child !== null) { L.child.return = L, L = L.child; continue } if (L === _) break; for (; L.sibling === null;) { if (L.return === null || L.return === _) return; L = L.return, L.tag === 4 && (H = !1) } L.sibling.return = L.return, L = L.sibling } } function lu(w, _) { if (Ce) { switch (_.tag) { case 0: case 11: case 14: case 15: dc(3, _, _.return), wa(3, _), dc(5, _, _.return); return; case 1: return; case 5: var R = _.stateNode; if (R != null) { var L = _.memoizedProps; w = w !== null ? w.memoizedProps : L; var H = _.type, J = _.updateQueue; _.updateQueue = null, J !== null && en(R, J, H, w, L, _) } return; case 6: if (_.stateNode === null) throw Error(s(162)); R = _.memoizedProps, yt(_.stateNode, w !== null ? w.memoizedProps : R, R); return; case 3: oe && w !== null && w.memoizedState.isDehydrated && Qe(_.stateNode.containerInfo); return; case 12: return; case 13: eh(_); return; case 19: eh(_); return; case 17: return }throw Error(s(163)) } switch (_.tag) { case 0: case 11: case 14: case 15: dc(3, _, _.return), wa(3, _), dc(5, _, _.return); return; case 12: return; case 13: eh(_); return; case 19: eh(_); return; case 3: oe && w !== null && w.memoizedState.isDehydrated && Qe(_.stateNode.containerInfo); break; case 22: case 23: return }e: if (fe) { switch (_.tag) { case 1: case 5: case 6: break e; case 3: case 4: _ = _.stateNode, un(_.containerInfo, _.pendingChildren); break e }throw Error(s(163)) } } function eh(w) { var _ = w.updateQueue; if (_ !== null) { w.updateQueue = null; var R = w.stateNode; R === null && (R = w.stateNode = new Ed), _.forEach(function (L) { var H = cE.bind(null, w, L); R.has(L) || (R.add(L), L.then(H, H)) }) } } function XP(w, _) { for (zt = _; zt !== null;) { _ = zt; var R = _.deletions; if (R !== null) for (var L = 0; L < R.length; L++) { var H = R[L]; try { var J = w; Ce ? Nb(J, H, _) : So(J, H, _); var ve = H.alternate; ve !== null && (ve.return = null), H.return = null } catch (gn) { is(H, _, gn) } } if (R = _.child, (_.subtreeFlags & 12854) !== 0 && R !== null) R.return = _, zt = R; else for (; zt !== null;) { _ = zt; try { var Oe = _.flags; if (Oe & 32 && Ce && Fe(_.stateNode), Oe & 512) { var tt = _.alternate; if (tt !== null) { var Ot = tt.ref; Ot !== null && (typeof Ot == "function" ? Ot(null) : Ot.current = null) } } if (Oe & 8192) switch (_.tag) { case 13: if (_.memoizedState !== null) { var an = _.alternate; (an === null || an.memoizedState === null) && (im = Qi()) } break; case 22: var Bn = _.memoizedState !== null, En = _.alternate, rr = En !== null && En.memoizedState !== null; if (R = _, Ce) { e: if (L = R, H = Bn, J = null, Ce) for (var Qt = L; ;) { if (Qt.tag === 5) { if (J === null) { J = Qt; var Ea = Qt.stateNode; H ? ht(Ea) : De(Qt.stateNode, Qt.memoizedProps) } } else if (Qt.tag === 6) { if (J === null) { var zs = Qt.stateNode; H ? Ee(zs) : gt(zs, Qt.memoizedProps) } } else if ((Qt.tag !== 22 && Qt.tag !== 23 || Qt.memoizedState === null || Qt === L) && Qt.child !== null) { Qt.child.return = Qt, Qt = Qt.child; continue } if (Qt === L) break; for (; Qt.sibling === null;) { if (Qt.return === null || Qt.return === L) break e; J === Qt && (J = null), Qt = Qt.return } J === Qt && (J = null), Qt.sibling.return = Qt.return, Qt = Qt.sibling } } if (Bn && !rr && (R.mode & 1) !== 0) { zt = R; for (var Ve = R.child; Ve !== null;) { for (R = zt = Ve; zt !== null;) { L = zt; var Le = L.child; switch (L.tag) { case 0: case 11: case 14: case 15: dc(4, L, L.return); break; case 1: wo(L, L.return); var Ye = L.stateNode; if (typeof Ye.componentWillUnmount == "function") { var Ht = L.return; try { Ye.props = L.memoizedProps, Ye.state = L.memoizedState, Ye.componentWillUnmount() } catch (gn) { is(L, Ht, gn) } } break; case 5: wo(L, L.return); break; case 22: if (L.memoizedState !== null) { Pb(R); continue } }Le !== null ? (Le.return = L, zt = Le) : Pb(R) } Ve = Ve.sibling } } }switch (Oe & 4102) { case 2: Lv(_), _.flags &= -3; break; case 6: Lv(_), _.flags &= -3, lu(_.alternate, _); break; case 4096: _.flags &= -4097; break; case 4100: _.flags &= -4097, lu(_.alternate, _); break; case 4: lu(_.alternate, _) } } catch (gn) { is(_, _.return, gn) } if (R = _.sibling, R !== null) { R.return = _.return, zt = R; break } zt = _.return } } } function Qp(w, _, R) { zt = w, Jp(w) } function Jp(w, _, R) { for (var L = (w.mode & 1) !== 0; zt !== null;) { var H = zt, J = H.child; if (H.tag === 22 && L) { var ve = H.memoizedState !== null || ns; if (!ve) { var Oe = H.alternate, tt = Oe !== null && Oe.memoizedState !== null || fa; Oe = ns; var Ot = fa; if (ns = ve, (fa = tt) && !Ot) for (zt = H; zt !== null;)ve = zt, tt = ve.child, ve.tag === 22 && ve.memoizedState !== null ? Md(H) : tt !== null ? (tt.return = ve, zt = tt) : Md(H); for (; J !== null;)zt = J, Jp(J), J = J.sibling; zt = H, ns = Oe, fa = Ot } Ab(w) } else (H.subtreeFlags & 8772) !== 0 && J !== null ? (J.return = H, zt = J) : Ab(w) } } function Ab(w) { for (; zt !== null;) { var _ = zt; if ((_.flags & 8772) !== 0) { var R = _.alternate; try { if ((_.flags & 8772) !== 0) switch (_.tag) { case 0: case 11: case 15: fa || wa(5, _); break; case 1: var L = _.stateNode; if (_.flags & 4 && !fa) if (R === null) L.componentDidMount(); else { var H = _.elementType === _.type ? R.memoizedProps : hs(_.type, R.memoizedProps); L.componentDidUpdate(H, R.memoizedState, L.__reactInternalSnapshotBeforeUpdate) } var J = _.updateQueue; J !== null && W_(_, J, L); break; case 3: var ve = _.updateQueue; if (ve !== null) { if (R = null, _.child !== null) switch (_.child.tag) { case 5: R = Y(_.child.stateNode); break; case 1: R = _.child.stateNode }W_(_, ve, R) } break; case 5: var Oe = _.stateNode; R === null && _.flags & 4 && Yt(Oe, _.type, _.memoizedProps, _); break; case 6: break; case 4: break; case 12: break; case 13: if (oe && _.memoizedState === null) { var tt = _.alternate; if (tt !== null) { var Ot = tt.memoizedState; if (Ot !== null) { var an = Ot.dehydrated; an !== null && Je(an) } } } break; case 19: case 17: case 21: case 22: case 23: break; default: throw Error(s(163)) }fa || _.flags & 512 && rs(_) } catch (Bn) { is(_, _.return, Bn) } } if (_ === w) { zt = null; break } if (R = _.sibling, R !== null) { R.return = _.return, zt = R; break } zt = _.return } } function Pb(w) { for (; zt !== null;) { var _ = zt; if (_ === w) { zt = null; break } var R = _.sibling; if (R !== null) { R.return = _.return, zt = R; break } zt = _.return } } function Md(w) { for (; zt !== null;) { var _ = zt; try { switch (_.tag) { case 0: case 11: case 15: var R = _.return; try { wa(4, _) } catch (tt) { is(_, R, tt) } break; case 1: var L = _.stateNode; if (typeof L.componentDidMount == "function") { var H = _.return; try { L.componentDidMount() } catch (tt) { is(_, H, tt) } } var J = _.return; try { rs(_) } catch (tt) { is(_, J, tt) } break; case 5: var ve = _.return; try { rs(_) } catch (tt) { is(_, ve, tt) } } } catch (tt) { is(_, _.return, tt) } if (_ === w) { zt = null; break } var Oe = _.sibling; if (Oe !== null) { Oe.return = _.return, zt = Oe; break } zt = _.return } } var em = 0, Td = 1, Cd = 2, fc = 3, th = 4; if (typeof Symbol == "function" && Symbol.for) { var Nd = Symbol.for; em = Nd("selector.component"), Td = Nd("selector.has_pseudo_class"), Cd = Nd("selector.role"), fc = Nd("selector.test_id"), th = Nd("selector.text") } function tm(w) { var _ = xe(w); if (_ != null) { if (typeof _.memoizedProps["data-testname"] != "string") throw Error(s(364)); return _ } if (w = Tt(w), w === null) throw Error(s(362)); return w.stateNode.current } function nm(w, _) { switch (_.$$typeof) { case em: if (w.type === _.value) return !0; break; case Td: e: { _ = _.value, w = [w, 0]; for (var R = 0; R < w.length;) { var L = w[R++], H = w[R++], J = _[H]; if (L.tag !== 5 || !ne(L)) { for (; J != null && nm(L, J);)H++, J = _[H]; if (H === _.length) { _ = !0; break e } else for (L = L.child; L !== null;)w.push(L, H), L = L.sibling } } _ = !1 } return _; case Cd: if (w.tag === 5 && Re(w.stateNode, _.value)) return !0; break; case th: if ((w.tag === 5 || w.tag === 6) && (w = ee(w), w !== null && 0 <= w.indexOf(_.value))) return !0; break; case fc: if (w.tag === 5 && (w = w.memoizedProps["data-testname"], typeof w == "string" && w.toLowerCase() === _.value.toLowerCase())) return !0; break; default: throw Error(s(365)) }return !1 } function cu(w) { switch (w.$$typeof) { case em: return "<" + (j(w.value) || "Unknown") + ">"; case Td: return ":has(" + (cu(w) || "") + ")"; case Cd: return '[role="' + w.value + '"]'; case th: return '"' + w.value + '"'; case fc: return '[data-testname="' + w.value + '"]'; default: throw Error(s(365)) } } function Fs(w, _) { var R = []; w = [w, 0]; for (var L = 0; L < w.length;) { var H = w[L++], J = w[L++], ve = _[J]; if (H.tag !== 5 || !ne(H)) { for (; ve != null && nm(H, ve);)J++, ve = _[J]; if (J === _.length) R.push(H); else for (H = H.child; H !== null;)w.push(H, J), H = H.sibling } } return R } function hc(w, _) { if (!nt) throw Error(s(363)); w = tm(w), w = Fs(w, _), _ = [], w = Array.from(w); for (var R = 0; R < w.length;) { var L = w[R++]; if (L.tag === 5) ne(L) || _.push(L.stateNode); else for (L = L.child; L !== null;)w.push(L), L = L.sibling } return _ } var jb = Math.ceil, rm = o.ReactCurrentDispatcher, Yo = o.ReactCurrentOwner, Ur = o.ReactCurrentBatchConfig, Zn = 0, Oi = null, Br = null, hi = 0, $a = 0, Ad = Pt(0), Ai = 0, nh = null, El = 0, Us = 0, Pd = 0, pc = null, Vi = null, im = 0, uu = 1 / 0; function jd() { uu = Qi() + 500 } var rh = !1, ai = null, Ko = null, ih = !1, Ml = null, Rd = 0, kd = 0, mc = null, Qr = -1, Pi = 0; function Cr() { return (Zn & 6) !== 0 ? Qi() : Qr !== -1 ? Qr : Qr = Qi() } function Zo(w) { return (w.mode & 1) === 0 ? 1 : (Zn & 2) !== 0 && hi !== 0 ? hi & -hi : H_.transition !== null ? (Pi === 0 && (w = yl, yl <<= 1, (yl & 4194240) === 0 && (yl = 64), Pi = w), Pi) : (w = sr, w !== 0 ? w : je()) } function za(w, _, R) { if (50 < kd) throw kd = 0, mc = null, Error(s(185)); var L = du(w, _); return L === null ? null : (ad(L, _, R), ((Zn & 2) === 0 || L !== Oi) && (L === Oi && ((Zn & 2) === 0 && (Us |= _), Ai === 4 && _a(L, hi)), vs(L, R), _ === 1 && Zn === 0 && (w.mode & 1) === 0 && (jd(), av && go())), L) } function du(w, _) { w.lanes |= _; var R = w.alternate; for (R !== null && (R.lanes |= _), R = w, w = w.return; w !== null;)w.childLanes |= _, R = w.alternate, R !== null && (R.childLanes |= _), R = w, w = w.return; return R.tag === 3 ? R.stateNode : null } function vs(w, _) { var R = w.callbackNode; V_(w, _); var L = Rp(w, w === Oi ? hi : 0); if (L === 0) R !== null && Lf(R), w.callbackNode = null, w.callbackPriority = 0; else if (_ = L & -L, w.callbackPriority !== _) { if (R != null && Lf(R), _ === 1) w.tag === 0 ? ov(Bs.bind(null, w)) : sv(Bs.bind(null, w)), Ze ? Xe(function () { Zn === 0 && go() }) : sd(od, go), R = null; else { switch (Jl(L)) { case 1: R = od; break; case 4: R = WP; break; case 16: R = rv; break; case 536870912: R = iv; break; default: R = rv }R = Bv(R, Sa.bind(null, w)) } w.callbackPriority = _, w.callbackNode = R } } function Sa(w, _) { if (Qr = -1, Pi = 0, (Zn & 6) !== 0) throw Error(s(327)); var R = w.callbackNode; if (Tl() && w.callbackNode !== R) return null; var L = Rp(w, w === Oi ? hi : 0); if (L === 0) return null; if ((L & 30) !== 0 || (L & w.expiredLanes) !== 0 || _) _ = lm(w, L); else { _ = L; var H = Zn; Zn |= 2; var J = Ib(); (Oi !== w || hi !== _) && (jd(), gc(w, _)); do try { sE(); break } catch (Oe) { kb(w, Oe) } while (!0); Ja(), rm.current = J, Zn = H, Br !== null ? _ = 0 : (Oi = null, hi = 0, _ = Ai) } if (_ !== 0) { if (_ === 2 && (H = ev(w), H !== 0 && (L = H, _ = am(w, H))), _ === 1) throw R = nh, gc(w, 0), _a(w, L), vs(w, Qi()), R; if (_ === 6) _a(w, L); else { if (H = w.current.alternate, (L & 30) === 0 && !Rb(H) && (_ = lm(w, L), _ === 2 && (J = ev(w), J !== 0 && (L = J, _ = am(w, J))), _ === 1)) throw R = nh, gc(w, 0), _a(w, L), vs(w, Qi()), R; switch (w.finishedWork = H, w.finishedLanes = L, _) { case 0: case 1: throw Error(s(345)); case 2: Qo(w, Vi); break; case 3: if (_a(w, L), (L & 130023424) === L && (_ = im + 500 - Qi(), 10 < _)) { if (Rp(w, 0) !== 0) break; if (H = w.suspendedLanes, (H & L) !== L) { Cr(), w.pingedLanes |= w.suspendedLanes & H; break } w.timeoutHandle = ae(Qo.bind(null, w, Vi), _); break } Qo(w, Vi); break; case 4: if (_a(w, L), (L & 4194240) === L) break; for (_ = w.eventTimes, H = -1; 0 < L;) { var ve = 31 - ur(L); J = 1 << ve, ve = _[ve], ve > H && (H = ve), L &= ~J } if (L = H, L = Qi() - L, L = (120 > L ? 120 : 480 > L ? 480 : 1080 > L ? 1080 : 1920 > L ? 1920 : 3e3 > L ? 3e3 : 4320 > L ? 4320 : 1960 * jb(L / 1960)) - L, 10 < L) { w.timeoutHandle = ae(Qo.bind(null, w, Vi), L); break } Qo(w, Vi); break; case 5: Qo(w, Vi); break; default: throw Error(s(329)) } } } return vs(w, Qi()), w.callbackNode === R ? Sa.bind(null, w) : null } function am(w, _) { var R = pc; return w.current.memoizedState.isDehydrated && (gc(w, _).flags |= 256), w = lm(w, _), w !== 2 && (_ = Vi, Vi = R, _ !== null && sm(_)), w } function sm(w) { Vi === null ? Vi = w : Vi.push.apply(Vi, w) } function Rb(w) { for (var _ = w; ;) { if (_.flags & 16384) { var R = _.updateQueue; if (R !== null && (R = R.stores, R !== null)) for (var L = 0; L < R.length; L++) { var H = R[L], J = H.getSnapshot; H = H.value; try { if (!Qa(J(), H)) return !1 } catch { return !1 } } } if (R = _.child, _.subtreeFlags & 16384 && R !== null) R.return = _, _ = R; else { if (_ === w) break; for (; _.sibling === null;) { if (_.return === null || _.return === w) return !0; _ = _.return } _.sibling.return = _.return, _ = _.sibling } } return !0 } function _a(w, _) { for (_ &= ~Pd, _ &= ~Us, w.suspendedLanes |= _, w.pingedLanes &= ~_, w = w.expirationTimes; 0 < _;) { var R = 31 - ur(_), L = 1 << R; w[R] = -1, _ &= ~L } } function Bs(w) { if ((Zn & 6) !== 0) throw Error(s(327)); Tl(); var _ = Rp(w, 0); if ((_ & 1) === 0) return vs(w, Qi()), null; var R = lm(w, _); if (w.tag !== 0 && R === 2) { var L = ev(w); L !== 0 && (_ = L, R = am(w, L)) } if (R === 1) throw R = nh, gc(w, 0), _a(w, _), vs(w, Qi()), R; if (R === 6) throw Error(s(345)); return w.finishedWork = w.current.alternate, w.finishedLanes = _, Qo(w, Vi), vs(w, Qi()), null } function ah(w) { Ml !== null && Ml.tag === 0 && (Zn & 6) === 0 && Tl(); var _ = Zn; Zn |= 1; var R = Ur.transition, L = sr; try { if (Ur.transition = null, sr = 1, w) return w() } finally { sr = L, Ur.transition = R, Zn = _, (Zn & 6) === 0 && go() } } function om() { $a = Ad.current, kt(Ad) } function gc(w, _) { w.finishedWork = null, w.finishedLanes = 0; var R = w.timeoutHandle; if (R !== he && (w.timeoutHandle = he, se(R)), Br !== null) for (R = Br.return; R !== null;) { var L = R; switch (ob(L), L.tag) { case 1: L = L.type.childContextTypes, L != null && gr(); break; case 3: Gf(), kt(nn), kt(_n), md(); break; case 5: ub(L); break; case 4: Gf(); break; case 13: kt(Si); break; case 19: kt(Si); break; case 10: Lp(L.type._context); break; case 22: case 23: om() }R = R.return } if (Oi = w, Br = w = vc(w.current, null), hi = $a = _, Ai = 0, nh = null, Pd = Us = El = 0, Vi = pc = null, vo !== null) { for (_ = 0; _ < vo.length; _++)if (R = vo[_], L = R.interleaved, L !== null) { R.interleaved = null; var H = L.next, J = R.pending; if (J !== null) { var ve = J.next; J.next = H, L.next = ve } R.pending = L } vo = null } return w } function kb(w, _) { do { var R = Br; try { if (Ja(), Up.current = Zf, xv) { for (var L = _i.memoizedState; L !== null;) { var H = L.queue; H !== null && (H.pending = null), L = L.next } xv = !1 } if (gd = 0, ca = la = _i = null, wl = !1, vd = 0, Yo.current = null, R === null || R.return === null) { Ai = 1, nh = _, Br = null; break } e: { var J = w, ve = R.return, Oe = R, tt = _; if (_ = hi, Oe.flags |= 32768, tt !== null && typeof tt == "object" && typeof tt.then == "function") { var Ot = tt, an = Oe, Bn = an.tag; if ((an.mode & 1) === 0 && (Bn === 0 || Bn === 11 || Bn === 15)) { var En = an.alternate; En ? (an.updateQueue = En.updateQueue, an.memoizedState = En.memoizedState, an.lanes = En.lanes) : (an.updateQueue = null, an.memoizedState = null) } var rr = bb(ve); if (rr !== null) { rr.flags &= -257, xd(rr, ve, Oe, J, _), rr.mode & 1 && sc(J, Ot, _), _ = rr, tt = Ot; var Qt = _.updateQueue; if (Qt === null) { var Ea = new Set; Ea.add(tt), _.updateQueue = Ea } else Qt.add(tt); break e } else { if ((_ & 1) === 0) { sc(J, Ot, _), Uv(); break e } tt = Error(s(426)) } } else if (fi && Oe.mode & 1) { var zs = bb(ve); if (zs !== null) { (zs.flags & 65536) === 0 && (zs.flags |= 256), xd(zs, ve, Oe, J, _), gv(tt); break e } } J = tt, Ai !== 4 && (Ai = 2), pc === null ? pc = [J] : pc.push(J), tt = xb(tt, Oe), Oe = ve; do { switch (Oe.tag) { case 3: Oe.flags |= 65536, _ &= -_, Oe.lanes |= _; var Ve = rE(Oe, tt, _); uv(Oe, Ve); break e; case 1: J = tt; var Le = Oe.type, Ye = Oe.stateNode; if ((Oe.flags & 128) === 0 && (typeof Le.getDerivedStateFromError == "function" || Ye !== null && typeof Ye.componentDidCatch == "function" && (Ko === null || !Ko.has(Ye)))) { Oe.flags |= 65536, _ &= -_, Oe.lanes |= _; var Ht = Av(Oe, J, _); uv(Oe, Ht); break e } }Oe = Oe.return } while (Oe !== null) } Db(R) } catch (gn) { _ = gn, Br === R && R !== null && (Br = R = R.return); continue } break } while (!0) } function Ib() { var w = rm.current; return rm.current = Zf, w === null ? Zf : w } function Uv() { (Ai === 0 || Ai === 3 || Ai === 2) && (Ai = 4), Oi === null || (El & 268435455) === 0 && (Us & 268435455) === 0 || _a(Oi, hi) } function lm(w, _) { var R = Zn; Zn |= 2; var L = Ib(); Oi === w && hi === _ || gc(w, _); do try { aE(); break } catch (H) { kb(w, H) } while (!0); if (Ja(), Zn = R, rm.current = L, Br !== null) throw Error(s(261)); return Oi = null, hi = 0, Ai } function aE() { for (; Br !== null;)Ob(Br) } function sE() { for (; Br !== null && !eu();)Ob(Br) } function Ob(w) { var _ = Ub(w.alternate, w, $a); w.memoizedProps = w.pendingProps, _ === null ? Db(w) : Br = _, Yo.current = null } function Db(w) { var _ = w; do { var R = _.alternate; if (w = _.return, (_.flags & 32768) === 0) { if (R = Rv(R, _, $a), R !== null) { Br = R; return } } else { if (R = Ov(R, _), R !== null) { R.flags &= 32767, Br = R; return } if (w !== null) w.flags |= 32768, w.subtreeFlags = 0, w.deletions = null; else { Ai = 6, Br = null; return } } if (_ = _.sibling, _ !== null) { Br = _; return } Br = _ = w } while (_ !== null); Ai === 0 && (Ai = 5) } function Qo(w, _) { var R = sr, L = Ur.transition; try { Ur.transition = null, sr = 1, oE(w, _, R) } finally { Ur.transition = L, sr = R } return null } function oE(w, _, R) { do Tl(); while (Ml !== null); if ((Zn & 6) !== 0) throw Error(s(327)); var L = w.finishedWork, H = w.finishedLanes; if (L === null) return null; if (w.finishedWork = null, w.finishedLanes = 0, L === w.current) throw Error(s(177)); w.callbackNode = null, w.callbackPriority = 0; var J = L.lanes | L.childLanes; if (nv(w, J), w === Oi && (Br = Oi = null, hi = 0), (L.subtreeFlags & 2064) === 0 && (L.flags & 2064) === 0 || ih || (ih = !0, Bv(rv, function () { return Tl(), null })), J = (L.flags & 15990) !== 0, (L.subtreeFlags & 15990) !== 0 || J) { J = Ur.transition, Ur.transition = null; var ve = sr; sr = 1; var Oe = Zn; Zn |= 4, Yo.current = null, Mb(w, L), XP(w, L), K(w.containerInfo), w.current = L, Qp(L), HP(), Zn = Oe, sr = ve, Ur.transition = J } else w.current = L; if (ih && (ih = !1, Ml = w, Rd = H), J = w.pendingLanes, J === 0 && (Ko = null), Ip(L.stateNode), vs(w, Qi()), _ !== null) for (R = w.onRecoverableError, L = 0; L < _.length; L++)R(_[L]); if (rh) throw rh = !1, w = ai, ai = null, w; return (Rd & 1) !== 0 && w.tag !== 0 && Tl(), J = w.pendingLanes, (J & 1) !== 0 ? w === mc ? kd++ : (kd = 0, mc = w) : kd = 0, go(), null } function Tl() { if (Ml !== null) { var w = Jl(Rd), _ = Ur.transition, R = sr; try { if (Ur.transition = null, sr = 16 > w ? 16 : w, Ml === null) var L = !1; else { if (w = Ml, Ml = null, Rd = 0, (Zn & 6) !== 0) throw Error(s(331)); var H = Zn; for (Zn |= 4, zt = w.current; zt !== null;) { var J = zt, ve = J.child; if ((zt.flags & 16) !== 0) { var Oe = J.deletions; if (Oe !== null) { for (var tt = 0; tt < Oe.length; tt++) { var Ot = Oe[tt]; for (zt = Ot; zt !== null;) { var an = zt; switch (an.tag) { case 0: case 11: case 15: dc(8, an, J) }var Bn = an.child; if (Bn !== null) Bn.return = an, zt = Bn; else for (; zt !== null;) { an = zt; var En = an.sibling, rr = an.return; if (Tb(an), an === Ot) { zt = null; break } if (En !== null) { En.return = rr, zt = En; break } zt = rr } } } var Qt = J.alternate; if (Qt !== null) { var Ea = Qt.child; if (Ea !== null) { Qt.child = null; do { var zs = Ea.sibling; Ea.sibling = null, Ea = zs } while (Ea !== null) } } zt = J } } if ((J.subtreeFlags & 2064) !== 0 && ve !== null) ve.return = J, zt = ve; else e: for (; zt !== null;) { if (J = zt, (J.flags & 2048) !== 0) switch (J.tag) { case 0: case 11: case 15: dc(9, J, J.return) }var Ve = J.sibling; if (Ve !== null) { Ve.return = J.return, zt = Ve; break e } zt = J.return } } var Le = w.current; for (zt = Le; zt !== null;) { ve = zt; var Ye = ve.child; if ((ve.subtreeFlags & 2064) !== 0 && Ye !== null) Ye.return = ve, zt = Ye; else e: for (ve = Le; zt !== null;) { if (Oe = zt, (Oe.flags & 2048) !== 0) try { switch (Oe.tag) { case 0: case 11: case 15: wa(9, Oe) } } catch (gn) { is(Oe, Oe.return, gn) } if (Oe === ve) { zt = null; break e } var Ht = Oe.sibling; if (Ht !== null) { Ht.return = Oe.return, zt = Ht; break e } zt = Oe.return } } if (Zn = H, go(), bl && typeof bl.onPostCommitFiberRoot == "function") try { bl.onPostCommitFiberRoot(kp, w) } catch { } L = !0 } return L } finally { sr = R, Ur.transition = _ } } return !1 } function cm(w, _, R) { _ = xb(R, _), _ = rE(w, _, 1), tu(w, _), _ = Cr(), w = du(w, 1), w !== null && (ad(w, 1, _), vs(w, _)) } function is(w, _, R) { if (w.tag === 3) cm(w, w, R); else for (; _ !== null;) { if (_.tag === 3) { cm(_, w, R); break } else if (_.tag === 1) { var L = _.stateNode; if (typeof _.type.getDerivedStateFromError == "function" || typeof L.componentDidCatch == "function" && (Ko === null || !Ko.has(L))) { w = xb(R, w), w = Av(_, w, 1), tu(_, w), w = Cr(), _ = du(_, 1), _ !== null && (ad(_, 1, w), vs(_, w)); break } } _ = _.return } } function Lb(w, _, R) { var L = w.pingCache; L !== null && L.delete(_), _ = Cr(), w.pingedLanes |= w.suspendedLanes & R, Oi === w && (hi & R) === R && (Ai === 4 || Ai === 3 && (hi & 130023424) === hi && 500 > Qi() - im ? gc(w, 0) : Pd |= R), vs(w, _) } function Fb(w, _) { _ === 0 && ((w.mode & 1) === 0 ? _ = 1 : (_ = nr, nr <<= 1, (nr & 130023424) === 0 && (nr = 4194304))); var R = Cr(); w = du(w, _), w !== null && (ad(w, _, R), vs(w, R)) } function lE(w) { var _ = w.memoizedState, R = 0; _ !== null && (R = _.retryLane), Fb(w, R) } function cE(w, _) { var R = 0; switch (w.tag) { case 13: var L = w.stateNode, H = w.memoizedState; H !== null && (R = H.retryLane); break; case 19: L = w.stateNode; break; default: throw Error(s(314)) }L !== null && L.delete(_), Fb(w, R) } var Ub; Ub = function (w, _, R) { if (w !== null) if (w.memoizedProps !== _.pendingProps || nn.current) da = !0; else { if ((w.lanes & R) === 0 && (_.flags & 128) === 0) return da = !1, Iv(w, _, R); da = (w.flags & 131072) !== 0 } else da = !1, fi && (_.flags & 1048576) !== 0 && Y_(_, pv, _.index); switch (_.lanes = 0, _.tag) { case 2: var L = _.type; w !== null && (w.alternate = null, _.alternate = null, _.flags |= 2), w = _.pendingProps; var H = Vn(_, _n.current); Ff(_, R), H = qf(null, _, L, w, H, R); var J = au(); return _.flags |= 1, typeof H == "object" && H !== null && typeof H.render == "function" && H.$$typeof === void 0 ? (_.tag = 1, _.memoizedState = null, _.updateQueue = null, bn(L) ? (J = !0, vr(_)) : J = !1, _.memoizedState = H.state !== null && H.state !== void 0 ? H.state : null, Uf(_), H.updater = fv, _.stateNode = H, H._reactInternals = _, ab(_, L, w, R), _ = Ba(null, _, L, !0, J, R)) : (_.tag = 0, fi && J && sb(_), Ni(null, _, H, R), _ = _.child), _; case 16: L = _.elementType; e: { switch (w !== null && (w.alternate = null, _.alternate = null, _.flags |= 2), w = _.pendingProps, H = L._init, L = H(L._payload), _.type = L, H = _.tag = YP(L), w = hs(L, w), H) { case 0: _ = cc(null, _, L, w, R); break e; case 1: _ = wd(null, _, L, w, R); break e; case 11: _ = Zr(null, _, L, w, R); break e; case 14: _ = Hr(null, _, L, hs(L.type, w), R); break e }throw Error(s(306, L, "")) } return _; case 0: return L = _.type, H = _.pendingProps, H = _.elementType === L ? H : hs(L, H), cc(w, _, L, H, R); case 1: return L = _.type, H = _.pendingProps, H = _.elementType === L ? H : hs(L, H), wd(w, _, L, H, R); case 3: e: { if (Xp(_), w === null) throw Error(s(387)); L = _.pendingProps, J = _.memoizedState, H = J.element, nb(w, _), dv(_, L, null, R); var ve = _.memoizedState; if (L = ve.element, oe && J.isDehydrated) if (J = { element: L, isDehydrated: !1, cache: ve.cache, transitions: ve.transitions }, _.updateQueue.baseState = J, _.memoizedState = J, _.flags & 256) { H = Error(s(423)), _ = Sb(w, _, L, R, H); break e } else if (L !== H) { H = Error(s(424)), _ = Sb(w, _, L, R, H); break e } else for (oe && (xa = Ql(_.stateNode.containerInfo), es = _, fi = !0, bo = null, $f = !1), R = Q_(_, null, L, R), _.child = R; R;)R.flags = R.flags & -3 | 4096, R = R.sibling; else { if (zf(), L === H) { _ = gs(w, _, R); break e } Ni(w, _, L, R) } _ = _.child } return _; case 5: return J_(_), w === null && ru(_), L = _.type, H = _.pendingProps, J = w !== null ? w.memoizedProps : null, ve = H.children, be(L, H) ? ve = null : J !== null && be(L, J) && (_.flags |= 32), ts(w, _), Ni(w, _, ve, R), _.child; case 6: return w === null && ru(_), null; case 13: return _b(w, _, R); case 4: return vv(_, _.stateNode.containerInfo), L = _.pendingProps, w === null ? _.child = ic(_, null, L, R) : Ni(w, _, L, R), _.child; case 11: return L = _.type, H = _.pendingProps, H = _.elementType === L ? H : hs(L, H), Zr(w, _, L, H, R); case 7: return Ni(w, _, _.pendingProps, R), _.child; case 8: return Ni(w, _, _.pendingProps.children, R), _.child; case 12: return Ni(w, _, _.pendingProps.children, R), _.child; case 10: e: { if (L = _.type._context, H = _.pendingProps, J = _.memoizedProps, ve = H.value, cd(_, L, ve), J !== null) if (Qa(J.value, ve)) { if (J.children === H.children && !nn.current) { _ = gs(w, _, R); break e } } else for (J = _.child, J !== null && (J.return = _); J !== null;) { var Oe = J.dependencies; if (Oe !== null) { ve = J.child; for (var tt = Oe.firstContext; tt !== null;) { if (tt.context === L) { if (J.tag === 1) { tt = tc(-1, R & -R), tt.tag = 2; var Ot = J.updateQueue; if (Ot !== null) { Ot = Ot.shared; var an = Ot.pending; an === null ? tt.next = tt : (tt.next = an.next, an.next = tt), Ot.pending = tt } } J.lanes |= R, tt = J.alternate, tt !== null && (tt.lanes |= R), ud(J.return, R, _), Oe.lanes |= R; break } tt = tt.next } } else if (J.tag === 10) ve = J.type === _.type ? null : J.child; else if (J.tag === 18) { if (ve = J.return, ve === null) throw Error(s(341)); ve.lanes |= R, Oe = ve.alternate, Oe !== null && (Oe.lanes |= R), ud(ve, R, _), ve = J.sibling } else ve = J.child; if (ve !== null) ve.return = J; else for (ve = J; ve !== null;) { if (ve === _) { ve = null; break } if (J = ve.sibling, J !== null) { J.return = ve.return, ve = J; break } ve = ve.return } J = ve } Ni(w, _, H.children, R), _ = _.child } return _; case 9: return H = _.type, L = _.pendingProps.children, Ff(_, R), H = ps(H), L = L(H), _.flags |= 1, Ni(w, _, L, R), _.child; case 14: return L = _.type, H = hs(L, _.pendingProps), H = hs(L.type, H), Hr(w, _, L, H, R); case 15: return lc(w, _, _.type, _.pendingProps, R); case 17: return L = _.type, H = _.pendingProps, H = _.elementType === L ? H : hs(L, H), w !== null && (w.alternate = null, _.alternate = null, _.flags |= 2), _.tag = 1, bn(L) ? (w = !0, vr(_)) : w = !1, Ff(_, R), q_(_, L, H), ab(_, L, H, R), Ba(null, _, L, !0, w, R); case 19: return _d(w, _, R); case 22: return ba(w, _, R) }throw Error(s(156, _.tag)) }; function Bv(w, _) { return sd(w, _) } function uE(w, _, R, L) { this.tag = w, this.key = R, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = _, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = L, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function $s(w, _, R, L) { return new uE(w, _, R, L) } function $v(w) { return w = w.prototype, !(!w || !w.isReactComponent) } function YP(w) { if (typeof w == "function") return $v(w) ? 1 : 0; if (w != null) { if (w = w.$$typeof, w === x) return 11; if (w === E) return 14 } return 2 } function vc(w, _) { var R = w.alternate; return R === null ? (R = $s(w.tag, _, w.key, w.mode), R.elementType = w.elementType, R.type = w.type, R.stateNode = w.stateNode, R.alternate = w, w.alternate = R) : (R.pendingProps = _, R.type = w.type, R.flags = 0, R.subtreeFlags = 0, R.deletions = null), R.flags = w.flags & 14680064, R.childLanes = w.childLanes, R.lanes = w.lanes, R.child = w.child, R.memoizedProps = w.memoizedProps, R.memoizedState = w.memoizedState, R.updateQueue = w.updateQueue, _ = w.dependencies, R.dependencies = _ === null ? null : { lanes: _.lanes, firstContext: _.firstContext }, R.sibling = w.sibling, R.index = w.index, R.ref = w.ref, R } function zv(w, _, R, L, H, J) { var ve = 2; if (L = w, typeof w == "function") $v(w) && (ve = 1); else if (typeof w == "string") ve = 5; else e: switch (w) { case d: return Id(R.children, H, J, _); case f: ve = 8, H |= 8; break; case h: return w = $s(12, R, _, H | 2), w.elementType = h, w.lanes = J, w; case v: return w = $s(13, R, _, H), w.elementType = v, w.lanes = J, w; case b: return w = $s(19, R, _, H), w.elementType = b, w.lanes = J, w; case C: return um(R, H, J, _); default: if (typeof w == "object" && w !== null) switch (w.$$typeof) { case m: ve = 10; break e; case g: ve = 9; break e; case x: ve = 11; break e; case E: ve = 14; break e; case M: ve = 16, L = null; break e }throw Error(s(130, w == null ? w : typeof w, "")) }return _ = $s(ve, R, _, H), _.elementType = w, _.type = L, _.lanes = J, _ } function Id(w, _, R, L) { return w = $s(7, w, L, _), w.lanes = R, w } function um(w, _, R, L) { return w = $s(22, w, L, _), w.elementType = C, w.lanes = R, w.stateNode = {}, w } function Vv(w, _, R) { return w = $s(6, w, null, _), w.lanes = R, w } function Hv(w, _, R) { return _ = $s(4, w.children !== null ? w.children : [], w.key, _), _.lanes = R, _.stateNode = { containerInfo: w.containerInfo, pendingChildren: null, implementation: w.implementation }, _ } function Wv(w, _, R, L, H) { this.tag = _, this.containerInfo = w, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = he, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = tv(0), this.expirationTimes = tv(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = tv(0), this.identifierPrefix = L, this.onRecoverableError = H, oe && (this.mutableSourceEagerHydrationData = null) } function dE(w, _, R, L, H, J, ve, Oe, tt) { return w = new Wv(w, _, R, Oe, tt), _ === 1 ? (_ = 1, J === !0 && (_ |= 8)) : _ = 0, J = $s(3, null, null, _), w.current = J, J.stateNode = w, J.memoizedState = { element: L, isDehydrated: R, cache: null, transitions: null }, Uf(J), w } function fE(w) { if (!w) return tn; w = w._reactInternals; e: { if (I(w) !== w || w.tag !== 1) throw Error(s(170)); var _ = w; do { switch (_.tag) { case 3: _ = _.stateNode.context; break e; case 1: if (bn(_.type)) { _ = _.stateNode.__reactInternalMemoizedMergedChildContext; break e } }_ = _.return } while (_ !== null); throw Error(s(171)) } if (w.tag === 1) { var R = w.type; if (bn(R)) return Sr(w, R, _) } return _ } function hE(w) { var _ = w._reactInternals; if (_ === void 0) throw typeof w.render == "function" ? Error(s(188)) : (w = Object.keys(w).join(","), Error(s(268, w))); return w = B(_), w === null ? null : w.stateNode } function _o(w, _) { if (w = w.memoizedState, w !== null && w.dehydrated !== null) { var R = w.retryLane; w.retryLane = R !== 0 && R < _ ? R : _ } } function dm(w, _) { _o(w, _), (w = w.alternate) && _o(w, _) } function Gv(w) { return w = B(w), w === null ? null : w.stateNode } function pE() { return null } return n.attemptContinuousHydration = function (w) { if (w.tag === 13) { var _ = Cr(); za(w, 134217728, _), dm(w, 134217728) } }, n.attemptHydrationAtCurrentPriority = function (w) { if (w.tag === 13) { var _ = Cr(), R = Zo(w); za(w, R, _), dm(w, R) } }, n.attemptSynchronousHydration = function (w) { switch (w.tag) { case 3: var _ = w.stateNode; if (_.current.memoizedState.isDehydrated) { var R = Df(_.pendingLanes); R !== 0 && (xl(_, R | 1), vs(_, Qi()), (Zn & 6) === 0 && (jd(), go())) } break; case 13: var L = Cr(); ah(function () { return za(w, 1, L) }), dm(w, 1) } }, n.batchedUpdates = function (w, _) { var R = Zn; Zn |= 1; try { return w(_) } finally { Zn = R, Zn === 0 && (jd(), av && go()) } }, n.createComponentSelector = function (w) { return { $$typeof: em, value: w } }, n.createContainer = function (w, _, R, L, H, J, ve) { return dE(w, _, !1, null, R, L, H, J, ve) }, n.createHasPseudoClassSelector = function (w) { return { $$typeof: Td, value: w } }, n.createHydrationContainer = function (w, _, R, L, H, J, ve, Oe, tt) { return w = dE(R, L, !0, w, H, J, ve, Oe, tt), w.context = fE(null), R = w.current, L = Cr(), H = Zo(R), J = tc(L, H), J.callback = _ ?? null, tu(R, J), w.current.lanes = H, ad(w, H, L), vs(w, L), w }, n.createPortal = function (w, _, R) { var L = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: u, key: L == null ? null : "" + L, children: w, containerInfo: _, implementation: R } }, n.createRoleSelector = function (w) { return { $$typeof: Cd, value: w } }, n.createTestNameSelector = function (w) { return { $$typeof: fc, value: w } }, n.createTextSelector = function (w) { return { $$typeof: th, value: w } }, n.deferredUpdates = function (w) { var _ = sr, R = Ur.transition; try { return Ur.transition = null, sr = 16, w() } finally { sr = _, Ur.transition = R } }, n.discreteUpdates = function (w, _, R, L, H) { var J = sr, ve = Ur.transition; try { return Ur.transition = null, sr = 1, w(_, R, L, H) } finally { sr = J, Ur.transition = ve, Zn === 0 && jd() } }, n.findAllNodes = hc, n.findBoundingRects = function (w, _) { if (!nt) throw Error(s(363)); _ = hc(w, _), w = []; for (var R = 0; R < _.length; R++)w.push(St(_[R])); for (_ = w.length - 1; 0 < _; _--) { R = w[_]; for (var L = R.x, H = L + R.width, J = R.y, ve = J + R.height, Oe = _ - 1; 0 <= Oe; Oe--)if (_ !== Oe) { var tt = w[Oe], Ot = tt.x, an = Ot + tt.width, Bn = tt.y, En = Bn + tt.height; if (L >= Ot && J >= Bn && H <= an && ve <= En) { w.splice(_, 1); break } else if (L !== Ot || R.width !== tt.width || En < J || Bn > ve) { if (!(J !== Bn || R.height !== tt.height || an < L || Ot > H)) { Ot > L && (tt.width += Ot - L, tt.x = L), an < H && (tt.width = H - Ot), w.splice(_, 1); break } } else { Bn > J && (tt.height += Bn - J, tt.y = J), En < ve && (tt.height = ve - Bn), w.splice(_, 1); break } } } return w }, n.findHostInstance = hE, n.findHostInstanceWithNoPortals = function (w) { return w = F(w), w = w !== null ? z(w) : null, w === null ? null : w.stateNode }, n.findHostInstanceWithWarning = function (w) { return hE(w) }, n.flushControlled = function (w) { var _ = Zn; Zn |= 1; var R = Ur.transition, L = sr; try { Ur.transition = null, sr = 1, w() } finally { sr = L, Ur.transition = R, Zn = _, Zn === 0 && (jd(), go()) } }, n.flushPassiveEffects = Tl, n.flushSync = ah, n.focusWithin = function (w, _) { if (!nt) throw Error(s(363)); for (w = tm(w), _ = Fs(w, _), _ = Array.from(_), w = 0; w < _.length;) { var R = _[w++]; if (!ne(R)) { if (R.tag === 5 && Ue(R.stateNode)) return !0; for (R = R.child; R !== null;)_.push(R), R = R.sibling } } return !1 }, n.getCurrentUpdatePriority = function () { return sr }, n.getFindAllNodesFailureDescription = function (w, _) {
			if (!nt) throw Error(s(363)); var R = 0, L = []; w = [tm(w), 0]; for (var H = 0; H < w.length;) { var J = w[H++], ve = w[H++], Oe = _[ve]; if ((J.tag !== 5 || !ne(J)) && (nm(J, Oe) && (L.push(cu(Oe)), ve++, ve > R && (R = ve)), ve < _.length)) for (J = J.child; J !== null;)w.push(J, ve), J = J.sibling } if (R < _.length) {
				for (w = []; R < _.length; R++)w.push(cu(_[R])); return `findAllNodes was able to match part of the selector:
  `+ (L.join(" > ") + `

No matching component was found for:
  `) + w.join(" > ")
			} return null
		}, n.getPublicRootInstance = function (w) { if (w = w.current, !w.child) return null; switch (w.child.tag) { case 5: return Y(w.child.stateNode); default: return w.child.stateNode } }, n.injectIntoDevTools = function (w) { if (w = { bundleType: w.bundleType, version: w.version, rendererPackageName: w.rendererPackageName, rendererConfig: w.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: o.ReactCurrentDispatcher, findHostInstanceByFiber: Gv, findFiberByHostInstance: w.findFiberByHostInstance || pE, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") w = !1; else { var _ = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (_.isDisabled || !_.supportsFiber) w = !0; else { try { kp = _.inject(w), bl = _ } catch { } w = !!_.checkDCE } } return w }, n.isAlreadyRendering = function () { return !1 }, n.observeVisibleRects = function (w, _, R, L) { if (!nt) throw Error(s(363)); w = hc(w, _); var H = et(w, R, L).disconnect; return { disconnect: function () { H() } } }, n.registerMutableSourceForHydration = function (w, _) { var R = _._getVersion; R = R(_._source), w.mutableSourceEagerHydrationData == null ? w.mutableSourceEagerHydrationData = [_, R] : w.mutableSourceEagerHydrationData.push(_, R) }, n.runWithPriority = function (w, _) { var R = sr; try { return sr = w, _() } finally { sr = R } }, n.shouldError = function () { return null }, n.shouldSuspend = function () { return !1 }, n.updateContainer = function (w, _, R, L) { var H = _.current, J = Cr(), ve = Zo(H); return R = fE(R), _.context === null ? _.context = R : _.pendingContext = R, _ = tc(J, ve), _.payload = { element: w }, L = L === void 0 ? null : L, L !== null && (_.callback = L), tu(H, _), w = za(H, ve, J), w !== null && cv(w, H, ve), ve }, n
	}), KR
} var s7; function bOe() { return s7 || (s7 = 1, qR.exports = xOe()), qR.exports } var wOe = bOe(); const SOe = Fr(wOe); var ZR = { exports: {} }, QR = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o7; function _Oe() { return o7 || (o7 = 1, (function (t) { function e($, V) { var K = $.length; $.push(V); e: for (; 0 < K;) { var X = K - 1 >>> 1, Q = $[X]; if (0 < i(Q, V)) $[X] = V, $[K] = Q, K = X; else break e } } function n($) { return $.length === 0 ? null : $[0] } function r($) { if ($.length === 0) return null; var V = $[0], K = $.pop(); if (K !== V) { $[0] = K; e: for (var X = 0, Q = $.length, re = Q >>> 1; X < re;) { var ce = 2 * (X + 1) - 1, be = $[ce], de = ce + 1, ae = $[de]; if (0 > i(be, K)) de < Q && 0 > i(ae, be) ? ($[X] = ae, $[de] = K, X = de) : ($[X] = be, $[ce] = K, X = ce); else if (de < Q && 0 > i(ae, K)) $[X] = ae, $[de] = K, X = de; else break e } } return V } function i($, V) { var K = $.sortIndex - V.sortIndex; return K !== 0 ? K : $.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var a = performance; t.unstable_now = function () { return a.now() } } else { var s = Date, o = s.now(); t.unstable_now = function () { return s.now() - o } } var c = [], u = [], d = 1, f = null, h = 3, m = !1, g = !1, x = !1, v = typeof setTimeout == "function" ? setTimeout : null, b = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M($) { for (var V = n(u); V !== null;) { if (V.callback === null) r(u); else if (V.startTime <= $) r(u), V.sortIndex = V.expirationTime, e(c, V); else break; V = n(u) } } function C($) { if (x = !1, M($), !g) if (n(c) !== null) g = !0, Y(N); else { var V = n(u); V !== null && Z(C, V.startTime - $) } } function N($, V) { g = !1, x && (x = !1, b(O), O = -1), m = !0; var K = h; try { for (M(V), f = n(c); f !== null && (!(f.expirationTime > V) || $ && !F());) { var X = f.callback; if (typeof X == "function") { f.callback = null, h = f.priorityLevel; var Q = X(f.expirationTime <= V); V = t.unstable_now(), typeof Q == "function" ? f.callback = Q : f === n(c) && r(c), M(V) } else r(c); f = n(c) } if (f !== null) var re = !0; else { var ce = n(u); ce !== null && Z(C, ce.startTime - V), re = !1 } return re } finally { f = null, h = K, m = !1 } } var A = !1, j = null, O = -1, I = 5, D = -1; function F() { return !(t.unstable_now() - D < I) } function B() { if (j !== null) { var $ = t.unstable_now(); D = $; var V = !0; try { V = j(!0, $) } finally { V ? G() : (A = !1, j = null) } } else A = !1 } var G; if (typeof E == "function") G = function () { E(B) }; else if (typeof MessageChannel < "u") { var z = new MessageChannel, q = z.port2; z.port1.onmessage = B, G = function () { q.postMessage(null) } } else G = function () { v(B, 0) }; function Y($) { j = $, A || (A = !0, G()) } function Z($, V) { O = v(function () { $(t.unstable_now()) }, V) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function ($) { $.callback = null }, t.unstable_continueExecution = function () { g || m || (g = !0, Y(N)) }, t.unstable_forceFrameRate = function ($) { 0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < $ ? Math.floor(1e3 / $) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(c) }, t.unstable_next = function ($) { switch (h) { case 1: case 2: case 3: var V = 3; break; default: V = h }var K = h; h = V; try { return $() } finally { h = K } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function ($, V) { switch ($) { case 1: case 2: case 3: case 4: case 5: break; default: $ = 3 }var K = h; h = $; try { return V() } finally { h = K } }, t.unstable_scheduleCallback = function ($, V, K) { var X = t.unstable_now(); switch (typeof K == "object" && K !== null ? (K = K.delay, K = typeof K == "number" && 0 < K ? X + K : X) : K = X, $) { case 1: var Q = -1; break; case 2: Q = 250; break; case 5: Q = 1073741823; break; case 4: Q = 1e4; break; default: Q = 5e3 }return Q = K + Q, $ = { id: d++, callback: V, priorityLevel: $, startTime: K, expirationTime: Q, sortIndex: -1 }, K > X ? ($.sortIndex = K, e(u, $), n(c) === null && $ === n(u) && (x ? (b(O), O = -1) : x = !0, Z(C, K - X))) : ($.sortIndex = Q, e(c, $), g || m || (g = !0, Y(N))), $ }, t.unstable_shouldYield = F, t.unstable_wrapCallback = function ($) { var V = h; return function () { var K = h; h = V; try { return $.apply(this, arguments) } finally { h = K } } } })(QR)), QR } var l7; function EOe() { return l7 || (l7 = 1, ZR.exports = _Oe()), ZR.exports } var c7 = EOe(); const RB = {}, Lse = t => void Object.assign(RB, t); function MOe(t, e) { function n(d, { args: f = [], attach: h, ...m }, g) { let x = `${d[0].toUpperCase()}${d.slice(1)}`, v; if (d === "primitive") { if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!"); const b = m.object; v = Py(b, { type: d, root: g, attach: h, primitive: !0 }) } else { const b = RB[x]; if (!b) throw new Error(`R3F: ${x} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(f)) throw new Error("R3F: The args prop must be an array!"); v = Py(new b(...f), { type: d, root: g, attach: h, memoizedProps: { args: f } }) } return v.__r3f.attach === void 0 && (v.isBufferGeometry ? v.__r3f.attach = "geometry" : v.isMaterial && (v.__r3f.attach = "material")), x !== "inject" && tk(v, m), v } function r(d, f) { let h = !1; if (f) { var m, g; (m = f.__r3f) != null && m.attach ? ek(d, f, f.__r3f.attach) : f.isObject3D && d.isObject3D && (d.add(f), h = !0), h || (g = d.__r3f) == null || g.objects.push(f), f.__r3f || Py(f, {}), f.__r3f.parent = d, t4(f), jy(f) } } function i(d, f, h) { let m = !1; if (f) { var g, x; if ((g = f.__r3f) != null && g.attach) ek(d, f, f.__r3f.attach); else if (f.isObject3D && d.isObject3D) { f.parent = d, f.dispatchEvent({ type: "added" }), d.dispatchEvent({ type: "childadded", child: f }); const v = d.children.filter(E => E !== f), b = v.indexOf(h); d.children = [...v.slice(0, b), f, ...v.slice(b)], m = !0 } m || (x = d.__r3f) == null || x.objects.push(f), f.__r3f || Py(f, {}), f.__r3f.parent = d, t4(f), jy(f) } } function a(d, f, h = !1) { d && [...d].forEach(m => s(f, m, h)) } function s(d, f, h) { if (f) { var m, g, x; if (f.__r3f && (f.__r3f.parent = null), (m = d.__r3f) != null && m.objects && (d.__r3f.objects = d.__r3f.objects.filter(C => C !== f)), (g = f.__r3f) != null && g.attach) p7(d, f, f.__r3f.attach); else if (f.isObject3D && d.isObject3D) { var v; d.remove(f), (v = f.__r3f) != null && v.root && ROe(kT(f), f) } const E = (x = f.__r3f) == null ? void 0 : x.primitive, M = !E && (h === void 0 ? f.dispose !== null : h); if (!E) { var b; a((b = f.__r3f) == null ? void 0 : b.objects, f, M), a(f.children, f, M) } if (delete f.__r3f, M && f.dispose && f.type !== "Scene") { const C = () => { try { f.dispose() } catch { } }; typeof IS_REACT_ACT_ENVIRONMENT > "u" ? c7.unstable_scheduleCallback(c7.unstable_IdlePriority, C) : C() } jy(d) } } function o(d, f, h, m) { var g; const x = (g = d.__r3f) == null ? void 0 : g.parent; if (!x) return; const v = n(f, h, d.__r3f.root); if (d.children) { for (const b of d.children) b.__r3f && r(v, b); d.children = d.children.filter(b => !b.__r3f) } d.__r3f.objects.forEach(b => r(v, b)), d.__r3f.objects = [], d.__r3f.autoRemovedBeforeAppend || s(x, d), v.parent && (v.__r3f.autoRemovedBeforeAppend = !0), r(x, v), v.raycast && v.__r3f.eventCount && kT(v).getState().internal.interaction.push(v), [m, m.alternate].forEach(b => { b !== null && (b.stateNode = v, b.ref && (typeof b.ref == "function" ? b.ref(v) : b.ref.current = v)) }) } const c = () => { }; return { reconciler: SOe({ createInstance: n, removeChild: s, appendChild: r, appendInitialChild: r, insertBefore: i, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (d, f) => { if (!f) return; const h = d.getState().scene; h.__r3f && (h.__r3f.root = d, r(h, f)) }, removeChildFromContainer: (d, f) => { f && s(d.getState().scene, f) }, insertInContainerBefore: (d, f, h) => { if (!f || !h) return; const m = d.getState().scene; m.__r3f && i(m, f, h) }, getRootHostContext: () => null, getChildHostContext: d => d, finalizeInitialChildren(d) { var f; return !!((f = d?.__r3f) != null ? f : {}).handlers }, prepareUpdate(d, f, h, m) { var g; if (((g = d?.__r3f) != null ? g : {}).primitive && m.object && m.object !== d) return [!0]; { const { args: v = [], children: b, ...E } = m, { args: M = [], children: C, ...N } = h; if (!Array.isArray(v)) throw new Error("R3F: the args prop must be an array!"); if (v.some((j, O) => j !== M[O])) return [!0]; const A = Hse(d, E, N, !0); return A.changes.length ? [!1, A] : null } }, commitUpdate(d, [f, h], m, g, x, v) { f ? o(d, m, x, v) : tk(d, h) }, commitMount(d, f, h, m) { var g; const x = (g = d.__r3f) != null ? g : {}; d.raycast && x.handlers && x.eventCount && kT(d).getState().internal.interaction.push(d) }, getPublicInstance: d => d, prepareForCommit: () => null, preparePortalMount: d => Py(d.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(d) { var f; const { attach: h, parent: m } = (f = d.__r3f) != null ? f : {}; h && m && p7(m, d, h), d.isObject3D && (d.visible = !1), jy(d) }, unhideInstance(d, f) { var h; const { attach: m, parent: g } = (h = d.__r3f) != null ? h : {}; m && g && ek(g, d, m), (d.isObject3D && f.visible == null || f.visible) && (d.visible = !0), jy(d) }, createTextInstance: c, hideTextInstance: c, unhideTextInstance: c, getCurrentEventPriority: () => e ? e() : zy.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: typeof performance < "u" && gi.fun(performance.now) ? performance.now : gi.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: gi.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: gi.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: tk } } var u7, d7; const JR = t => "colorSpace" in t || "outputColorSpace" in t, Fse = () => { var t; return (t = RB.ColorManagement) != null ? t : null }, Use = t => t && t.isOrthographicCamera, TOe = t => t && t.hasOwnProperty("current"), v_ = typeof window < "u" && ((u7 = window.document) != null && u7.createElement || ((d7 = window.navigator) == null ? void 0 : d7.product) === "ReactNative") ? S.useLayoutEffect : S.useEffect; function Bse(t) { const e = S.useRef(t); return v_(() => void (e.current = t), [t]), e } function COe({ set: t }) { return v_(() => (t(new Promise(() => null)), () => t(!1)), [t]), null } class $se extends S.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } $se.getDerivedStateFromError = () => ({ error: !0 }); const zse = "__default", f7 = new Map, NOe = t => t && !!t.memoized && !!t.changes; function Vse(t) { var e; const n = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1; return Array.isArray(t) ? Math.min(Math.max(t[0], n), t[1]) : t } const cw = t => { var e; return (e = t.__r3f) == null ? void 0 : e.root.getState() }; function kT(t) { let e = t.__r3f.root; for (; e.getState().previousRoot;)e = e.getState().previousRoot; return e } const gi = { obj: t => t === Object(t) && !gi.arr(t) && typeof t != "function", fun: t => typeof t == "function", str: t => typeof t == "string", num: t => typeof t == "number", boo: t => typeof t == "boolean", und: t => t === void 0, arr: t => Array.isArray(t), equ(t, e, { arrays: n = "shallow", objects: r = "reference", strict: i = !0 } = {}) { if (typeof t != typeof e || !!t != !!e) return !1; if (gi.str(t) || gi.num(t) || gi.boo(t)) return t === e; const a = gi.obj(t); if (a && r === "reference") return t === e; const s = gi.arr(t); if (s && n === "reference") return t === e; if ((s || a) && t === e) return !0; let o; for (o in t) if (!(o in e)) return !1; if (a && n === "shallow" && r === "shallow") { for (o in i ? e : t) if (!gi.equ(t[o], e[o], { strict: i, objects: "reference" })) return !1 } else for (o in i ? e : t) if (t[o] !== e[o]) return !1; if (gi.und(o)) { if (s && t.length === 0 && e.length === 0 || a && Object.keys(t).length === 0 && Object.keys(e).length === 0) return !0; if (t !== e) return !1 } return !0 } }; function AOe(t) { const e = { nodes: {}, materials: {} }; return t && t.traverse(n => { n.name && (e.nodes[n.name] = n), n.material && !e.materials[n.material.name] && (e.materials[n.material.name] = n.material) }), e } function POe(t) { t.dispose && t.type !== "Scene" && t.dispose(); for (const e in t) e.dispose == null || e.dispose(), delete t[e] } function Py(t, e) { const n = t; return n.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }, t } function e4(t, e) { let n = t; if (e.includes("-")) { const r = e.split("-"), i = r.pop(); return n = r.reduce((a, s) => a[s], t), { target: n, key: i } } else return { target: n, key: e } } const h7 = /-\d+$/; function ek(t, e, n) { if (gi.str(n)) { if (h7.test(n)) { const a = n.replace(h7, ""), { target: s, key: o } = e4(t, a); Array.isArray(s[o]) || (s[o] = []) } const { target: r, key: i } = e4(t, n); e.__r3f.previousAttach = r[i], r[i] = e } else e.__r3f.previousAttach = n(t, e) } function p7(t, e, n) { var r, i; if (gi.str(n)) { const { target: a, key: s } = e4(t, n), o = e.__r3f.previousAttach; o === void 0 ? delete a[s] : a[s] = o } else (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(t, e); (i = e.__r3f) == null || delete i.previousAttach } function Hse(t, { children: e, key: n, ref: r, ...i }, { children: a, key: s, ref: o, ...c } = {}, u = !1) { const d = t.__r3f, f = Object.entries(i), h = []; if (u) { const g = Object.keys(c); for (let x = 0; x < g.length; x++)i.hasOwnProperty(g[x]) || f.unshift([g[x], zse + "remove"]) } f.forEach(([g, x]) => { var v; if ((v = t.__r3f) != null && v.primitive && g === "object" || gi.equ(x, c[g])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(g)) return h.push([g, x, !0, []]); let b = []; g.includes("-") && (b = g.split("-")), h.push([g, x, !1, b]); for (const E in i) { const M = i[E]; E.startsWith(`${g}-`) && h.push([E, M, !1, E.split("-")]) } }); const m = { ...i }; return d != null && d.memoizedProps && d != null && d.memoizedProps.args && (m.args = d.memoizedProps.args), d != null && d.memoizedProps && d != null && d.memoizedProps.attach && (m.attach = d.memoizedProps.attach), { memoized: m, changes: h } } function tk(t, e) { var n; const r = t.__r3f, i = r?.root, a = i == null || i.getState == null ? void 0 : i.getState(), { memoized: s, changes: o } = NOe(e) ? e : Hse(t, e), c = r?.eventCount; t.__r3f && (t.__r3f.memoizedProps = s); for (let h = 0; h < o.length; h++) { let [m, g, x, v] = o[h]; if (JR(t)) { const C = "srgb", N = "srgb-linear"; m === "encoding" ? (m = "colorSpace", g = g === 3001 ? C : N) : m === "outputEncoding" && (m = "outputColorSpace", g = g === 3001 ? C : N) } let b = t, E = b[m]; if (v.length && (E = v.reduce((M, C) => M[C], t), !(E && E.set))) { const [M, ...C] = v.reverse(); b = C.reverse().reduce((N, A) => N[A], t), m = M } if (g === zse + "remove") if (b.constructor) { let M = f7.get(b.constructor); M || (M = new b.constructor, f7.set(b.constructor, M)), g = M[m] } else g = 0; if (x && r) g ? r.handlers[m] = g : delete r.handlers[m], r.eventCount = Object.keys(r.handlers).length; else if (E && E.set && (E.copy || E instanceof hg)) { if (Array.isArray(g)) E.fromArray ? E.fromArray(g) : E.set(...g); else if (E.copy && g && g.constructor && E.constructor === g.constructor) E.copy(g); else if (g !== void 0) { var u; const M = (u = E) == null ? void 0 : u.isColor; !M && E.setScalar ? E.setScalar(g) : E instanceof hg && g instanceof hg ? E.mask = g.mask : E.set(g), !Fse() && a && !a.linear && M && E.convertSRGBToLinear() } } else { var d; if (b[m] = g, (d = b[m]) != null && d.isTexture && b[m].format === ia && b[m].type === lo && a) { const M = b[m]; JR(M) && JR(a.gl) ? M.colorSpace = a.gl.outputColorSpace : M.encoding = a.gl.outputEncoding } } jy(t) } if (r && r.parent && t.raycast && c !== r.eventCount) { const h = kT(t).getState().internal, m = h.interaction.indexOf(t); m > -1 && h.interaction.splice(m, 1), r.eventCount && h.interaction.push(t) } return !(o.length === 1 && o[0][0] === "onUpdate") && o.length && (n = t.__r3f) != null && n.parent && t4(t), t } function jy(t) { var e, n; const r = (e = t.__r3f) == null || (n = e.root) == null || n.getState == null ? void 0 : n.getState(); r && r.internal.frames === 0 && r.invalidate() } function t4(t) { t.onUpdate == null || t.onUpdate(t) } function Wse(t, e) { t.manual || (Use(t) ? (t.left = e.width / -2, t.right = e.width / 2, t.top = e.height / 2, t.bottom = e.height / -2) : t.aspect = e.width / e.height, t.updateProjectionMatrix(), t.updateMatrixWorld()) } function $M(t) { return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId } function jOe() { var t; const e = typeof self < "u" && self || typeof window < "u" && window; if (!e) return zy.DefaultEventPriority; switch ((t = e.event) == null ? void 0 : t.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return zy.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return zy.ContinuousEventPriority; default: return zy.DefaultEventPriority } } function Gse(t, e, n, r) { const i = n.get(e); i && (n.delete(e), n.size === 0 && (t.delete(r), i.target.releasePointerCapture(r))) } function ROe(t, e) { const { internal: n } = t.getState(); n.interaction = n.interaction.filter(r => r !== e), n.initialHits = n.initialHits.filter(r => r !== e), n.hovered.forEach((r, i) => { (r.eventObject === e || r.object === e) && n.hovered.delete(i) }), n.capturedMap.forEach((r, i) => { Gse(n.capturedMap, e, r, i) }) } function kOe(t) { function e(c) { const { internal: u } = t.getState(), d = c.offsetX - u.initialClick[0], f = c.offsetY - u.initialClick[1]; return Math.round(Math.sqrt(d * d + f * f)) } function n(c) { return c.filter(u => ["Move", "Over", "Enter", "Out", "Leave"].some(d => { var f; return (f = u.__r3f) == null ? void 0 : f.handlers["onPointer" + d] })) } function r(c, u) { const d = t.getState(), f = new Set, h = [], m = u ? u(d.internal.interaction) : d.internal.interaction; for (let b = 0; b < m.length; b++) { const E = cw(m[b]); E && (E.raycaster.camera = void 0) } d.previousRoot || d.events.compute == null || d.events.compute(c, d); function g(b) { const E = cw(b); if (!E || !E.events.enabled || E.raycaster.camera === null) return []; if (E.raycaster.camera === void 0) { var M; E.events.compute == null || E.events.compute(c, E, (M = E.previousRoot) == null ? void 0 : M.getState()), E.raycaster.camera === void 0 && (E.raycaster.camera = null) } return E.raycaster.camera ? E.raycaster.intersectObject(b, !0) : [] } let x = m.flatMap(g).sort((b, E) => { const M = cw(b.object), C = cw(E.object); return !M || !C ? b.distance - E.distance : C.events.priority - M.events.priority || b.distance - E.distance }).filter(b => { const E = $M(b); return f.has(E) ? !1 : (f.add(E), !0) }); d.events.filter && (x = d.events.filter(x, d)); for (const b of x) { let E = b.object; for (; E;) { var v; (v = E.__r3f) != null && v.eventCount && h.push({ ...b, eventObject: E }), E = E.parent } } if ("pointerId" in c && d.internal.capturedMap.has(c.pointerId)) for (let b of d.internal.capturedMap.get(c.pointerId).values()) f.has($M(b.intersection)) || h.push(b.intersection); return h } function i(c, u, d, f) { const h = t.getState(); if (c.length) { const m = { stopped: !1 }; for (const g of c) { const x = cw(g.object) || h, { raycaster: v, pointer: b, camera: E, internal: M } = x, C = new pe(b.x, b.y, 0).unproject(E), N = D => { var F, B; return (F = (B = M.capturedMap.get(D)) == null ? void 0 : B.has(g.eventObject)) != null ? F : !1 }, A = D => { const F = { intersection: g, target: u.target }; M.capturedMap.has(D) ? M.capturedMap.get(D).set(g.eventObject, F) : M.capturedMap.set(D, new Map([[g.eventObject, F]])), u.target.setPointerCapture(D) }, j = D => { const F = M.capturedMap.get(D); F && Gse(M.capturedMap, g.eventObject, F, D) }; let O = {}; for (let D in u) { let F = u[D]; typeof F != "function" && (O[D] = F) } let I = { ...g, ...O, pointer: b, intersections: c, stopped: m.stopped, delta: d, unprojectedPoint: C, ray: v.ray, camera: E, stopPropagation() { const D = "pointerId" in u && M.capturedMap.get(u.pointerId); if ((!D || D.has(g.eventObject)) && (I.stopped = m.stopped = !0, M.hovered.size && Array.from(M.hovered.values()).find(F => F.eventObject === g.eventObject))) { const F = c.slice(0, c.indexOf(g)); a([...F, g]) } }, target: { hasPointerCapture: N, setPointerCapture: A, releasePointerCapture: j }, currentTarget: { hasPointerCapture: N, setPointerCapture: A, releasePointerCapture: j }, nativeEvent: u }; if (f(I), m.stopped === !0) break } } return c } function a(c) { const { internal: u } = t.getState(); for (const d of u.hovered.values()) if (!c.length || !c.find(f => f.object === d.object && f.index === d.index && f.instanceId === d.instanceId)) { const h = d.eventObject.__r3f, m = h?.handlers; if (u.hovered.delete($M(d)), h != null && h.eventCount) { const g = { ...d, intersections: c }; m.onPointerOut == null || m.onPointerOut(g), m.onPointerLeave == null || m.onPointerLeave(g) } } } function s(c, u) { for (let d = 0; d < u.length; d++) { const f = u[d].__r3f; f == null || f.handlers.onPointerMissed == null || f.handlers.onPointerMissed(c) } } function o(c) { switch (c) { case "onPointerLeave": case "onPointerCancel": return () => a([]); case "onLostPointerCapture": return u => { const { internal: d } = t.getState(); "pointerId" in u && d.capturedMap.has(u.pointerId) && requestAnimationFrame(() => { d.capturedMap.has(u.pointerId) && (d.capturedMap.delete(u.pointerId), a([])) }) } }return function (d) { const { onPointerMissed: f, internal: h } = t.getState(); h.lastEvent.current = d; const m = c === "onPointerMove", g = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick", v = r(d, m ? n : void 0), b = g ? e(d) : 0; c === "onPointerDown" && (h.initialClick = [d.offsetX, d.offsetY], h.initialHits = v.map(M => M.eventObject)), g && !v.length && b <= 2 && (s(d, h.interaction), f && f(d)), m && a(v); function E(M) { const C = M.eventObject, N = C.__r3f, A = N?.handlers; if (N != null && N.eventCount) if (m) { if (A.onPointerOver || A.onPointerEnter || A.onPointerOut || A.onPointerLeave) { const j = $M(M), O = h.hovered.get(j); O ? O.stopped && M.stopPropagation() : (h.hovered.set(j, M), A.onPointerOver == null || A.onPointerOver(M), A.onPointerEnter == null || A.onPointerEnter(M)) } A.onPointerMove == null || A.onPointerMove(M) } else { const j = A[c]; j ? (!g || h.initialHits.includes(C)) && (s(d, h.interaction.filter(O => !h.initialHits.includes(O))), j(M)) : g && h.initialHits.includes(C) && s(d, h.interaction.filter(O => !h.initialHits.includes(O))) } } i(v, d, b, E) } } return { handlePointer: o } } const IOe = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"], qse = t => !!(t != null && t.render), kB = S.createContext(null), OOe = (t, e) => { const n = Ise((o, c) => { const u = new pe, d = new pe, f = new pe; function h(b = c().camera, E = d, M = c().size) { const { width: C, height: N, top: A, left: j } = M, O = C / N; E.isVector3 ? f.copy(E) : f.set(...E); const I = b.getWorldPosition(u).distanceTo(f); if (Use(b)) return { width: C / b.zoom, height: N / b.zoom, top: A, left: j, factor: 1, distance: I, aspect: O }; { const D = b.fov * Math.PI / 180, F = 2 * Math.tan(D / 2) * I, B = F * (C / N); return { width: B, height: F, top: A, left: j, factor: C / B, distance: I, aspect: O } } } let m; const g = b => o(E => ({ performance: { ...E.performance, current: b } })), x = new lt; return { set: o, get: c, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, scene: null, invalidate: (b = 1) => t(c(), b), advance: (b, E) => e(b, E, c()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new EB, pointer: x, mouse: x, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const b = c(); m && clearTimeout(m), b.performance.current !== b.performance.min && g(b.performance.min), m = setTimeout(() => g(c().performance.max), b.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: h }, setEvents: b => o(E => ({ ...E, events: { ...E.events, ...b } })), setSize: (b, E, M, C, N) => { const A = c().camera, j = { width: b, height: E, top: C || 0, left: N || 0, updateStyle: M }; o(O => ({ size: j, viewport: { ...O.viewport, ...h(A, d, j) } })) }, setDpr: b => o(E => { const M = Vse(b); return { viewport: { ...E.viewport, dpr: M, initialDpr: E.viewport.initialDpr || M } } }), setFrameloop: (b = "always") => { const E = c().clock; E.stop(), E.elapsedTime = 0, b !== "never" && (E.start(), E.elapsedTime = 0), o(() => ({ frameloop: b })) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: S.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (b, E, M) => { const C = c().internal; return C.priority = C.priority + (E > 0 ? 1 : 0), C.subscribers.push({ ref: b, priority: E, store: M }), C.subscribers = C.subscribers.sort((N, A) => N.priority - A.priority), () => { const N = c().internal; N != null && N.subscribers && (N.priority = N.priority - (E > 0 ? 1 : 0), N.subscribers = N.subscribers.filter(A => A.ref !== b)) } } } } }), r = n.getState(); let i = r.size, a = r.viewport.dpr, s = r.camera; return n.subscribe(() => { const { camera: o, size: c, viewport: u, gl: d, set: f } = n.getState(); if (c.width !== i.width || c.height !== i.height || u.dpr !== a) { var h; i = c, a = u.dpr, Wse(o, c), d.setPixelRatio(u.dpr); const m = (h = c.updateStyle) != null ? h : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement; d.setSize(c.width, c.height, m) } o !== s && (s = o, f(m => ({ viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(o) } }))) }), n.subscribe(o => t(o)), n }; let zM, DOe = new Set, LOe = new Set, FOe = new Set; function nk(t, e) { if (t.size) for (const { callback: n } of t.values()) n(e) } function uw(t, e) { switch (t) { case "before": return nk(DOe, e); case "after": return nk(LOe, e); case "tail": return nk(FOe, e) } } let rk, ik; function ak(t, e, n) { let r = e.clock.getDelta(); for (e.frameloop === "never" && typeof t == "number" && (r = t - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = t), rk = e.internal.subscribers, zM = 0; zM < rk.length; zM++)ik = rk[zM], ik.ref.current(ik.store.getState(), r, n); return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames } function UOe(t) { let e = !1, n = !1, r, i, a; function s(u) { i = requestAnimationFrame(s), e = !0, r = 0, uw("before", u), n = !0; for (const f of t.values()) { var d; a = f.store.getState(), a.internal.active && (a.frameloop === "always" || a.internal.frames > 0) && !((d = a.gl.xr) != null && d.isPresenting) && (r += ak(u, a)) } if (n = !1, uw("after", u), r === 0) return uw("tail", u), e = !1, cancelAnimationFrame(i) } function o(u, d = 1) { var f; if (!u) return t.forEach(h => o(h.store.getState(), d)); (f = u.gl.xr) != null && f.isPresenting || !u.internal.active || u.frameloop === "never" || (d > 1 ? u.internal.frames = Math.min(60, u.internal.frames + d) : n ? u.internal.frames = 2 : u.internal.frames = 1, e || (e = !0, requestAnimationFrame(s))) } function c(u, d = !0, f, h) { if (d && uw("before", u), f) ak(u, f, h); else for (const m of t.values()) ak(u, m.store.getState()); d && uw("after", u) } return { loop: s, invalidate: o, advance: c } } function IB() { const t = S.useContext(kB); if (!t) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return t } function il(t = n => n, e) { return IB()(t, e) } function xp(t, e = 0) { const n = IB(), r = n.getState().internal.subscribe, i = Bse(t); return v_(() => r(i, e, n), [e, r, n]), null } const m7 = new WeakMap; function Xse(t, e) { return function (n, ...r) { let i = m7.get(n); return i || (i = new n, m7.set(n, i)), t && t(i), Promise.all(r.map(a => new Promise((s, o) => i.load(a, c => { c.scene && Object.assign(c, AOe(c.scene)), s(c) }, e, c => o(new Error(`Could not load ${a}: ${c?.message}`)))))) } } function Cx(t, e, n, r) { const i = Array.isArray(e) ? e : [e], a = pOe(Xse(n, r), [t, ...i], { equal: gi.equ }); return Array.isArray(e) ? a : a[0] } Cx.preload = function (t, e, n) { const r = Array.isArray(e) ? e : [e]; return mOe(Xse(n), [t, ...r]) }; Cx.clear = function (t, e) { const n = Array.isArray(e) ? e : [e]; return gOe([t, ...n]) }; const Nx = new Map, { invalidate: g7, advance: v7 } = UOe(Nx), { reconciler: G1, applyProps: Nh } = MOe(Nx, jOe), wy = { objects: "shallow", strict: !1 }, BOe = (t, e) => { const n = typeof t == "function" ? t(e) : t; return qse(n) ? n : new jB({ powerPreference: "high-performance", canvas: e, antialias: !0, alpha: !0, ...t }) }; function $Oe(t, e) { const n = typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement; if (e) { const { width: r, height: i, top: a, left: s, updateStyle: o = n } = e; return { width: r, height: i, top: a, left: s, updateStyle: o } } else if (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && t.parentElement) { const { width: r, height: i, top: a, left: s } = t.parentElement.getBoundingClientRect(); return { width: r, height: i, top: a, left: s, updateStyle: n } } else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas) return { width: t.width, height: t.height, top: 0, left: 0, updateStyle: n }; return { width: 0, height: 0, top: 0, left: 0 } } function zOe(t) { const e = Nx.get(t), n = e?.fiber, r = e?.store; e && console.warn("R3F.createRoot should only be called once!"); const i = typeof reportError == "function" ? reportError : console.error, a = r || OOe(g7, v7), s = n || G1.createContainer(a, zy.ConcurrentRoot, null, !1, null, "", i, null); e || Nx.set(t, { fiber: s, store: a }); let o, c = !1, u; return { configure(d = {}) { let { gl: f, size: h, scene: m, events: g, onCreated: x, shadows: v = !1, linear: b = !1, flat: E = !1, legacy: M = !1, orthographic: C = !1, frameloop: N = "always", dpr: A = [1, 2], performance: j, raycaster: O, camera: I, onPointerMissed: D } = d, F = a.getState(), B = F.gl; F.gl || F.set({ gl: B = BOe(f, t) }); let G = F.raycaster; G || F.set({ raycaster: G = new NB }); const { params: z, ...q } = O || {}; if (gi.equ(q, G, wy) || Nh(G, { ...q }), gi.equ(z, G.params, wy) || Nh(G, { params: { ...G.params, ...z } }), !F.camera || F.camera === u && !gi.equ(u, I, wy)) { u = I; const K = I instanceof o_, X = K ? I : C ? new of(0, 0, 0, 0, .1, 1e3) : new ra(75, 0, .1, 1e3); K || (X.position.z = 5, I && (Nh(X, I), ("aspect" in I || "left" in I || "right" in I || "bottom" in I || "top" in I) && (X.manual = !0, X.updateProjectionMatrix())), !F.camera && !(I != null && I.rotation) && X.lookAt(0, 0, 0)), F.set({ camera: X }), G.camera = X } if (!F.scene) { let K; m != null && m.isScene ? K = m : (K = new c_, m && Nh(K, m)), F.set({ scene: Py(K) }) } if (!F.xr) { var Y; const K = (re, ce) => { const be = a.getState(); be.frameloop !== "never" && v7(re, !0, be, ce) }, X = () => { const re = a.getState(); re.gl.xr.enabled = re.gl.xr.isPresenting, re.gl.xr.setAnimationLoop(re.gl.xr.isPresenting ? K : null), re.gl.xr.isPresenting || g7(re) }, Q = { connect() { const re = a.getState().gl; re.xr.addEventListener("sessionstart", X), re.xr.addEventListener("sessionend", X) }, disconnect() { const re = a.getState().gl; re.xr.removeEventListener("sessionstart", X), re.xr.removeEventListener("sessionend", X) } }; typeof ((Y = B.xr) == null ? void 0 : Y.addEventListener) == "function" && Q.connect(), F.set({ xr: Q }) } if (B.shadowMap) { const K = B.shadowMap.enabled, X = B.shadowMap.type; if (B.shadowMap.enabled = !!v, gi.boo(v)) B.shadowMap.type = Ww; else if (gi.str(v)) { var Z; const Q = { basic: Oie, percentage: BA, soft: Ww, variance: Pc }; B.shadowMap.type = (Z = Q[v]) != null ? Z : Ww } else gi.obj(v) && Object.assign(B.shadowMap, v); (K !== B.shadowMap.enabled || X !== B.shadowMap.type) && (B.shadowMap.needsUpdate = !0) } const $ = Fse(); $ && ("enabled" in $ ? $.enabled = !M : "legacyMode" in $ && ($.legacyMode = M)), c || Nh(B, { outputEncoding: b ? 3e3 : 3001, toneMapping: E ? ju : HU }), F.legacy !== M && F.set(() => ({ legacy: M })), F.linear !== b && F.set(() => ({ linear: b })), F.flat !== E && F.set(() => ({ flat: E })), f && !gi.fun(f) && !qse(f) && !gi.equ(f, B, wy) && Nh(B, f), g && !F.events.handlers && F.set({ events: g(a) }); const V = $Oe(t, h); return gi.equ(V, F.size, wy) || F.setSize(V.width, V.height, V.updateStyle, V.top, V.left), A && F.viewport.dpr !== Vse(A) && F.setDpr(A), F.frameloop !== N && F.setFrameloop(N), F.onPointerMissed || F.set({ onPointerMissed: D }), j && !gi.equ(j, F.performance, wy) && F.set(K => ({ performance: { ...K.performance, ...j } })), o = x, c = !0, this }, render(d) { return c || this.configure(), G1.updateContainer(l.jsx(VOe, { store: a, children: d, onCreated: o, rootElement: t }), s, null, () => { }), a }, unmount() { Yse(t) } } } function VOe({ store: t, children: e, onCreated: n, rootElement: r }) { return v_(() => { const i = t.getState(); i.set(a => ({ internal: { ...a.internal, active: !0 } })), n && n(i), t.getState().events.connected || i.events.connect == null || i.events.connect(r) }, []), l.jsx(kB.Provider, { value: t, children: e }) } function Yse(t, e) { const n = Nx.get(t), r = n?.fiber; if (r) { const i = n?.store.getState(); i && (i.internal.active = !1), G1.updateContainer(null, r, null, () => { i && setTimeout(() => { try { var a, s, o, c; i.events.disconnect == null || i.events.disconnect(), (a = i.gl) == null || (s = a.renderLists) == null || s.dispose == null || s.dispose(), (o = i.gl) == null || o.forceContextLoss == null || o.forceContextLoss(), (c = i.gl) != null && c.xr && i.xr.disconnect(), POe(i), Nx.delete(t) } catch { } }, 500) }) } } function HOe(t, e, n) { return l.jsx(WOe, { children: t, container: e, state: n }, e.uuid) } function WOe({ state: t = {}, children: e, container: n }) { const { events: r, size: i, ...a } = t, s = IB(), [o] = S.useState(() => new NB), [c] = S.useState(() => new lt), u = S.useCallback((f, h) => { const m = { ...f }; Object.keys(f).forEach(x => { (IOe.includes(x) || f[x] !== h[x] && h[x]) && delete m[x] }); let g; if (h && i) { const x = h.camera; g = f.viewport.getCurrentViewport(x, new pe, i), x !== f.camera && Wse(x, i) } return { ...m, scene: n, raycaster: o, pointer: c, mouse: c, previousRoot: s, events: { ...f.events, ...h?.events, ...r }, size: { ...f.size, ...i }, viewport: { ...f.viewport, ...g }, ...a } }, [t]), [d] = S.useState(() => { const f = s.getState(); return Ise((m, g) => ({ ...f, scene: n, raycaster: o, pointer: c, mouse: c, previousRoot: s, events: { ...f.events, ...r }, size: { ...f.size, ...i }, ...a, set: m, get: g, setEvents: x => m(v => ({ ...v, events: { ...v.events, ...x } })) })) }); return S.useEffect(() => { const f = s.subscribe(h => d.setState(m => u(h, m))); return () => { f() } }, [u]), S.useEffect(() => { d.setState(f => u(s.getState(), f)) }, [u]), S.useEffect(() => () => { d.destroy() }, []), l.jsx(l.Fragment, { children: G1.createPortal(l.jsx(kB.Provider, { value: d, children: e }), d, null) }) } G1.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: S.version }); const sk = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function GOe(t) { const { handlePointer: e } = kOe(t); return { priority: 1, enabled: !0, compute(n, r, i) { r.pointer.set(n.offsetX / r.size.width * 2 - 1, -(n.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera) }, connected: void 0, handlers: Object.keys(sk).reduce((n, r) => ({ ...n, [r]: e(r) }), {}), update: () => { var n; const { events: r, internal: i } = t.getState(); (n = i.lastEvent) != null && n.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current) }, connect: n => { var r; const { set: i, events: a } = t.getState(); a.disconnect == null || a.disconnect(), i(s => ({ events: { ...s.events, connected: n } })), Object.entries((r = a.handlers) != null ? r : []).forEach(([s, o]) => { const [c, u] = sk[s]; n.addEventListener(c, o, { passive: u }) }) }, disconnect: () => { const { set: n, events: r } = t.getState(); if (r.connected) { var i; Object.entries((i = r.handlers) != null ? i : []).forEach(([a, s]) => { if (r && r.connected instanceof HTMLElement) { const [o] = sk[a]; r.connected.removeEventListener(o, s) } }), n(a => ({ events: { ...a.events, connected: void 0 } })) } } } } function y7(t, e) { let n; return (...r) => { window.clearTimeout(n), n = window.setTimeout(() => t(...r), e) } } function qOe({ debounce: t, scroll: e, polyfill: n, offsetSize: r } = { debounce: 0, scroll: !1, offsetSize: !1 }) { const i = n || (typeof window > "u" ? class { } : window.ResizeObserver); if (!i) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [a, s] = S.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), o = S.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: a, orientationHandler: null }), c = t ? typeof t == "number" ? t : t.scroll : null, u = t ? typeof t == "number" ? t : t.resize : null, d = S.useRef(!1); S.useEffect(() => (d.current = !0, () => void (d.current = !1))); const [f, h, m] = S.useMemo(() => { const b = () => { if (!o.current.element) return; const { left: E, top: M, width: C, height: N, bottom: A, right: j, x: O, y: I } = o.current.element.getBoundingClientRect(), D = { left: E, top: M, width: C, height: N, bottom: A, right: j, x: O, y: I }; o.current.element instanceof HTMLElement && r && (D.height = o.current.element.offsetHeight, D.width = o.current.element.offsetWidth), Object.freeze(D), d.current && !ZOe(o.current.lastBounds, D) && s(o.current.lastBounds = D) }; return [b, u ? y7(b, u) : b, c ? y7(b, c) : b] }, [s, r, c, u]); function g() { o.current.scrollContainers && (o.current.scrollContainers.forEach(b => b.removeEventListener("scroll", m, !0)), o.current.scrollContainers = null), o.current.resizeObserver && (o.current.resizeObserver.disconnect(), o.current.resizeObserver = null), o.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", o.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", o.current.orientationHandler)) } function x() { o.current.element && (o.current.resizeObserver = new i(m), o.current.resizeObserver.observe(o.current.element), e && o.current.scrollContainers && o.current.scrollContainers.forEach(b => b.addEventListener("scroll", m, { capture: !0, passive: !0 })), o.current.orientationHandler = () => { m() }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", o.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", o.current.orientationHandler)) } const v = b => { !b || b === o.current.element || (g(), o.current.element = b, o.current.scrollContainers = Kse(b), x()) }; return YOe(m, !!e), XOe(h), S.useEffect(() => { g(), x() }, [e, m, h]), S.useEffect(() => g, []), [v, a, f] } function XOe(t) { S.useEffect(() => { const e = t; return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e) }, [t]) } function YOe(t, e) { S.useEffect(() => { if (e) { const n = t; return window.addEventListener("scroll", n, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", n, !0) } }, [t, e]) } function Kse(t) { const e = []; if (!t || t === document.body) return e; const { overflow: n, overflowX: r, overflowY: i } = window.getComputedStyle(t); return [n, r, i].some(a => a === "auto" || a === "scroll") && e.push(t), [...e, ...Kse(t.parentElement)] } const KOe = ["x", "y", "top", "bottom", "left", "right", "width", "height"], ZOe = (t, e) => KOe.every(n => t[n] === e[n]); var QOe = Object.defineProperty, JOe = Object.defineProperties, eDe = Object.getOwnPropertyDescriptors, x7 = Object.getOwnPropertySymbols, tDe = Object.prototype.hasOwnProperty, nDe = Object.prototype.propertyIsEnumerable, b7 = (t, e, n) => e in t ? QOe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, w7 = (t, e) => { for (var n in e || (e = {})) tDe.call(e, n) && b7(t, n, e[n]); if (x7) for (var n of x7(e)) nDe.call(e, n) && b7(t, n, e[n]); return t }, rDe = (t, e) => JOe(t, eDe(e)), S7, _7; typeof window < "u" && ((S7 = window.document) != null && S7.createElement || ((_7 = window.navigator) == null ? void 0 : _7.product) === "ReactNative") ? S.useLayoutEffect : S.useEffect; function Zse(t, e, n) { if (!t) return; if (n(t) === !0) return t; let r = t.child; for (; r;) { const i = Zse(r, e, n); if (i) return i; r = r.sibling } } function Qse(t) { try { return Object.defineProperties(t, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return t } } const E7 = console.error; console.error = function () { const t = [...arguments].join(""); if (t?.startsWith("Warning:") && t.includes("useContext")) { console.error = E7; return } return E7.apply(this, arguments) }; const OB = Qse(S.createContext(null)); class Jse extends S.Component { render() { return S.createElement(OB.Provider, { value: this._reactInternals }, this.props.children) } } function iDe() { const t = S.useContext(OB); if (t === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const e = S.useId(); return S.useMemo(() => { for (const r of [t, t?.alternate]) { if (!r) continue; const i = Zse(r, !1, a => { let s = a.memoizedState; for (; s;) { if (s.memoizedState === e) return !0; s = s.next } }); if (i) return i } }, [t, e]) } function aDe() { const t = iDe(), [e] = S.useState(() => new Map); e.clear(); let n = t; for (; n;) { if (n.type && typeof n.type == "object") { const i = n.type._context === void 0 && n.type.Provider === n.type ? n.type : n.type._context; i && i !== OB && !e.has(i) && e.set(i, S.useContext(Qse(i))) } n = n.return } return e } function sDe() { const t = aDe(); return S.useMemo(() => Array.from(t.keys()).reduce((e, n) => r => S.createElement(e, null, S.createElement(n.Provider, rDe(w7({}, r), { value: t.get(n) }))), e => S.createElement(Jse, w7({}, e))), [t]) } const oDe = S.forwardRef(function ({ children: e, fallback: n, resize: r, style: i, gl: a, events: s = GOe, eventSource: o, eventPrefix: c, shadows: u, linear: d, flat: f, legacy: h, orthographic: m, frameloop: g, dpr: x, performance: v, raycaster: b, camera: E, scene: M, onPointerMissed: C, onCreated: N, ...A }, j) { S.useMemo(() => Lse(lOe), []); const O = sDe(), [I, D] = qOe({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }), F = S.useRef(null), B = S.useRef(null); S.useImperativeHandle(j, () => F.current); const G = Bse(C), [z, q] = S.useState(!1), [Y, Z] = S.useState(!1); if (z) throw z; if (Y) throw Y; const $ = S.useRef(null); v_(() => { const K = F.current; D.width > 0 && D.height > 0 && K && ($.current || ($.current = zOe(K)), $.current.configure({ gl: a, events: s, shadows: u, linear: d, flat: f, legacy: h, orthographic: m, frameloop: g, dpr: x, performance: v, raycaster: b, camera: E, scene: M, size: D, onPointerMissed: (...X) => G.current == null ? void 0 : G.current(...X), onCreated: X => { X.events.connect == null || X.events.connect(o ? TOe(o) ? o.current : o : B.current), c && X.setEvents({ compute: (Q, re) => { const ce = Q[c + "X"], be = Q[c + "Y"]; re.pointer.set(ce / re.size.width * 2 - 1, -(be / re.size.height) * 2 + 1), re.raycaster.setFromCamera(re.pointer, re.camera) } }), N?.(X) } }), $.current.render(l.jsx(O, { children: l.jsx($se, { set: Z, children: l.jsx(S.Suspense, { fallback: l.jsx(COe, { set: q }), children: e ?? null }) }) }))) }), S.useEffect(() => { const K = F.current; if (K) return () => Yse(K) }, []); const V = o ? "none" : "auto"; return l.jsx("div", { ref: B, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: V, ...i }, ...A, children: l.jsx("div", { ref: I, style: { width: "100%", height: "100%" }, children: l.jsx("canvas", { ref: F, style: { display: "block" }, children: n }) }) }) }), eoe = S.forwardRef(function (e, n) { return l.jsx(Jse, { children: l.jsx(oDe, { ...e, ref: n }) }) }); function XC() { return XC = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, XC.apply(null, arguments) } const toe = parseInt(n_.replace(/\D+/g, "")); var Ll = Uint8Array, Dh = Uint16Array, n4 = Uint32Array, noe = new Ll([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), roe = new Ll([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), lDe = new Ll([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ioe = function (t, e) { for (var n = new Dh(31), r = 0; r < 31; ++r)n[r] = e += 1 << t[r - 1]; for (var i = new n4(n[30]), r = 1; r < 30; ++r)for (var a = n[r]; a < n[r + 1]; ++a)i[a] = a - n[r] << 5 | r; return [n, i] }, aoe = ioe(noe, 2), soe = aoe[0], cDe = aoe[1]; soe[28] = 258, cDe[258] = 28; var uDe = ioe(roe, 0), dDe = uDe[0], r4 = new Dh(32768); for (var Ti = 0; Ti < 32768; ++Ti) { var _h = (Ti & 43690) >>> 1 | (Ti & 21845) << 1; _h = (_h & 52428) >>> 2 | (_h & 13107) << 2, _h = (_h & 61680) >>> 4 | (_h & 3855) << 4, r4[Ti] = ((_h & 65280) >>> 8 | (_h & 255) << 8) >>> 1 } var e1 = (function (t, e, n) { for (var r = t.length, i = 0, a = new Dh(e); i < r; ++i)++a[t[i] - 1]; var s = new Dh(e); for (i = 0; i < e; ++i)s[i] = s[i - 1] + a[i - 1] << 1; var o; if (n) { o = new Dh(1 << e); var c = 15 - e; for (i = 0; i < r; ++i)if (t[i]) for (var u = i << 4 | t[i], d = e - t[i], f = s[t[i] - 1]++ << d, h = f | (1 << d) - 1; f <= h; ++f)o[r4[f] >>> c] = u } else for (o = new Dh(r), i = 0; i < r; ++i)t[i] && (o[i] = r4[s[t[i] - 1]++] >>> 15 - t[i]); return o }), y_ = new Ll(288); for (var Ti = 0; Ti < 144; ++Ti)y_[Ti] = 8; for (var Ti = 144; Ti < 256; ++Ti)y_[Ti] = 9; for (var Ti = 256; Ti < 280; ++Ti)y_[Ti] = 7; for (var Ti = 280; Ti < 288; ++Ti)y_[Ti] = 8; var ooe = new Ll(32); for (var Ti = 0; Ti < 32; ++Ti)ooe[Ti] = 5; var fDe = e1(y_, 9, 1), hDe = e1(ooe, 5, 1), ok = function (t) { for (var e = t[0], n = 1; n < t.length; ++n)t[n] > e && (e = t[n]); return e }, Tc = function (t, e, n) { var r = e / 8 | 0; return (t[r] | t[r + 1] << 8) >> (e & 7) & n }, lk = function (t, e) { var n = e / 8 | 0; return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (e & 7) }, pDe = function (t) { return (t / 8 | 0) + (t & 7 && 1) }, mDe = function (t, e, n) { (n == null || n > t.length) && (n = t.length); var r = new (t instanceof Dh ? Dh : t instanceof n4 ? n4 : Ll)(n - e); return r.set(t.subarray(e, n)), r }, gDe = function (t, e, n) { var r = t.length; if (!r || n && !n.l && r < 5) return e || new Ll(0); var i = !e || n, a = !n || n.i; n || (n = {}), e || (e = new Ll(r * 3)); var s = function (de) { var ae = e.length; if (de > ae) { var se = new Ll(Math.max(ae * 2, de)); se.set(e), e = se } }, o = n.f || 0, c = n.p || 0, u = n.b || 0, d = n.l, f = n.d, h = n.m, m = n.n, g = r * 8; do { if (!d) { n.f = o = Tc(t, c, 1); var x = Tc(t, c + 1, 3); if (c += 3, x) if (x == 1) d = fDe, f = hDe, h = 9, m = 5; else if (x == 2) { var M = Tc(t, c, 31) + 257, C = Tc(t, c + 10, 15) + 4, N = M + Tc(t, c + 5, 31) + 1; c += 14; for (var A = new Ll(N), j = new Ll(19), O = 0; O < C; ++O)j[lDe[O]] = Tc(t, c + O * 3, 7); c += C * 3; for (var I = ok(j), D = (1 << I) - 1, F = e1(j, I, 1), O = 0; O < N;) { var B = F[Tc(t, c, D)]; c += B & 15; var v = B >>> 4; if (v < 16) A[O++] = v; else { var G = 0, z = 0; for (v == 16 ? (z = 3 + Tc(t, c, 3), c += 2, G = A[O - 1]) : v == 17 ? (z = 3 + Tc(t, c, 7), c += 3) : v == 18 && (z = 11 + Tc(t, c, 127), c += 7); z--;)A[O++] = G } } var q = A.subarray(0, M), Y = A.subarray(M); h = ok(q), m = ok(Y), d = e1(q, h, 1), f = e1(Y, m, 1) } else throw "invalid block type"; else { var v = pDe(c) + 4, b = t[v - 4] | t[v - 3] << 8, E = v + b; if (E > r) { if (a) throw "unexpected EOF"; break } i && s(u + b), e.set(t.subarray(v, E), u), n.b = u += b, n.p = c = E * 8; continue } if (c > g) { if (a) throw "unexpected EOF"; break } } i && s(u + 131072); for (var Z = (1 << h) - 1, $ = (1 << m) - 1, V = c; ; V = c) { var G = d[lk(t, c) & Z], K = G >>> 4; if (c += G & 15, c > g) { if (a) throw "unexpected EOF"; break } if (!G) throw "invalid length/literal"; if (K < 256) e[u++] = K; else if (K == 256) { V = c, d = null; break } else { var X = K - 254; if (K > 264) { var O = K - 257, Q = noe[O]; X = Tc(t, c, (1 << Q) - 1) + soe[O], c += Q } var re = f[lk(t, c) & $], ce = re >>> 4; if (!re) throw "invalid distance"; c += re & 15; var Y = dDe[ce]; if (ce > 3) { var Q = roe[ce]; Y += lk(t, c) & (1 << Q) - 1, c += Q } if (c > g) { if (a) throw "unexpected EOF"; break } i && s(u + 131072); for (var be = u + X; u < be; u += 4)e[u] = e[u - Y], e[u + 1] = e[u + 1 - Y], e[u + 2] = e[u + 2 - Y], e[u + 3] = e[u + 3 - Y]; u = be } } n.l = d, n.p = V, n.b = u, d && (o = 1, n.m = h, n.d = f, n.n = m) } while (!o); return u == e.length ? e : mDe(e, 0, u) }, vDe = new Ll(0), yDe = function (t) { if ((t[0] & 15) != 8 || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31) throw "invalid zlib data"; if (t[1] & 32) throw "invalid zlib data: preset dictionaries not supported" }; function VM(t, e) { return gDe((yDe(t), t.subarray(2, -4)), e) } var xDe = typeof TextDecoder < "u" && new TextDecoder, bDe = 0; try { xDe.decode(vDe, { stream: !0 }), bDe = 1 } catch { } const wDe = t => t && t.isCubeTexture; class SDe extends Bi {
	constructor(e, n) {
		var r, i; const a = wDe(e), o = ((i = a ? (r = e.image[0]) == null ? void 0 : r.width : e.image.width) != null ? i : 1024) / 4, c = Math.floor(Math.log2(o)), u = Math.pow(2, c), d = 3 * Math.max(u, 112), f = 4 * u, h = [a ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1 / d}`, `#define CUBEUV_TEXEL_HEIGHT ${1 / f}`, `#define CUBEUV_MAX_MIP ${c}.0`], m = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `, g = h.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${toe >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `, x = { map: { value: e }, height: { value: n?.height || 15 }, radius: { value: n?.radius || 100 } }, v = new f_(1, 16), b = new Bo({ uniforms: x, fragmentShader: g, vertexShader: m, side: Oc }); super(v, b)
	} set radius(e) { this.material.uniforms.radius.value = e } get radius() { return this.material.uniforms.radius.value } set height(e) { this.material.uniforms.height.value = e } get height() { return this.material.uniforms.height.value }
} var _De = Object.defineProperty, EDe = (t, e, n) => e in t ? _De(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, MDe = (t, e, n) => (EDe(t, e + "", n), n); class TDe { constructor() { MDe(this, "_listeners") } addEventListener(e, n) { this._listeners === void 0 && (this._listeners = {}); const r = this._listeners; r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n) } hasEventListener(e, n) { if (this._listeners === void 0) return !1; const r = this._listeners; return r[e] !== void 0 && r[e].indexOf(n) !== -1 } removeEventListener(e, n) { if (this._listeners === void 0) return; const i = this._listeners[e]; if (i !== void 0) { const a = i.indexOf(n); a !== -1 && i.splice(a, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const r = this._listeners[e.type]; if (r !== void 0) { e.target = this; const i = r.slice(0); for (let a = 0, s = i.length; a < s; a++)i[a].call(this, e); e.target = null } } } var CDe = Object.defineProperty, NDe = (t, e, n) => e in t ? CDe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Nn = (t, e, n) => (NDe(t, typeof e != "symbol" ? e + "" : e, n), n); const HM = new Hg, M7 = new Yd, ADe = Math.cos(70 * (Math.PI / 180)), T7 = (t, e) => (t % e + e) % e; let PDe = class extends TDe { constructor(e, n) { super(), Nn(this, "object"), Nn(this, "domElement"), Nn(this, "enabled", !0), Nn(this, "target", new pe), Nn(this, "minDistance", 0), Nn(this, "maxDistance", 1 / 0), Nn(this, "minZoom", 0), Nn(this, "maxZoom", 1 / 0), Nn(this, "minPolarAngle", 0), Nn(this, "maxPolarAngle", Math.PI), Nn(this, "minAzimuthAngle", -1 / 0), Nn(this, "maxAzimuthAngle", 1 / 0), Nn(this, "enableDamping", !1), Nn(this, "dampingFactor", .05), Nn(this, "enableZoom", !0), Nn(this, "zoomSpeed", 1), Nn(this, "enableRotate", !0), Nn(this, "rotateSpeed", 1), Nn(this, "enablePan", !0), Nn(this, "panSpeed", 1), Nn(this, "screenSpacePanning", !0), Nn(this, "keyPanSpeed", 7), Nn(this, "zoomToCursor", !1), Nn(this, "autoRotate", !1), Nn(this, "autoRotateSpeed", 2), Nn(this, "reverseOrbit", !1), Nn(this, "reverseHorizontalOrbit", !1), Nn(this, "reverseVerticalOrbit", !1), Nn(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), Nn(this, "mouseButtons", { LEFT: Lm.ROTATE, MIDDLE: Lm.DOLLY, RIGHT: Lm.PAN }), Nn(this, "touches", { ONE: Fm.ROTATE, TWO: Fm.DOLLY_PAN }), Nn(this, "target0"), Nn(this, "position0"), Nn(this, "zoom0"), Nn(this, "_domElementKeyEvents", null), Nn(this, "getPolarAngle"), Nn(this, "getAzimuthalAngle"), Nn(this, "setPolarAngle"), Nn(this, "setAzimuthalAngle"), Nn(this, "getDistance"), Nn(this, "getZoomScale"), Nn(this, "listenToKeyEvents"), Nn(this, "stopListenToKeyEvents"), Nn(this, "saveState"), Nn(this, "reset"), Nn(this, "update"), Nn(this, "connect"), Nn(this, "dispose"), Nn(this, "dollyIn"), Nn(this, "dollyOut"), Nn(this, "getScale"), Nn(this, "setScale"), this.object = e, this.domElement = n, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => d.phi, this.getAzimuthalAngle = () => d.theta, this.setPolarAngle = Se => { let Fe = T7(Se, 2 * Math.PI), ht = d.phi; ht < 0 && (ht += 2 * Math.PI), Fe < 0 && (Fe += 2 * Math.PI); let Ee = Math.abs(Fe - ht); 2 * Math.PI - Ee < Ee && (Fe < ht ? Fe += 2 * Math.PI : ht += 2 * Math.PI), f.phi = Fe - ht, r.update() }, this.setAzimuthalAngle = Se => { let Fe = T7(Se, 2 * Math.PI), ht = d.theta; ht < 0 && (ht += 2 * Math.PI), Fe < 0 && (Fe += 2 * Math.PI); let Ee = Math.abs(Fe - ht); 2 * Math.PI - Ee < Ee && (Fe < ht ? Fe += 2 * Math.PI : ht += 2 * Math.PI), f.theta = Fe - ht, r.update() }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = Se => { Se.addEventListener("keydown", Ge), this._domElementKeyEvents = Se }, this.stopListenToKeyEvents = () => { this._domElementKeyEvents.removeEventListener("keydown", Ge), this._domElementKeyEvents = null }, this.saveState = () => { r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom }, this.reset = () => { r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(i), r.update(), c = o.NONE }, this.update = (() => { const Se = new pe, Fe = new pe(0, 1, 0), ht = new As().setFromUnitVectors(e.up, Fe), Ee = ht.clone().invert(), De = new pe, gt = new As, Bt = 2 * Math.PI; return function () { const ot = r.object.position; ht.setFromUnitVectors(e.up, Fe), Ee.copy(ht).invert(), Se.copy(ot).sub(r.target), Se.applyQuaternion(ht), d.setFromVector3(Se), r.autoRotate && c === o.NONE && z(B()), r.enableDamping ? (d.theta += f.theta * r.dampingFactor, d.phi += f.phi * r.dampingFactor) : (d.theta += f.theta, d.phi += f.phi); let it = r.minAzimuthAngle, Ft = r.maxAzimuthAngle; isFinite(it) && isFinite(Ft) && (it < -Math.PI ? it += Bt : it > Math.PI && (it -= Bt), Ft < -Math.PI ? Ft += Bt : Ft > Math.PI && (Ft -= Bt), it <= Ft ? d.theta = Math.max(it, Math.min(Ft, d.theta)) : d.theta = d.theta > (it + Ft) / 2 ? Math.max(it, d.theta) : Math.min(Ft, d.theta)), d.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, d.phi)), d.makeSafe(), r.enableDamping === !0 ? r.target.addScaledVector(m, r.dampingFactor) : r.target.add(m), r.zoomToCursor && I || r.object.isOrthographicCamera ? d.radius = re(d.radius) : d.radius = re(d.radius * h), Se.setFromSpherical(d), Se.applyQuaternion(Ee), ot.copy(r.target).add(Se), r.object.matrixAutoUpdate || r.object.updateMatrix(), r.object.lookAt(r.target), r.enableDamping === !0 ? (f.theta *= 1 - r.dampingFactor, f.phi *= 1 - r.dampingFactor, m.multiplyScalar(1 - r.dampingFactor)) : (f.set(0, 0, 0), m.set(0, 0, 0)); let un = !1; if (r.zoomToCursor && I) { let wn = null; if (r.object instanceof ra && r.object.isPerspectiveCamera) { const wr = Se.length(); wn = re(wr * h); const Tr = wr - wn; r.object.position.addScaledVector(j, Tr), r.object.updateMatrixWorld() } else if (r.object.isOrthographicCamera) { const wr = new pe(O.x, O.y, 0); wr.unproject(r.object), r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / h)), r.object.updateProjectionMatrix(), un = !0; const Tr = new pe(O.x, O.y, 0); Tr.unproject(r.object), r.object.position.sub(Tr).add(wr), r.object.updateMatrixWorld(), wn = Se.length() } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), r.zoomToCursor = !1; wn !== null && (r.screenSpacePanning ? r.target.set(0, 0, -1).transformDirection(r.object.matrix).multiplyScalar(wn).add(r.object.position) : (HM.origin.copy(r.object.position), HM.direction.set(0, 0, -1).transformDirection(r.object.matrix), Math.abs(r.object.up.dot(HM.direction)) < ADe ? e.lookAt(r.target) : (M7.setFromNormalAndCoplanarPoint(r.object.up, r.target), HM.intersectPlane(M7, r.target)))) } else r.object instanceof of && r.object.isOrthographicCamera && (un = h !== 1, un && (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / h)), r.object.updateProjectionMatrix())); return h = 1, I = !1, un || De.distanceToSquared(r.object.position) > u || 8 * (1 - gt.dot(r.object.quaternion)) > u ? (r.dispatchEvent(i), De.copy(r.object.position), gt.copy(r.object.quaternion), un = !1, !0) : !1 } })(), this.connect = Se => { r.domElement = Se, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", Yt), r.domElement.addEventListener("pointerdown", St), r.domElement.addEventListener("pointercancel", ne), r.domElement.addEventListener("wheel", et) }, this.dispose = () => { var Se, Fe, ht, Ee, De, gt; r.domElement && (r.domElement.style.touchAction = "auto"), (Se = r.domElement) == null || Se.removeEventListener("contextmenu", Yt), (Fe = r.domElement) == null || Fe.removeEventListener("pointerdown", St), (ht = r.domElement) == null || ht.removeEventListener("pointercancel", ne), (Ee = r.domElement) == null || Ee.removeEventListener("wheel", et), (De = r.domElement) == null || De.ownerDocument.removeEventListener("pointermove", ee), (gt = r.domElement) == null || gt.ownerDocument.removeEventListener("pointerup", ne), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", Ge) }; const r = this, i = { type: "change" }, a = { type: "start" }, s = { type: "end" }, o = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let c = o.NONE; const u = 1e-6, d = new KL, f = new KL; let h = 1; const m = new pe, g = new lt, x = new lt, v = new lt, b = new lt, E = new lt, M = new lt, C = new lt, N = new lt, A = new lt, j = new pe, O = new lt; let I = !1; const D = [], F = {}; function B() { return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed } function G() { return Math.pow(.95, r.zoomSpeed) } function z(Se) { r.reverseOrbit || r.reverseHorizontalOrbit ? f.theta += Se : f.theta -= Se } function q(Se) { r.reverseOrbit || r.reverseVerticalOrbit ? f.phi += Se : f.phi -= Se } const Y = (() => { const Se = new pe; return function (ht, Ee) { Se.setFromMatrixColumn(Ee, 0), Se.multiplyScalar(-ht), m.add(Se) } })(), Z = (() => { const Se = new pe; return function (ht, Ee) { r.screenSpacePanning === !0 ? Se.setFromMatrixColumn(Ee, 1) : (Se.setFromMatrixColumn(Ee, 0), Se.crossVectors(r.object.up, Se)), Se.multiplyScalar(ht), m.add(Se) } })(), $ = (() => { const Se = new pe; return function (ht, Ee) { const De = r.domElement; if (De && r.object instanceof ra && r.object.isPerspectiveCamera) { const gt = r.object.position; Se.copy(gt).sub(r.target); let Bt = Se.length(); Bt *= Math.tan(r.object.fov / 2 * Math.PI / 180), Y(2 * ht * Bt / De.clientHeight, r.object.matrix), Z(2 * Ee * Bt / De.clientHeight, r.object.matrix) } else De && r.object instanceof of && r.object.isOrthographicCamera ? (Y(ht * (r.object.right - r.object.left) / r.object.zoom / De.clientWidth, r.object.matrix), Z(Ee * (r.object.top - r.object.bottom) / r.object.zoom / De.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1) } })(); function V(Se) { r.object instanceof ra && r.object.isPerspectiveCamera || r.object instanceof of && r.object.isOrthographicCamera ? h = Se : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function K(Se) { V(h / Se) } function X(Se) { V(h * Se) } function Q(Se) { if (!r.zoomToCursor || !r.domElement) return; I = !0; const Fe = r.domElement.getBoundingClientRect(), ht = Se.clientX - Fe.left, Ee = Se.clientY - Fe.top, De = Fe.width, gt = Fe.height; O.x = ht / De * 2 - 1, O.y = -(Ee / gt) * 2 + 1, j.set(O.x, O.y, 1).unproject(r.object).sub(r.object.position).normalize() } function re(Se) { return Math.max(r.minDistance, Math.min(r.maxDistance, Se)) } function ce(Se) { g.set(Se.clientX, Se.clientY) } function be(Se) { Q(Se), C.set(Se.clientX, Se.clientY) } function de(Se) { b.set(Se.clientX, Se.clientY) } function ae(Se) { x.set(Se.clientX, Se.clientY), v.subVectors(x, g).multiplyScalar(r.rotateSpeed); const Fe = r.domElement; Fe && (z(2 * Math.PI * v.x / Fe.clientHeight), q(2 * Math.PI * v.y / Fe.clientHeight)), g.copy(x), r.update() } function se(Se) { N.set(Se.clientX, Se.clientY), A.subVectors(N, C), A.y > 0 ? K(G()) : A.y < 0 && X(G()), C.copy(N), r.update() } function he(Se) { E.set(Se.clientX, Se.clientY), M.subVectors(E, b).multiplyScalar(r.panSpeed), $(M.x, M.y), b.copy(E), r.update() } function Ae(Se) { Q(Se), Se.deltaY < 0 ? X(G()) : Se.deltaY > 0 && K(G()), r.update() } function Ce(Se) { let Fe = !1; switch (Se.code) { case r.keys.UP: $(0, r.keyPanSpeed), Fe = !0; break; case r.keys.BOTTOM: $(0, -r.keyPanSpeed), Fe = !0; break; case r.keys.LEFT: $(r.keyPanSpeed, 0), Fe = !0; break; case r.keys.RIGHT: $(-r.keyPanSpeed, 0), Fe = !0; break }Fe && (Se.preventDefault(), r.update()) } function fe() { if (D.length == 1) g.set(D[0].pageX, D[0].pageY); else { const Se = .5 * (D[0].pageX + D[1].pageX), Fe = .5 * (D[0].pageY + D[1].pageY); g.set(Se, Fe) } } function oe() { if (D.length == 1) b.set(D[0].pageX, D[0].pageY); else { const Se = .5 * (D[0].pageX + D[1].pageX), Fe = .5 * (D[0].pageY + D[1].pageY); b.set(Se, Fe) } } function xe() { const Se = D[0].pageX - D[1].pageX, Fe = D[0].pageY - D[1].pageY, ht = Math.sqrt(Se * Se + Fe * Fe); C.set(0, ht) } function _e() { r.enableZoom && xe(), r.enablePan && oe() } function je() { r.enableZoom && xe(), r.enableRotate && fe() } function ke(Se) { if (D.length == 1) x.set(Se.pageX, Se.pageY); else { const ht = pn(Se), Ee = .5 * (Se.pageX + ht.x), De = .5 * (Se.pageY + ht.y); x.set(Ee, De) } v.subVectors(x, g).multiplyScalar(r.rotateSpeed); const Fe = r.domElement; Fe && (z(2 * Math.PI * v.x / Fe.clientHeight), q(2 * Math.PI * v.y / Fe.clientHeight)), g.copy(x) } function Ze(Se) { if (D.length == 1) E.set(Se.pageX, Se.pageY); else { const Fe = pn(Se), ht = .5 * (Se.pageX + Fe.x), Ee = .5 * (Se.pageY + Fe.y); E.set(ht, Ee) } M.subVectors(E, b).multiplyScalar(r.panSpeed), $(M.x, M.y), b.copy(E) } function Xe(Se) { const Fe = pn(Se), ht = Se.pageX - Fe.x, Ee = Se.pageY - Fe.y, De = Math.sqrt(ht * ht + Ee * Ee); N.set(0, De), A.set(0, Math.pow(N.y / C.y, r.zoomSpeed)), K(A.y), C.copy(N) } function nt(Se) { r.enableZoom && Xe(Se), r.enablePan && Ze(Se) } function Tt(Se) { r.enableZoom && Xe(Se), r.enableRotate && ke(Se) } function St(Se) { var Fe, ht; r.enabled !== !1 && (D.length === 0 && ((Fe = r.domElement) == null || Fe.ownerDocument.addEventListener("pointermove", ee), (ht = r.domElement) == null || ht.ownerDocument.addEventListener("pointerup", ne)), en(Se), Se.pointerType === "touch" ? Xt(Se) : Re(Se)) } function ee(Se) { r.enabled !== !1 && (Se.pointerType === "touch" ? yt(Se) : Ue(Se)) } function ne(Se) { var Fe, ht, Ee; pt(Se), D.length === 0 && ((Fe = r.domElement) == null || Fe.releasePointerCapture(Se.pointerId), (ht = r.domElement) == null || ht.ownerDocument.removeEventListener("pointermove", ee), (Ee = r.domElement) == null || Ee.ownerDocument.removeEventListener("pointerup", ne)), r.dispatchEvent(s), c = o.NONE } function Re(Se) { let Fe; switch (Se.button) { case 0: Fe = r.mouseButtons.LEFT; break; case 1: Fe = r.mouseButtons.MIDDLE; break; case 2: Fe = r.mouseButtons.RIGHT; break; default: Fe = -1 }switch (Fe) { case Lm.DOLLY: if (r.enableZoom === !1) return; be(Se), c = o.DOLLY; break; case Lm.ROTATE: if (Se.ctrlKey || Se.metaKey || Se.shiftKey) { if (r.enablePan === !1) return; de(Se), c = o.PAN } else { if (r.enableRotate === !1) return; ce(Se), c = o.ROTATE } break; case Lm.PAN: if (Se.ctrlKey || Se.metaKey || Se.shiftKey) { if (r.enableRotate === !1) return; ce(Se), c = o.ROTATE } else { if (r.enablePan === !1) return; de(Se), c = o.PAN } break; default: c = o.NONE }c !== o.NONE && r.dispatchEvent(a) } function Ue(Se) { if (r.enabled !== !1) switch (c) { case o.ROTATE: if (r.enableRotate === !1) return; ae(Se); break; case o.DOLLY: if (r.enableZoom === !1) return; se(Se); break; case o.PAN: if (r.enablePan === !1) return; he(Se); break } } function et(Se) { r.enabled === !1 || r.enableZoom === !1 || c !== o.NONE && c !== o.ROTATE || (Se.preventDefault(), r.dispatchEvent(a), Ae(Se), r.dispatchEvent(s)) } function Ge(Se) { r.enabled === !1 || r.enablePan === !1 || Ce(Se) } function Xt(Se) { switch (bt(Se), D.length) { case 1: switch (r.touches.ONE) { case Fm.ROTATE: if (r.enableRotate === !1) return; fe(), c = o.TOUCH_ROTATE; break; case Fm.PAN: if (r.enablePan === !1) return; oe(), c = o.TOUCH_PAN; break; default: c = o.NONE }break; case 2: switch (r.touches.TWO) { case Fm.DOLLY_PAN: if (r.enableZoom === !1 && r.enablePan === !1) return; _e(), c = o.TOUCH_DOLLY_PAN; break; case Fm.DOLLY_ROTATE: if (r.enableZoom === !1 && r.enableRotate === !1) return; je(), c = o.TOUCH_DOLLY_ROTATE; break; default: c = o.NONE }break; default: c = o.NONE }c !== o.NONE && r.dispatchEvent(a) } function yt(Se) { switch (bt(Se), c) { case o.TOUCH_ROTATE: if (r.enableRotate === !1) return; ke(Se), r.update(); break; case o.TOUCH_PAN: if (r.enablePan === !1) return; Ze(Se), r.update(); break; case o.TOUCH_DOLLY_PAN: if (r.enableZoom === !1 && r.enablePan === !1) return; nt(Se), r.update(); break; case o.TOUCH_DOLLY_ROTATE: if (r.enableZoom === !1 && r.enableRotate === !1) return; Tt(Se), r.update(); break; default: c = o.NONE } } function Yt(Se) { r.enabled !== !1 && Se.preventDefault() } function en(Se) { D.push(Se) } function pt(Se) { delete F[Se.pointerId]; for (let Fe = 0; Fe < D.length; Fe++)if (D[Fe].pointerId == Se.pointerId) { D.splice(Fe, 1); return } } function bt(Se) { let Fe = F[Se.pointerId]; Fe === void 0 && (Fe = new lt, F[Se.pointerId] = Fe), Fe.set(Se.pageX, Se.pageY) } function pn(Se) { const Fe = Se.pointerId === D[0].pointerId ? D[1] : D[0]; return F[Fe.pointerId] } this.dollyIn = (Se = G()) => { X(Se), r.update() }, this.dollyOut = (Se = G()) => { K(Se), r.update() }, this.getScale = () => h, this.setScale = Se => { V(Se), r.update() }, this.getZoomScale = () => G(), n !== void 0 && this.connect(n), this.update() } }; class jDe extends wB {
	constructor(e) { super(e), this.type = Ya } parse(e) {
		const s = function (O, I) { switch (O) { case 1: throw new Error("THREE.RGBELoader: Read Error: " + (I || "")); case 2: throw new Error("THREE.RGBELoader: Write Error: " + (I || "")); case 3: throw new Error("THREE.RGBELoader: Bad File Format: " + (I || "")); default: case 4: throw new Error("THREE.RGBELoader: Memory Error: " + (I || "")) } }, f = function (O, I, D) {
			I = I || 1024; let B = O.pos, G = -1, z = 0, q = "", Y = String.fromCharCode.apply(null, new Uint16Array(O.subarray(B, B + 128))); for (; 0 > (G = Y.indexOf(`
`)) && z < I && B < O.byteLength;)q += Y, z += Y.length, B += 128, Y += String.fromCharCode.apply(null, new Uint16Array(O.subarray(B, B + 128))); return -1 < G ? (O.pos += z + G + 1, q + Y.slice(0, G)) : !1
		}, h = function (O) {
			const I = /^#\?(\S+)/, D = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, F = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, B = /^\s*FORMAT=(\S+)\s*$/, G = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, z = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 }; let q, Y; for ((O.pos >= O.byteLength || !(q = f(O))) && s(1, "no header found"), (Y = q.match(I)) || s(3, "bad initial token"), z.valid |= 1, z.programtype = Y[1], z.string += q + `
`; q = f(O), q !== !1;) {
				if (z.string += q + `
`, q.charAt(0) === "#") {
					z.comments += q + `
`; continue
				} if ((Y = q.match(D)) && (z.gamma = parseFloat(Y[1])), (Y = q.match(F)) && (z.exposure = parseFloat(Y[1])), (Y = q.match(B)) && (z.valid |= 2, z.format = Y[1]), (Y = q.match(G)) && (z.valid |= 4, z.height = parseInt(Y[1], 10), z.width = parseInt(Y[2], 10)), z.valid & 2 && z.valid & 4) break
			} return z.valid & 2 || s(3, "missing format specifier"), z.valid & 4 || s(3, "missing image size specifier"), z
		}, m = function (O, I, D) { const F = I; if (F < 8 || F > 32767 || O[0] !== 2 || O[1] !== 2 || O[2] & 128) return new Uint8Array(O); F !== (O[2] << 8 | O[3]) && s(3, "wrong scanline width"); const B = new Uint8Array(4 * I * D); B.length || s(4, "unable to allocate buffer space"); let G = 0, z = 0; const q = 4 * F, Y = new Uint8Array(4), Z = new Uint8Array(q); let $ = D; for (; $ > 0 && z < O.byteLength;) { z + 4 > O.byteLength && s(1), Y[0] = O[z++], Y[1] = O[z++], Y[2] = O[z++], Y[3] = O[z++], (Y[0] != 2 || Y[1] != 2 || (Y[2] << 8 | Y[3]) != F) && s(3, "bad rgbe scanline format"); let V = 0, K; for (; V < q && z < O.byteLength;) { K = O[z++]; const Q = K > 128; if (Q && (K -= 128), (K === 0 || V + K > q) && s(3, "bad scanline data"), Q) { const re = O[z++]; for (let ce = 0; ce < K; ce++)Z[V++] = re } else Z.set(O.subarray(z, z + K), V), V += K, z += K } const X = F; for (let Q = 0; Q < X; Q++) { let re = 0; B[G] = Z[Q + re], re += F, B[G + 1] = Z[Q + re], re += F, B[G + 2] = Z[Q + re], re += F, B[G + 3] = Z[Q + re], G += 4 } $-- } return B }, g = function (O, I, D, F) { const B = O[I + 3], G = Math.pow(2, B - 128) / 255; D[F + 0] = O[I + 0] * G, D[F + 1] = O[I + 1] * G, D[F + 2] = O[I + 2] * G, D[F + 3] = 1 }, x = function (O, I, D, F) { const B = O[I + 3], G = Math.pow(2, B - 128) / 255; D[F + 0] = Zm.toHalfFloat(Math.min(O[I + 0] * G, 65504)), D[F + 1] = Zm.toHalfFloat(Math.min(O[I + 1] * G, 65504)), D[F + 2] = Zm.toHalfFloat(Math.min(O[I + 2] * G, 65504)), D[F + 3] = Zm.toHalfFloat(1) }, v = new Uint8Array(e); v.pos = 0; const b = h(v), E = b.width, M = b.height, C = m(v.subarray(v.pos), E, M); let N, A, j; switch (this.type) { case Ui: j = C.length / 4; const O = new Float32Array(j * 4); for (let D = 0; D < j; D++)g(C, D * 4, O, D * 4); N = O, A = Ui; break; case Ya: j = C.length / 4; const I = new Uint16Array(j * 4); for (let D = 0; D < j; D++)x(C, D * 4, I, D * 4); N = I, A = Ya; break; default: throw new Error("THREE.RGBELoader: Unsupported type: " + this.type) }return { width: E, height: M, data: N, header: b.string, gamma: b.gamma, exposure: b.exposure, type: A }
	} setDataType(e) { return this.type = e, this } load(e, n, r, i) { function a(s, o) { switch (s.type) { case Ui: case Ya: "colorSpace" in s ? s.colorSpace = "srgb-linear" : s.encoding = 3e3, s.minFilter = Xr, s.magFilter = Xr, s.generateMipmaps = !1, s.flipY = !0; break }n && n(s, o) } return super.load(e, a, r, i) }
} const dw = toe >= 152; class RDe extends wB { constructor(e) { super(e), this.type = Ya } parse(e) { const I = Math.pow(2.7182818, 2.2); function D(ie, ue) { for (var Ne = 0, He = 0; He < 65536; ++He)(He == 0 || ie[He >> 3] & 1 << (He & 7)) && (ue[Ne++] = He); for (var Qe = Ne - 1; Ne < 65536;)ue[Ne++] = 0; return Qe } function F(ie) { for (var ue = 0; ue < 16384; ue++)ie[ue] = {}, ie[ue].len = 0, ie[ue].lit = 0, ie[ue].p = null } const B = { l: 0, c: 0, lc: 0 }; function G(ie, ue, Ne, He, Qe) { for (; Ne < ie;)ue = ue << 8 | pn(He, Qe), Ne += 8; Ne -= ie, B.l = ue >> Ne & (1 << ie) - 1, B.c = ue, B.lc = Ne } const z = new Array(59); function q(ie) { for (var ue = 0; ue <= 58; ++ue)z[ue] = 0; for (var ue = 0; ue < 65537; ++ue)z[ie[ue]] += 1; for (var Ne = 0, ue = 58; ue > 0; --ue) { var He = Ne + z[ue] >> 1; z[ue] = Ne, Ne = He } for (var ue = 0; ue < 65537; ++ue) { var Qe = ie[ue]; Qe > 0 && (ie[ue] = Qe | z[Qe]++ << 6) } } function Y(ie, ue, Ne, He, Qe, Je, Nt) { for (var te = Ne, ye = 0, Me = 0; Qe <= Je; Qe++) { if (te.value - Ne.value > He) return !1; G(6, ye, Me, ie, te); var Te = B.l; if (ye = B.c, Me = B.lc, Nt[Qe] = Te, Te == 63) { if (te.value - Ne.value > He) throw "Something wrong with hufUnpackEncTable"; G(8, ye, Me, ie, te); var ge = B.l + 6; if (ye = B.c, Me = B.lc, Qe + ge > Je + 1) throw "Something wrong with hufUnpackEncTable"; for (; ge--;)Nt[Qe++] = 0; Qe-- } else if (Te >= 59) { var ge = Te - 59 + 2; if (Qe + ge > Je + 1) throw "Something wrong with hufUnpackEncTable"; for (; ge--;)Nt[Qe++] = 0; Qe-- } } q(Nt) } function Z(ie) { return ie & 63 } function $(ie) { return ie >> 6 } function V(ie, ue, Ne, He) { for (; ue <= Ne; ue++) { var Qe = $(ie[ue]), Je = Z(ie[ue]); if (Qe >> Je) throw "Invalid table entry"; if (Je > 14) { var Nt = He[Qe >> Je - 14]; if (Nt.len) throw "Invalid table entry"; if (Nt.lit++, Nt.p) { var te = Nt.p; Nt.p = new Array(Nt.lit); for (var ye = 0; ye < Nt.lit - 1; ++ye)Nt.p[ye] = te[ye] } else Nt.p = new Array(1); Nt.p[Nt.lit - 1] = ue } else if (Je) for (var Me = 0, ye = 1 << 14 - Je; ye > 0; ye--) { var Nt = He[(Qe << 14 - Je) + Me]; if (Nt.len || Nt.p) throw "Invalid table entry"; Nt.len = Je, Nt.lit = ue, Me++ } } return !0 } const K = { c: 0, lc: 0 }; function X(ie, ue, Ne, He) { ie = ie << 8 | pn(Ne, He), ue += 8, K.c = ie, K.lc = ue } const Q = { c: 0, lc: 0 }; function re(ie, ue, Ne, He, Qe, Je, Nt, te, ye, Me) { if (ie == ue) { He < 8 && (X(Ne, He, Qe, Nt), Ne = K.c, He = K.lc), He -= 8; var Te = Ne >> He, Te = new Uint8Array([Te])[0]; if (ye.value + Te > Me) return !1; for (var ge = te[ye.value - 1]; Te-- > 0;)te[ye.value++] = ge } else if (ye.value < Me) te[ye.value++] = ie; else return !1; Q.c = Ne, Q.lc = He } function ce(ie) { return ie & 65535 } function be(ie) { var ue = ce(ie); return ue > 32767 ? ue - 65536 : ue } const de = { a: 0, b: 0 }; function ae(ie, ue) { var Ne = be(ie), He = be(ue), Qe = He, Je = Ne + (Qe & 1) + (Qe >> 1), Nt = Je, te = Je - Qe; de.a = Nt, de.b = te } function se(ie, ue) { var Ne = ce(ie), He = ce(ue), Qe = Ne - (He >> 1) & 65535, Je = He + Qe - 32768 & 65535; de.a = Je, de.b = Qe } function he(ie, ue, Ne, He, Qe, Je, Nt) { for (var te = Nt < 16384, ye = Ne > Qe ? Qe : Ne, Me = 1, Te; Me <= ye;)Me <<= 1; for (Me >>= 1, Te = Me, Me >>= 1; Me >= 1;) { for (var ge = 0, at = ge + Je * (Qe - Te), Ke = Je * Me, st = Je * Te, ft = He * Me, At = He * Te, $t, Pt, kt, Zt; ge <= at; ge += st) { for (var tn = ge, _n = ge + He * (Ne - Te); tn <= _n; tn += At) { var nn = tn + ft, Vt = tn + Ke, Vn = Vt + ft; te ? (ae(ie[tn + ue], ie[Vt + ue]), $t = de.a, kt = de.b, ae(ie[nn + ue], ie[Vn + ue]), Pt = de.a, Zt = de.b, ae($t, Pt), ie[tn + ue] = de.a, ie[nn + ue] = de.b, ae(kt, Zt), ie[Vt + ue] = de.a, ie[Vn + ue] = de.b) : (se(ie[tn + ue], ie[Vt + ue]), $t = de.a, kt = de.b, se(ie[nn + ue], ie[Vn + ue]), Pt = de.a, Zt = de.b, se($t, Pt), ie[tn + ue] = de.a, ie[nn + ue] = de.b, se(kt, Zt), ie[Vt + ue] = de.a, ie[Vn + ue] = de.b) } if (Ne & Me) { var Vt = tn + Ke; te ? ae(ie[tn + ue], ie[Vt + ue]) : se(ie[tn + ue], ie[Vt + ue]), $t = de.a, ie[Vt + ue] = de.b, ie[tn + ue] = $t } } if (Qe & Me) for (var tn = ge, _n = ge + He * (Ne - Te); tn <= _n; tn += At) { var nn = tn + ft; te ? ae(ie[tn + ue], ie[nn + ue]) : se(ie[tn + ue], ie[nn + ue]), $t = de.a, ie[nn + ue] = de.b, ie[tn + ue] = $t } Te = Me, Me >>= 1 } return ge } function Ae(ie, ue, Ne, He, Qe, Je, Nt, te, ye, Me) { for (var Te = 0, ge = 0, at = te, Ke = Math.trunc(Qe.value + (Je + 7) / 8); Qe.value < Ke;)for (X(Te, ge, Ne, Qe), Te = K.c, ge = K.lc; ge >= 14;) { var st = Te >> ge - 14 & 16383, ft = ue[st]; if (ft.len) ge -= ft.len, re(ft.lit, Nt, Te, ge, Ne, He, Qe, ye, Me, at), Te = Q.c, ge = Q.lc; else { if (!ft.p) throw "hufDecode issues"; var At; for (At = 0; At < ft.lit; At++) { for (var $t = Z(ie[ft.p[At]]); ge < $t && Qe.value < Ke;)X(Te, ge, Ne, Qe), Te = K.c, ge = K.lc; if (ge >= $t && $(ie[ft.p[At]]) == (Te >> ge - $t & (1 << $t) - 1)) { ge -= $t, re(ft.p[At], Nt, Te, ge, Ne, He, Qe, ye, Me, at), Te = Q.c, ge = Q.lc; break } } if (At == ft.lit) throw "hufDecode issues" } } var Pt = 8 - Je & 7; for (Te >>= Pt, ge -= Pt; ge > 0;) { var ft = ue[Te << 14 - ge & 16383]; if (ft.len) ge -= ft.len, re(ft.lit, Nt, Te, ge, Ne, He, Qe, ye, Me, at), Te = Q.c, ge = Q.lc; else throw "hufDecode issues" } return !0 } function Ce(ie, ue, Ne, He, Qe, Je) { var Nt = { value: 0 }, te = Ne.value, ye = bt(ue, Ne), Me = bt(ue, Ne); Ne.value += 4; var Te = bt(ue, Ne); if (Ne.value += 4, ye < 0 || ye >= 65537 || Me < 0 || Me >= 65537) throw "Something wrong with HUF_ENCSIZE"; var ge = new Array(65537), at = new Array(16384); F(at); var Ke = He - (Ne.value - te); if (Y(ie, ue, Ne, Ke, ye, Me, ge), Te > 8 * (He - (Ne.value - te))) throw "Something wrong with hufUncompress"; V(ge, ye, Me, at), Ae(ge, at, ie, ue, Ne, Te, Me, Je, Qe, Nt) } function fe(ie, ue, Ne) { for (var He = 0; He < Ne; ++He)ue[He] = ie[ue[He]] } function oe(ie) { for (var ue = 1; ue < ie.length; ue++) { var Ne = ie[ue - 1] + ie[ue] - 128; ie[ue] = Ne } } function xe(ie, ue) { for (var Ne = 0, He = Math.floor((ie.length + 1) / 2), Qe = 0, Je = ie.length - 1; !(Qe > Je || (ue[Qe++] = ie[Ne++], Qe > Je));)ue[Qe++] = ie[He++] } function _e(ie) { for (var ue = ie.byteLength, Ne = new Array, He = 0, Qe = new DataView(ie); ue > 0;) { var Je = Qe.getInt8(He++); if (Je < 0) { var Nt = -Je; ue -= Nt + 1; for (var te = 0; te < Nt; te++)Ne.push(Qe.getUint8(He++)) } else { var Nt = Je; ue -= 2; for (var ye = Qe.getUint8(He++), te = 0; te < Nt + 1; te++)Ne.push(ye) } } return Ne } function je(ie, ue, Ne, He, Qe, Je) { var nn = new DataView(Je.buffer), Nt = Ne[ie.idx[0]].width, te = Ne[ie.idx[0]].height, ye = 3, Me = Math.floor(Nt / 8), Te = Math.ceil(Nt / 8), ge = Math.ceil(te / 8), at = Nt - (Te - 1) * 8, Ke = te - (ge - 1) * 8, st = { value: 0 }, ft = new Array(ye), At = new Array(ye), $t = new Array(ye), Pt = new Array(ye), kt = new Array(ye); for (let tr = 0; tr < ye; ++tr)kt[tr] = ue[ie.idx[tr]], ft[tr] = tr < 1 ? 0 : ft[tr - 1] + Te * ge, At[tr] = new Float32Array(64), $t[tr] = new Uint16Array(64), Pt[tr] = new Uint16Array(Te * 64); for (let tr = 0; tr < ge; ++tr) { var Zt = 8; tr == ge - 1 && (Zt = Ke); var tn = 8; for (let vr = 0; vr < Te; ++vr) { vr == Te - 1 && (tn = at); for (let yn = 0; yn < ye; ++yn)$t[yn].fill(0), $t[yn][0] = Qe[ft[yn]++], ke(st, He, $t[yn]), Ze($t[yn], At[yn]), Xe(At[yn]); nt(At); for (let yn = 0; yn < ye; ++yn)Tt(At[yn], Pt[yn], vr * 64) } let Sr = 0; for (let vr = 0; vr < ye; ++vr) { const yn = Ne[ie.idx[vr]].type; for (let ur = 8 * tr; ur < 8 * tr + Zt; ++ur) { Sr = kt[vr][ur]; for (let di = 0; di < Me; ++di) { const yr = di * 64 + (ur & 7) * 8; nn.setUint16(Sr + 0 * yn, Pt[vr][yr + 0], !0), nn.setUint16(Sr + 2 * yn, Pt[vr][yr + 1], !0), nn.setUint16(Sr + 4 * yn, Pt[vr][yr + 2], !0), nn.setUint16(Sr + 6 * yn, Pt[vr][yr + 3], !0), nn.setUint16(Sr + 8 * yn, Pt[vr][yr + 4], !0), nn.setUint16(Sr + 10 * yn, Pt[vr][yr + 5], !0), nn.setUint16(Sr + 12 * yn, Pt[vr][yr + 6], !0), nn.setUint16(Sr + 14 * yn, Pt[vr][yr + 7], !0), Sr += 16 * yn } } if (Me != Te) for (let ur = 8 * tr; ur < 8 * tr + Zt; ++ur) { const di = kt[vr][ur] + 8 * Me * 2 * yn, yr = Me * 64 + (ur & 7) * 8; for (let ri = 0; ri < tn; ++ri)nn.setUint16(di + ri * 2 * yn, Pt[vr][yr + ri], !0) } } } for (var _n = new Uint16Array(Nt), nn = new DataView(Je.buffer), Vt = 0; Vt < ye; ++Vt) { Ne[ie.idx[Vt]].decoded = !0; var Vn = Ne[ie.idx[Vt]].type; if (Ne[Vt].type == 2) for (var bn = 0; bn < te; ++bn) { const tr = kt[Vt][bn]; for (var gr = 0; gr < Nt; ++gr)_n[gr] = nn.getUint16(tr + gr * 2 * Vn, !0); for (var gr = 0; gr < Nt; ++gr)nn.setFloat32(tr + gr * 2 * Vn, De(_n[gr]), !0) } } } function ke(ie, ue, Ne) { for (var He, Qe = 1; Qe < 64;)He = ue[ie.value], He == 65280 ? Qe = 64 : He >> 8 == 255 ? Qe += He & 255 : (Ne[Qe] = He, Qe++), ie.value++ } function Ze(ie, ue) { ue[0] = De(ie[0]), ue[1] = De(ie[1]), ue[2] = De(ie[5]), ue[3] = De(ie[6]), ue[4] = De(ie[14]), ue[5] = De(ie[15]), ue[6] = De(ie[27]), ue[7] = De(ie[28]), ue[8] = De(ie[2]), ue[9] = De(ie[4]), ue[10] = De(ie[7]), ue[11] = De(ie[13]), ue[12] = De(ie[16]), ue[13] = De(ie[26]), ue[14] = De(ie[29]), ue[15] = De(ie[42]), ue[16] = De(ie[3]), ue[17] = De(ie[8]), ue[18] = De(ie[12]), ue[19] = De(ie[17]), ue[20] = De(ie[25]), ue[21] = De(ie[30]), ue[22] = De(ie[41]), ue[23] = De(ie[43]), ue[24] = De(ie[9]), ue[25] = De(ie[11]), ue[26] = De(ie[18]), ue[27] = De(ie[24]), ue[28] = De(ie[31]), ue[29] = De(ie[40]), ue[30] = De(ie[44]), ue[31] = De(ie[53]), ue[32] = De(ie[10]), ue[33] = De(ie[19]), ue[34] = De(ie[23]), ue[35] = De(ie[32]), ue[36] = De(ie[39]), ue[37] = De(ie[45]), ue[38] = De(ie[52]), ue[39] = De(ie[54]), ue[40] = De(ie[20]), ue[41] = De(ie[22]), ue[42] = De(ie[33]), ue[43] = De(ie[38]), ue[44] = De(ie[46]), ue[45] = De(ie[51]), ue[46] = De(ie[55]), ue[47] = De(ie[60]), ue[48] = De(ie[21]), ue[49] = De(ie[34]), ue[50] = De(ie[37]), ue[51] = De(ie[47]), ue[52] = De(ie[50]), ue[53] = De(ie[56]), ue[54] = De(ie[59]), ue[55] = De(ie[61]), ue[56] = De(ie[35]), ue[57] = De(ie[36]), ue[58] = De(ie[48]), ue[59] = De(ie[49]), ue[60] = De(ie[57]), ue[61] = De(ie[58]), ue[62] = De(ie[62]), ue[63] = De(ie[63]) } function Xe(ie) { const ue = .5 * Math.cos(.7853975), Ne = .5 * Math.cos(3.14159 / 16), He = .5 * Math.cos(3.14159 / 8), Qe = .5 * Math.cos(3 * 3.14159 / 16), Je = .5 * Math.cos(5 * 3.14159 / 16), Nt = .5 * Math.cos(3 * 3.14159 / 8), te = .5 * Math.cos(7 * 3.14159 / 16); for (var ye = new Array(4), Me = new Array(4), Te = new Array(4), ge = new Array(4), at = 0; at < 8; ++at) { var Ke = at * 8; ye[0] = He * ie[Ke + 2], ye[1] = Nt * ie[Ke + 2], ye[2] = He * ie[Ke + 6], ye[3] = Nt * ie[Ke + 6], Me[0] = Ne * ie[Ke + 1] + Qe * ie[Ke + 3] + Je * ie[Ke + 5] + te * ie[Ke + 7], Me[1] = Qe * ie[Ke + 1] - te * ie[Ke + 3] - Ne * ie[Ke + 5] - Je * ie[Ke + 7], Me[2] = Je * ie[Ke + 1] - Ne * ie[Ke + 3] + te * ie[Ke + 5] + Qe * ie[Ke + 7], Me[3] = te * ie[Ke + 1] - Je * ie[Ke + 3] + Qe * ie[Ke + 5] - Ne * ie[Ke + 7], Te[0] = ue * (ie[Ke + 0] + ie[Ke + 4]), Te[3] = ue * (ie[Ke + 0] - ie[Ke + 4]), Te[1] = ye[0] + ye[3], Te[2] = ye[1] - ye[2], ge[0] = Te[0] + Te[1], ge[1] = Te[3] + Te[2], ge[2] = Te[3] - Te[2], ge[3] = Te[0] - Te[1], ie[Ke + 0] = ge[0] + Me[0], ie[Ke + 1] = ge[1] + Me[1], ie[Ke + 2] = ge[2] + Me[2], ie[Ke + 3] = ge[3] + Me[3], ie[Ke + 4] = ge[3] - Me[3], ie[Ke + 5] = ge[2] - Me[2], ie[Ke + 6] = ge[1] - Me[1], ie[Ke + 7] = ge[0] - Me[0] } for (var st = 0; st < 8; ++st)ye[0] = He * ie[16 + st], ye[1] = Nt * ie[16 + st], ye[2] = He * ie[48 + st], ye[3] = Nt * ie[48 + st], Me[0] = Ne * ie[8 + st] + Qe * ie[24 + st] + Je * ie[40 + st] + te * ie[56 + st], Me[1] = Qe * ie[8 + st] - te * ie[24 + st] - Ne * ie[40 + st] - Je * ie[56 + st], Me[2] = Je * ie[8 + st] - Ne * ie[24 + st] + te * ie[40 + st] + Qe * ie[56 + st], Me[3] = te * ie[8 + st] - Je * ie[24 + st] + Qe * ie[40 + st] - Ne * ie[56 + st], Te[0] = ue * (ie[st] + ie[32 + st]), Te[3] = ue * (ie[st] - ie[32 + st]), Te[1] = ye[0] + ye[3], Te[2] = ye[1] - ye[2], ge[0] = Te[0] + Te[1], ge[1] = Te[3] + Te[2], ge[2] = Te[3] - Te[2], ge[3] = Te[0] - Te[1], ie[0 + st] = ge[0] + Me[0], ie[8 + st] = ge[1] + Me[1], ie[16 + st] = ge[2] + Me[2], ie[24 + st] = ge[3] + Me[3], ie[32 + st] = ge[3] - Me[3], ie[40 + st] = ge[2] - Me[2], ie[48 + st] = ge[1] - Me[1], ie[56 + st] = ge[0] - Me[0] } function nt(ie) { for (var ue = 0; ue < 64; ++ue) { var Ne = ie[0][ue], He = ie[1][ue], Qe = ie[2][ue]; ie[0][ue] = Ne + 1.5747 * Qe, ie[1][ue] = Ne - .1873 * He - .4682 * Qe, ie[2][ue] = Ne + 1.8556 * He } } function Tt(ie, ue, Ne) { for (var He = 0; He < 64; ++He)ue[Ne + He] = Zm.toHalfFloat(St(ie[He])) } function St(ie) { return ie <= 1 ? Math.sign(ie) * Math.pow(Math.abs(ie), 2.2) : Math.sign(ie) * Math.pow(I, Math.abs(ie) - 1) } function ee(ie) { return new DataView(ie.array.buffer, ie.offset.value, ie.size) } function ne(ie) { var ue = ie.viewer.buffer.slice(ie.offset.value, ie.offset.value + ie.size), Ne = new Uint8Array(_e(ue)), He = new Uint8Array(Ne.length); return oe(Ne), xe(Ne, He), new DataView(He.buffer) } function Re(ie) { var ue = ie.array.slice(ie.offset.value, ie.offset.value + ie.size), Ne = VM(ue), He = new Uint8Array(Ne.length); return oe(Ne), xe(Ne, He), new DataView(He.buffer) } function Ue(ie) { for (var ue = ie.viewer, Ne = { value: ie.offset.value }, He = new Uint16Array(ie.width * ie.scanlineBlockSize * (ie.channels * ie.type)), Qe = new Uint8Array(8192), Je = 0, Nt = new Array(ie.channels), te = 0; te < ie.channels; te++)Nt[te] = {}, Nt[te].start = Je, Nt[te].end = Nt[te].start, Nt[te].nx = ie.width, Nt[te].ny = ie.lines, Nt[te].size = ie.type, Je += Nt[te].nx * Nt[te].ny * Nt[te].size; var ye = gt(ue, Ne), Me = gt(ue, Ne); if (Me >= 8192) throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"; if (ye <= Me) for (var te = 0; te < Me - ye + 1; te++)Qe[te + ye] = Se(ue, Ne); var Te = new Uint16Array(65536), ge = D(Qe, Te), at = bt(ue, Ne); Ce(ie.array, ue, Ne, at, He, Je); for (var te = 0; te < ie.channels; ++te)for (var Ke = Nt[te], st = 0; st < Nt[te].size; ++st)he(He, Ke.start + st, Ke.nx, Ke.size, Ke.ny, Ke.nx * Ke.size, ge); fe(Te, He, Je); for (var ft = 0, At = new Uint8Array(He.buffer.byteLength), $t = 0; $t < ie.lines; $t++)for (var Pt = 0; Pt < ie.channels; Pt++) { var Ke = Nt[Pt], kt = Ke.nx * Ke.size, Zt = new Uint8Array(He.buffer, Ke.end * 2, kt * 2); At.set(Zt, ft), ft += kt * 2, Ke.end += kt } return new DataView(At.buffer) } function et(ie) { var ue = ie.array.slice(ie.offset.value, ie.offset.value + ie.size), Ne = VM(ue); const He = ie.lines * ie.channels * ie.width, Qe = ie.type == 1 ? new Uint16Array(He) : new Uint32Array(He); let Je = 0, Nt = 0; const te = new Array(4); for (let ye = 0; ye < ie.lines; ye++)for (let Me = 0; Me < ie.channels; Me++) { let Te = 0; switch (ie.type) { case 1: te[0] = Je, te[1] = te[0] + ie.width, Je = te[1] + ie.width; for (let ge = 0; ge < ie.width; ++ge) { const at = Ne[te[0]++] << 8 | Ne[te[1]++]; Te += at, Qe[Nt] = Te, Nt++ } break; case 2: te[0] = Je, te[1] = te[0] + ie.width, te[2] = te[1] + ie.width, Je = te[2] + ie.width; for (let ge = 0; ge < ie.width; ++ge) { const at = Ne[te[0]++] << 24 | Ne[te[1]++] << 16 | Ne[te[2]++] << 8; Te += at, Qe[Nt] = Te, Nt++ } break } } return new DataView(Qe.buffer) } function Ge(ie) { var ue = ie.viewer, Ne = { value: ie.offset.value }, He = new Uint8Array(ie.width * ie.lines * (ie.channels * ie.type * 2)), Qe = { version: Fe(ue, Ne), unknownUncompressedSize: Fe(ue, Ne), unknownCompressedSize: Fe(ue, Ne), acCompressedSize: Fe(ue, Ne), dcCompressedSize: Fe(ue, Ne), rleCompressedSize: Fe(ue, Ne), rleUncompressedSize: Fe(ue, Ne), rleRawSize: Fe(ue, Ne), totalAcUncompressedCount: Fe(ue, Ne), totalDcUncompressedCount: Fe(ue, Ne), acCompression: Fe(ue, Ne) }; if (Qe.version < 2) throw "EXRLoader.parse: " + Zi.compression + " version " + Qe.version + " is unsupported"; for (var Je = new Array, Nt = gt(ue, Ne) - 2; Nt > 0;) { var te = Xt(ue.buffer, Ne), ye = Se(ue, Ne), Me = ye >> 2 & 3, Te = (ye >> 4) - 1, ge = new Int8Array([Te])[0], at = Se(ue, Ne); Je.push({ name: te, index: ge, type: at, compression: Me }), Nt -= te.length + 3 } for (var Ke = Zi.channels, st = new Array(ie.channels), ft = 0; ft < ie.channels; ++ft) { var At = st[ft] = {}, $t = Ke[ft]; At.name = $t.name, At.compression = 0, At.decoded = !1, At.type = $t.pixelType, At.pLinear = $t.pLinear, At.width = ie.width, At.height = ie.lines } for (var Pt = { idx: new Array(3) }, kt = 0; kt < ie.channels; ++kt)for (var At = st[kt], ft = 0; ft < Je.length; ++ft) { var Zt = Je[ft]; At.name == Zt.name && (At.compression = Zt.compression, Zt.index >= 0 && (Pt.idx[Zt.index] = kt), At.offset = kt) } if (Qe.acCompressedSize > 0) switch (Qe.acCompression) { case 0: var nn = new Uint16Array(Qe.totalAcUncompressedCount); Ce(ie.array, ue, Ne, Qe.acCompressedSize, nn, Qe.totalAcUncompressedCount); break; case 1: var tn = ie.array.slice(Ne.value, Ne.value + Qe.totalAcUncompressedCount), _n = VM(tn), nn = new Uint16Array(_n.buffer); Ne.value += Qe.totalAcUncompressedCount; break }if (Qe.dcCompressedSize > 0) { var Vt = { array: ie.array, offset: Ne, size: Qe.dcCompressedSize }, Vn = new Uint16Array(Re(Vt).buffer); Ne.value += Qe.dcCompressedSize } if (Qe.rleRawSize > 0) { var tn = ie.array.slice(Ne.value, Ne.value + Qe.rleCompressedSize), _n = VM(tn), bn = _e(_n.buffer); Ne.value += Qe.rleCompressedSize } for (var gr = 0, tr = new Array(st.length), ft = 0; ft < tr.length; ++ft)tr[ft] = new Array; for (var Sr = 0; Sr < ie.lines; ++Sr)for (var vr = 0; vr < st.length; ++vr)tr[vr].push(gr), gr += st[vr].width * ie.type * 2; je(Pt, tr, st, nn, Vn, He); for (var ft = 0; ft < st.length; ++ft) { var At = st[ft]; if (!At.decoded) switch (At.compression) { case 2: for (var yn = 0, ur = 0, Sr = 0; Sr < ie.lines; ++Sr) { for (var di = tr[ft][yn], yr = 0; yr < At.width; ++yr) { for (var ri = 0; ri < 2 * At.type; ++ri)He[di++] = bn[ur + ri * At.width * At.height]; ur++ } yn++ } break; case 1: default: throw "EXRLoader.parse: unsupported channel compression" } } return new DataView(He.buffer) } function Xt(ie, ue) { for (var Ne = new Uint8Array(ie), He = 0; Ne[ue.value + He] != 0;)He += 1; var Qe = new TextDecoder().decode(Ne.slice(ue.value, ue.value + He)); return ue.value = ue.value + He + 1, Qe } function yt(ie, ue, Ne) { var He = new TextDecoder().decode(new Uint8Array(ie).slice(ue.value, ue.value + Ne)); return ue.value = ue.value + Ne, He } function Yt(ie, ue) { var Ne = pt(ie, ue), He = bt(ie, ue); return [Ne, He] } function en(ie, ue) { var Ne = bt(ie, ue), He = bt(ie, ue); return [Ne, He] } function pt(ie, ue) { var Ne = ie.getInt32(ue.value, !0); return ue.value = ue.value + 4, Ne } function bt(ie, ue) { var Ne = ie.getUint32(ue.value, !0); return ue.value = ue.value + 4, Ne } function pn(ie, ue) { var Ne = ie[ue.value]; return ue.value = ue.value + 1, Ne } function Se(ie, ue) { var Ne = ie.getUint8(ue.value); return ue.value = ue.value + 1, Ne } const Fe = function (ie, ue) { let Ne; return "getBigInt64" in DataView.prototype ? Ne = Number(ie.getBigInt64(ue.value, !0)) : Ne = ie.getUint32(ue.value + 4, !0) + Number(ie.getUint32(ue.value, !0) << 32), ue.value += 8, Ne }; function ht(ie, ue) { var Ne = ie.getFloat32(ue.value, !0); return ue.value += 4, Ne } function Ee(ie, ue) { return Zm.toHalfFloat(ht(ie, ue)) } function De(ie) { var ue = (ie & 31744) >> 10, Ne = ie & 1023; return (ie >> 15 ? -1 : 1) * (ue ? ue === 31 ? Ne ? NaN : 1 / 0 : Math.pow(2, ue - 15) * (1 + Ne / 1024) : 6103515625e-14 * (Ne / 1024)) } function gt(ie, ue) { var Ne = ie.getUint16(ue.value, !0); return ue.value += 2, Ne } function Bt(ie, ue) { return De(gt(ie, ue)) } function mt(ie, ue, Ne, He) { for (var Qe = Ne.value, Je = []; Ne.value < Qe + He - 1;) { var Nt = Xt(ue, Ne), te = pt(ie, Ne), ye = Se(ie, Ne); Ne.value += 3; var Me = pt(ie, Ne), Te = pt(ie, Ne); Je.push({ name: Nt, pixelType: te, pLinear: ye, xSampling: Me, ySampling: Te }) } return Ne.value += 1, Je } function ot(ie, ue) { var Ne = ht(ie, ue), He = ht(ie, ue), Qe = ht(ie, ue), Je = ht(ie, ue), Nt = ht(ie, ue), te = ht(ie, ue), ye = ht(ie, ue), Me = ht(ie, ue); return { redX: Ne, redY: He, greenX: Qe, greenY: Je, blueX: Nt, blueY: te, whiteX: ye, whiteY: Me } } function it(ie, ue) { var Ne = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"], He = Se(ie, ue); return Ne[He] } function Ft(ie, ue) { var Ne = bt(ie, ue), He = bt(ie, ue), Qe = bt(ie, ue), Je = bt(ie, ue); return { xMin: Ne, yMin: He, xMax: Qe, yMax: Je } } function un(ie, ue) { var Ne = ["INCREASING_Y"], He = Se(ie, ue); return Ne[He] } function wn(ie, ue) { var Ne = ht(ie, ue), He = ht(ie, ue); return [Ne, He] } function wr(ie, ue) { var Ne = ht(ie, ue), He = ht(ie, ue), Qe = ht(ie, ue); return [Ne, He, Qe] } function Tr(ie, ue, Ne, He, Qe) { if (He === "string" || He === "stringvector" || He === "iccProfile") return yt(ue, Ne, Qe); if (He === "chlist") return mt(ie, ue, Ne, Qe); if (He === "chromaticities") return ot(ie, Ne); if (He === "compression") return it(ie, Ne); if (He === "box2i") return Ft(ie, Ne); if (He === "lineOrder") return un(ie, Ne); if (He === "float") return ht(ie, Ne); if (He === "v2f") return wn(ie, Ne); if (He === "v3f") return wr(ie, Ne); if (He === "int") return pt(ie, Ne); if (He === "rational") return Yt(ie, Ne); if (He === "timecode") return en(ie, Ne); if (He === "preview") return Ne.value += Qe, "skipped"; Ne.value += Qe } function Ua(ie, ue, Ne) { const He = {}; if (ie.getUint32(0, !0) != 20000630) throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format."; He.version = ie.getUint8(4); const Qe = ie.getUint8(5); He.spec = { singleTile: !!(Qe & 2), longName: !!(Qe & 4), deepFormat: !!(Qe & 8), multiPart: !!(Qe & 16) }, Ne.value = 8; for (var Je = !0; Je;) { var Nt = Xt(ue, Ne); if (Nt == 0) Je = !1; else { var te = Xt(ue, Ne), ye = bt(ie, Ne), Me = Tr(ie, ue, Ne, te, ye); Me === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${te}'.`) : He[Nt] = Me } } if ((Qe & -5) != 0) throw console.error("EXRHeader:", He), "THREE.EXRLoader: provided file is currently unsupported."; return He } function Vr(ie, ue, Ne, He, Qe) { const Je = { size: 0, viewer: ue, array: Ne, offset: He, width: ie.dataWindow.xMax - ie.dataWindow.xMin + 1, height: ie.dataWindow.yMax - ie.dataWindow.yMin + 1, channels: ie.channels.length, bytesPerLine: null, lines: null, inputSize: null, type: ie.channels[0].pixelType, uncompress: null, getter: null, format: null, [dw ? "colorSpace" : "encoding"]: null }; switch (ie.compression) { case "NO_COMPRESSION": Je.lines = 1, Je.uncompress = ee; break; case "RLE_COMPRESSION": Je.lines = 1, Je.uncompress = ne; break; case "ZIPS_COMPRESSION": Je.lines = 1, Je.uncompress = Re; break; case "ZIP_COMPRESSION": Je.lines = 16, Je.uncompress = Re; break; case "PIZ_COMPRESSION": Je.lines = 32, Je.uncompress = Ue; break; case "PXR24_COMPRESSION": Je.lines = 16, Je.uncompress = et; break; case "DWAA_COMPRESSION": Je.lines = 32, Je.uncompress = Ge; break; case "DWAB_COMPRESSION": Je.lines = 256, Je.uncompress = Ge; break; default: throw "EXRLoader.parse: " + ie.compression + " is unsupported" }if (Je.scanlineBlockSize = Je.lines, Je.type == 1) switch (Qe) { case Ui: Je.getter = Bt, Je.inputSize = 2; break; case Ya: Je.getter = gt, Je.inputSize = 2; break } else if (Je.type == 2) switch (Qe) { case Ui: Je.getter = ht, Je.inputSize = 4; break; case Ya: Je.getter = Ee, Je.inputSize = 4 } else throw "EXRLoader.parse: unsupported pixelType " + Je.type + " for " + ie.compression + "."; Je.blockCount = (ie.dataWindow.yMax + 1) / Je.scanlineBlockSize; for (var Nt = 0; Nt < Je.blockCount; Nt++)Fe(ue, He); Je.outputChannels = Je.channels == 3 ? 4 : Je.channels; const te = Je.width * Je.height * Je.outputChannels; switch (Qe) { case Ui: Je.byteArray = new Float32Array(te), Je.channels < Je.outputChannels && Je.byteArray.fill(1, 0, te); break; case Ya: Je.byteArray = new Uint16Array(te), Je.channels < Je.outputChannels && Je.byteArray.fill(15360, 0, te); break; default: console.error("THREE.EXRLoader: unsupported type: ", Qe); break }return Je.bytesPerLine = Je.width * Je.inputSize * Je.channels, Je.outputChannels == 4 ? Je.format = ia : Je.format = a_, dw ? Je.colorSpace = "srgb-linear" : Je.encoding = 3e3, Je } const zi = new DataView(e), po = new Uint8Array(e), ks = { value: 0 }, Zi = Ua(zi, e, ks), Hn = Vr(Zi, zi, po, ks, this.type), Ql = { value: 0 }, Of = { R: 0, G: 1, B: 2, A: 3, Y: 0 }; for (let ie = 0; ie < Hn.height / Hn.scanlineBlockSize; ie++) { const ue = bt(zi, ks); Hn.size = bt(zi, ks), Hn.lines = ue + Hn.scanlineBlockSize > Hn.height ? Hn.height - ue : Hn.scanlineBlockSize; const He = Hn.size < Hn.lines * Hn.bytesPerLine ? Hn.uncompress(Hn) : ee(Hn); ks.value += Hn.size; for (let Qe = 0; Qe < Hn.scanlineBlockSize; Qe++) { const Je = Qe + ie * Hn.scanlineBlockSize; if (Je >= Hn.height) break; for (let Nt = 0; Nt < Hn.channels; Nt++) { const te = Of[Zi.channels[Nt].name]; for (let ye = 0; ye < Hn.width; ye++) { Ql.value = (Qe * (Hn.channels * Hn.width) + Nt * Hn.width + ye) * Hn.inputSize; const Me = (Hn.height - 1 - Je) * (Hn.width * Hn.outputChannels) + ye * Hn.outputChannels + te; Hn.byteArray[Me] = Hn.getter(He, Ql) } } } } return { header: Zi, width: Hn.width, height: Hn.height, data: Hn.byteArray, format: Hn.format, [dw ? "colorSpace" : "encoding"]: Hn[dw ? "colorSpace" : "encoding"], type: this.type } } setDataType(e) { return this.type = e, this } load(e, n, r, i) { function a(s, o) { dw ? s.colorSpace = o.colorSpace : s.encoding = o.encoding, s.minFilter = Xr, s.magFilter = Xr, s.generateMipmaps = !1, s.flipY = !1, n && n(s, o) } return super.load(e, a, r, i) } } const loe = S.forwardRef(({ makeDefault: t, camera: e, regress: n, domElement: r, enableDamping: i = !0, keyEvents: a = !1, onChange: s, onStart: o, onEnd: c, ...u }, d) => { const f = il(A => A.invalidate), h = il(A => A.camera), m = il(A => A.gl), g = il(A => A.events), x = il(A => A.setEvents), v = il(A => A.set), b = il(A => A.get), E = il(A => A.performance), M = e || h, C = r || g.connected || m.domElement, N = S.useMemo(() => new PDe(M), [M]); return xp(() => { N.enabled && N.update() }, -1), S.useEffect(() => (a && N.connect(a === !0 ? C : a), N.connect(C), () => void N.dispose()), [a, C, n, N, f]), S.useEffect(() => { const A = I => { f(), n && E.regress(), s && s(I) }, j = I => { o && o(I) }, O = I => { c && c(I) }; return N.addEventListener("change", A), N.addEventListener("start", j), N.addEventListener("end", O), () => { N.removeEventListener("start", j), N.removeEventListener("end", O), N.removeEventListener("change", A) } }, [s, o, c, N, f, x]), S.useEffect(() => { if (t) { const A = b().controls; return v({ controls: N }), () => v({ controls: A }) } }, [t, N]), S.createElement("primitive", XC({ ref: d, object: N, enableDamping: i }, u)) }), kDe = "modulepreload", IDe = function (t) { return "/" + t }, C7 = {}, ODe = function (e, n, r) { let i = Promise.resolve(); if (n && n.length > 0) { let u = function (d) { return Promise.all(d.map(f => Promise.resolve(f).then(h => ({ status: "fulfilled", value: h }), h => ({ status: "rejected", reason: h })))) }; var s = u; document.getElementsByTagName("link"); const o = document.querySelector("meta[property=csp-nonce]"), c = o?.nonce || o?.getAttribute("nonce"); i = u(n.map(d => { if (d = IDe(d), d in C7) return; C7[d] = !0; const f = d.endsWith(".css"), h = f ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${d}"]${h}`)) return; const m = document.createElement("link"); if (m.rel = f ? "stylesheet" : kDe, f || (m.as = "script"), m.crossOrigin = "", m.href = d, c && m.setAttribute("nonce", c), document.head.appendChild(m), f) return new Promise((g, x) => { m.addEventListener("load", g), m.addEventListener("error", () => x(new Error(`Unable to preload CSS for ${d}`))) }) })) } function a(o) { const c = new Event("vite:preloadError", { cancelable: !0 }); if (c.payload = o, window.dispatchEvent(c), !c.defaultPrevented) throw o } return i.then(o => { for (const c of o || []) c.status === "rejected" && a(c.reason); return e().catch(a) }) }; var ck = { exports: {} }, uk, N7; function DDe() { if (N7) return uk; N7 = 1; var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"; return uk = t, uk } var dk, A7; function LDe() { if (A7) return dk; A7 = 1; var t = DDe(); function e() { } function n() { } return n.resetWarningCache = e, dk = function () { function r(s, o, c, u, d, f) { if (f !== t) { var h = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw h.name = "Invariant Violation", h } } r.isRequired = r; function i() { return r } var a = { array: r, bigint: r, bool: r, func: r, number: r, object: r, string: r, symbol: r, any: r, arrayOf: i, element: r, elementType: r, instanceOf: i, node: r, objectOf: i, oneOf: i, oneOfType: i, shape: i, exact: i, checkPropTypes: n, resetWarningCache: e }; return a.PropTypes = a, a }, dk } var P7; function FDe() { return P7 || (P7 = 1, ck.exports = LDe()()), ck.exports } var UDe = FDe(); const $r = Fr(UDe), BDe = 3e3, $De = 3001, coe = (t, e, n) => { let r; switch (t) { case lo: r = new Uint8ClampedArray(e * n * 4); break; case Ya: r = new Uint16Array(e * n * 4); break; case zu: r = new Uint32Array(e * n * 4); break; case $A: r = new Int8Array(e * n * 4); break; case zA: r = new Int16Array(e * n * 4); break; case i_: r = new Int32Array(e * n * 4); break; case Ui: r = new Float32Array(e * n * 4); break; default: throw new Error("Unsupported data type") }return r }; let WM; const zDe = (t, e, n, r) => { if (WM !== void 0) return WM; const i = new Hl(1, 1, r); e.setRenderTarget(i); const a = new Bi(new vp, new _f({ color: 16777215 })); e.render(a, n), e.setRenderTarget(null); const s = coe(t, i.width, i.height); return e.readRenderTargetPixels(i, 0, 0, i.width, i.height, s), i.dispose(), a.geometry.dispose(), a.material.dispose(), WM = s[0] !== 0, WM }; class DB { constructor(e) { var n, r, i, a, s, o, c, u, d, f, h, m, g, x, v, b; this._rendererIsDisposable = !1, this._supportsReadPixels = !0, this.render = () => { this._renderer.setRenderTarget(this._renderTarget); try { this._renderer.render(this._scene, this._camera) } catch (M) { throw this._renderer.setRenderTarget(null), M } this._renderer.setRenderTarget(null) }, this._width = e.width, this._height = e.height, this._type = e.type, this._colorSpace = e.colorSpace; const E = { format: ia, depthBuffer: !1, stencilBuffer: !1, type: this._type, colorSpace: this._colorSpace, anisotropy: ((n = e.renderTargetOptions) === null || n === void 0 ? void 0 : n.anisotropy) !== void 0 ? (r = e.renderTargetOptions) === null || r === void 0 ? void 0 : r.anisotropy : 1, generateMipmaps: ((i = e.renderTargetOptions) === null || i === void 0 ? void 0 : i.generateMipmaps) !== void 0 ? (a = e.renderTargetOptions) === null || a === void 0 ? void 0 : a.generateMipmaps : !1, magFilter: ((s = e.renderTargetOptions) === null || s === void 0 ? void 0 : s.magFilter) !== void 0 ? (o = e.renderTargetOptions) === null || o === void 0 ? void 0 : o.magFilter : Xr, minFilter: ((c = e.renderTargetOptions) === null || c === void 0 ? void 0 : c.minFilter) !== void 0 ? (u = e.renderTargetOptions) === null || u === void 0 ? void 0 : u.minFilter : Xr, samples: ((d = e.renderTargetOptions) === null || d === void 0 ? void 0 : d.samples) !== void 0 ? (f = e.renderTargetOptions) === null || f === void 0 ? void 0 : f.samples : void 0, wrapS: ((h = e.renderTargetOptions) === null || h === void 0 ? void 0 : h.wrapS) !== void 0 ? (m = e.renderTargetOptions) === null || m === void 0 ? void 0 : m.wrapS : va, wrapT: ((g = e.renderTargetOptions) === null || g === void 0 ? void 0 : g.wrapT) !== void 0 ? (x = e.renderTargetOptions) === null || x === void 0 ? void 0 : x.wrapT : va }; if (this._material = e.material, e.renderer ? this._renderer = e.renderer : (this._renderer = DB.instantiateRenderer(), this._rendererIsDisposable = !0), this._scene = new c_, this._camera = new of, this._camera.position.set(0, 0, 10), this._camera.left = -.5, this._camera.right = .5, this._camera.top = .5, this._camera.bottom = -.5, this._camera.updateProjectionMatrix(), !zDe(this._type, this._renderer, this._camera, E)) { let M; switch (this._type) { case Ya: M = this._renderer.extensions.has("EXT_color_buffer_float") ? Ui : void 0; break }M !== void 0 ? (console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${Ui}`), this._type = M) : (this._supportsReadPixels = !1, console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown")) } this._quad = new Bi(new vp, this._material), this._quad.geometry.computeBoundingBox(), this._scene.add(this._quad), this._renderTarget = new Hl(this.width, this.height, E), this._renderTarget.texture.mapping = ((v = e.renderTargetOptions) === null || v === void 0 ? void 0 : v.mapping) !== void 0 ? (b = e.renderTargetOptions) === null || b === void 0 ? void 0 : b.mapping : np } static instantiateRenderer() { const e = new jB; return e.setSize(128, 128), e } toArray() { if (!this._supportsReadPixels) throw new Error("Can't read pixels in this browser"); const e = coe(this._type, this._width, this._height); return this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, e), e } toDataTexture(e) { const n = new Uc(this.toArray(), this.width, this.height, ia, this._type, e?.mapping || np, e?.wrapS || va, e?.wrapT || va, e?.magFilter || Xr, e?.minFilter || Xr, e?.anisotropy || 1, Vu); return n.generateMipmaps = e?.generateMipmaps !== void 0 ? e?.generateMipmaps : !1, n } disposeOnDemandRenderer() { this._renderer.setRenderTarget(null), this._rendererIsDisposable && (this._renderer.dispose(), this._renderer.forceContextLoss()) } dispose(e) { this.disposeOnDemandRenderer(), e && this.renderTarget.dispose(), this.material instanceof Bo && Object.values(this.material.uniforms).forEach(n => { n.value instanceof ti && n.value.dispose() }), Object.values(this.material).forEach(n => { n instanceof ti && n.dispose() }), this.material.dispose(), this._quad.geometry.dispose() } get width() { return this._width } set width(e) { this._width = e, this._renderTarget.setSize(this._width, this._height) } get height() { return this._height } set height(e) { this._height = e, this._renderTarget.setSize(this._width, this._height) } get renderer() { return this._renderer } get renderTarget() { return this._renderTarget } set renderTarget(e) { this._renderTarget = e, this._width = e.width, this._height = e.height } get material() { return this._material } get type() { return this._type } get colorSpace() { return this._colorSpace } } const VDe = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`, HDe = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`; class WDe extends Bo { constructor({ gamma: e, offsetHdr: n, offsetSdr: r, gainMapMin: i, gainMapMax: a, maxDisplayBoost: s, hdrCapacityMin: o, hdrCapacityMax: c, sdr: u, gainMap: d }) { super({ name: "GainMapDecoderMaterial", vertexShader: VDe, fragmentShader: HDe, uniforms: { sdr: { value: u }, gainMap: { value: d }, gamma: { value: new pe(1 / e[0], 1 / e[1], 1 / e[2]) }, offsetHdr: { value: new pe().fromArray(n) }, offsetSdr: { value: new pe().fromArray(r) }, gainMapMin: { value: new pe().fromArray(i) }, gainMapMax: { value: new pe().fromArray(a) }, weightFactor: { value: (Math.log2(s) - o) / (c - o) } }, blending: Pu, depthTest: !1, depthWrite: !1 }), this._maxDisplayBoost = s, this._hdrCapacityMin = o, this._hdrCapacityMax = c, this.needsUpdate = !0, this.uniformsNeedUpdate = !0 } get sdr() { return this.uniforms.sdr.value } set sdr(e) { this.uniforms.sdr.value = e } get gainMap() { return this.uniforms.gainMap.value } set gainMap(e) { this.uniforms.gainMap.value = e } get offsetHdr() { return this.uniforms.offsetHdr.value.toArray() } set offsetHdr(e) { this.uniforms.offsetHdr.value.fromArray(e) } get offsetSdr() { return this.uniforms.offsetSdr.value.toArray() } set offsetSdr(e) { this.uniforms.offsetSdr.value.fromArray(e) } get gainMapMin() { return this.uniforms.gainMapMin.value.toArray() } set gainMapMin(e) { this.uniforms.gainMapMin.value.fromArray(e) } get gainMapMax() { return this.uniforms.gainMapMax.value.toArray() } set gainMapMax(e) { this.uniforms.gainMapMax.value.fromArray(e) } get gamma() { const e = this.uniforms.gamma.value; return [1 / e.x, 1 / e.y, 1 / e.z] } set gamma(e) { const n = this.uniforms.gamma.value; n.x = 1 / e[0], n.y = 1 / e[1], n.z = 1 / e[2] } get hdrCapacityMin() { return this._hdrCapacityMin } set hdrCapacityMin(e) { this._hdrCapacityMin = e, this.calculateWeight() } get hdrCapacityMax() { return this._hdrCapacityMax } set hdrCapacityMax(e) { this._hdrCapacityMax = e, this.calculateWeight() } get maxDisplayBoost() { return this._maxDisplayBoost } set maxDisplayBoost(e) { this._maxDisplayBoost = Math.max(1, Math.min(65504, e)), this.calculateWeight() } calculateWeight() { const e = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin); this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e)) } } class uoe extends Error { } class doe extends Error { } const fw = (t, e, n) => { const r = new RegExp(`${e}="([^"]*)"`, "i").exec(t); if (r) return r[1]; const i = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, "i").exec(t); if (i) { const a = i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g); return a && a.length === 3 ? a.map(s => s.replace(/<\/?rdf:li>/g, "")) : i[1].trim() } if (n !== void 0) return n; throw new Error(`Can't find ${e} in gainmap metadata`) }, GDe = t => { let e; typeof TextDecoder < "u" ? e = new TextDecoder().decode(t) : e = t.toString(); let n = e.indexOf("<x:xmpmeta"); for (; n !== -1;) { const r = e.indexOf("x:xmpmeta>", n), i = e.slice(n, r + 10); try { const a = fw(i, "hdrgm:GainMapMin", "0"), s = fw(i, "hdrgm:GainMapMax"), o = fw(i, "hdrgm:Gamma", "1"), c = fw(i, "hdrgm:OffsetSDR", "0.015625"), u = fw(i, "hdrgm:OffsetHDR", "0.015625"), d = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(i), f = d ? d[1] : "0", h = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(i); if (!h) throw new Error("Incomplete gainmap metadata"); const m = h[1]; return { gainMapMin: Array.isArray(a) ? a.map(g => parseFloat(g)) : [parseFloat(a), parseFloat(a), parseFloat(a)], gainMapMax: Array.isArray(s) ? s.map(g => parseFloat(g)) : [parseFloat(s), parseFloat(s), parseFloat(s)], gamma: Array.isArray(o) ? o.map(g => parseFloat(g)) : [parseFloat(o), parseFloat(o), parseFloat(o)], offsetSdr: Array.isArray(c) ? c.map(g => parseFloat(g)) : [parseFloat(c), parseFloat(c), parseFloat(c)], offsetHdr: Array.isArray(u) ? u.map(g => parseFloat(g)) : [parseFloat(u), parseFloat(u), parseFloat(u)], hdrCapacityMin: parseFloat(f), hdrCapacityMax: parseFloat(m) } } catch { } n = e.indexOf("<x:xmpmeta", r) } }; class qDe { constructor(e) { this.options = { debug: e && e.debug !== void 0 ? e.debug : !1, extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0, extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0 } } extract(e) { return new Promise((n, r) => { const i = this.options.debug, a = new DataView(e.buffer); if (a.getUint16(0) !== 65496) { r(new Error("Not a valid jpeg")); return } const s = a.byteLength; let o = 2, c = 0, u; for (; o < s;) { if (++c > 250) { r(new Error(`Found no marker after ${c} loops `)); return } if (a.getUint8(o) !== 255) { r(new Error(`Not a valid marker at offset 0x${o.toString(16)}, found: 0x${a.getUint8(o).toString(16)}`)); return } if (u = a.getUint8(o + 1), i && console.log(`Marker: ${u.toString(16)}`), u === 226) { i && console.log("Found APP2 marker (0xffe2)"); const d = o + 4; if (a.getUint32(d) === 1297106432) { const f = d + 4; let h; if (a.getUint16(f) === 18761) h = !1; else if (a.getUint16(f) === 19789) h = !0; else { r(new Error("No valid endianness marker found in TIFF header")); return } if (a.getUint16(f + 2, !h) !== 42) { r(new Error("Not valid TIFF data! (no 0x002A marker)")); return } const m = a.getUint32(f + 4, !h); if (m < 8) { r(new Error("Not valid TIFF data! (First offset less than 8)")); return } const g = f + m, x = a.getUint16(g, !h), v = g + 2; let b = 0; for (let N = v; N < v + 12 * x; N += 12)a.getUint16(N, !h) === 45057 && (b = a.getUint32(N + 8, !h)); const M = g + 2 + x * 12 + 4, C = []; for (let N = M; N < M + b * 16; N += 16) { const A = { MPType: a.getUint32(N, !h), size: a.getUint32(N + 4, !h), dataOffset: a.getUint32(N + 8, !h), dependantImages: a.getUint32(N + 12, !h), start: -1, end: -1, isFII: !1 }; A.dataOffset ? (A.start = f + A.dataOffset, A.isFII = !1) : (A.start = 0, A.isFII = !0), A.end = A.start + A.size, C.push(A) } if (this.options.extractNonFII && C.length) { const N = new Blob([a]), A = []; for (const j of C) { if (j.isFII && !this.options.extractFII) continue; const O = N.slice(j.start, j.end + 1, "image/jpeg"); A.push(O) } n(A) } } } o += 2 + a.getUint16(o + 2) } }) } } const XDe = async t => { const e = GDe(t); if (!e) throw new doe("Gain map XMP metadata not found"); const r = await new qDe({ extractFII: !0, extractNonFII: !0 }).extract(t); if (r.length !== 2) throw new uoe("Gain map recovery image not found"); return { sdr: new Uint8Array(await r[0].arrayBuffer()), gainMap: new Uint8Array(await r[1].arrayBuffer()), metadata: e } }, j7 = t => new Promise((e, n) => { const r = document.createElement("img"); r.onload = () => { e(r) }, r.onerror = i => { n(i) }, r.src = URL.createObjectURL(t) }); class foe extends ho { constructor(e, n) { super(n), e && (this._renderer = e), this._internalLoadingManager = new h2 } setRenderer(e) { return this._renderer = e, this } setRenderTargetOptions(e) { return this._renderTargetOptions = e, this } prepareQuadRenderer() { this._renderer || console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer."); const e = new WDe({ gainMapMax: [1, 1, 1], gainMapMin: [0, 0, 0], gamma: [1, 1, 1], offsetHdr: [1, 1, 1], offsetSdr: [1, 1, 1], hdrCapacityMax: 1, hdrCapacityMin: 0, maxDisplayBoost: 1, gainMap: new ti, sdr: new ti }); return new DB({ width: 16, height: 16, type: Ya, colorSpace: Vu, material: e, renderer: this._renderer, renderTargetOptions: this._renderTargetOptions }) } async render(e, n, r, i) { const a = i ? new Blob([i], { type: "image/jpeg" }) : void 0, s = new Blob([r], { type: "image/jpeg" }); let o, c, u = !1; if (typeof createImageBitmap > "u") { const h = await Promise.all([a ? j7(a) : Promise.resolve(void 0), j7(s)]); c = h[0], o = h[1], u = !0 } else { const h = await Promise.all([a ? createImageBitmap(a, { imageOrientation: "flipY" }) : Promise.resolve(void 0), createImageBitmap(s, { imageOrientation: "flipY" })]); c = h[0], o = h[1] } const d = new ti(c || new ImageData(2, 2), np, va, va, Xr, $L, ia, lo, 1, Vu); d.flipY = u, d.needsUpdate = !0; const f = new ti(o, np, va, va, Xr, $L, ia, lo, 1, qs); f.flipY = u, f.needsUpdate = !0, e.width = o.width, e.height = o.height, e.material.gainMap = d, e.material.sdr = f, e.material.gainMapMin = n.gainMapMin, e.material.gainMapMax = n.gainMapMax, e.material.offsetHdr = n.offsetHdr, e.material.offsetSdr = n.offsetSdr, e.material.gamma = n.gamma, e.material.hdrCapacityMin = n.hdrCapacityMin, e.material.hdrCapacityMax = n.hdrCapacityMax, e.material.maxDisplayBoost = Math.pow(2, n.hdrCapacityMax), e.material.needsUpdate = !0, e.render() } } class YDe extends foe { load([e, n, r], i, a, s) { const o = this.prepareQuadRenderer(); let c, u, d; const f = async () => { if (c && u && d) { try { await this.render(o, d, c, u) } catch (I) { this.manager.itemError(e), this.manager.itemError(n), this.manager.itemError(r), typeof s == "function" && s(I), o.disposeOnDemandRenderer(); return } typeof i == "function" && i(o), this.manager.itemEnd(e), this.manager.itemEnd(n), this.manager.itemEnd(r), o.disposeOnDemandRenderer() } }; let h = !0, m = 0, g = 0, x = !0, v = 0, b = 0, E = !0, M = 0, C = 0; const N = () => { if (typeof a == "function") { const I = m + v + M, D = g + b + C, F = h && x && E; a(new ProgressEvent("progress", { lengthComputable: F, loaded: D, total: I })) } }; this.manager.itemStart(e), this.manager.itemStart(n), this.manager.itemStart(r); const A = new hl(this._internalLoadingManager); A.setResponseType("arraybuffer"), A.setRequestHeader(this.requestHeader), A.setPath(this.path), A.setWithCredentials(this.withCredentials), A.load(e, async I => { if (typeof I == "string") throw new Error("Invalid sdr buffer"); c = I, await f() }, I => { h = I.lengthComputable, g = I.loaded, m = I.total, N() }, I => { this.manager.itemError(e), typeof s == "function" && s(I) }); const j = new hl(this._internalLoadingManager); j.setResponseType("arraybuffer"), j.setRequestHeader(this.requestHeader), j.setPath(this.path), j.setWithCredentials(this.withCredentials), j.load(n, async I => { if (typeof I == "string") throw new Error("Invalid gainmap buffer"); u = I, await f() }, I => { x = I.lengthComputable, b = I.loaded, v = I.total, N() }, I => { this.manager.itemError(n), typeof s == "function" && s(I) }); const O = new hl(this._internalLoadingManager); return O.setRequestHeader(this.requestHeader), O.setPath(this.path), O.setWithCredentials(this.withCredentials), O.load(r, async I => { if (typeof I != "string") throw new Error("Invalid metadata string"); d = JSON.parse(I), await f() }, I => { E = I.lengthComputable, C = I.loaded, M = I.total, N() }, I => { this.manager.itemError(r), typeof s == "function" && s(I) }), o } } class KDe extends foe { load(e, n, r, i) { const a = this.prepareQuadRenderer(), s = new hl(this._internalLoadingManager); return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(this.withCredentials), this.manager.itemStart(e), s.load(e, async o => { if (typeof o == "string") throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]"); const c = new Uint8Array(o); let u, d, f; try { const h = await XDe(c); u = h.sdr, d = h.gainMap, f = h.metadata } catch (h) { if (h instanceof doe || h instanceof uoe) console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`), f = { gainMapMin: [0, 0, 0], gainMapMax: [1, 1, 1], gamma: [1, 1, 1], hdrCapacityMin: 0, hdrCapacityMax: 1, offsetHdr: [0, 0, 0], offsetSdr: [0, 0, 0] }, u = c; else throw h } try { await this.render(a, f, u, d) } catch (h) { this.manager.itemError(e), typeof i == "function" && i(h), a.disposeOnDemandRenderer(); return } typeof n == "function" && n(a), this.manager.itemEnd(e), a.disposeOnDemandRenderer() }, r, o => { this.manager.itemError(e), typeof i == "function" && i(o) }), a } } const q1 = { apartment: "lebombo_1k.hdr", city: "potsdamer_platz_1k.hdr", dawn: "kiara_1_dawn_1k.hdr", forest: "forest_slope_1k.hdr", lobby: "st_fagans_interior_1k.hdr", night: "dikhololo_night_1k.hdr", park: "rooitou_park_1k.hdr", studio: "studio_small_03_1k.hdr", sunset: "venice_sunset_1k.hdr", warehouse: "empty_warehouse_01_1k.hdr" }, hoe = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/", ex = t => Array.isArray(t), LB = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"]; function g2({ files: t = LB, path: e = "", preset: n = void 0, encoding: r = void 0, extensions: i } = {}) { let a = null, s = !1; n && (FB(n), t = q1[n], e = hoe), s = ex(t); const { extension: o, isCubemap: c } = UB(t); if (a = BB(o), !a) throw new Error("useEnvironment: Unrecognized file extension: " + t); const u = il(m => m.gl); S.useLayoutEffect(() => { if (o !== "webp" && o !== "jpg" && o !== "jpeg") return; function m() { Cx.clear(a, s ? [t] : t) } u.domElement.addEventListener("webglcontextlost", m, { once: !0 }) }, [t, u.domElement]); const d = Cx(a, s ? [t] : t, m => { (o === "webp" || o === "jpg" || o === "jpeg") && m.setRenderer(u), m.setPath == null || m.setPath(e), i && i(m) }); let f = s ? d[0] : d; if (o === "jpg" || o === "jpeg" || o === "webp") { var h; f = (h = f.renderTarget) == null ? void 0 : h.texture } return f.mapping = c ? $u : vx, "colorSpace" in f ? f.colorSpace = r ?? c ? "srgb" : "srgb-linear" : f.encoding = r ?? c ? $De : BDe, f } const ZDe = { files: LB, path: "", preset: void 0, extensions: void 0 }; g2.preload = t => { const e = { ...ZDe, ...t }; let { files: n, path: r = "" } = e; const { preset: i, extensions: a } = e; i && (FB(i), n = q1[i], r = hoe); const { extension: s } = UB(n); if (s === "webp" || s === "jpg" || s === "jpeg") throw new Error("useEnvironment: Preloading gainmaps is not supported"); const o = BB(s); if (!o) throw new Error("useEnvironment: Unrecognized file extension: " + n); Cx.preload(o, ex(n) ? [n] : n, c => { c.setPath == null || c.setPath(r), a && a(c) }) }; const QDe = { files: LB, preset: void 0 }; g2.clear = t => { const e = { ...QDe, ...t }; let { files: n } = e; const { preset: r } = e; r && (FB(r), n = q1[r]); const { extension: i } = UB(n), a = BB(i); if (!a) throw new Error("useEnvironment: Unrecognized file extension: " + n); Cx.clear(a, ex(n) ? [n] : n) }; function FB(t) { if (!(t in q1)) throw new Error("Preset must be one of: " + Object.keys(q1).join(", ")) } function UB(t) { var e; const n = ex(t) && t.length === 6, r = ex(t) && t.length === 3 && t.some(s => s.endsWith("json")), i = ex(t) ? t[0] : t; return { extension: n ? "cube" : r ? "webp" : i.startsWith("data:application/exr") ? "exr" : i.startsWith("data:application/hdr") ? "hdr" : i.startsWith("data:image/jpeg") ? "jpg" : (e = i.split(".").pop()) == null || (e = e.split("?")) == null || (e = e.shift()) == null ? void 0 : e.toLowerCase(), isCubemap: n, isGainmap: r } } function BB(t) { return t === "cube" ? fse : t === "hdr" ? jDe : t === "exr" ? RDe : t === "jpg" || t === "jpeg" ? KDe : t === "webp" ? YDe : null } const JDe = t => t.current && t.current.isScene, e3e = t => JDe(t) ? t.current : t; function $B(t, e, n, r, i = {}) { var a, s, o, c; i = { backgroundBlurriness: 0, backgroundIntensity: 1, backgroundRotation: [0, 0, 0], environmentIntensity: 1, environmentRotation: [0, 0, 0], ...i }; const u = e3e(e || n), d = u.background, f = u.environment, h = { backgroundBlurriness: u.backgroundBlurriness, backgroundIntensity: u.backgroundIntensity, backgroundRotation: (a = (s = u.backgroundRotation) == null || s.clone == null ? void 0 : s.clone()) !== null && a !== void 0 ? a : [0, 0, 0], environmentIntensity: u.environmentIntensity, environmentRotation: (o = (c = u.environmentRotation) == null || c.clone == null ? void 0 : c.clone()) !== null && o !== void 0 ? o : [0, 0, 0] }; return t !== "only" && (u.environment = r), t && (u.background = r), Nh(u, i), () => { t !== "only" && (u.environment = f), t && (u.background = d), Nh(u, h) } } function zB({ scene: t, background: e = !1, map: n, ...r }) { const i = il(a => a.scene); return S.useLayoutEffect(() => { if (n) return $B(e, t, i, n, r) }), null } function poe({ background: t = !1, scene: e, blur: n, backgroundBlurriness: r, backgroundIntensity: i, backgroundRotation: a, environmentIntensity: s, environmentRotation: o, ...c }) { const u = g2(c), d = il(f => f.scene); return S.useLayoutEffect(() => $B(t, e, d, u, { backgroundBlurriness: n ?? r, backgroundIntensity: i, backgroundRotation: a, environmentIntensity: s, environmentRotation: o })), S.useEffect(() => () => { u.dispose() }, [u]), null } function t3e({ children: t, near: e = .1, far: n = 1e3, resolution: r = 256, frames: i = 1, map: a, background: s = !1, blur: o, backgroundBlurriness: c, backgroundIntensity: u, backgroundRotation: d, environmentIntensity: f, environmentRotation: h, scene: m, files: g, path: x, preset: v = void 0, extensions: b }) { const E = il(O => O.gl), M = il(O => O.scene), C = S.useRef(null), [N] = S.useState(() => new c_), A = S.useMemo(() => { const O = new rB(r); return O.texture.type = Ya, O }, [r]); S.useEffect(() => () => { A.dispose() }, [A]), S.useLayoutEffect(() => { if (i === 1) { const O = E.autoClear; E.autoClear = !0, C.current.update(E, N), E.autoClear = O } return $B(s, m, M, A.texture, { backgroundBlurriness: o ?? c, backgroundIntensity: u, backgroundRotation: d, environmentIntensity: f, environmentRotation: h }) }, [t, N, A.texture, m, M, s, i, E]); let j = 1; return xp(() => { if (i === 1 / 0 || j < i) { const O = E.autoClear; E.autoClear = !0, C.current.update(E, N), E.autoClear = O, j++ } }), S.createElement(S.Fragment, null, HOe(S.createElement(S.Fragment, null, t, S.createElement("cubeCamera", { ref: C, args: [e, n, A] }), g || v ? S.createElement(poe, { background: !0, files: g, preset: v, path: x, extensions: b }) : a ? S.createElement(zB, { background: !0, map: a, extensions: b }) : null), N)) } function n3e(t) { var e, n, r, i; const a = g2(t), s = t.map || a; S.useMemo(() => Lse({ GroundProjectedEnvImpl: SDe }), []), S.useEffect(() => () => { a.dispose() }, [a]); const o = S.useMemo(() => [s], [s]), c = (e = t.ground) == null ? void 0 : e.height, u = (n = t.ground) == null ? void 0 : n.radius, d = (r = (i = t.ground) == null ? void 0 : i.scale) !== null && r !== void 0 ? r : 1e3; return S.createElement(S.Fragment, null, S.createElement(zB, XC({}, t, { map: s })), S.createElement("groundProjectedEnvImpl", { args: o, scale: d, height: c, radius: u })) } function moe(t) { return t.ground ? S.createElement(n3e, t) : t.map ? S.createElement(zB, t) : t.children ? S.createElement(t3e, t) : S.createElement(poe, t) } var fk = { exports: {} }, hk = {};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var R7; function r3e() { if (R7) return hk; R7 = 1; var t = IS(); function e(f, h) { return f === h && (f !== 0 || 1 / f === 1 / h) || f !== f && h !== h } var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, i = t.useEffect, a = t.useLayoutEffect, s = t.useDebugValue; function o(f, h) { var m = h(), g = r({ inst: { value: m, getSnapshot: h } }), x = g[0].inst, v = g[1]; return a(function () { x.value = m, x.getSnapshot = h, c(x) && v({ inst: x }) }, [f, m, h]), i(function () { return c(x) && v({ inst: x }), f(function () { c(x) && v({ inst: x }) }) }, [f]), s(m), m } function c(f) { var h = f.getSnapshot; f = f.value; try { var m = h(); return !n(f, m) } catch { return !0 } } function u(f, h) { return h() } var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : o; return hk.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : d, hk } var k7; function i3e() { return k7 || (k7 = 1, fk.exports = r3e()), fk.exports } function a3e() { const t = S.useRef(null), e = S.useRef(null), n = S.useRef(null), { points: r, connections: i } = S.useMemo(() => { const o = [], c = []; for (let d = 0; d < 80; d++) { const f = Math.acos(-1 + 2 * d / 80), h = Math.sqrt(80 * Math.PI) * f, m = Math.cos(h) * Math.sin(f), g = Math.sin(h) * Math.sin(f), x = Math.cos(f); o.push(new pe(m * 3, g * 3, x * 3)) } for (let d = 0; d < o.length; d++)for (let f = d + 1; f < o.length; f++)o[d].distanceTo(o[f]) < 2.5 && c.push([o[d], o[f]]); return { points: o, connections: c } }, []), a = S.useMemo(() => { const o = new Kn, c = new Float32Array(r.length * 3), u = new Float32Array(r.length * 3); return r.forEach((d, f) => { c[f * 3] = d.x, c[f * 3 + 1] = d.y, c[f * 3 + 2] = d.z; const h = (d.y + 3) / 6, m = new Kt().setHSL(h, .8, .6); u[f * 3] = m.r, u[f * 3 + 1] = m.g, u[f * 3 + 2] = m.b }), o.setAttribute("position", new Lr(c, 3)), o.setAttribute("color", new Lr(u, 3)), o }, [r]), s = S.useMemo(() => { const o = new Kn, c = new Float32Array(i.length * 6); return i.forEach(([u, d], f) => { c[f * 6] = u.x, c[f * 6 + 1] = u.y, c[f * 6 + 2] = u.z, c[f * 6 + 3] = d.x, c[f * 6 + 4] = d.y, c[f * 6 + 5] = d.z }), o.setAttribute("position", new Lr(c, 3)), o }, [i]); return xp(o => { const c = o.clock.getElapsedTime(); t.current && (t.current.rotation.x = c * .1, t.current.rotation.y = c * .15), e.current && (e.current.rotation.x = c * .05, e.current.rotation.y = c * .1), n.current && (n.current.rotation.x = c * .05, n.current.rotation.y = c * .1) }), l.jsxs("group", { children: [l.jsx("lineSegments", { ref: n, geometry: s, children: l.jsx("lineBasicMaterial", { color: "#3b82f6", opacity: .6, transparent: !0 }) }), l.jsx("points", { ref: e, geometry: a, children: l.jsx("pointsMaterial", { size: .1, vertexColors: !0 }) })] }) } function s3e() { const t = S.useRef(null), { positions: e, colors: n } = S.useMemo(() => { const i = new Float32Array(600), a = new Float32Array(600); for (let s = 0; s < 200; s++) { const o = Math.random() * 8 + 2, c = Math.random() * Math.PI * 2, u = Math.acos(Math.random() * 2 - 1); i[s * 3] = o * Math.sin(u) * Math.cos(c), i[s * 3 + 1] = o * Math.sin(u) * Math.sin(c), i[s * 3 + 2] = o * Math.cos(u); const d = .6 + Math.random() * .2, f = new Kt().setHSL(d, .8, .7); a[s * 3] = f.r, a[s * 3 + 1] = f.g, a[s * 3 + 2] = f.b } return { positions: i, colors: a } }, []); return xp(r => { const i = r.clock.getElapsedTime(); if (t.current) { const a = t.current.geometry.attributes.position.array; for (let s = 0; s < a.length; s += 3)a[s + 1] += Math.sin(i + s * .01) * .001, a[s] += Math.cos(i + s * .01) * 5e-4; t.current.geometry.attributes.position.needsUpdate = !0 } }), l.jsxs("points", { ref: t, children: [l.jsxs("bufferGeometry", { children: [l.jsx("bufferAttribute", { attach: "attributes-position", count: e.length / 3, array: e, itemSize: 3 }), l.jsx("bufferAttribute", { attach: "attributes-color", count: n.length / 3, array: n, itemSize: 3 })] }), l.jsx("pointsMaterial", { size: .05, vertexColors: !0, transparent: !0, opacity: .8 })] }) } function o3e() { return l.jsx("div", { className: "absolute inset-0", children: l.jsxs(eoe, { camera: { position: [0, 0, 10], fov: 60 }, style: { background: "transparent" }, dpr: [1, 2], performance: { min: .5 }, children: [l.jsx("ambientLight", { intensity: .4 }), l.jsx("pointLight", { position: [10, 10, 10], intensity: .8, color: "#3b82f6" }), l.jsx("pointLight", { position: [-10, -10, -10], intensity: .6, color: "#8b5cf6" }), l.jsx(moe, { preset: "night" }), l.jsx(a3e, {}), l.jsx(s3e, {}), l.jsx(loe, { enableZoom: !1, enablePan: !1, autoRotate: !0, autoRotateSpeed: .5, maxPolarAngle: Math.PI / 2, minPolarAngle: Math.PI / 2 })] }) }) } const I7 = $g("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-medium transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", { variants: { variant: { default: "bg-primary text-primary-foreground shadow hover:bg-primary/90 hover:shadow-md active:scale-95", destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90 hover:shadow-md active:scale-95", outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground hover:shadow-md active:scale-95", secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80 hover:shadow-md active:scale-95", ghost: "hover:bg-accent hover:text-accent-foreground active:scale-95", link: "text-primary underline-offset-4 hover:underline active:scale-95", gradient: "bg-gradient-primary text-primary-foreground shadow-lg hover:shadow-xl hover:opacity-90 active:scale-95 glow", success: "bg-success text-success-foreground shadow-sm hover:bg-success/90 hover:shadow-md active:scale-95", warning: "bg-warning text-warning-foreground shadow-sm hover:bg-warning/90 hover:shadow-md active:scale-95" }, size: { default: "h-10 px-4 py-2", sm: "h-8 rounded-md px-3 text-xs", lg: "h-12 rounded-lg px-8 text-base", xl: "h-14 rounded-xl px-10 text-lg", icon: "h-10 w-10", "icon-sm": "h-8 w-8", "icon-lg": "h-12 w-12" }, animation: { none: "", bounce: "hover:animate-bounce-subtle", pulse: "hover:animate-pulse-glow", shimmer: "relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:animate-shimmer before:bg-gradient-to-r before:from-transparent before:via-white/20 before:to-transparent" } }, defaultVariants: { variant: "default", size: "default", animation: "none" } }), on = S.forwardRef(({ className: t, variant: e, size: n, animation: r, asChild: i = !1, loading: a = !1, leftIcon: s, rightIcon: o, motionProps: c, children: u, disabled: d, ...f }, h) => { const m = i ? jJ : $e.button, g = d || a, x = l.jsxs(l.Fragment, { children: [a && l.jsx($e.div, { className: "mr-2 h-4 w-4", animate: { rotate: 360 }, transition: { duration: 1, repeat: 1 / 0, ease: "linear" }, children: l.jsxs("svg", { className: "h-4 w-4 animate-spin", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [l.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), l.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] }) }), !a && s && l.jsx("span", { className: "mr-2", children: s }), u, !a && o && l.jsx("span", { className: "ml-2", children: o })] }); return c ? l.jsx(m, { className: _t(I7({ variant: e, size: n, animation: r, className: t })), ref: h, disabled: g, ...c, ...f, children: x }) : l.jsx("button", { className: _t(I7({ variant: e, size: n, animation: r, className: t })), ref: h, disabled: g, ...f, children: x }) }); on.displayName = "EnhancedButton"; function l3e() { const t = ui(), [e, n] = S.useState({ x: 0, y: 0 }); S.useEffect(() => { const i = a => { n({ x: a.clientX / window.innerWidth * 2 - 1, y: -(a.clientY / window.innerHeight) * 2 + 1 }) }; return window.addEventListener("mousemove", i), () => window.removeEventListener("mousemove", i) }, []); const r = [{ icon: ro, text: "AI-Powered" }, { icon: Qh, text: "Real Practice" }, { icon: vA, text: "Instant Feedback" }]; return l.jsxs("section", { className: "relative min-h-screen flex items-center justify-center overflow-hidden", children: [l.jsx(o3e, {}), l.jsx("div", { className: "absolute inset-0 bg-gradient-to-br from-background/80 via-background/60 to-background/40 z-10" }), l.jsx("div", { className: "relative z-20 container mx-auto px-4 py-20", children: l.jsxs("div", { className: "max-w-4xl mx-auto text-center", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, className: "inline-flex items-center gap-2 px-4 py-2 rounded-full bg-primary/10 text-primary text-sm font-medium mb-8 backdrop-blur-sm", children: [l.jsx(Ia, { className: "h-4 w-4" }), "AI-Powered Interview Platform"] }), l.jsxs($e.h1, { initial: { opacity: 0, y: 30 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: .2 }, className: "text-3xl sm:text-4xl md:text-6xl lg:text-7xl xl:text-8xl font-bold tracking-tight mb-4 sm:mb-6 leading-tight", style: { transform: `translate(${e.x * 10}px, ${e.y * 10}px)` }, children: [l.jsx("span", { className: "bg-gradient-to-r from-primary via-secondary to-accent bg-clip-text text-transparent", children: "Master Your Interview Skills" }), l.jsx("br", {}), l.jsx("span", { className: "text-foreground", children: "with AI" })] }), l.jsx($e.p, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: .4 }, className: "text-base sm:text-lg md:text-xl lg:text-2xl text-muted-foreground mb-6 sm:mb-8 max-w-3xl mx-auto px-4", style: { transform: `translate(${e.x * 5}px, ${e.y * 5}px)` }, children: "Simulate, learn, and rise with real-time feedback. Practice with AI, peers, or family to build confidence for your dream job." }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: .6 }, className: "flex flex-wrap justify-center gap-4 mb-12", children: r.map((i, a) => l.jsxs($e.div, { initial: { opacity: 0, scale: .8 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .5, delay: .8 + a * .1 }, whileHover: { scale: 1.05 }, className: "flex items-center gap-2 px-4 py-2 rounded-full bg-background/20 backdrop-blur-sm border border-border/50", children: [l.jsx(i.icon, { className: "h-4 w-4 text-primary" }), l.jsx("span", { className: "text-sm font-medium", children: i.text })] }, i.text)) }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: .8 }, className: "flex flex-col sm:flex-row gap-4 justify-center items-center", children: [l.jsxs(on, { size: "lg", className: "text-lg px-8 py-4 bg-gradient-primary hover:opacity-90 transition-all duration-300", onClick: () => t("/login"), children: [l.jsx(yg, { className: "h-5 w-5 mr-2" }), "Start Practicing"] }), l.jsxs(on, { variant: "outline", size: "lg", className: "text-lg px-8 py-4 bg-background/20 backdrop-blur-sm border-border/50 hover:bg-primary/10 hover:text-primary", onClick: () => t("/resources"), children: [l.jsx(Kh, { className: "h-5 w-5 mr-2" }), "Learn More"] })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: 1 }, className: "grid grid-cols-3 gap-4 sm:gap-6 md:gap-8 mt-12 sm:mt-16 max-w-2xl mx-auto px-4", children: [{ number: "50K+", label: "Users Helped" }, { number: "87%", label: "Success Rate" }, { number: "4.9", label: "User Rating" }].map((i, a) => l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: 1.2 + a * .1 }, className: "text-center", children: [l.jsx("div", { className: "text-2xl md:text-3xl font-bold text-primary mb-2", children: i.number }), l.jsx("div", { className: "text-sm text-muted-foreground", children: i.label })] }, i.label)) })] }) })] }) } function c3e({ intensity: t = .25, color: e = "#3b82f6", speed: n = .35, size: r = 10 }) { const i = S.useRef(null), a = S.useRef(null), { positions: s, colors: o } = S.useMemo(() => { const u = new Float32Array(240), d = new Float32Array(240); for (let f = 0; f < 80; f++) { const h = (Math.random() - .5) * r, m = (Math.random() - .5) * r, g = (Math.random() - .5) * r; u[f * 3] = h, u[f * 3 + 1] = m, u[f * 3 + 2] = g; const x = new Kt(e); d[f * 3] = x.r * t, d[f * 3 + 1] = x.g * t, d[f * 3 + 2] = x.b * t } return { positions: u, colors: d } }, [r, e, t]); return xp(c => { const u = c.clock.getElapsedTime(); if (i.current) { const d = Math.sin(u * n * .05) * .02, f = Math.cos(u * n * .04) * .03, h = Math.sin(u * n * .03) * .01; i.current.rotation.x = Io.lerp(i.current.rotation.x, d, .04), i.current.rotation.y = Io.lerp(i.current.rotation.y, f, .04), i.current.rotation.z = Io.lerp(i.current.rotation.z, h, .04) } if (a.current) { const d = Math.sin(u * n * .02) * .01, f = Math.cos(u * n * .015) * .015; a.current.rotation.x = Io.lerp(a.current.rotation.x, d, .03), a.current.rotation.y = Io.lerp(a.current.rotation.y, f, .03) } }), l.jsx("group", { children: l.jsxs("points", { ref: a, children: [l.jsxs("bufferGeometry", { children: [l.jsx("bufferAttribute", { attach: "attributes-position", count: s.length / 3, array: s, itemSize: 3 }), l.jsx("bufferAttribute", { attach: "attributes-color", count: o.length / 3, array: o, itemSize: 3 })] }), l.jsx("pointsMaterial", { size: .08, vertexColors: !0, transparent: !0, opacity: .45 })] }) }) } function u3e({ count: t = 12, color: e = "#8b5cf6", intensity: n = .25, speed: r = .6 }) { const i = S.useRef(null), a = S.useMemo(() => Array.from({ length: t }, (s, o) => ({ position: [(Math.random() - .5) * 16, (Math.random() - .5) * 12, (Math.random() - .5) * 16], scale: Math.random() * .4 + .4, speed: Math.random() * .5 + .5, color: new Kt(e).multiplyScalar(n), bobOffset: Math.random() * Math.PI * 2 })), [t, e, n]); return xp(s => { const o = s.clock.getElapsedTime(); i.current && i.current.children.forEach((c, u) => { const d = a[u], f = Math.sin(o * d.speed * .6 + d.bobOffset) * 1.2; c.position.y = d.position[1] + f, c.rotation.x = Io.lerp(c.rotation.x, o * d.speed * .04, .06), c.rotation.y = Io.lerp(c.rotation.y, o * d.speed * .05, .06) }) }), l.jsx("group", { ref: i, children: a.map((s, o) => l.jsxs("mesh", { position: s.position, scale: s.scale, children: [l.jsx("sphereGeometry", { args: [.4, 8, 6] }), l.jsx("meshBasicMaterial", { color: s.color, transparent: !0, opacity: .22 })] }, o)) }) } function d3e({ color: t = "#3b82f6", intensity: e = .12, speed: n = .4, amplitude: r = .8 }) { const i = S.useRef(null), { positions: a, colors: s } = S.useMemo(() => { const c = new Float32Array(4800), u = new Float32Array(1600 * 3); for (let d = 0; d < 40; d++)for (let f = 0; f < 40; f++) { const h = (d * 40 + f) * 3, m = (d / 40 - .5) * 20, g = (f / 40 - .5) * 20, x = Math.sin(d * .18) * Math.cos(f * .18) * r * .9; c[h] = m, c[h + 1] = x, c[h + 2] = g; const v = new Kt(t); u[h] = v.r * e, u[h + 1] = v.g * e, u[h + 2] = v.b * e } return { positions: c, colors: u } }, [t, e, r]); return xp(o => { const c = o.clock.getElapsedTime(); if (i.current) { const u = i.current.geometry.attributes.position.array, d = 40; for (let f = 0; f < d; f++)for (let h = 0; h < d; h++) { const m = (f * d + h) * 3, g = Math.sin(f * .18 + c * n) * Math.cos(h * .18 + c * n) * r * .9; u[m + 1] = Io.lerp(u[m + 1], g, .06) } i.current.geometry.attributes.position.needsUpdate = !0 } }), l.jsxs("mesh", { ref: i, children: [l.jsxs("bufferGeometry", { children: [l.jsx("bufferAttribute", { attach: "attributes-position", count: a.length / 3, array: a, itemSize: 3 }), l.jsx("bufferAttribute", { attach: "attributes-color", count: s.length / 3, array: s, itemSize: 3 })] }), l.jsx("meshBasicMaterial", { vertexColors: !0, transparent: !0, opacity: .25 })] }) } function f3e({ color: t = "#3b82f6", intensity: e = .18, speed: n = .6, hoverIntensity: r = .45 }) { const i = S.useRef(null), [a, s] = S.useState(!1), [o, c] = S.useState({ x: 0, y: 0 }), u = S.useRef({ x: 0, y: 0 }), d = S.useRef(0); S.useEffect(() => { const m = g => { c({ x: g.clientX / window.innerWidth * 2 - 1, y: -(g.clientY / window.innerHeight) * 2 + 1 }) }; return window.addEventListener("mousemove", m), () => window.removeEventListener("mousemove", m) }, []); const { positions: f, colors: h } = S.useMemo(() => { const g = new Float32Array(2700), x = new Float32Array(900 * 3); for (let v = 0; v < 30; v++)for (let b = 0; b < 30; b++) { const E = (v * 30 + b) * 3, M = (v / 30 - .5) * 15, C = (b / 30 - .5) * 15, N = Math.sin(v * .3) * Math.cos(b * .3) * 1.2; g[E] = M, g[E + 1] = N, g[E + 2] = C; const A = new Kt(t); x[E] = A.r * e, x[E + 1] = A.g * e, x[E + 2] = A.b * e } return { positions: g, colors: x } }, [t, e]); return xp(m => { const g = m.clock.getElapsedTime(); if (u.current.x = Io.lerp(u.current.x, o.x, .08), u.current.y = Io.lerp(u.current.y, o.y, .08), d.current = Io.lerp(d.current, a ? 1 : 0, .08), i.current) { const x = i.current.geometry.attributes.position.array, v = 30, b = Io.lerp(e, r, d.current); for (let E = 0; E < v; E++)for (let M = 0; M < v; M++) { const C = (E * v + M) * 3, N = Math.sin(E * .3 + g * n + u.current.x * 1.2) * Math.cos(M * .3 + g * n + u.current.y * 1.2) * 1.2 * b, A = x[C + 1]; x[C + 1] = Io.lerp(A, N, .07) } i.current.geometry.attributes.position.needsUpdate = !0 } }), l.jsxs("mesh", { ref: i, onPointerOver: () => s(!0), onPointerOut: () => s(!1), children: [l.jsxs("bufferGeometry", { children: [l.jsx("bufferAttribute", { attach: "attributes-position", count: f.length / 3, array: f, itemSize: 3 }), l.jsx("bufferAttribute", { attach: "attributes-color", count: h.length / 3, array: h, itemSize: 3 })] }), l.jsx("meshBasicMaterial", { vertexColors: !0, transparent: !0, opacity: .35 })] }) } function mu({ children: t, backgroundType: e = "mesh", intensity: n = .18, color: r = "#3b82f6", speed: i = .4, className: a = "" }) { const s = () => { switch (e) { case "mesh": return l.jsx(c3e, { intensity: n, color: r, speed: i }); case "shapes": return l.jsx(u3e, { intensity: n, color: r, speed: i }); case "wave": return l.jsx(d3e, { intensity: n, color: r, speed: i }); case "interactive": return l.jsx(f3e, { intensity: n, color: r, speed: i }); default: return null } }; return l.jsxs("section", { className: `relative overflow-hidden ${a}`, children: [e !== "none" && l.jsx("div", { className: "absolute inset-0 z-0", children: l.jsxs(eoe, { camera: { position: [0, 0, 10], fov: 60 }, style: { background: "transparent" }, dpr: [1, 2], performance: { min: .5 }, children: [l.jsx("ambientLight", { intensity: .3 }), l.jsx("pointLight", { position: [10, 10, 10], intensity: .45, color: r }), l.jsx(moe, { preset: "night" }), s(), l.jsx(loe, { enableZoom: !1, enablePan: !1, autoRotate: !0, autoRotateSpeed: Math.max(.1, i * .35), maxPolarAngle: Math.PI / 2, minPolarAngle: Math.PI / 2 })] }) }), l.jsx("div", { className: "relative z-10", children: t })] }) } const Lt = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("rounded-lg border bg-card text-card-foreground shadow-sm", t), ...e })); Lt.displayName = "Card"; const h3e = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("flex flex-col space-y-1.5 p-6", t), ...e })); h3e.displayName = "CardHeader"; const p3e = S.forwardRef(({ className: t, ...e }, n) => l.jsx("h3", { ref: n, className: _t("text-2xl font-semibold leading-none tracking-tight", t), ...e })); p3e.displayName = "CardTitle"; const m3e = S.forwardRef(({ className: t, ...e }, n) => l.jsx("p", { ref: n, className: _t("text-sm text-muted-foreground", t), ...e })); m3e.displayName = "CardDescription"; const g3e = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("p-6 pt-0", t), ...e })); g3e.displayName = "CardContent"; const v3e = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("flex items-center p-6 pt-0", t), ...e })); v3e.displayName = "CardFooter"; var y3e = i3e(); function x3e() { return y3e.useSyncExternalStore(b3e, () => !0, () => !1) } function b3e() { return () => { } } var VB = "Avatar", [w3e] = oa(VB), [S3e, goe] = w3e(VB), voe = S.forwardRef((t, e) => { const { __scopeAvatar: n, ...r } = t, [i, a] = S.useState("idle"); return l.jsx(S3e, { scope: n, imageLoadingStatus: i, onImageLoadingStatusChange: a, children: l.jsx(qt.span, { ...r, ref: e }) }) }); voe.displayName = VB; var yoe = "AvatarImage", xoe = S.forwardRef((t, e) => { const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => { }, ...a } = t, s = goe(yoe, n), o = _3e(r, a), c = Yi(u => { i(u), s.onImageLoadingStatusChange(u) }); return Ki(() => { o !== "idle" && c(o) }, [o, c]), o === "loaded" ? l.jsx(qt.img, { ...a, ref: e, src: r }) : null }); xoe.displayName = yoe; var boe = "AvatarFallback", woe = S.forwardRef((t, e) => { const { __scopeAvatar: n, delayMs: r, ...i } = t, a = goe(boe, n), [s, o] = S.useState(r === void 0); return S.useEffect(() => { if (r !== void 0) { const c = window.setTimeout(() => o(!0), r); return () => window.clearTimeout(c) } }, [r]), s && a.imageLoadingStatus !== "loaded" ? l.jsx(qt.span, { ...i, ref: e }) : null }); woe.displayName = boe; function O7(t, e) { return t ? e ? (t.src !== e && (t.src = e), t.complete && t.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle" } function _3e(t, { referrerPolicy: e, crossOrigin: n }) { const r = x3e(), i = S.useRef(null), a = r ? (i.current || (i.current = new window.Image), i.current) : null, [s, o] = S.useState(() => O7(a, t)); return Ki(() => { o(O7(a, t)) }, [a, t]), Ki(() => { const c = f => () => { o(f) }; if (!a) return; const u = c("loaded"), d = c("error"); return a.addEventListener("load", u), a.addEventListener("error", d), e && (a.referrerPolicy = e), typeof n == "string" && (a.crossOrigin = n), () => { a.removeEventListener("load", u), a.removeEventListener("error", d) } }, [a, n, e]), s } var Soe = voe, _oe = xoe, Eoe = woe; const Vc = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Soe, { ref: n, className: _t("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", t), ...e })); Vc.displayName = Soe.displayName; const xf = S.forwardRef(({ className: t, ...e }, n) => l.jsx(_oe, { ref: n, className: _t("aspect-square h-full w-full", t), ...e })); xf.displayName = _oe.displayName; const Hc = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Eoe, { ref: n, className: _t("flex h-full w-full items-center justify-center rounded-full bg-muted", t), ...e })); Hc.displayName = Eoe.displayName; function E3e() { const t = ui(), e = fs(), [n, r] = S.useState(!1), [i, a] = S.useState(!1); S.useEffect(() => { const u = e.state?.scrollTo, d = e.hash ? e.hash.replace("#", "") : void 0, f = u ?? d; if (f) { const m = setTimeout(() => { const g = document.getElementById(f); if (g) { const b = g.getBoundingClientRect().top + window.pageYOffset - 64; window.scrollTo({ top: Math.max(0, b), behavior: "smooth" }), window.history.replaceState(null, "", `#${f}`); const E = () => { window.dispatchEvent(new Event("scroll")) }; E(), setTimeout(E, 200), setTimeout(E, 400), setTimeout(E, 600), setTimeout(E, 800) } }, 150); return t(e.pathname + e.search, { replace: !0, state: null }), () => clearTimeout(m) } }, [e.state, e.hash]); const s = [{ icon: ro, title: "AI-Powered Interviews", description: "Practice with advanced AI that adapts to your responses and provides real-time feedback.", color: "text-primary" }, { icon: qc, title: "Peer-to-Peer Practice", description: "Connect with other candidates to practice together and share knowledge.", color: "text-secondary" }, { icon: US, title: "Family & Friends Mode", description: "Invite trusted people to help you practice in a comfortable environment.", color: "text-accent" }, { icon: Qh, title: "Targeted Feedback", description: "Get detailed insights on technical skills, communication, and confidence.", color: "text-primary" }, { icon: Fu, title: "Track Progress", description: "Monitor your improvement over time with comprehensive analytics.", color: "text-secondary" }, { icon: vA, title: "Instant Results", description: "Receive immediate feedback and actionable recommendations after each session.", color: "text-accent" }], o = [{ icon: Kh, title: "Interview Guides", description: "Comprehensive guides covering all types of interviews and industries." }, { icon: Fo, title: "Video Tutorials", description: "Learn best practices from successful candidates and industry experts." }, { icon: df, title: "Question Banks", description: "Access thousands of interview questions categorized by role and difficulty." }, { icon: mA, title: "Certification Prep", description: "Prepare for industry certifications with targeted mock interviews." }], c = ["Build genuine interview confidence", "Get comfortable with video interviews", "Improve technical communication", "Learn from detailed feedback", "Practice at your own pace", "Track your progress over time"]; return l.jsxs("div", { className: "min-h-screen", children: [l.jsx(DA, {}), l.jsx(l3e, {}), l.jsx("div", { className: "block md:hidden py-12 px-4", children: l.jsx("div", { className: "container text-center", children: l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, children: [l.jsx("h1", { className: "text-3xl font-bold mb-4", children: "Master Your Interview Skills with AI" }), l.jsx("p", { className: "text-lg text-muted-foreground mb-6", children: "Practice with advanced AI that adapts to your responses and provides real-time feedback." }), l.jsx(vt, { size: "lg", onClick: () => t("/login?signup=true"), className: "bg-gradient-primary text-primary-foreground hover:opacity-90 transition-all duration-300 hover:scale-105", children: "Get Started Today" })] }) }) }), l.jsx(mu, { backgroundType: "shapes", intensity: .15, color: "#C4B5FD", speed: .3, children: l.jsx("div", { id: "features", className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "Everything You Need to Succeed" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "Comprehensive tools and features designed to transform you into an interview expert" })] }), l.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8 px-4", children: s.map((u, d) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: d * .1 }, whileHover: { y: -5 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover-lift h-full glass", children: [l.jsx(u.icon, { className: `h-10 w-10 sm:h-12 sm:w-12 ${u.color} mb-3 sm:mb-4 mx-auto` }), l.jsx("h3", { className: "text-lg sm:text-xl font-semibold mb-2 text-center", children: u.title }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground text-center", children: u.description })] }) }, u.title)) })] }) }) }), l.jsx(mu, { backgroundType: "wave", intensity: .1, color: "#C4B5FD", speed: .4, children: l.jsx("div", { id: "how-it-works", className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "How It Works" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "Get started in minutes with our simple 3-step process" })] }), l.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8 max-w-4xl mx-auto px-4", children: [{ step: "01", title: "Choose Your Mode", description: "Select between AI-powered interviews, peer practice, or family/friend sessions based on your comfort level.", color: "text-primary" }, { step: "02", title: "Practice & Improve", description: "Conduct realistic mock interviews with instant feedback and detailed performance analytics.", color: "text-accent" }, { step: "03", title: "Track Progress", description: "Monitor your improvement over time with comprehensive analytics and personalized recommendations.", color: "text-secondary" }].map((u, d) => l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: d * .2 }, className: "text-center", whileHover: { scale: 1.05 }, children: [l.jsx("div", { className: "relative mb-4 sm:mb-6", children: l.jsx("div", { className: "w-16 h-16 sm:w-20 sm:h-20 bg-gradient-primary rounded-full flex items-center justify-center mx-auto mb-3 sm:mb-4 glass", children: l.jsx("span", { className: "text-lg sm:text-2xl font-bold text-primary-foreground", children: u.step }) }) }), l.jsx("h3", { className: "text-lg sm:text-xl font-semibold mb-2 sm:mb-3", children: u.title }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: u.description })] }, u.step)) })] }) }) }), l.jsx(mu, { backgroundType: "interactive", intensity: .2, color: "#C4B5FD", speed: .5, children: l.jsx("div", { className: "py-20 md:py-32", children: l.jsx("div", { className: "container px-4", children: l.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8 lg:gap-12 items-center", children: [l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4 sm:mb-6", children: "Why MockRise Works" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground mb-6 sm:mb-8", children: "Our platform is designed by interview experts and powered by advanced AI to give you the most realistic and valuable practice experience." }), l.jsx("div", { className: "space-y-4", children: c.map((u, d) => l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: d * .1 }, className: "flex items-center gap-3", children: [l.jsx(oi, { className: "h-5 w-5 sm:h-6 sm:w-6 text-accent flex-shrink-0" }), l.jsx("span", { className: "text-base sm:text-lg", children: u })] }, u)) })] }), l.jsxs($e.div, { initial: { opacity: 0, x: 20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "relative", children: [l.jsx("div", { className: "aspect-square rounded-2xl bg-gradient-primary opacity-20 blur-3xl absolute inset-0" }), l.jsx(Lt, { className: "p-6 sm:p-8 relative glass", children: l.jsxs("div", { className: "space-y-4 sm:space-y-6", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsx("span", { className: "text-3xl sm:text-4xl font-bold", children: "87%" }), l.jsx(Fu, { className: "h-6 w-6 sm:h-8 sm:w-8 text-accent" })] }), l.jsx("p", { className: "text-base sm:text-lg font-medium", children: "Success Rate" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Of users report feeling more confident and prepared after using MockRise" })] }) })] })] }) }) }) }), l.jsx(mu, { backgroundType: "mesh", intensity: .1, color: "#C4B5FD", speed: .2, children: l.jsx("div", { id: "testimonials", className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "What Our Users Say" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "Join thousands of successful candidates who improved their interview skills with MockRise" })] }), l.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8 max-w-6xl mx-auto px-4", children: [{ name: "Sarah Chen", role: "Software Engineer at Google", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Sarah", content: "MockRise helped me land my dream job at Google! The AI interviewer was incredibly realistic and the feedback was spot-on. I went from being nervous to confident in just 2 weeks.", rating: 5 }, { name: "Michael Rodriguez", role: "Product Manager at Microsoft", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Michael", content: "The peer practice sessions were game-changing. Practicing with other candidates gave me real-world experience and boosted my confidence tremendously.", rating: 5 }, { name: "Emily Johnson", role: "Data Scientist at Amazon", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Emily", content: "The detailed analytics helped me identify my weak areas. I improved my technical communication by 40% in just one month of practice.", rating: 5 }, { name: "David Kim", role: "Frontend Developer at Netflix", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=David", content: "The family mode was perfect for me. Practicing with my sister helped me get comfortable with the interview format before the real thing.", rating: 5 }, { name: "Lisa Wang", role: "UX Designer at Airbnb", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Lisa", content: "The behavioral interview prep was incredible. The AI asked follow-up questions that really challenged me and prepared me for anything.", rating: 5 }, { name: "Alex Thompson", role: "Backend Engineer at Stripe", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Alex", content: "I was skeptical about AI interviews, but MockRise proved me wrong. The feedback was more detailed than any human interviewer I've had.", rating: 5 }].map((u, d) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: d * .1 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover-lift h-full", children: [l.jsx("div", { className: "flex items-center gap-1 mb-3 sm:mb-4", children: [...Array(u.rating)].map((f, h) => l.jsx(Ug, { className: "h-3 w-3 sm:h-4 sm:w-4 fill-current text-warning" }, h)) }), l.jsxs("p", { className: "text-sm sm:text-base text-muted-foreground mb-3 sm:mb-4 italic", children: ['"', u.content, '"'] }), l.jsxs("div", { className: "flex items-center gap-3", children: [l.jsxs(Vc, { className: "h-8 w-8 sm:h-10 sm:w-10", children: [l.jsx(xf, { src: u.avatar }), l.jsx(Hc, { children: u.name.split(" ").map(f => f[0]).join("") })] }), l.jsxs("div", { children: [l.jsx("p", { className: "font-semibold text-xs sm:text-sm", children: u.name }), l.jsx("p", { className: "text-xs text-muted-foreground", children: u.role })] })] })] }) }, u.name)) })] }) }) }), l.jsx(mu, { backgroundType: "shapes", intensity: .1, color: "#C4B5FD", speed: .3, children: l.jsx("div", { id: "resources", className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "Learning Resources" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "Access our comprehensive library of interview preparation materials" })] }), l.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 px-4", children: o.map((u, d) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: d * .1 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover-lift text-center h-full", children: [l.jsx(u.icon, { className: "h-10 w-10 sm:h-12 sm:w-12 text-primary mx-auto mb-3 sm:mb-4" }), l.jsx("h3", { className: "text-base sm:text-lg font-semibold mb-2", children: u.title }), l.jsx("p", { className: "text-xs sm:text-sm text-muted-foreground", children: u.description })] }) }, u.title)) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6, delay: .4 }, className: "mt-16", children: l.jsx(Lt, { className: "p-6 sm:p-8 bg-gradient-to-r from-primary/5 to-secondary/5 border-primary/20 mx-4", children: l.jsxs("div", { className: "text-center max-w-2xl mx-auto", children: [l.jsx("h3", { className: "text-xl sm:text-2xl font-bold mb-3 sm:mb-4", children: "Explore Resources" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground mb-4 sm:mb-6", children: "Articles, FAQs, and Help Guides to boost your interview skills." }), l.jsx(vt, { size: "lg", onClick: () => t("/resources"), className: "bg-gradient-primary text-primary-foreground hover:opacity-90 transition-all duration-300 hover:scale-105", children: "Learn More" })] }) }) })] }) }) }), l.jsx(mu, { backgroundType: "shapes", intensity: .15, color: "#C4B5FD", speed: .3, children: l.jsx("div", { id: "about", className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "About MockRise" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "We're on a mission to democratize interview preparation and help everyone land their dream job" })] }), l.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8 lg:gap-12 items-center max-w-6xl mx-auto px-4", children: [l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, children: [l.jsx("h3", { className: "text-xl sm:text-2xl font-bold mb-4 sm:mb-6", children: "Our Mission" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground mb-4 sm:mb-6", children: "At MockRise, we believe that interview success shouldn't depend on expensive coaching or luck. Our AI-powered platform makes professional interview preparation accessible to everyone, regardless of background or budget." }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground mb-6 sm:mb-8", children: "We combine cutting-edge artificial intelligence with human expertise to create the most realistic and effective interview practice experience available." }), l.jsxs("div", { className: "grid grid-cols-2 gap-6", children: [l.jsxs("div", { className: "text-center", children: [l.jsx("div", { className: "text-2xl sm:text-3xl font-bold text-primary mb-2", children: "50K+" }), l.jsx("div", { className: "text-xs sm:text-sm text-muted-foreground", children: "Users Helped" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx("div", { className: "text-2xl sm:text-3xl font-bold text-primary mb-2", children: "87%" }), l.jsx("div", { className: "text-xs sm:text-sm text-muted-foreground", children: "Success Rate" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx("div", { className: "text-2xl sm:text-3xl font-bold text-primary mb-2", children: "4.9" }), l.jsx("div", { className: "text-xs sm:text-sm text-muted-foreground", children: "User Rating" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx("div", { className: "text-2xl sm:text-3xl font-bold text-primary mb-2", children: "24/7" }), l.jsx("div", { className: "text-xs sm:text-sm text-muted-foreground", children: "AI Available" })] })] })] }), l.jsxs($e.div, { initial: { opacity: 0, x: 20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "relative", children: [l.jsx("div", { className: "aspect-square rounded-2xl bg-gradient-primary opacity-20 blur-3xl absolute inset-0" }), l.jsxs(Lt, { className: "p-6 sm:p-8 relative glass", children: [l.jsx("h4", { className: "text-lg sm:text-xl font-semibold mb-4 sm:mb-6", children: "Our Team" }), l.jsx("div", { className: "space-y-3 sm:space-y-4", children: [{ name: "Dr. Sarah Johnson", role: "CEO & Co-Founder", expertise: "Former Google Engineering Manager", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Sarah" }, { name: "Michael Chen", role: "CTO & Co-Founder", expertise: "AI Research at Stanford", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Michael" }, { name: "Emily Rodriguez", role: "Head of Product", expertise: "UX Design at Apple", avatar: "https://api.dicebear.com/7.x/avataaars/svg?seed=Emily" }].map((u, d) => l.jsxs($e.div, { initial: { opacity: 0, y: 10 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: d * .1 }, className: "flex items-center gap-3", children: [l.jsxs(Vc, { className: "h-10 w-10 sm:h-12 sm:w-12", children: [l.jsx(xf, { src: u.avatar }), l.jsx(Hc, { children: u.name.split(" ").map(f => f[0]).join("") })] }), l.jsxs("div", { children: [l.jsx("p", { className: "font-semibold text-sm sm:text-base", children: u.name }), l.jsx("p", { className: "text-xs sm:text-sm text-muted-foreground", children: u.role }), l.jsx("p", { className: "text-xs text-primary", children: u.expertise })] })] }, u.name)) })] })] })] })] }) }) }), l.jsx(mu, { backgroundType: "mesh", intensity: .1, color: "#C4B5FD", speed: .2, children: l.jsx("div", { id: "contact", className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "Get in Touch" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "Have questions? We're here to help you succeed in your interview journey." })] }), l.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8 max-w-4xl mx-auto px-4", children: [{ icon: Lu, title: "Email Support", description: "Get help via email within 24 hours", contact: "support@mockrise.com", action: "Send Email" }, { icon: ff, title: "Live Chat", description: "Chat with our support team instantly", contact: "Available 24/7", action: "Start Chat" }, { icon: AJ, title: "Phone Support", description: "Speak directly with our team", contact: "+1 (555) 123-4567", action: "Call Now" }].map((u, d) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: d * .1 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover-lift text-center h-full", children: [l.jsx(u.icon, { className: "h-10 w-10 sm:h-12 sm:w-12 text-primary mx-auto mb-3 sm:mb-4" }), l.jsx("h3", { className: "text-base sm:text-lg font-semibold mb-2", children: u.title }), l.jsx("p", { className: "text-xs sm:text-sm text-muted-foreground mb-3 sm:mb-4", children: u.description }), l.jsx("p", { className: "text-xs sm:text-sm font-medium mb-3 sm:mb-4", children: u.contact }), l.jsx(vt, { variant: "outline", size: "sm", className: "w-full hover:bg-gradient-accent hover:opacity-70 hover:scale-105 transition-all duration-200 text-xs sm:text-sm", children: u.action })] }) }, u.title)) })] }) }) }), l.jsx(mu, { backgroundType: "mesh", intensity: .08, color: "#C4B5FD", speed: .25, className: "bg-gradient-primary", children: l.jsx("div", { className: "py-20 md:py-32", children: l.jsx("div", { className: "container", children: l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center text-primary-foreground", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4 sm:mb-6", children: "Ready to Ace Your Next Interview?" }), l.jsx("p", { className: "text-base sm:text-lg mb-6 sm:mb-8 opacity-90 max-w-2xl mx-auto", children: "Join thousands of candidates who have improved their interview skills with MockRise" }), l.jsx(vt, { size: "lg", onClick: () => t("/login?signup=true"), className: "bg-background text-foreground hover:bg-background/90 transition-all duration-300 hover:scale-105 text-base sm:text-lg px-6 sm:px-8 relative z-10", children: "Get Started Today" })] }) }) }) }), l.jsx(Rie, {})] }) } const fn = S.forwardRef(({ className: t, type: e, prefix: n, ...r }, i) => l.jsxs("div", { className: "relative", children: [n && l.jsx("div", { className: "absolute left-3 top-1/2 transform -translate-y-1/2", children: n }), l.jsx("input", { type: e, className: _t("flex h-10 w-full rounded-md border-2 border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus:outline-none focus:border-primary focus:border-2 focus:ring-0 focus-visible:outline-none focus-visible:border-primary focus-visible:border-2 focus-visible:ring-0 disabled:cursor-not-allowed disabled:opacity-50 disabled:border-input md:text-sm transition-colors", n && "pl-10", t), ref: i, ...r })] })); fn.displayName = "Input"; var M3e = "Label", Moe = S.forwardRef((t, e) => l.jsx(qt.label, { ...t, ref: e, onMouseDown: n => { n.target.closest("button, input, select, textarea") || (t.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault()) } })); Moe.displayName = M3e; var Toe = Moe; const T3e = $g("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), We = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Toe, { ref: n, className: _t(T3e(), t), ...e })); We.displayName = Toe.displayName; var C3e = "Separator", D7 = "horizontal", N3e = ["horizontal", "vertical"], Coe = S.forwardRef((t, e) => { const { decorative: n, orientation: r = D7, ...i } = t, a = A3e(r) ? r : D7, o = n ? { role: "none" } : { "aria-orientation": a === "vertical" ? a : void 0, role: "separator" }; return l.jsx(qt.div, { "data-orientation": a, ...o, ...i, ref: e }) }); Coe.displayName = C3e; function A3e(t) { return N3e.includes(t) } var Noe = Coe; const Na = S.forwardRef(({ className: t, orientation: e = "horizontal", decorative: n = !0, ...r }, i) => l.jsx(Noe, { ref: i, decorative: n, orientation: e, className: _t("shrink-0 bg-border", e === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", t), ...r })); Na.displayName = Noe.displayName; function x_(t) { const e = S.useRef({ value: t, previous: t }); return S.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]) } var P3e = [" ", "Enter", "ArrowUp", "ArrowDown"], j3e = [" ", "Enter"], Cg = "Select", [v2, y2, R3e] = m0(Cg), [P0] = oa(Cg, [R3e, b0]), x2 = b0(), [k3e, bp] = P0(Cg), [I3e, O3e] = P0(Cg), Aoe = t => { const { __scopeSelect: e, children: n, open: r, defaultOpen: i, onOpenChange: a, value: s, defaultValue: o, onValueChange: c, dir: u, name: d, autoComplete: f, disabled: h, required: m, form: g } = t, x = x2(e), [v, b] = S.useState(null), [E, M] = S.useState(null), [C, N] = S.useState(!1), A = pp(u), [j, O] = Uo({ prop: r, defaultProp: i ?? !1, onChange: a, caller: Cg }), [I, D] = Uo({ prop: s, defaultProp: o, onChange: c, caller: Cg }), F = S.useRef(null), B = v ? g || !!v.closest("form") : !0, [G, z] = S.useState(new Set), q = Array.from(G).map(Y => Y.props.value).join(";"); return l.jsx(Vee, { ...x, children: l.jsxs(k3e, { required: m, scope: e, trigger: v, onTriggerChange: b, valueNode: E, onValueNodeChange: M, valueNodeHasChildren: C, onValueNodeHasChildrenChange: N, contentId: $l(), value: I, onValueChange: D, open: j, onOpenChange: O, dir: A, triggerPointerDownPosRef: F, disabled: h, children: [l.jsx(v2.Provider, { scope: e, children: l.jsx(I3e, { scope: t.__scopeSelect, onNativeOptionAdd: S.useCallback(Y => { z(Z => new Set(Z).add(Y)) }, []), onNativeOptionRemove: S.useCallback(Y => { z(Z => { const $ = new Set(Z); return $.delete(Y), $ }) }, []), children: n }) }), B ? l.jsxs(Joe, { "aria-hidden": !0, required: m, tabIndex: -1, name: d, autoComplete: f, value: I, onChange: Y => D(Y.target.value), disabled: h, form: g, children: [I === void 0 ? l.jsx("option", { value: "" }) : null, Array.from(G)] }, q) : null] }) }) }; Aoe.displayName = Cg; var Poe = "SelectTrigger", joe = S.forwardRef((t, e) => { const { __scopeSelect: n, disabled: r = !1, ...i } = t, a = x2(n), s = bp(Poe, n), o = s.disabled || r, c = Mn(e, s.onTriggerChange), u = y2(n), d = S.useRef("touch"), [f, h, m] = tle(x => { const v = u().filter(M => !M.disabled), b = v.find(M => M.value === s.value), E = nle(v, x, b); E !== void 0 && s.onValueChange(E.value) }), g = x => { o || (s.onOpenChange(!0), m()), x && (s.triggerPointerDownPosRef.current = { x: Math.round(x.pageX), y: Math.round(x.pageY) }) }; return l.jsx(k5, { asChild: !0, ...a, children: l.jsx(qt.button, { type: "button", role: "combobox", "aria-controls": s.contentId, "aria-expanded": s.open, "aria-required": s.required, "aria-autocomplete": "none", dir: s.dir, "data-state": s.open ? "open" : "closed", disabled: o, "data-disabled": o ? "" : void 0, "data-placeholder": ele(s.value) ? "" : void 0, ...i, ref: c, onClick: Mt(i.onClick, x => { x.currentTarget.focus(), d.current !== "mouse" && g(x) }), onPointerDown: Mt(i.onPointerDown, x => { d.current = x.pointerType; const v = x.target; v.hasPointerCapture(x.pointerId) && v.releasePointerCapture(x.pointerId), x.button === 0 && x.ctrlKey === !1 && x.pointerType === "mouse" && (g(x), x.preventDefault()) }), onKeyDown: Mt(i.onKeyDown, x => { const v = f.current !== ""; !(x.ctrlKey || x.altKey || x.metaKey) && x.key.length === 1 && h(x.key), !(v && x.key === " ") && P3e.includes(x.key) && (g(), x.preventDefault()) }) }) }) }); joe.displayName = Poe; var Roe = "SelectValue", koe = S.forwardRef((t, e) => { const { __scopeSelect: n, className: r, style: i, children: a, placeholder: s = "", ...o } = t, c = bp(Roe, n), { onValueNodeHasChildrenChange: u } = c, d = a !== void 0, f = Mn(e, c.onValueNodeChange); return Ki(() => { u(d) }, [u, d]), l.jsx(qt.span, { ...o, ref: f, style: { pointerEvents: "none" }, children: ele(c.value) ? l.jsx(l.Fragment, { children: s }) : a }) }); koe.displayName = Roe; var D3e = "SelectIcon", Ioe = S.forwardRef((t, e) => { const { __scopeSelect: n, children: r, ...i } = t; return l.jsx(qt.span, { "aria-hidden": !0, ...i, ref: e, children: r || "" }) }); Ioe.displayName = D3e; var L3e = "SelectPortal", Ooe = t => l.jsx(zS, { asChild: !0, ...t }); Ooe.displayName = L3e; var Ng = "SelectContent", Doe = S.forwardRef((t, e) => { const n = bp(Ng, t.__scopeSelect), [r, i] = S.useState(); if (Ki(() => { i(new DocumentFragment) }, []), !n.open) { const a = r; return a ? xi.createPortal(l.jsx(Loe, { scope: t.__scopeSelect, children: l.jsx(v2.Slot, { scope: t.__scopeSelect, children: l.jsx("div", { children: t.children }) }) }), a) : null } return l.jsx(Foe, { ...t, ref: e }) }); Doe.displayName = Ng; var Ac = 10, [Loe, wp] = P0(Ng), F3e = "SelectContentImpl", U3e = xg("SelectContent.RemoveScroll"), Foe = S.forwardRef((t, e) => { const { __scopeSelect: n, position: r = "item-aligned", onCloseAutoFocus: i, onEscapeKeyDown: a, onPointerDownOutside: s, side: o, sideOffset: c, align: u, alignOffset: d, arrowPadding: f, collisionBoundary: h, collisionPadding: m, sticky: g, hideWhenDetached: x, avoidCollisions: v, ...b } = t, E = bp(Ng, n), [M, C] = S.useState(null), [N, A] = S.useState(null), j = Mn(e, ae => C(ae)), [O, I] = S.useState(null), [D, F] = S.useState(null), B = y2(n), [G, z] = S.useState(!1), q = S.useRef(!1); S.useEffect(() => { if (M) return EU(M) }, [M]), wU(); const Y = S.useCallback(ae => { const [se, ...he] = B().map(fe => fe.ref.current), [Ae] = he.slice(-1), Ce = document.activeElement; for (const fe of ae) if (fe === Ce || (fe?.scrollIntoView({ block: "nearest" }), fe === se && N && (N.scrollTop = 0), fe === Ae && N && (N.scrollTop = N.scrollHeight), fe?.focus(), document.activeElement !== Ce)) return }, [B, N]), Z = S.useCallback(() => Y([O, M]), [Y, O, M]); S.useEffect(() => { G && Z() }, [G, Z]); const { onOpenChange: $, triggerPointerDownPosRef: V } = E; S.useEffect(() => { if (M) { let ae = { x: 0, y: 0 }; const se = Ae => { ae = { x: Math.abs(Math.round(Ae.pageX) - (V.current?.x ?? 0)), y: Math.abs(Math.round(Ae.pageY) - (V.current?.y ?? 0)) } }, he = Ae => { ae.x <= 10 && ae.y <= 10 ? Ae.preventDefault() : M.contains(Ae.target) || $(!1), document.removeEventListener("pointermove", se), V.current = null }; return V.current !== null && (document.addEventListener("pointermove", se), document.addEventListener("pointerup", he, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", se), document.removeEventListener("pointerup", he, { capture: !0 }) } } }, [M, $, V]), S.useEffect(() => { const ae = () => $(!1); return window.addEventListener("blur", ae), window.addEventListener("resize", ae), () => { window.removeEventListener("blur", ae), window.removeEventListener("resize", ae) } }, [$]); const [K, X] = tle(ae => { const se = B().filter(Ce => !Ce.disabled), he = se.find(Ce => Ce.ref.current === document.activeElement), Ae = nle(se, ae, he); Ae && setTimeout(() => Ae.ref.current.focus()) }), Q = S.useCallback((ae, se, he) => { const Ae = !q.current && !he; (E.value !== void 0 && E.value === se || Ae) && (I(ae), Ae && (q.current = !0)) }, [E.value]), re = S.useCallback(() => M?.focus(), [M]), ce = S.useCallback((ae, se, he) => { const Ae = !q.current && !he; (E.value !== void 0 && E.value === se || Ae) && F(ae) }, [E.value]), be = r === "popper" ? i4 : Uoe, de = be === i4 ? { side: o, sideOffset: c, align: u, alignOffset: d, arrowPadding: f, collisionBoundary: h, collisionPadding: m, sticky: g, hideWhenDetached: x, avoidCollisions: v } : {}; return l.jsx(Loe, { scope: n, content: M, viewport: N, onViewportChange: A, itemRefCallback: Q, selectedItem: O, onItemLeave: re, itemTextRefCallback: ce, focusSelectedItem: Z, selectedItemText: D, position: r, isPositioned: G, searchRef: K, children: l.jsx(RA, { as: U3e, allowPinchZoom: !0, children: l.jsx(PA, { asChild: !0, trapped: E.open, onMountAutoFocus: ae => { ae.preventDefault() }, onUnmountAutoFocus: Mt(i, ae => { E.trigger?.focus({ preventScroll: !0 }), ae.preventDefault() }), children: l.jsx(g0, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: a, onPointerDownOutside: s, onFocusOutside: ae => ae.preventDefault(), onDismiss: () => E.onOpenChange(!1), children: l.jsx(be, { role: "listbox", id: E.contentId, "data-state": E.open ? "open" : "closed", dir: E.dir, onContextMenu: ae => ae.preventDefault(), ...b, ...de, onPlaced: () => z(!0), ref: j, style: { display: "flex", flexDirection: "column", outline: "none", ...b.style }, onKeyDown: Mt(b.onKeyDown, ae => { const se = ae.ctrlKey || ae.altKey || ae.metaKey; if (ae.key === "Tab" && ae.preventDefault(), !se && ae.key.length === 1 && X(ae.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(ae.key)) { let Ae = B().filter(Ce => !Ce.disabled).map(Ce => Ce.ref.current); if (["ArrowUp", "End"].includes(ae.key) && (Ae = Ae.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(ae.key)) { const Ce = ae.target, fe = Ae.indexOf(Ce); Ae = Ae.slice(fe + 1) } setTimeout(() => Y(Ae)), ae.preventDefault() } }) }) }) }) }) }) }); Foe.displayName = F3e; var B3e = "SelectItemAlignedPosition", Uoe = S.forwardRef((t, e) => { const { __scopeSelect: n, onPlaced: r, ...i } = t, a = bp(Ng, n), s = wp(Ng, n), [o, c] = S.useState(null), [u, d] = S.useState(null), f = Mn(e, j => d(j)), h = y2(n), m = S.useRef(!1), g = S.useRef(!0), { viewport: x, selectedItem: v, selectedItemText: b, focusSelectedItem: E } = s, M = S.useCallback(() => { if (a.trigger && a.valueNode && o && u && x && v && b) { const j = a.trigger.getBoundingClientRect(), O = u.getBoundingClientRect(), I = a.valueNode.getBoundingClientRect(), D = b.getBoundingClientRect(); if (a.dir !== "rtl") { const Ce = D.left - O.left, fe = I.left - Ce, oe = j.left - fe, xe = j.width + oe, _e = Math.max(xe, O.width), je = window.innerWidth - Ac, ke = A1(fe, [Ac, Math.max(Ac, je - _e)]); o.style.minWidth = xe + "px", o.style.left = ke + "px" } else { const Ce = O.right - D.right, fe = window.innerWidth - I.right - Ce, oe = window.innerWidth - j.right - fe, xe = j.width + oe, _e = Math.max(xe, O.width), je = window.innerWidth - Ac, ke = A1(fe, [Ac, Math.max(Ac, je - _e)]); o.style.minWidth = xe + "px", o.style.right = ke + "px" } const F = h(), B = window.innerHeight - Ac * 2, G = x.scrollHeight, z = window.getComputedStyle(u), q = parseInt(z.borderTopWidth, 10), Y = parseInt(z.paddingTop, 10), Z = parseInt(z.borderBottomWidth, 10), $ = parseInt(z.paddingBottom, 10), V = q + Y + G + $ + Z, K = Math.min(v.offsetHeight * 5, V), X = window.getComputedStyle(x), Q = parseInt(X.paddingTop, 10), re = parseInt(X.paddingBottom, 10), ce = j.top + j.height / 2 - Ac, be = B - ce, de = v.offsetHeight / 2, ae = v.offsetTop + de, se = q + Y + ae, he = V - se; if (se <= ce) { const Ce = F.length > 0 && v === F[F.length - 1].ref.current; o.style.bottom = "0px"; const fe = u.clientHeight - x.offsetTop - x.offsetHeight, oe = Math.max(be, de + (Ce ? re : 0) + fe + Z), xe = se + oe; o.style.height = xe + "px" } else { const Ce = F.length > 0 && v === F[0].ref.current; o.style.top = "0px"; const oe = Math.max(ce, q + x.offsetTop + (Ce ? Q : 0) + de) + he; o.style.height = oe + "px", x.scrollTop = se - ce + x.offsetTop } o.style.margin = `${Ac}px 0`, o.style.minHeight = K + "px", o.style.maxHeight = B + "px", r?.(), requestAnimationFrame(() => m.current = !0) } }, [h, a.trigger, a.valueNode, o, u, x, v, b, a.dir, r]); Ki(() => M(), [M]); const [C, N] = S.useState(); Ki(() => { u && N(window.getComputedStyle(u).zIndex) }, [u]); const A = S.useCallback(j => { j && g.current === !0 && (M(), E?.(), g.current = !1) }, [M, E]); return l.jsx(z3e, { scope: n, contentWrapper: o, shouldExpandOnScrollRef: m, onScrollButtonChange: A, children: l.jsx("div", { ref: c, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: C }, children: l.jsx(qt.div, { ...i, ref: f, style: { boxSizing: "border-box", maxHeight: "100%", ...i.style } }) }) }) }); Uoe.displayName = B3e; var $3e = "SelectPopperPosition", i4 = S.forwardRef((t, e) => { const { __scopeSelect: n, align: r = "start", collisionPadding: i = Ac, ...a } = t, s = x2(n); return l.jsx(I5, { ...s, ...a, ref: e, align: r, collisionPadding: i, style: { boxSizing: "border-box", ...a.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); i4.displayName = $3e; var [z3e, HB] = P0(Ng, {}), a4 = "SelectViewport", Boe = S.forwardRef((t, e) => { const { __scopeSelect: n, nonce: r, ...i } = t, a = wp(a4, n), s = HB(a4, n), o = Mn(e, a.onViewportChange), c = S.useRef(0); return l.jsxs(l.Fragment, { children: [l.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: r }), l.jsx(v2.Slot, { scope: n, children: l.jsx(qt.div, { "data-radix-select-viewport": "", role: "presentation", ...i, ref: o, style: { position: "relative", flex: 1, overflow: "hidden auto", ...i.style }, onScroll: Mt(i.onScroll, u => { const d = u.currentTarget, { contentWrapper: f, shouldExpandOnScrollRef: h } = s; if (h?.current && f) { const m = Math.abs(c.current - d.scrollTop); if (m > 0) { const g = window.innerHeight - Ac * 2, x = parseFloat(f.style.minHeight), v = parseFloat(f.style.height), b = Math.max(x, v); if (b < g) { const E = b + m, M = Math.min(g, E), C = E - M; f.style.height = M + "px", f.style.bottom === "0px" && (d.scrollTop = C > 0 ? C : 0, f.style.justifyContent = "flex-end") } } } c.current = d.scrollTop }) }) })] }) }); Boe.displayName = a4; var $oe = "SelectGroup", [V3e, H3e] = P0($oe), W3e = S.forwardRef((t, e) => { const { __scopeSelect: n, ...r } = t, i = $l(); return l.jsx(V3e, { scope: n, id: i, children: l.jsx(qt.div, { role: "group", "aria-labelledby": i, ...r, ref: e }) }) }); W3e.displayName = $oe; var zoe = "SelectLabel", Voe = S.forwardRef((t, e) => { const { __scopeSelect: n, ...r } = t, i = H3e(zoe, n); return l.jsx(qt.div, { id: i.id, ...r, ref: e }) }); Voe.displayName = zoe; var YC = "SelectItem", [G3e, Hoe] = P0(YC), Woe = S.forwardRef((t, e) => { const { __scopeSelect: n, value: r, disabled: i = !1, textValue: a, ...s } = t, o = bp(YC, n), c = wp(YC, n), u = o.value === r, [d, f] = S.useState(a ?? ""), [h, m] = S.useState(!1), g = Mn(e, E => c.itemRefCallback?.(E, r, i)), x = $l(), v = S.useRef("touch"), b = () => { i || (o.onValueChange(r), o.onOpenChange(!1)) }; if (r === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return l.jsx(G3e, { scope: n, value: r, disabled: i, textId: x, isSelected: u, onItemTextChange: S.useCallback(E => { f(M => M || (E?.textContent ?? "").trim()) }, []), children: l.jsx(v2.ItemSlot, { scope: n, value: r, disabled: i, textValue: d, children: l.jsx(qt.div, { role: "option", "aria-labelledby": x, "data-highlighted": h ? "" : void 0, "aria-selected": u && h, "data-state": u ? "checked" : "unchecked", "aria-disabled": i || void 0, "data-disabled": i ? "" : void 0, tabIndex: i ? void 0 : -1, ...s, ref: g, onFocus: Mt(s.onFocus, () => m(!0)), onBlur: Mt(s.onBlur, () => m(!1)), onClick: Mt(s.onClick, () => { v.current !== "mouse" && b() }), onPointerUp: Mt(s.onPointerUp, () => { v.current === "mouse" && b() }), onPointerDown: Mt(s.onPointerDown, E => { v.current = E.pointerType }), onPointerMove: Mt(s.onPointerMove, E => { v.current = E.pointerType, i ? c.onItemLeave?.() : v.current === "mouse" && E.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: Mt(s.onPointerLeave, E => { E.currentTarget === document.activeElement && c.onItemLeave?.() }), onKeyDown: Mt(s.onKeyDown, E => { c.searchRef?.current !== "" && E.key === " " || (j3e.includes(E.key) && b(), E.key === " " && E.preventDefault()) }) }) }) }) }); Woe.displayName = YC; var Ow = "SelectItemText", Goe = S.forwardRef((t, e) => { const { __scopeSelect: n, className: r, style: i, ...a } = t, s = bp(Ow, n), o = wp(Ow, n), c = Hoe(Ow, n), u = O3e(Ow, n), [d, f] = S.useState(null), h = Mn(e, b => f(b), c.onItemTextChange, b => o.itemTextRefCallback?.(b, c.value, c.disabled)), m = d?.textContent, g = S.useMemo(() => l.jsx("option", { value: c.value, disabled: c.disabled, children: m }, c.value), [c.disabled, c.value, m]), { onNativeOptionAdd: x, onNativeOptionRemove: v } = u; return Ki(() => (x(g), () => v(g)), [x, v, g]), l.jsxs(l.Fragment, { children: [l.jsx(qt.span, { id: c.textId, ...a, ref: h }), c.isSelected && s.valueNode && !s.valueNodeHasChildren ? xi.createPortal(a.children, s.valueNode) : null] }) }); Goe.displayName = Ow; var qoe = "SelectItemIndicator", Xoe = S.forwardRef((t, e) => { const { __scopeSelect: n, ...r } = t; return Hoe(qoe, n).isSelected ? l.jsx(qt.span, { "aria-hidden": !0, ...r, ref: e }) : null }); Xoe.displayName = qoe; var s4 = "SelectScrollUpButton", Yoe = S.forwardRef((t, e) => { const n = wp(s4, t.__scopeSelect), r = HB(s4, t.__scopeSelect), [i, a] = S.useState(!1), s = Mn(e, r.onScrollButtonChange); return Ki(() => { if (n.viewport && n.isPositioned) { let o = function () { const u = c.scrollTop > 0; a(u) }; const c = n.viewport; return o(), c.addEventListener("scroll", o), () => c.removeEventListener("scroll", o) } }, [n.viewport, n.isPositioned]), i ? l.jsx(Zoe, { ...t, ref: s, onAutoScroll: () => { const { viewport: o, selectedItem: c } = n; o && c && (o.scrollTop = o.scrollTop - c.offsetHeight) } }) : null }); Yoe.displayName = s4; var o4 = "SelectScrollDownButton", Koe = S.forwardRef((t, e) => { const n = wp(o4, t.__scopeSelect), r = HB(o4, t.__scopeSelect), [i, a] = S.useState(!1), s = Mn(e, r.onScrollButtonChange); return Ki(() => { if (n.viewport && n.isPositioned) { let o = function () { const u = c.scrollHeight - c.clientHeight, d = Math.ceil(c.scrollTop) < u; a(d) }; const c = n.viewport; return o(), c.addEventListener("scroll", o), () => c.removeEventListener("scroll", o) } }, [n.viewport, n.isPositioned]), i ? l.jsx(Zoe, { ...t, ref: s, onAutoScroll: () => { const { viewport: o, selectedItem: c } = n; o && c && (o.scrollTop = o.scrollTop + c.offsetHeight) } }) : null }); Koe.displayName = o4; var Zoe = S.forwardRef((t, e) => { const { __scopeSelect: n, onAutoScroll: r, ...i } = t, a = wp("SelectScrollButton", n), s = S.useRef(null), o = y2(n), c = S.useCallback(() => { s.current !== null && (window.clearInterval(s.current), s.current = null) }, []); return S.useEffect(() => () => c(), [c]), Ki(() => { o().find(d => d.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" }) }, [o]), l.jsx(qt.div, { "aria-hidden": !0, ...i, ref: e, style: { flexShrink: 0, ...i.style }, onPointerDown: Mt(i.onPointerDown, () => { s.current === null && (s.current = window.setInterval(r, 50)) }), onPointerMove: Mt(i.onPointerMove, () => { a.onItemLeave?.(), s.current === null && (s.current = window.setInterval(r, 50)) }), onPointerLeave: Mt(i.onPointerLeave, () => { c() }) }) }), q3e = "SelectSeparator", Qoe = S.forwardRef((t, e) => { const { __scopeSelect: n, ...r } = t; return l.jsx(qt.div, { "aria-hidden": !0, ...r, ref: e }) }); Qoe.displayName = q3e; var l4 = "SelectArrow", X3e = S.forwardRef((t, e) => { const { __scopeSelect: n, ...r } = t, i = x2(n), a = bp(l4, n), s = wp(l4, n); return a.open && s.position === "popper" ? l.jsx(O5, { ...i, ...r, ref: e }) : null }); X3e.displayName = l4; var Y3e = "SelectBubbleInput", Joe = S.forwardRef(({ __scopeSelect: t, value: e, ...n }, r) => { const i = S.useRef(null), a = Mn(r, i), s = x_(e); return S.useEffect(() => { const o = i.current; if (!o) return; const c = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(c, "value").set; if (s !== e && d) { const f = new Event("change", { bubbles: !0 }); d.call(o, e), o.dispatchEvent(f) } }, [s, e]), l.jsx(qt.select, { ...n, style: { ...LJ, ...n.style }, ref: a, defaultValue: e }) }); Joe.displayName = Y3e; function ele(t) { return t === "" || t === void 0 } function tle(t) { const e = Yi(t), n = S.useRef(""), r = S.useRef(0), i = S.useCallback(s => { const o = n.current + s; e(o), (function c(u) { n.current = u, window.clearTimeout(r.current), u !== "" && (r.current = window.setTimeout(() => c(""), 1e3)) })(o) }, [e]), a = S.useCallback(() => { n.current = "", window.clearTimeout(r.current) }, []); return S.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, a] } function nle(t, e, n) { const i = e.length > 1 && Array.from(e).every(u => u === e[0]) ? e[0] : e, a = n ? t.indexOf(n) : -1; let s = K3e(t, Math.max(a, 0)); i.length === 1 && (s = s.filter(u => u !== n)); const c = s.find(u => u.textValue.toLowerCase().startsWith(i.toLowerCase())); return c !== n ? c : void 0 } function K3e(t, e) { return t.map((n, r) => t[(e + r) % t.length]) } var Z3e = Aoe, rle = joe, Q3e = koe, J3e = Ioe, eLe = Ooe, ile = Doe, tLe = Boe, ale = Voe, sle = Woe, nLe = Goe, rLe = Xoe, ole = Yoe, lle = Koe, cle = Qoe; const Jn = Z3e, er = Q3e, qn = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsxs(rle, { ref: r, className: _t("flex h-10 w-full items-center justify-between rounded-md border-2 border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:border-primary focus:border-2 focus:ring-0 focus-visible:outline-none focus-visible:border-primary focus-visible:border-2 focus-visible:ring-0 disabled:cursor-not-allowed disabled:opacity-50 disabled:border-input [&>span]:line-clamp-1 data-[state=open]:border-primary data-[state=open]:border-2 data-[state=open]:ring-0 transition-colors", t), ...n, children: [e, l.jsx(J3e, { asChild: !0, children: l.jsx(gA, { className: "h-4 w-4 opacity-50" }) })] })); qn.displayName = rle.displayName; const ule = S.forwardRef(({ className: t, ...e }, n) => l.jsx(ole, { ref: n, className: _t("flex cursor-default items-center justify-center py-1", t), ...e, children: l.jsx($ve, { className: "h-4 w-4" }) })); ule.displayName = ole.displayName; const dle = S.forwardRef(({ className: t, ...e }, n) => l.jsx(lle, { ref: n, className: _t("flex cursor-default items-center justify-center py-1", t), ...e, children: l.jsx(gA, { className: "h-4 w-4" }) })); dle.displayName = lle.displayName; const Xn = S.forwardRef(({ className: t, children: e, position: n = "popper", ...r }, i) => l.jsx(eLe, { children: l.jsxs(ile, { ref: i, className: _t("relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", t), position: n, ...r, children: [l.jsx(ule, {}), l.jsx(tLe, { className: _t("p-1", n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"), children: e }), l.jsx(dle, {})] }) })); Xn.displayName = ile.displayName; const iLe = S.forwardRef(({ className: t, ...e }, n) => l.jsx(ale, { ref: n, className: _t("py-1.5 pl-8 pr-2 text-sm font-semibold", t), ...e })); iLe.displayName = ale.displayName; const ut = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsxs(sle, { ref: r, className: _t("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground", t), ...n, children: [l.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: l.jsx(rLe, { children: l.jsx(l5, { className: "h-4 w-4" }) }) }), l.jsx(nLe, { children: e })] })); ut.displayName = sle.displayName; const aLe = S.forwardRef(({ className: t, ...e }, n) => l.jsx(cle, { ref: n, className: _t("-mx-1 my-1 h-px bg-muted", t), ...e })); aLe.displayName = cle.displayName; var WB = "Radio", [sLe, fle] = oa(WB), [oLe, lLe] = sLe(WB), hle = S.forwardRef((t, e) => { const { __scopeRadio: n, name: r, checked: i = !1, required: a, disabled: s, value: o = "on", onCheck: c, form: u, ...d } = t, [f, h] = S.useState(null), m = Mn(e, v => h(v)), g = S.useRef(!1), x = f ? u || !!f.closest("form") : !0; return l.jsxs(oLe, { scope: n, checked: i, disabled: s, children: [l.jsx(qt.button, { type: "button", role: "radio", "aria-checked": i, "data-state": vle(i), "data-disabled": s ? "" : void 0, disabled: s, value: o, ...d, ref: m, onClick: Mt(t.onClick, v => { i || c?.(), x && (g.current = v.isPropagationStopped(), g.current || v.stopPropagation()) }) }), x && l.jsx(gle, { control: f, bubbles: !g.current, name: r, value: o, checked: i, required: a, disabled: s, form: u, style: { transform: "translateX(-100%)" } })] }) }); hle.displayName = WB; var ple = "RadioIndicator", mle = S.forwardRef((t, e) => { const { __scopeRadio: n, forceMount: r, ...i } = t, a = lLe(ple, n); return l.jsx(Ka, { present: r || a.checked, children: l.jsx(qt.span, { "data-state": vle(a.checked), "data-disabled": a.disabled ? "" : void 0, ...i, ref: e }) }) }); mle.displayName = ple; var cLe = "RadioBubbleInput", gle = S.forwardRef(({ __scopeRadio: t, control: e, checked: n, bubbles: r = !0, ...i }, a) => { const s = S.useRef(null), o = Mn(s, a), c = x_(n), u = WS(e); return S.useEffect(() => { const d = s.current; if (!d) return; const f = window.HTMLInputElement.prototype, m = Object.getOwnPropertyDescriptor(f, "checked").set; if (c !== n && m) { const g = new Event("click", { bubbles: r }); m.call(d, n), d.dispatchEvent(g) } }, [c, n, r]), l.jsx(qt.input, { type: "radio", "aria-hidden": !0, defaultChecked: n, ...i, tabIndex: -1, ref: o, style: { ...i.style, ...u, position: "absolute", pointerEvents: "none", opacity: 0, margin: 0 } }) }); gle.displayName = cLe; function vle(t) { return t ? "checked" : "unchecked" } var uLe = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], b2 = "RadioGroup", [dLe] = oa(b2, [M0, fle]), yle = M0(), xle = fle(), [fLe, hLe] = dLe(b2), ble = S.forwardRef((t, e) => { const { __scopeRadioGroup: n, name: r, defaultValue: i, value: a, required: s = !1, disabled: o = !1, orientation: c, dir: u, loop: d = !0, onValueChange: f, ...h } = t, m = yle(n), g = pp(u), [x, v] = Uo({ prop: a, defaultProp: i ?? null, onChange: f, caller: b2 }); return l.jsx(fLe, { scope: n, name: r, required: s, disabled: o, value: x, onValueChange: v, children: l.jsx(SU, { asChild: !0, ...m, orientation: c, dir: g, loop: d, children: l.jsx(qt.div, { role: "radiogroup", "aria-required": s, "aria-orientation": c, "data-disabled": o ? "" : void 0, dir: g, ...h, ref: e }) }) }) }); ble.displayName = b2; var wle = "RadioGroupItem", Sle = S.forwardRef((t, e) => { const { __scopeRadioGroup: n, disabled: r, ...i } = t, a = hLe(wle, n), s = a.disabled || r, o = yle(n), c = xle(n), u = S.useRef(null), d = Mn(e, u), f = a.value === i.value, h = S.useRef(!1); return S.useEffect(() => { const m = x => { uLe.includes(x.key) && (h.current = !0) }, g = () => h.current = !1; return document.addEventListener("keydown", m), document.addEventListener("keyup", g), () => { document.removeEventListener("keydown", m), document.removeEventListener("keyup", g) } }, []), l.jsx(_U, { asChild: !0, ...o, focusable: !s, active: f, children: l.jsx(hle, { disabled: s, required: a.required, checked: f, ...c, ...i, name: a.name, ref: d, onCheck: () => a.onValueChange(i.value), onKeyDown: Mt(m => { m.key === "Enter" && m.preventDefault() }), onFocus: Mt(i.onFocus, () => { h.current && u.current?.click() }) }) }) }); Sle.displayName = wle; var pLe = "RadioGroupIndicator", _le = S.forwardRef((t, e) => { const { __scopeRadioGroup: n, ...r } = t, i = xle(n); return l.jsx(mle, { ...i, ...r, ref: e }) }); _le.displayName = pLe; var Ele = ble, Mle = Sle, mLe = _le; const w2 = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Ele, { className: _t("grid gap-2", t), ...e, ref: n })); w2.displayName = Ele.displayName; const Ax = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Mle, { ref: n, className: _t("aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ...e, children: l.jsx(mLe, { className: "flex items-center justify-center", children: l.jsx(wJ, { className: "h-2.5 w-2.5 fill-current text-current" }) }) })); Ax.displayName = Mle.displayName; function eg({ children: t, className: e, ...n }) { return l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4 }, className: _t("relative overflow-hidden rounded-xl bg-background/40 p-8", "backdrop-blur-md border border-white/10", "shadow-[0_8px_16px_rgb(0_0_0/0.1)]", "before:absolute before:inset-0", "before:bg-gradient-to-b before:from-white/5 before:to-white/10", "before:pointer-events-none", e), ...n, children: t }) } function ef({ children: t, variant: e = "login" }) { const [n, r] = S.useState({ x: 0, y: 0 }), i = () => { switch (e) { case "signup": return { primary: "from-primary/20 via-secondary/20 to-accent/20", secondary: "from-accent/10 via-primary/10 to-secondary/10" }; case "forgot": return { primary: "from-secondary/20 via-accent/20 to-primary/20", secondary: "from-primary/10 via-secondary/10 to-accent/10" }; default: return { primary: "from-primary/20 via-accent/20 to-secondary/20", secondary: "from-secondary/10 via-primary/10 to-accent/10" } } }; S.useEffect(() => { const o = c => { const { clientX: u, clientY: d } = c, f = u / window.innerWidth, h = d / window.innerHeight; r({ x: f, y: h }) }; return window.addEventListener("mousemove", o), () => window.removeEventListener("mousemove", o) }, []); const { primary: a, secondary: s } = i(); return l.jsxs("div", { className: "min-h-screen relative overflow-hidden bg-background", children: [l.jsx($e.div, { className: `absolute inset-0 bg-gradient-to-tr opacity-50 ${a}`, animate: { scale: [1, 1.1, 1], rotate: [0, 3, 0], x: n.x * 10, y: n.y * 10 }, transition: { duration: 8, repeat: 1 / 0, repeatType: "reverse" } }), l.jsx($e.div, { className: `absolute inset-0 bg-gradient-to-bl opacity-30 ${s}`, animate: { scale: [1.1, 1, 1.1], rotate: [0, -3, 0], x: n.x * -10, y: n.y * -10 }, transition: { duration: 8, repeat: 1 / 0, repeatType: "reverse" } }), l.jsx("div", { className: "absolute inset-0 overflow-hidden", children: l.jsx("div", { className: "particles-container" }) }), l.jsx("div", { className: "relative z-10", children: t })] }) } const Qd = { "Front-End Development": { subcategories: ["HTML", "CSS", "JavaScript", "React", "Next.js", "Vue.js", "Tailwind", "Bootstrap"] }, "Back-End Development": { subcategories: ["Node.js", "Express", "Django", "Flask", "Laravel", "PHP", "MongoDB", "PostgreSQL"] }, "Full-Stack Development": { subcategories: [] }, "Mobile Development": { subcategories: ["Flutter", "React Native"] }, "DevOps & Cloud": { subcategories: ["Docker", "Kubernetes", "CI/CD", "AWS", "GCP", "Azure"] }, "Software Testing & QA": { subcategories: ["Manual Testing", "Automation Testing", "Cypress", "Selenium", "API Testing"] }, "UI/UX Design": { subcategories: ["UI Fundamentals", "UX Research", "Wireframing & Prototyping", "Figma Tutorials", "Design Systems", "Usability Testing"] }, "Soft Skills & Career": { subcategories: ["Communication", "Interview Preparation", "Leadership", "Productivity"] } }, L7 = (t, e) => { const n = "https://res.cloudinary.com/demo/image/upload", r = { guide: `${n}/w_400,h_200,c_fill,e_blur:300,q_auto/sample.jpg`, video: `${n}/w_400,h_200,c_fill,q_auto/video.jpg`, question_bank: `${n}/w_400,h_200,c_fill,e_art:hokusai,q_auto/sample.jpg`, course: `${n}/w_400,h_200,c_fill,e_brightness:10,q_auto/sample.jpg`, article: `${n}/w_400,h_200,c_fill,e_sharpen,q_auto/sample.jpg` }, i = { guide: "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=200&fit=crop", video: "https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=400&h=200&fit=crop", question_bank: "https://images.unsplash.com/photo-1434030216411-0b793f4b4173?w=400&h=200&fit=crop", course: "https://images.unsplash.com/photo-1501504905252-473c47e087f8?w=400&h=200&fit=crop", article: "https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=200&fit=crop" }; return r[t] || i[t] || i.guide }; function gLe() { const { login: t, register: e, user: n, loading: r, logout: i, fetchUser: a } = La(), [s] = pJ(), o = fs(), c = ui(), u = s.get("signup") === "true", d = s.get("role"), [f, h] = S.useState(u), [m, g] = S.useState(!1), [x, v] = S.useState(!1), [b, E] = S.useState(!1), [M, C] = S.useState(d || "trainee"); S.useEffect(() => { d && d === "interviewer" && (h(!0), C("interviewer")) }, [d]); const [N, A] = S.useState(""), [j, O] = S.useState(""), [I, D] = S.useState(""), [F, B] = S.useState(null), [G, z] = S.useState(null), [q, Y] = S.useState({ name: "", email: "", password: "", confirmPassword: "" }), [Z, $] = S.useState({}), [V, K] = S.useState({ length: !1, uppercase: !1, lowercase: !1, number: !1, special: !1 }); S.useEffect(() => { const ae = s.get("error"), se = s.get("message"); if (ae === "oauth_failed" || ae === "oauth_invalid_role") { const he = se || "OAuth authentication failed. Please try again."; dt.error(he), c("/login?signup=" + (f ? "true" : "false"), { replace: !0 }) } }, [s, c, f]), S.useEffect(() => { (window.history.state?.passwordResetSuccess || s.get("passwordResetSuccess") === "true") && (dt.success("Password reset successful! Please log in with your new password."), c("/login", { replace: !0 })) }, [s, c]), S.useEffect(() => { a() }, [a]), S.useEffect(() => { if (n && !r) { if (n.role === "interviewer" && n.status === "rejected") { c("/rejected-notice", { replace: !0 }); return } if (n.role === "interviewer" && n.status === "pending_verification") { c("/pending-verification", { replace: !0 }); return } if (n.status === "rejected" && u) return; if (!f) { const ae = n.role === "super_admin" ? "admin" : n.role; c(`/dashboard/${ae}`, { replace: !0 }) } } }, [n, c, r, f, u, o.state]); const X = ae => { z(null); const se = { length: ae.length >= 8, uppercase: /[A-Z]/.test(ae), lowercase: /[a-z]/.test(ae), number: /\d/.test(ae), special: /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(ae) }; return K(se), Object.values(se).every(Boolean) }, Q = () => { z(null); const ae = {}; return f ? (q.name.trim() || (ae.name = "Full name is required."), q.email.trim() ? /\S+@\S+\.\S+/.test(q.email) || (ae.email = "Please enter a valid email address.") : ae.email = "Email is required.", q.password ? X(q.password) || (ae.password = "Password does not meet requirements.") : ae.password = "Password is required.", q.confirmPassword ? q.password !== q.confirmPassword && (ae.confirmPassword = "Passwords do not match.") : ae.confirmPassword = "Please confirm your password.", M === "interviewer" && (N || (ae.yearsExperience = "Years of experience is required."), j || (ae.expertiseArea = "Area of expertise is required."), I.trim() ? /^https?:\/\/(www\.)?linkedin\.com\/.*$/.test(I) || (ae.linkedinUrl = "Please enter a valid LinkedIn URL.") : ae.linkedinUrl = "LinkedIn URL is required.", F || (ae.resume = "Resume upload is required."))) : (q.email.trim() ? /\S+@\S+\.\S+/.test(q.email) || (ae.email = "Please enter a valid email address.") : ae.email = "Email is required.", q.password || (ae.password = "Password is required.")), $(ae), Object.keys(ae).length === 0 }, re = async ae => { if (ae.preventDefault(), !!Q()) { g(!0), z(null); try { let se; if (f) { const he = { name: q.name, email: q.email, password: q.password, role: M }; if (M === "interviewer" && (he.experience = N, he.expertise = j, he.linkedin = I, F)) { const { uploadService: Ae } = await ODe(async () => { const { uploadService: Ce } = await Promise.resolve().then(() => O4e); return { uploadService: Ce } }, void 0); try { const Ce = await Ae.uploadResume(F); he.resume = Ce.data.url } catch { dt.error("Failed to upload resume. Please try again."), g(!1); return } } if (se = await e(he), M === "trainee") { const Ae = q.email; dt.success("Account created successfully! Please log in to continue."); try { await i() } catch (Ce) { console.error("Logout error:", Ce) } Y({ name: "", email: Ae, password: "", confirmPassword: "" }), A(""), O(""), D(""), B(null), $({}), z(null), K({ length: !1, uppercase: !1, lowercase: !1, number: !1, special: !1 }), h(!1), c("/login", { replace: !0 }); return } else if (M === "interviewer") { if (dt.success("Account created! Your application is under review."), se) c(se); else { const Ae = n?.role === "super_admin" ? "admin" : n?.role || "trainee"; c(`/dashboard/${Ae}`) } return } } else if (se = await t(q.email, q.password), se !== "/rejected-notice" && dt.success("Welcome back!"), se) c(se); else { const he = n?.role === "super_admin" ? "admin" : n?.role || "trainee"; c(`/dashboard/${he}`) } } catch (se) { const he = se instanceof Error ? se.message : "An unexpected error occurred."; z(he), he.includes("already exists") && f && M === "interviewer" ? dt.error("An account with this email already exists. Please use a different email or contact support if you'd like to update your application.") : dt.error(he) } finally { g(!1) } } }, ce = ae => { const se = ae.target.files?.[0]; se && se.type === "application/pdf" ? (B(se), dt.success("Resume uploaded successfully!")) : dt.error("Please upload a PDF file.") }, be = () => { const ae = Lc.getOAuthUrl("google"); window.location.href = ae }, de = () => { const ae = Lc.getOAuthUrl("github"); window.location.href = ae }; return l.jsx(ef, { variant: f ? "signup" : "login", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { duration: .5 }, className: "w-full max-w-md", children: l.jsxs(eg, { children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-8 group", children: [l.jsx($e.div, { whileHover: { rotate: 12, scale: 1.1 }, transition: { type: "spring", stiffness: 400, damping: 10 }, children: l.jsx(Ia, { className: "h-8 w-8 text-primary" }) }), l.jsx("span", { className: "text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary via-secondary to-accent", children: "MockRise" })] }), l.jsxs("div", { className: "text-center mb-8", children: [l.jsx("h1", { className: "text-2xl font-bold mb-2", children: f ? "Create Your Account" : "Welcome Back" }), l.jsx("p", { className: "text-muted-foreground", children: f ? "Start your journey to interview success" : "Continue your interview preparation" })] }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .2 }, className: "space-y-3 mb-6", children: [l.jsxs(on, { type: "button", variant: "outline", className: "w-full", onClick: () => be(), motionProps: { whileHover: { scale: 1.02 }, whileTap: { scale: .98 } }, children: [l.jsxs("svg", { className: "h-5 w-5 mr-2", viewBox: "0 0 24 24", children: [l.jsx("path", { fill: "currentColor", d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" }), l.jsx("path", { fill: "currentColor", d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" }), l.jsx("path", { fill: "currentColor", d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" }), l.jsx("path", { fill: "currentColor", d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" })] }), "Continue with Google"] }), l.jsxs(on, { type: "button", variant: "outline", className: "w-full", onClick: () => de(), motionProps: { whileHover: { scale: 1.02 }, whileTap: { scale: .98 } }, children: [l.jsx(Wve, { className: "h-5 w-5 mr-2" }), "Continue with Github"] })] }), l.jsxs("div", { className: "flex items-center my-6", children: [l.jsx(Na, { className: "flex-1" }), l.jsx("span", { className: "mx-4 text-xs text-muted-foreground", children: "OR" }), l.jsx(Na, { className: "flex-1" })] }), l.jsxs("form", { onSubmit: re, className: "space-y-4", children: [f && l.jsx($e.div, { initial: { opacity: 0, y: -10 }, animate: { opacity: 1, y: 0 }, className: "space-y-4", children: l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "name", children: "Full Name" }), l.jsxs("div", { className: "relative", children: [l.jsx(hf, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "name", type: "text", placeholder: "John Doe", className: "pl-10", value: q.name, onChange: ae => Y({ ...q, name: ae.target.value }), required: !0 })] }), Z.name && l.jsx("p", { className: "text-sm text-destructive", children: Z.name })] }) }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "email", children: "Email" }), l.jsxs("div", { className: "relative", children: [l.jsx(Lu, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "email", type: "email", placeholder: "john@example.com", className: "pl-10", value: q.email, onChange: ae => Y({ ...q, email: ae.target.value }), required: !0 })] }), Z.email && l.jsx("p", { className: "text-sm text-destructive", children: Z.email })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "password", children: "Password" }), l.jsxs("div", { className: "relative", children: [l.jsx(Zh, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "password", type: x ? "text" : "password", placeholder: "", className: "pl-10", value: q.password, onChange: ae => { Y({ ...q, password: ae.target.value }), X(ae.target.value) }, required: !0 }), l.jsx("button", { type: "button", onClick: () => v(!x), className: "absolute right-3 top-1/2 -translate-y-1/2", children: x ? l.jsx(zT, { className: "h-4 w-4 text-muted-foreground" }) : l.jsx(Du, { className: "h-4 w-4 text-muted-foreground" }) })] }), Z.password && l.jsx("p", { className: "text-sm text-destructive", children: Z.password })] }), !f && l.jsx("div", { className: "flex items-center justify-end", children: l.jsx(yi, { to: "/forgot-password", children: l.jsx(on, { type: "button", variant: "link", className: "text-sm text-primary px-0", children: "Forgot password?" }) }) }), f && l.jsxs($e.div, { initial: { opacity: 0, y: -10 }, animate: { opacity: 1, y: 0 }, className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "confirmPassword", children: "Confirm Password" }), l.jsxs("div", { className: "relative", children: [l.jsx(Zh, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "confirmPassword", type: b ? "text" : "password", placeholder: "", className: "pl-10", value: q.confirmPassword, onChange: ae => Y({ ...q, confirmPassword: ae.target.value }), required: !0 }), l.jsx("button", { type: "button", onClick: () => E(!b), className: "absolute right-3 top-1/2 -translate-y-1/2", children: b ? l.jsx(zT, { className: "h-4 w-4 text-muted-foreground" }) : l.jsx(Du, { className: "h-4 w-4 text-muted-foreground" }) })] }), Z.confirmPassword && l.jsx("p", { className: "text-sm text-destructive", children: Z.confirmPassword })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { children: "Choose your role" }), l.jsxs(w2, { defaultValue: "trainee", className: "flex space-x-4", onValueChange: C, children: [l.jsxs("div", { className: "flex items-center space-x-2", children: [l.jsx(Ax, { value: "trainee", id: "trainee" }), l.jsx(We, { htmlFor: "trainee", children: "Trainee" })] }), l.jsxs("div", { className: "flex items-center space-x-2", children: [l.jsx(Ax, { value: "interviewer", id: "interviewer" }), l.jsx(We, { htmlFor: "interviewer", children: "Interviewer" })] })] })] }), M === "interviewer" && l.jsxs($e.div, { initial: { opacity: 0, height: 0 }, animate: { opacity: 1, height: "auto" }, exit: { opacity: 0, height: 0 }, className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "yearsExperience", children: "Years of Experience" }), l.jsxs(Jn, { onValueChange: A, value: N, children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select your experience" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "0-2", children: "0-2 years" }), l.jsx(ut, { value: "2-5", children: "2-5 years" }), l.jsx(ut, { value: "5-10", children: "5-10 years" }), l.jsx(ut, { value: "10+", children: "10+ years" })] })] }), Z.yearsExperience && l.jsx("p", { className: "text-sm text-destructive", children: Z.yearsExperience })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "expertiseArea", children: "Area of Expertise *" }), l.jsxs(Jn, { value: j, onValueChange: ae => O(ae), children: [l.jsx(qn, { id: "expertiseArea", children: l.jsx(er, { placeholder: "Select your area of expertise" }) }), l.jsx(Xn, { children: Object.keys(Qd).map(ae => l.jsx(ut, { value: ae, children: ae }, ae)) })] }), Z.expertiseArea && l.jsx("p", { className: "text-sm text-destructive", children: Z.expertiseArea })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "linkedinUrl", children: "LinkedIn Profile" }), l.jsxs("div", { className: "relative", children: [l.jsx(BS, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "linkedinUrl", type: "url", placeholder: "https://linkedin.com/in/yourprofile", className: "pl-10", value: I, onChange: ae => D(ae.target.value) })] }), Z.linkedinUrl && l.jsx("p", { className: "text-sm text-destructive", children: Z.linkedinUrl })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "resume", children: "Upload Resume (PDF)" }), l.jsxs("div", { className: "relative", children: [l.jsx($S, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "resume", type: "file", accept: ".pdf", className: "pl-10 file:text-sm file:font-medium file:text-primary", onChange: ce })] }), Z.resume && l.jsx("p", { className: "text-sm text-destructive", children: Z.resume })] })] })] }), G && l.jsxs("div", { className: "bg-destructive/10 text-destructive text-sm p-3 rounded-md flex items-center", children: [l.jsx(Pa, { className: "h-4 w-4 mr-2" }), G] }), l.jsx(on, { type: "submit", className: "w-full", disabled: m, motionProps: { whileHover: { scale: 1.02 }, whileTap: { scale: .98 } }, children: m ? "Processing..." : f ? "Create Account" : "Log In" })] }), l.jsxs("p", { className: "mt-6 text-center text-sm text-muted-foreground", children: [f ? "Already have an account?" : "Don't have an account?", l.jsx("button", { onClick: () => h(!f), className: "font-semibold text-primary hover:underline ml-1", children: f ? "Log In" : "Sign Up" })] })] }) }) }) }) } function vLe() { ui(); const [t, e] = S.useState(""), [n, r] = S.useState(!1), [i, a] = S.useState(!1), [s, o] = S.useState(0); S.useEffect(() => { if (s <= 0) return; const h = setInterval(() => o(m => Math.max(0, m - 1)), 1e3); return () => clearInterval(h) }, [s]); const [c, u] = S.useState(null), d = async h => { if (h.preventDefault(), u(null), !t) { dt.error("Please enter your email address."); return } if (!/\S+@\S+\.\S+/.test(t)) { dt.error("Please enter a valid email address."); return } r(!0); try { const m = await Lc.forgotPassword(t); m.success ? (a(!0), o(60), dt.success(m.message || "A password reset link has been sent to your email.")) : m.error === "oauth_account" ? (u(m.message || "This email is associated with an OAuth account. Please sign in using your OAuth provider."), dt.error(m.message || "This email is associated with an OAuth account. Please sign in using your OAuth provider.")) : (u(m.message || "An error occurred. Please try again."), dt.error(m.message || "An error occurred. Please try again.")) } catch (m) { const g = m.responseData || {}, x = g.message || m.message || "An error occurred. Please try again."; g.error === "oauth_account" || x.includes("OAuth") || x.includes("oauth_account") || m.statusCode === 400 || m.statusCode === 500 ? (u(x), dt.error(x)) : (u("Failed to send password reset email. Please try again."), dt.error("Failed to send password reset email. Please try again.")) } finally { r(!1) } }, f = async () => { if (s > 0) { dt.info(`Please wait ${s}s before resending.`); return } if (!t || !/\S+@\S+\.\S+/.test(t)) { dt.error("Please enter a valid email address."); return } u(null); try { const h = await Lc.forgotPassword(t); h.success ? (o(60), dt.success(h.message || "A password reset link has been sent to your email."), u(null)) : h.error === "oauth_account" ? (u(h.message || "This email is associated with an OAuth account. Please sign in using your OAuth provider."), dt.error(h.message || "This email is associated with an OAuth account. Please sign in using your OAuth provider.")) : (u(h.message || "An error occurred. Please try again."), dt.error(h.message || "An error occurred. Please try again.")) } catch (h) { const m = h.responseData || {}, g = m.message || h.message || "An error occurred. Please try again."; m.error === "oauth_account" || g.includes("OAuth") || g.includes("oauth_account") ? (u(g), dt.error(g)) : (u("Failed to send password reset email. Please try again."), dt.error("Failed to send password reset email. Please try again.")) } }; return i ? l.jsx(ef, { variant: "forgot", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .98 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .45 }, className: "w-full max-w-md relative z-10", children: l.jsxs(eg, { children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-6 group focus:outline-none", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx($e.div, { initial: { scale: 0 }, animate: { scale: 1 }, transition: { type: "spring", stiffness: 220, damping: 14, delay: .12 }, className: "mx-auto mb-4 w-16 h-16 bg-success/12 rounded-full flex items-center justify-center shadow-sm", "aria-hidden": !0, children: l.jsx(oi, { className: "h-8 w-8 text-success" }) }), l.jsx("h2", { className: "text-2xl font-semibold mb-2", children: "Check Your Email" }), l.jsxs("p", { className: "text-sm text-muted-foreground mb-6", children: ["We've sent a password reset link to ", l.jsx("strong", { children: t || "your email" }), ". Check your inbox and follow the instructions to reset your password."] }), l.jsxs("div", { className: "space-y-3", children: [l.jsx(on, { variant: "outline", onClick: f, className: "w-full", disabled: s > 0, "aria-disabled": s > 0, "aria-live": "polite", children: s > 0 ? `Resend in ${s}s` : "Resend Email" }), l.jsx(yi, { to: "/login", children: l.jsxs(on, { variant: "ghost", className: "w-full", children: [l.jsx(f0, { className: "mr-2 h-4 w-4" }), "Back to Login"] }) })] })] })] }) }) }) }) : l.jsx(ef, { variant: "forgot", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, y: 12 }, animate: { opacity: 1, y: 0 }, transition: { duration: .45 }, className: "w-full max-w-md relative z-10", children: l.jsxs(eg, { children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-6 group focus:outline-none", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsxs("div", { className: "text-center mb-4", children: [l.jsx("h1", { className: "text-2xl font-semibold mb-1", children: "Forgot Password?" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Enter your email and we'll send a link to reset your password." })] }), l.jsxs("form", { onSubmit: d, className: "space-y-4", "aria-describedby": "forgot-desc", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "email", children: "Email Address" }), l.jsxs("div", { className: "relative", children: [l.jsx(Lu, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "email", type: "email", placeholder: "you@example.com", className: "pl-10", value: t, onChange: h => { e(h.target.value), u(null) }, required: !0, "aria-required": !0, "aria-label": "Email address", autoComplete: "email" })] }), c && l.jsx("div", { className: "bg-destructive/10 text-destructive text-sm p-3 rounded-md border border-destructive/20", children: l.jsx("p", { children: c }) })] }), l.jsx(on, { type: "submit", className: "w-full bg-gradient-primary text-primary-foreground hover:opacity-95 transition-opacity", loading: n, disabled: n, "aria-disabled": n, children: n ? "Sending..." : "Send Reset Link" })] }), l.jsx("div", { className: "mt-4", children: l.jsx(Na, {}) }), l.jsx("div", { className: "mt-4 text-center text-sm", children: l.jsx(yi, { to: "/login", className: "text-primary hover:underline", children: "Back to login" }) })] }) }) }) }) } function yLe() { const t = ui(), [e] = pJ(), n = e.get("token"), [r, i] = S.useState(""), [a, s] = S.useState(""), [o, c] = S.useState(!1), [u, d] = S.useState(!1), [f, h] = S.useState(!1), [m, g] = S.useState(!0), [x, v] = S.useState(!1), [b, E] = S.useState(!1), [M, C] = S.useState({}), [N, A] = S.useState({ length: !1, uppercase: !1, lowercase: !1, number: !1, special: !1 }); S.useEffect(() => { (async () => { if (!n) { g(!1), v(!1), dt.error("Invalid reset link. Please request a new password reset."); return } try { (await Lc.validateResetToken(n)).success ? v(!0) : (v(!1), dt.error("Invalid or expired reset token. Please request a new password reset link.")) } catch (D) { v(!1), dt.error(D.message || "Invalid or expired reset token. Please request a new password reset link.") } finally { g(!1) } })() }, [n]); const j = I => { const D = { length: I.length >= 8, uppercase: /[A-Z]/.test(I), lowercase: /[a-z]/.test(I), number: /\d/.test(I), special: /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(I) }; return A(D), Object.values(D).every(Boolean) }, O = async I => { if (I.preventDefault(), C({}), !r) { C({ password: "Password is required." }); return } if (!j(r)) { C({ password: "Password does not meet all requirements." }); return } if (!a) { C({ confirmPassword: "Please confirm your password." }); return } if (r !== a) { C({ confirmPassword: "Passwords do not match." }); return } if (!n) { dt.error("Invalid reset token. Please request a new password reset link."); return } h(!0); try { (await Lc.resetPassword(n, r)).success && (E(!0), dt.success("Password reset successfully! Redirecting to login..."), setTimeout(() => { t("/login", { replace: !0, state: { passwordResetSuccess: !0 } }) }, 2e3)) } catch (D) { dt.error(D.message || "Failed to reset password. Please try again."), C({ submit: D.message || "Failed to reset password. Please try again." }) } finally { h(!1) } }; return m ? l.jsx(ef, { variant: "forgot", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .98 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .45 }, className: "w-full max-w-md relative z-10", children: l.jsx(eg, { children: l.jsxs("div", { className: "flex flex-col items-center justify-center py-8", children: [l.jsx(sa, { className: "h-8 w-8 animate-spin text-primary mb-4" }), l.jsx("p", { className: "text-muted-foreground", children: "Validating reset token..." })] }) }) }) }) }) : !x || !n ? l.jsx(ef, { variant: "forgot", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .98 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .45 }, className: "w-full max-w-md relative z-10", children: l.jsxs(eg, { children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-6 group focus:outline-none", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx($e.div, { initial: { scale: 0 }, animate: { scale: 1 }, transition: { type: "spring", stiffness: 220, damping: 14 }, className: "mx-auto mb-4 w-16 h-16 bg-destructive/12 rounded-full flex items-center justify-center", "aria-hidden": !0, children: l.jsx(ji, { className: "h-8 w-8 text-destructive" }) }), l.jsx("h2", { className: "text-2xl font-semibold mb-2", children: "Invalid Reset Link" }), l.jsx("p", { className: "text-sm text-muted-foreground mb-6", children: "This password reset link is invalid or has expired. Please request a new password reset link." }), l.jsxs("div", { className: "space-y-3", children: [l.jsx(yi, { to: "/forgot-password", children: l.jsx(on, { className: "w-full", children: "Request New Reset Link" }) }), l.jsx(yi, { to: "/login", children: l.jsxs(on, { variant: "ghost", className: "w-full", children: [l.jsx(f0, { className: "mr-2 h-4 w-4" }), "Back to Login"] }) })] })] })] }) }) }) }) : b ? l.jsx(ef, { variant: "forgot", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .98 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .45 }, className: "w-full max-w-md relative z-10", children: l.jsxs(eg, { children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-6 group focus:outline-none", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx($e.div, { initial: { scale: 0 }, animate: { scale: 1 }, transition: { type: "spring", stiffness: 220, damping: 14, delay: .12 }, className: "mx-auto mb-4 w-16 h-16 bg-success/12 rounded-full flex items-center justify-center shadow-sm", "aria-hidden": !0, children: l.jsx(oi, { className: "h-8 w-8 text-success" }) }), l.jsx("h2", { className: "text-2xl font-semibold mb-2", children: "Password Reset Successful" }), l.jsx("p", { className: "text-sm text-muted-foreground mb-6", children: "Your password has been reset successfully. You can now log in with your new password." }), l.jsx(yi, { to: "/login", children: l.jsx(on, { className: "w-full", children: "Go to Login" }) })] })] }) }) }) }) : l.jsx(ef, { variant: "forgot", children: l.jsx("div", { className: "min-h-screen flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, y: 12 }, animate: { opacity: 1, y: 0 }, transition: { duration: .45 }, className: "w-full max-w-md relative z-10", children: l.jsxs(eg, { children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-6 group focus:outline-none", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsxs("div", { className: "text-center mb-4", children: [l.jsx("h1", { className: "text-2xl font-semibold mb-1", children: "Reset Your Password" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Enter your new password below." })] }), l.jsxs("form", { onSubmit: O, className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "password", children: "New Password" }), l.jsxs("div", { className: "relative", children: [l.jsx(Zh, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "password", type: o ? "text" : "password", placeholder: "", className: "pl-10 pr-10", value: r, onChange: I => { i(I.target.value), j(I.target.value), C(D => ({ ...D, password: void 0 })) }, required: !0, "aria-required": !0, autoComplete: "new-password" }), l.jsx("button", { type: "button", onClick: () => c(!o), className: "absolute right-3 top-3", tabIndex: -1, children: o ? l.jsx(zT, { className: "h-4 w-4 text-muted-foreground" }) : l.jsx(Du, { className: "h-4 w-4 text-muted-foreground" }) })] }), M.password && l.jsx("p", { className: "text-sm text-destructive", children: M.password }), r && l.jsxs("div", { className: "text-xs space-y-1 mt-2 p-3 bg-muted/50 rounded-md", children: [l.jsx("p", { className: "font-medium mb-2", children: "Password must contain:" }), l.jsxs("div", { className: "grid grid-cols-2 gap-1", children: [l.jsxs("div", { className: `flex items-center gap-1 ${N.length ? "text-success" : "text-muted-foreground"}`, children: [N.length ? l.jsx(oi, { className: "h-3 w-3" }) : l.jsx(ji, { className: "h-3 w-3" }), l.jsx("span", { children: "8+ characters" })] }), l.jsxs("div", { className: `flex items-center gap-1 ${N.uppercase ? "text-success" : "text-muted-foreground"}`, children: [N.uppercase ? l.jsx(oi, { className: "h-3 w-3" }) : l.jsx(ji, { className: "h-3 w-3" }), l.jsx("span", { children: "Uppercase" })] }), l.jsxs("div", { className: `flex items-center gap-1 ${N.lowercase ? "text-success" : "text-muted-foreground"}`, children: [N.lowercase ? l.jsx(oi, { className: "h-3 w-3" }) : l.jsx(ji, { className: "h-3 w-3" }), l.jsx("span", { children: "Lowercase" })] }), l.jsxs("div", { className: `flex items-center gap-1 ${N.number ? "text-success" : "text-muted-foreground"}`, children: [N.number ? l.jsx(oi, { className: "h-3 w-3" }) : l.jsx(ji, { className: "h-3 w-3" }), l.jsx("span", { children: "Number" })] }), l.jsxs("div", { className: `flex items-center gap-1 ${N.special ? "text-success" : "text-muted-foreground"}`, children: [N.special ? l.jsx(oi, { className: "h-3 w-3" }) : l.jsx(ji, { className: "h-3 w-3" }), l.jsx("span", { children: "Special char" })] })] })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "confirmPassword", children: "Confirm New Password" }), l.jsxs("div", { className: "relative", children: [l.jsx(Zh, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "confirmPassword", type: u ? "text" : "password", placeholder: "", className: "pl-10 pr-10", value: a, onChange: I => { s(I.target.value), C(D => ({ ...D, confirmPassword: void 0 })) }, required: !0, "aria-required": !0, autoComplete: "new-password" }), l.jsx("button", { type: "button", onClick: () => d(!u), className: "absolute right-3 top-3", tabIndex: -1, children: u ? l.jsx(zT, { className: "h-4 w-4 text-muted-foreground" }) : l.jsx(Du, { className: "h-4 w-4 text-muted-foreground" }) })] }), M.confirmPassword && l.jsx("p", { className: "text-sm text-destructive", children: M.confirmPassword })] }), M.submit && l.jsxs("div", { className: "bg-destructive/10 text-destructive text-sm p-3 rounded-md flex items-center", children: [l.jsx(ji, { className: "h-4 w-4 mr-2" }), M.submit] }), l.jsx(on, { type: "submit", className: "w-full bg-gradient-primary text-primary-foreground hover:opacity-95 transition-opacity", loading: f, disabled: f, "aria-disabled": f, children: f ? "Resetting Password..." : "Reset Password" })] }), l.jsx("div", { className: "mt-4", children: l.jsx(Na, {}) }), l.jsx("div", { className: "mt-4 text-center text-sm", children: l.jsx(yi, { to: "/login", className: "text-primary hover:underline", children: "Back to login" }) })] }) }) }) }) } var S2 = "Switch", [xLe] = oa(S2), [bLe, wLe] = xLe(S2), Tle = S.forwardRef((t, e) => { const { __scopeSwitch: n, name: r, checked: i, defaultChecked: a, required: s, disabled: o, value: c = "on", onCheckedChange: u, form: d, ...f } = t, [h, m] = S.useState(null), g = Mn(e, M => m(M)), x = S.useRef(!1), v = h ? d || !!h.closest("form") : !0, [b, E] = Uo({ prop: i, defaultProp: a ?? !1, onChange: u, caller: S2 }); return l.jsxs(bLe, { scope: n, checked: b, disabled: o, children: [l.jsx(qt.button, { type: "button", role: "switch", "aria-checked": b, "aria-required": s, "data-state": Ple(b), "data-disabled": o ? "" : void 0, disabled: o, value: c, ...f, ref: g, onClick: Mt(t.onClick, M => { E(C => !C), v && (x.current = M.isPropagationStopped(), x.current || M.stopPropagation()) }) }), v && l.jsx(Ale, { control: h, bubbles: !x.current, name: r, value: c, checked: b, required: s, disabled: o, form: d, style: { transform: "translateX(-100%)" } })] }) }); Tle.displayName = S2; var Cle = "SwitchThumb", Nle = S.forwardRef((t, e) => { const { __scopeSwitch: n, ...r } = t, i = wLe(Cle, n); return l.jsx(qt.span, { "data-state": Ple(i.checked), "data-disabled": i.disabled ? "" : void 0, ...r, ref: e }) }); Nle.displayName = Cle; var SLe = "SwitchBubbleInput", Ale = S.forwardRef(({ __scopeSwitch: t, control: e, checked: n, bubbles: r = !0, ...i }, a) => { const s = S.useRef(null), o = Mn(s, a), c = x_(n), u = WS(e); return S.useEffect(() => { const d = s.current; if (!d) return; const f = window.HTMLInputElement.prototype, m = Object.getOwnPropertyDescriptor(f, "checked").set; if (c !== n && m) { const g = new Event("click", { bubbles: r }); m.call(d, n), d.dispatchEvent(g) } }, [c, n, r]), l.jsx("input", { type: "checkbox", "aria-hidden": !0, defaultChecked: n, ...i, tabIndex: -1, ref: o, style: { ...i.style, ...u, position: "absolute", pointerEvents: "none", opacity: 0, margin: 0 } }) }); Ale.displayName = SLe; function Ple(t) { return t ? "checked" : "unchecked" } var jle = Tle, _Le = Nle; const Aa = S.forwardRef(({ className: t, ...e }, n) => l.jsx(jle, { className: _t("peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50", t), ...e, ref: n, children: l.jsx(_Le, { className: _t("pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0") }) })); Aa.displayName = jle.displayName; function ELe() { const [t, e] = S.useState(!1), n = [{ name: "Free", icon: vA, description: "Perfect for getting started with interview practice", monthlyPrice: 0, yearlyPrice: 0, features: [{ name: "5 AI interview sessions per month", included: !0 }, { name: "Basic feedback analysis", included: !0 }, { name: "Practice with friends & family", included: !0 }, { name: "Access to interview guides", included: !0 }, { name: "Advanced analytics", included: !1 }, { name: "Priority support", included: !1 }, { name: "Team collaboration tools", included: !1 }, { name: "Custom interview scenarios", included: !1 }], ctaText: "Get Started Free", ctaVariant: "outline", popular: !1 }, { name: "Pro", icon: Ug, description: "Ideal for serious candidates preparing for top companies", monthlyPrice: 29, yearlyPrice: 19, features: [{ name: "Unlimited AI interview sessions", included: !0 }, { name: "Advanced feedback analysis", included: !0 }, { name: "Practice with friends & family", included: !0 }, { name: "Access to interview guides", included: !0 }, { name: "Advanced analytics & insights", included: !0 }, { name: "Priority email support", included: !0 }, { name: "Team collaboration tools", included: !1 }, { name: "Custom interview scenarios", included: !1 }], ctaText: "Start Pro Trial", ctaVariant: "default", popular: !0 }, { name: "Team", icon: Hve, description: "Perfect for organizations and interview training programs", monthlyPrice: 99, yearlyPrice: 79, features: [{ name: "Everything in Pro", included: !0 }, { name: "Up to 50 team members", included: !0 }, { name: "Team collaboration tools", included: !0 }, { name: "Custom interview scenarios", included: !0 }, { name: "Admin dashboard & analytics", included: !0 }, { name: "Dedicated success manager", included: !0 }, { name: "Custom branding options", included: !0 }, { name: "API access", included: !0 }], ctaText: "Contact Sales", ctaVariant: "outline", popular: !1 }], r = [{ question: "Can I switch plans anytime?", answer: "Yes, you can upgrade or downgrade your plan at any time. Changes take effect immediately, and we'll prorate any charges." }, { question: "Is there a free trial for Pro?", answer: "Yes! We offer a 14-day free trial for the Pro plan. No credit card required to start your trial." }, { question: "What payment methods do you accept?", answer: "We accept all major credit cards (Visa, MasterCard, American Express), PayPal, and bank transfers for annual plans." }, { question: "Can I cancel my subscription?", answer: "Absolutely. You can cancel your subscription at any time from your account settings. You'll retain access until the end of your billing period." }, { question: "Do you offer discounts for students or non-profits?", answer: "Yes! We offer special pricing for students, educators, and non-profit organizations. Contact our support team for details." }, { question: "What happens to my data if I cancel?", answer: "Your data is yours. You can export all your interview sessions and analytics before canceling. We retain data for 30 days after cancellation in case you change your mind." }]; return l.jsxs("div", { className: "min-h-screen", children: [l.jsx(DA, {}), l.jsx(mu, { backgroundType: "shapes", intensity: .15, color: "#C4B5FD", speed: .3, children: l.jsx("div", { className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h1", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "Choose Your Plan" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto mb-8", children: "Select the perfect plan to accelerate your interview preparation journey" }), l.jsxs("div", { className: "flex items-center justify-center gap-4 mb-8", children: [l.jsx("span", { className: `text-sm font-medium ${t ? "text-muted-foreground" : "text-foreground"}`, children: "Monthly" }), l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(Aa, { checked: t, onCheckedChange: e, className: "data-[state=checked]:bg-primary" }), l.jsx("span", { className: `text-sm font-medium ${t ? "text-foreground" : "text-muted-foreground"}`, children: "Yearly" }), l.jsx("span", { className: "text-xs bg-accent text-accent-foreground px-2 py-1 rounded-full font-medium", children: "Save 33%" })] })] })] }), l.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8 max-w-7xl mx-auto px-4", children: n.map((i, a) => l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: a * .1 }, className: "relative", children: [i.popular && l.jsx("div", { className: "absolute -top-1 right-2 transform z-10", children: l.jsx("div", { className: "bg-gradient-primary text-primary-foreground px-4 py-2 rounded-full text-sm font-semibold shadow-lg", children: "Most Popular" }) }), l.jsxs(Lt, { className: `p-6 md:p-8 hover-lift h-full relative overflow-hidden ${i.popular ? "ring-2 ring-primary shadow-xl scale-105" : "glass"}`, children: [i.popular && l.jsx("div", { className: "absolute inset-0 bg-gradient-primary opacity-5 rounded-lg" }), l.jsxs("div", { className: "relative z-10", children: [l.jsxs("div", { className: "flex items-center gap-3 mb-4", children: [l.jsx(i.icon, { className: `h-8 w-8 ${i.popular ? "text-primary" : "text-secondary"}` }), l.jsx("h3", { className: "text-xl md:text-2xl font-bold", children: i.name })] }), l.jsx("p", { className: "text-muted-foreground mb-6", children: i.description }), l.jsxs("div", { className: "mb-6", children: [l.jsxs("div", { className: "flex items-baseline gap-1", children: [l.jsxs("span", { className: "text-3xl md:text-4xl font-bold", children: ["$", t ? i.yearlyPrice : i.monthlyPrice] }), i.monthlyPrice > 0 && l.jsxs("span", { className: "text-muted-foreground", children: ["/", "month"] })] }), t && i.monthlyPrice > 0 && l.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: ["Billed annually ($", i.yearlyPrice * 12, "/year)"] })] }), l.jsx(vt, { className: `w-full mb-6 ${i.popular ? "bg-gradient-primary hover:opacity-90" : ""}`, variant: i.ctaVariant, size: "lg", children: i.ctaText }), l.jsx("div", { className: "space-y-3", children: i.features.map((s, o) => l.jsxs("div", { className: "flex items-start gap-3", children: [s.included ? l.jsx(oi, { className: "h-5 w-5 text-accent flex-shrink-0 mt-0.5" }) : l.jsx(Pa, { className: "h-5 w-5 text-muted-foreground flex-shrink-0 mt-0.5" }), l.jsx("span", { className: `text-sm ${s.included ? "text-foreground" : "text-muted-foreground"}`, children: s.name })] }, o)) })] })] })] }, i.name)) })] }) }) }), l.jsx(mu, { backgroundType: "mesh", intensity: .1, color: "#C4B5FD", speed: .2, children: l.jsx("div", { className: "py-20 md:py-32", children: l.jsxs("div", { className: "container", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6 }, className: "text-center mb-12 md:mb-16 px-4", children: [l.jsx("h2", { className: "text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold mb-4", children: "Frequently Asked Questions" }), l.jsx("p", { className: "text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto", children: "Everything you need to know about MockRise pricing and features" })] }), l.jsx("div", { className: "max-w-4xl mx-auto px-4", children: l.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8", children: r.map((i, a) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .5, delay: a * .1 }, children: l.jsx(Lt, { className: "p-6 hover-lift glass", children: l.jsxs("div", { className: "flex items-start gap-4", children: [l.jsx(bJ, { className: "h-6 w-6 text-primary flex-shrink-0 mt-1" }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold mb-2", children: i.question }), l.jsx("p", { className: "text-sm text-muted-foreground", children: i.answer })] })] }) }) }, a)) }) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6, delay: .4 }, className: "text-center mt-16", children: l.jsxs(Lt, { className: "p-6 md:p-8 bg-gradient-to-r from-primary/5 to-secondary/5 border-primary/20 mx-4 max-w-2xl mx-auto", children: [l.jsx("h3", { className: "text-xl md:text-2xl font-bold mb-3 md:mb-4", children: "Still have questions?" }), l.jsx("p", { className: "text-base md:text-lg text-muted-foreground mb-4 md:mb-6", children: "Our support team is here to help you choose the right plan for your needs." }), l.jsx(vt, { size: "lg", className: "bg-gradient-primary text-primary-foreground hover:opacity-90", children: "Contact Support" })] }) })] }) }) }), l.jsx(Rie, {})] }) } function Rle({ title: t, subtitle: e, badge: n, badgeIcon: r }) { const [i, a] = S.useState({ x: 0, y: 0 }); return S.useEffect(() => { const s = o => { a({ x: o.clientX / window.innerWidth * 2 - 1, y: -(o.clientY / window.innerHeight) * 2 + 1 }) }; return window.addEventListener("mousemove", s), () => window.removeEventListener("mousemove", s) }, []), l.jsxs("section", { className: "relative py-20 md:py-32 overflow-hidden", children: [l.jsxs("div", { className: "absolute inset-0 bg-gradient-to-br from-primary/5 via-secondary/5 to-accent/5", children: [l.jsx("div", { className: "absolute inset-0", children: [...Array(20)].map((s, o) => l.jsx($e.div, { className: "absolute w-2 h-2 bg-primary/20 rounded-full", style: { left: `${Math.random() * 100}%`, top: `${Math.random() * 100}%` }, animate: { x: i.x * (o + 1) * 10, y: i.y * (o + 1) * 10, scale: [1, 1.2, 1] }, transition: { duration: 2 + o * .1, repeat: 1 / 0, ease: "easeInOut" } }, o)) }), l.jsx("div", { className: "absolute inset-0 opacity-10", children: l.jsx("div", { className: "grid grid-cols-12 grid-rows-8 h-full w-full", children: [...Array(96)].map((s, o) => l.jsx($e.div, { className: "border border-primary/20", animate: { opacity: [.1, .3, .1] }, transition: { duration: 3, delay: o * .01, repeat: 1 / 0, ease: "easeInOut" } }, o)) }) }), l.jsxs("div", { className: "absolute inset-0", children: [l.jsx($e.div, { className: "absolute w-32 h-32 bg-gradient-primary rounded-full opacity-20 blur-xl", style: { left: "10%", top: "20%" }, animate: { x: [0, 50, 0], y: [0, -30, 0], scale: [1, 1.2, 1] }, transition: { duration: 8, repeat: 1 / 0, ease: "easeInOut" } }), l.jsx($e.div, { className: "absolute w-24 h-24 bg-gradient-secondary rounded-full opacity-20 blur-xl", style: { right: "15%", top: "60%" }, animate: { x: [0, -40, 0], y: [0, 40, 0], scale: [1, .8, 1] }, transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" } }), l.jsx($e.div, { className: "absolute w-20 h-20 bg-gradient-accent rounded-full opacity-20 blur-xl", style: { left: "70%", top: "30%" }, animate: { x: [0, 30, 0], y: [0, -20, 0], scale: [1, 1.3, 1] }, transition: { duration: 7, repeat: 1 / 0, ease: "easeInOut" } })] }), l.jsx("div", { className: "absolute inset-0", children: [...Array(5)].map((s, o) => l.jsx($e.div, { className: "absolute h-px bg-gradient-to-r from-transparent via-primary/30 to-transparent", style: { top: `${20 + o * 15}%`, left: "0%", width: "100%" }, animate: { x: ["-100%", "100%"], opacity: [0, 1, 0] }, transition: { duration: 4 + o, delay: o * .5, repeat: 1 / 0, ease: "easeInOut" } }, o)) })] }), l.jsx("div", { className: "container relative z-10", children: l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, className: "text-center max-w-4xl mx-auto", children: [n && r && l.jsxs($e.div, { initial: { opacity: 0, scale: .8 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .5, delay: .2 }, className: "inline-flex items-center gap-2 px-4 py-2 rounded-full bg-primary/10 text-primary text-sm font-medium mb-6", children: [l.jsx(r, { className: "h-4 w-4" }), n] }), l.jsx($e.h1, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .3 }, className: "text-4xl md:text-6xl lg:text-7xl font-bold tracking-tight mb-6", style: { transform: `translate(${i.x * 5}px, ${i.y * 5}px)` }, children: t }), l.jsx($e.p, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .4 }, className: "text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto", style: { transform: `translate(${i.x * 3}px, ${i.y * 3}px)` }, children: e })] }) })] }) } const GM = $g("rounded-xl border bg-card text-card-foreground shadow-sm transition-all duration-300", { variants: { variant: { default: "border-border", elevated: "border-border shadow-lg hover:shadow-xl", glass: "bg-card/80 backdrop-blur-lg border-border/50", gradient: "bg-gradient-primary text-primary-foreground border-primary/20", accent: "bg-gradient-accent text-accent-foreground border-accent/20", success: "bg-success/10 border-success/20 text-success-foreground", warning: "bg-warning/10 border-warning/20 text-warning-foreground", destructive: "bg-destructive/10 border-destructive/20 text-destructive-foreground" }, size: { sm: "p-4", default: "p-6", lg: "p-8", xl: "p-10" }, hover: { none: "", lift: "hover:-translate-y-1 hover:shadow-lg", glow: "hover:shadow-glow", scale: "hover:scale-105", rotate: "hover:rotate-1" }, interactive: { true: "cursor-pointer", false: "" } }, defaultVariants: { variant: "default", size: "default", hover: "none", interactive: !1 } }), sn = S.forwardRef(({ className: t, variant: e, size: n, hover: r, interactive: i, motionProps: a, loading: s = !1, skeleton: o = !1, children: c, ...u }, d) => { const f = a ? $e.div : "div"; return o ? l.jsx("div", { ref: d, className: _t(GM({ variant: e, size: n, hover: r, interactive: i, className: t }), "animate-pulse"), ...u, children: l.jsxs("div", { className: "space-y-3", children: [l.jsx("div", { className: "h-4 bg-muted rounded w-3/4" }), l.jsx("div", { className: "h-4 bg-muted rounded w-1/2" }), l.jsx("div", { className: "h-4 bg-muted rounded w-5/6" })] }) }) : s ? l.jsxs("div", { ref: d, className: _t(GM({ variant: e, size: n, hover: r, interactive: i, className: t }), "relative overflow-hidden"), ...u, children: [l.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer" }), c] }) : a ? l.jsx(f, { ref: d, className: _t(GM({ variant: e, size: n, hover: r, interactive: i, className: t })), ...a, ...u, children: c }) : l.jsx("div", { ref: d, className: _t(GM({ variant: e, size: n, hover: r, interactive: i, className: t })), ...u, children: c }) }); sn.displayName = "EnhancedCard"; const MLe = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("flex flex-col space-y-1.5 p-6", t), ...e })); MLe.displayName = "CardHeader"; const TLe = S.forwardRef(({ className: t, ...e }, n) => l.jsx("h3", { ref: n, className: _t("text-2xl font-semibold leading-none tracking-tight", t), ...e })); TLe.displayName = "CardTitle"; const CLe = S.forwardRef(({ className: t, ...e }, n) => l.jsx("p", { ref: n, className: _t("text-sm text-muted-foreground", t), ...e })); CLe.displayName = "CardDescription"; const NLe = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("p-6 pt-0", t), ...e })); NLe.displayName = "CardContent"; const ALe = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("flex items-center p-6 pt-0", t), ...e })); ALe.displayName = "CardFooter"; const PLe = $g("inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", { variants: { variant: { default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80", secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80", destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80", outline: "text-foreground" } }, defaultVariants: { variant: "default" } }); function Jt({ className: t, variant: e, ...n }) { return l.jsx("div", { className: _t(PLe({ variant: e }), t), ...n }) } var _2 = "Tabs", [jLe] = oa(_2, [M0]), kle = M0(), [RLe, GB] = jLe(_2), Ile = S.forwardRef((t, e) => { const { __scopeTabs: n, value: r, onValueChange: i, defaultValue: a, orientation: s = "horizontal", dir: o, activationMode: c = "automatic", ...u } = t, d = pp(o), [f, h] = Uo({ prop: r, onChange: i, defaultProp: a ?? "", caller: _2 }); return l.jsx(RLe, { scope: n, baseId: $l(), value: f, onValueChange: h, orientation: s, dir: d, activationMode: c, children: l.jsx(qt.div, { dir: d, "data-orientation": s, ...u, ref: e }) }) }); Ile.displayName = _2; var Ole = "TabsList", Dle = S.forwardRef((t, e) => { const { __scopeTabs: n, loop: r = !0, ...i } = t, a = GB(Ole, n), s = kle(n); return l.jsx(SU, { asChild: !0, ...s, orientation: a.orientation, dir: a.dir, loop: r, children: l.jsx(qt.div, { role: "tablist", "aria-orientation": a.orientation, ...i, ref: e }) }) }); Dle.displayName = Ole; var Lle = "TabsTrigger", Fle = S.forwardRef((t, e) => { const { __scopeTabs: n, value: r, disabled: i = !1, ...a } = t, s = GB(Lle, n), o = kle(n), c = $le(s.baseId, r), u = zle(s.baseId, r), d = r === s.value; return l.jsx(_U, { asChild: !0, ...o, focusable: !i, active: d, children: l.jsx(qt.button, { type: "button", role: "tab", "aria-selected": d, "aria-controls": u, "data-state": d ? "active" : "inactive", "data-disabled": i ? "" : void 0, disabled: i, id: c, ...a, ref: e, onMouseDown: Mt(t.onMouseDown, f => { !i && f.button === 0 && f.ctrlKey === !1 ? s.onValueChange(r) : f.preventDefault() }), onKeyDown: Mt(t.onKeyDown, f => { [" ", "Enter"].includes(f.key) && s.onValueChange(r) }), onFocus: Mt(t.onFocus, () => { const f = s.activationMode !== "manual"; !d && !i && f && s.onValueChange(r) }) }) }) }); Fle.displayName = Lle; var Ule = "TabsContent", Ble = S.forwardRef((t, e) => { const { __scopeTabs: n, value: r, forceMount: i, children: a, ...s } = t, o = GB(Ule, n), c = $le(o.baseId, r), u = zle(o.baseId, r), d = r === o.value, f = S.useRef(d); return S.useEffect(() => { const h = requestAnimationFrame(() => f.current = !1); return () => cancelAnimationFrame(h) }, []), l.jsx(Ka, { present: i || d, children: ({ present: h }) => l.jsx(qt.div, { "data-state": d ? "active" : "inactive", "data-orientation": o.orientation, role: "tabpanel", "aria-labelledby": c, hidden: !h, id: u, tabIndex: 0, ...s, ref: e, style: { ...t.style, animationDuration: f.current ? "0s" : void 0 }, children: h && a }) }) }); Ble.displayName = Ule; function $le(t, e) { return `${t}-trigger-${e}` } function zle(t, e) { return `${t}-content-${e}` } var kLe = Ile, Vle = Dle, Hle = Fle, Wle = Ble; const Sp = kLe, Ef = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Vle, { ref: n, className: _t("inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", t), ...e })); Ef.displayName = Vle.displayName; const Rr = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Hle, { ref: n, className: _t("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", t), ...e })); Rr.displayName = Hle.displayName; const Dr = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Wle, { ref: n, className: _t("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", t), ...e })); Dr.displayName = Wle.displayName; const Vy = { async getResources(t = {}) { const e = new URLSearchParams; return t.page && e.append("page", t.page.toString()), t.limit && e.append("limit", t.limit.toString()), t.resourceType && t.resourceType !== "all" && e.append("resourceType", t.resourceType), t.category && t.category !== "all" && e.append("category", t.category), t.subcategory && t.subcategory !== "all" && e.append("subcategory", t.subcategory), t.difficulty && t.difficulty !== "all" && e.append("difficulty", t.difficulty), t.search && e.append("search", t.search), t.sortBy && e.append("sortBy", t.sortBy), t.sortOrder && e.append("sortOrder", t.sortOrder), Yn.get(`${jn.resources.getAll}?${e.toString()}`) }, async getResource(t) { return Yn.get(jn.resources.getById(t)) }, async createResource(t) { return Yn.post(jn.resources.create, t) }, async updateResource(t, e) { return Yn.put(jn.resources.update(t), e) }, async deleteResource(t) { return Yn.delete(jn.resources.delete(t)) }, async incrementViews(t) { return Yn.post(jn.resources.incrementViews(t)) } }; function ILe({ resource: t, index: e, onOpen: n, onPlay: r }) { const i = g => { switch (g) { case "guide": return Kh; case "video": return Fo; case "question_bank": return df; case "course": return MJ; case "article": return yJ; default: return df } }, a = g => { switch (g) { case "beginner": return "bg-green-100 text-green-800 border-green-200"; case "intermediate": return "bg-yellow-100 text-yellow-800 border-yellow-200"; case "advanced": return "bg-red-100 text-red-800 border-red-200"; default: return "bg-gray-100 text-gray-800 border-gray-200" } }, s = g => g.charAt(0).toUpperCase() + g.slice(1), o = i(t.resourceType), c = s(t.difficulty), u = t.thumbnailUrl || L7(t.resourceType, t.subcategory || void 0), d = () => { switch (t.resourceType) { case "video": return "Watch Now"; case "course": return "Enroll Now"; case "article": return "Read Article"; default: return "Open Resource" } }, h = (() => { switch (t.resourceType) { case "video": return yg; default: return SJ } })(), m = t.resourceType === "video" && r ? r : n; return l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: e * .05 }, className: "h-full", children: l.jsxs(sn, { className: "p-0 overflow-hidden hover-lift h-full flex flex-col", variant: "elevated", children: [l.jsxs("div", { className: "relative w-full h-48 bg-gradient-to-br from-primary/10 to-primary/5 flex items-center justify-center overflow-hidden", children: [t.thumbnailUrl ? l.jsx("img", { src: u, alt: t.title, className: "w-full h-full object-cover", onError: g => { const x = g.target; x.src = L7(t.resourceType, t.subcategory || void 0) } }) : l.jsx("div", { className: "w-full h-full flex items-center justify-center bg-gradient-to-br from-primary/20 to-primary/10", children: l.jsx(o, { className: "h-16 w-16 text-primary/50" }) }), t.resourceType === "video" && l.jsx("div", { className: "absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity", children: l.jsx(on, { variant: "ghost", size: "icon", className: "bg-white/90 hover:text-white hover:bg-primary hover:opacity-85 text-black h-14 w-14", onClick: g => { g.stopPropagation(), r && r(t) }, children: l.jsx(yg, { className: "h-7 w-7" }) }) }), t.duration && l.jsx("div", { className: "absolute bottom-3 right-3", children: l.jsxs(Jt, { className: "bg-black/80 text-white border-0", children: [l.jsx(ni, { className: "h-3 w-3 mr-1" }), t.duration] }) }), l.jsx("div", { className: "absolute top-3 left-3", children: l.jsx(Jt, { className: a(t.difficulty), children: c }) })] }), l.jsxs("div", { className: "p-5 flex-1 flex flex-col", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-2 flex-wrap", children: [l.jsx(Jt, { variant: "outline", className: "text-xs", children: t.category }), t.subcategory && l.jsx(Jt, { variant: "outline", className: "text-xs text-muted-foreground", children: t.subcategory })] }), l.jsx("h3", { className: "text-lg font-semibold mb-2 line-clamp-2 min-h-[3.5rem]", children: t.title || "Untitled Resource" }), l.jsx("p", { className: "text-sm text-muted-foreground mb-3 line-clamp-3 flex-1", children: t.description || "No description available" }), t.tags && t.tags.length > 0 && l.jsx("div", { className: "flex flex-wrap gap-1.5 mb-3", children: t.tags.map((g, x) => l.jsx(Jt, { variant: "outline", className: "text-xs hover:bg-primary/10 hover:text-primary transition-colors cursor-default", children: g }, x)) }), l.jsxs("div", { className: "flex items-center justify-between text-xs text-muted-foreground mb-4", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(Du, { className: "h-3 w-3" }), (t.views || 0).toLocaleString(), " ", t.views === 1 ? "view" : "views"] }), (t.rating || 0) > 0 && l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(Ug, { className: "h-3 w-3 fill-yellow-400 text-yellow-400" }), (t.rating || 0).toFixed(1)] })] }), l.jsxs("div", { className: "flex items-center gap-2 mt-auto", children: [l.jsxs(on, { className: "flex-1", onClick: () => m(t), children: [l.jsx(h, { className: "h-4 w-4 mr-2" }), d()] }), l.jsx(on, { variant: "outline", size: "icon", className: "bg-background/80 hover:bg-primary/10 hover:text-primary", children: l.jsx(Fve, { className: "h-4 w-4" }) })] })] })] }) }) } function OLe() { const [t, e] = S.useState(""), [n, r] = S.useState("all"), [i, a] = S.useState("all"), [s, o] = S.useState("all"), [c, u] = S.useState("guides"), [d, f] = S.useState(null), [h, m] = S.useState(!1), [g, x] = S.useState(!1), [v, b] = S.useState([]), [E, M] = S.useState(!0), [C, N] = S.useState({ total: 0, guides: 0, videos: 0, question_banks: 0, courses: 0, articles: 0 }), [A, j] = S.useState([]), [O, I] = S.useState([]), D = Y => { switch (Y) { case "guides": return "guide"; case "videos": return "video"; case "questions": return "question_bank"; case "courses": return "course"; case "articles": return "article"; default: return } }, F = S.useCallback(async () => { try { M(!0); const Y = D(c), Z = n !== "all" ? n : void 0, $ = n !== "all" && i !== "all" ? i : void 0, V = await Vy.getResources({ resourceType: Y || "all", category: Z, subcategory: $, difficulty: s !== "all" ? s : void 0, search: t && t.trim() ? t.trim() : void 0, limit: 100 }); b(V.data), V.stats && N(V.stats), V.categoryStats && j(V.categoryStats), V.subcategoryStats && I(V.subcategoryStats) } catch (Y) { console.error("Failed to fetch resources:", Y), dt.error("Failed to load resources. Please try again later.") } finally { M(!1) } }, [c, n, i, s, t]); S.useEffect(() => { a("all") }, [n]), S.useEffect(() => { F() }, [F]); const B = v, G = Y => { if (!Y.contentUrl || typeof Y.contentUrl != "string") return null; const Z = Y.contentUrl.trim(); return !Z || Z === "null" || Z === "undefined" ? null : Z.startsWith("http://") || Z.startsWith("https://") ? Z : `http://localhost:5000${Z.startsWith("/") ? Z : "/" + Z}` }, z = async Y => { try { const Z = G(Y); if (!Z) { dt.error("This resource doesn't have a valid URL"); return } const $ = Y._id, V = Date.now(), K = `viewed_${$}`, X = sessionStorage.getItem(K); if (!X || V - parseInt(X) > 5e3) try { await Vy.incrementViews($), b(Q => Q.map(re => re._id === $ ? { ...re, views: (re.views || 0) + 1 } : re)), sessionStorage.setItem(K, V.toString()) } catch (Q) { console.error("Failed to increment views:", Q) } window.open(Z, "_blank", "noopener,noreferrer"), dt.success("Opening resource...") } catch (Z) { console.error("Error opening resource:", Z), dt.error("Failed to open resource. Please check the URL.") } }, q = Y => { const Z = G(Y); if (!Z) { dt.error("This resource doesn't have a valid URL"); return } window.open(Z, "_blank", "noopener,noreferrer") }; return l.jsxs("div", { className: "min-h-screen", children: [l.jsx(DA, {}), l.jsx("div", { className: "min-h-screen bg-gradient-to-br from-background via-background to-muted/20", children: l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsx(Rle, { title: "Master Your Interview Skills", subtitle: "Comprehensive guides, tutorials, and materials to boost your interview skills and land your dream job", badge: "Learning Resources", badgeIcon: Ia }), l.jsx("div", { className: "block md:hidden py-8 px-4", children: l.jsx("div", { className: "container text-center", children: l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, children: [l.jsx("h1", { className: "text-2xl font-bold mb-3", children: "Master Your Interview Skills" }), l.jsx("p", { className: "text-base text-muted-foreground mb-4", children: "Comprehensive guides, tutorials, and materials to boost your interview skills and land your dream job" }), l.jsx(on, { size: "lg", onClick: () => window.location.href = "/login?signup=true", className: "bg-gradient-primary text-primary-foreground hover:opacity-90 transition-all duration-300 hover:scale-105", children: "Get Started Today" })] }) }) }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "w-full px-4", children: [l.jsx("div", { className: "w-full max-w-7xl mx-auto", children: l.jsxs("div", { className: "flex flex-nowrap items-center gap-3 overflow-x-auto pb-2 mb-3 scrollbar-thin scrollbar-thumb-border scrollbar-track-transparent", children: [l.jsxs("div", { className: "relative flex-1 min-w-[300px]", children: [l.jsx(lg, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground z-10" }), l.jsx(fn, { type: "text", placeholder: "Search resources...", value: t, onChange: Y => e(Y.target.value), className: "pl-10 pr-10 w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2" }), t && l.jsx("button", { onClick: () => e(""), className: "absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground z-10", children: l.jsx(Pa, { className: "h-4 w-4" }) })] }), l.jsx("div", { className: "flex-shrink-0 min-w-[200px]", children: l.jsxs(Jn, { value: n, onValueChange: r, children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Category", children: n === "all" ? "All Categories" : n }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Categories" }), A.map(Y => { const Z = Y._id, $ = Y.count || 0; return l.jsxs(ut, { value: Z, children: [Z, " (", $, ")"] }, Z) })] })] }) }), n && n !== "all" && l.jsx("div", { className: "flex-shrink-0 min-w-[200px]", children: l.jsxs(Jn, { value: i, onValueChange: a, children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Subcategory", children: i === "all" ? "All Subcategories" : i }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Subcategories" }), (() => { const Y = O.find(Z => Z._id.toLowerCase() === n.toLowerCase()); return Y && Y.subcategories && Y.subcategories.length > 0 ? Y.subcategories.map(Z => l.jsxs(ut, { value: Z.name, children: [Z.name, " (", Z.count || 0, ")"] }, Z.name)) : (Qd[n]?.subcategories || []).map(Z => l.jsx(ut, { value: Z, children: Z }, Z)) })()] })] }) }), l.jsx("div", { className: "flex-shrink-0 min-w-[180px]", children: l.jsxs(Jn, { value: s, onValueChange: Y => o(Y), children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Difficulty" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Difficulties" }), l.jsx(ut, { value: "beginner", children: "Beginner" }), l.jsx(ut, { value: "intermediate", children: "Intermediate" }), l.jsx(ut, { value: "advanced", children: "Advanced" })] })] }) }), (n !== "all" || i !== "all" || s !== "all" || t.trim()) && l.jsxs("button", { onClick: () => { r("all"), a("all"), o("all"), e("") }, className: "flex-shrink-0 flex items-center gap-2 px-4 py-2 text-sm text-muted-foreground hover:text-foreground transition-colors whitespace-nowrap", children: [l.jsx(Pa, { className: "h-4 w-4" }), "Clear"] })] }) }), (n !== "all" || i !== "all" || s !== "all" || t.trim()) && l.jsxs("div", { className: "flex flex-wrap gap-2 mb-4", children: [n !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: [n, l.jsx("button", { onClick: () => { r("all"), a("all") }, className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), i !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: [i, l.jsx("button", { onClick: () => a("all"), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), s !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: [s, l.jsx("button", { onClick: () => o("all"), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), t.trim() && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: ["Search: ", t, l.jsx("button", { onClick: () => e(""), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] })] })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .3 }, className: "container", children: l.jsxs(Sp, { value: c, onValueChange: u, className: "space-y-8", children: [l.jsx("div", { className: "flex justify-center", children: l.jsxs(Ef, { className: "grid w-full max-w-2xl grid-cols-5", children: [l.jsxs(Rr, { value: "guides", className: "data-[state=active]:bg-primary data-[state=active]:text-primary-foreground", children: ["Guides (", C.guides, ")"] }), l.jsxs(Rr, { value: "videos", className: "data-[state=active]:bg-primary data-[state=active]:text-primary-foreground", children: ["Videos (", C.videos, ")"] }), l.jsxs(Rr, { value: "questions", className: "data-[state=active]:bg-primary data-[state=active]:text-primary-foreground", children: ["Questions (", C.question_banks, ")"] }), l.jsxs(Rr, { value: "courses", className: "data-[state=active]:bg-primary data-[state=active]:text-primary-foreground", children: ["Courses (", C.courses, ")"] }), l.jsxs(Rr, { value: "articles", className: "data-[state=active]:bg-primary data-[state=active]:text-primary-foreground", children: ["Articles (", C.articles, ")"] })] }) }), E ? l.jsx(Dr, { value: c, className: "space-y-6", children: l.jsxs("div", { className: "flex items-center justify-center py-12", children: [l.jsx(sa, { className: "h-8 w-8 animate-spin text-primary" }), l.jsx("span", { className: "ml-3 text-muted-foreground", children: "Loading resources..." })] }) }) : B.length === 0 ? l.jsx(Dr, { value: c, className: "space-y-6", children: l.jsxs("div", { className: "text-center py-12", children: [l.jsx("p", { className: "text-muted-foreground mb-4", children: "No resources found in this category." }), l.jsx(on, { variant: "outline", onClick: () => { r("all"), a("all"), o("all"), e("") }, children: "Clear Filters" })] }) }) : l.jsx(Dr, { value: c, className: "space-y-6", children: l.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-6", children: B.map((Y, Z) => l.jsx(ILe, { resource: Y, index: Z, onOpen: z, onPlay: q }, Y._id)) }) })] }) }), l.jsx("footer", { className: "bg-background border-t border-border py-12", children: l.jsxs("div", { className: "container mx-auto px-4", children: [l.jsxs("div", { className: "grid md:grid-cols-5 gap-8 mb-8", children: [l.jsxs("div", { children: [l.jsxs(yi, { to: "/", className: "flex items-center space-x-2 group", children: [l.jsxs("div", { className: "relative", children: [l.jsx(Ia, { className: "h-6 w-6 text-primary transition-all duration-300 group-hover:text-secondary group-hover:rotate-12" }), l.jsx("div", { className: "absolute inset-0 blur-lg bg-primary/20 group-hover:bg-secondary/30 transition-all duration-300 -z-10" })] }), l.jsx("span", { className: "text-xl font-bold gradient-text", children: "MockRise" })] }), l.jsx("p", { className: "text-sm text-muted-foreground mb-4 leading-relaxed", children: "Empowering job seekers with AI-powered interview practice for a brighter future." }), l.jsx("div", { className: "flex gap-2", children: [{ icon: d5, href: "https://facebook.com", label: "Facebook" }, { icon: g5, href: "https://twitter.com", label: "Twitter" }, { icon: p5, href: "https://instagram.com", label: "Instagram" }, { icon: BS, href: "https://linkedin.com", label: "LinkedIn" }].map((Y, Z) => l.jsx($e.a, { href: Y.href, "aria-label": Y.label, target: "_blank", rel: "noopener noreferrer", whileHover: { scale: 1.2, y: -2 }, whileTap: { scale: .95 }, className: "p-2 rounded-xl bg-muted/20 hover:bg-primary/10 hover:text-primary transition-all", children: l.jsx(Y.icon, { className: "h-5 w-5" }) }, Z)) })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Product" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("a", { href: "#features", className: "hover:text-primary transition-colors", children: "Features" }) }), l.jsx("li", { children: l.jsx("a", { href: "#", className: "hover:text-primary transition-colors", children: "Pricing" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Resources" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx(yi, { to: "/resources", className: "hover:text-primary transition-colors", children: "Resources" }) }), l.jsx("li", { children: l.jsx(yi, { to: "/faq", className: "hover:text-primary transition-colors", children: "FAQ" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Company" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("a", { href: "#about", className: "hover:text-primary transition-colors", children: "About Us" }) }), l.jsx("li", { children: l.jsx("a", { href: "#contact", className: "hover:text-primary transition-colors", children: "Contact" }) }), l.jsx("li", { children: l.jsx("a", { href: "#resources", className: "hover:text-primary transition-colors", children: "Careers" }) }), l.jsx("li", { children: l.jsx("a", { href: "#resources", className: "hover:text-primary transition-colors", children: "Blog" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Legal" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsxs("button", { onClick: () => m(!0), className: "hover:text-primary transition-colors flex items-center gap-2", children: [l.jsx(Zh, { className: "h-3 w-3" }), "Privacy Policy"] }) }), l.jsx("li", { children: l.jsxs("button", { onClick: () => x(!0), className: "hover:text-primary transition-colors flex items-center gap-2", children: [l.jsx(df, { className: "h-3 w-3" }), "Terms of Service"] }) })] })] })] }), l.jsx("div", { className: "border-t border-border pt-8 text-center text-sm text-muted-foreground", children: l.jsx("p", { children: " 2025 MockRise. All rights reserved." }) })] }) }), l.jsx(gx, { open: h, onOpenChange: m, type: "privacy" }), l.jsx(gx, { open: g, onOpenChange: x, type: "terms" })] }) })] }) } var E2 = "Collapsible", [DLe, Gle] = oa(E2), [LLe, qB] = DLe(E2), qle = S.forwardRef((t, e) => { const { __scopeCollapsible: n, open: r, defaultOpen: i, disabled: a, onOpenChange: s, ...o } = t, [c, u] = Uo({ prop: r, defaultProp: i ?? !1, onChange: s, caller: E2 }); return l.jsx(LLe, { scope: n, disabled: a, contentId: $l(), open: c, onOpenToggle: S.useCallback(() => u(d => !d), [u]), children: l.jsx(qt.div, { "data-state": YB(c), "data-disabled": a ? "" : void 0, ...o, ref: e }) }) }); qle.displayName = E2; var Xle = "CollapsibleTrigger", Yle = S.forwardRef((t, e) => { const { __scopeCollapsible: n, ...r } = t, i = qB(Xle, n); return l.jsx(qt.button, { type: "button", "aria-controls": i.contentId, "aria-expanded": i.open || !1, "data-state": YB(i.open), "data-disabled": i.disabled ? "" : void 0, disabled: i.disabled, ...r, ref: e, onClick: Mt(t.onClick, i.onOpenToggle) }) }); Yle.displayName = Xle; var XB = "CollapsibleContent", Kle = S.forwardRef((t, e) => { const { forceMount: n, ...r } = t, i = qB(XB, t.__scopeCollapsible); return l.jsx(Ka, { present: n || i.open, children: ({ present: a }) => l.jsx(FLe, { ...r, ref: e, present: a }) }) }); Kle.displayName = XB; var FLe = S.forwardRef((t, e) => { const { __scopeCollapsible: n, present: r, children: i, ...a } = t, s = qB(XB, n), [o, c] = S.useState(r), u = S.useRef(null), d = Mn(e, u), f = S.useRef(0), h = f.current, m = S.useRef(0), g = m.current, x = s.open || o, v = S.useRef(x), b = S.useRef(void 0); return S.useEffect(() => { const E = requestAnimationFrame(() => v.current = !1); return () => cancelAnimationFrame(E) }, []), Ki(() => { const E = u.current; if (E) { b.current = b.current || { transitionDuration: E.style.transitionDuration, animationName: E.style.animationName }, E.style.transitionDuration = "0s", E.style.animationName = "none"; const M = E.getBoundingClientRect(); f.current = M.height, m.current = M.width, v.current || (E.style.transitionDuration = b.current.transitionDuration, E.style.animationName = b.current.animationName), c(r) } }, [s.open, r]), l.jsx(qt.div, { "data-state": YB(s.open), "data-disabled": s.disabled ? "" : void 0, id: s.contentId, hidden: !x, ...a, ref: d, style: { "--radix-collapsible-content-height": h ? `${h}px` : void 0, "--radix-collapsible-content-width": g ? `${g}px` : void 0, ...t.style }, children: x && i }) }); function YB(t) { return t ? "open" : "closed" } var ULe = qle, BLe = Yle, $Le = Kle, Zc = "Accordion", zLe = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [KB, VLe, HLe] = m0(Zc), [M2] = oa(Zc, [HLe, Gle]), ZB = Gle(), Zle = P.forwardRef((t, e) => { const { type: n, ...r } = t, i = r, a = r; return l.jsx(KB.Provider, { scope: t.__scopeAccordion, children: n === "multiple" ? l.jsx(XLe, { ...a, ref: e }) : l.jsx(qLe, { ...i, ref: e }) }) }); Zle.displayName = Zc; var [Qle, WLe] = M2(Zc), [Jle, GLe] = M2(Zc, { collapsible: !1 }), qLe = P.forwardRef((t, e) => { const { value: n, defaultValue: r, onValueChange: i = () => { }, collapsible: a = !1, ...s } = t, [o, c] = Uo({ prop: n, defaultProp: r ?? "", onChange: i, caller: Zc }); return l.jsx(Qle, { scope: t.__scopeAccordion, value: P.useMemo(() => o ? [o] : [], [o]), onItemOpen: c, onItemClose: P.useCallback(() => a && c(""), [a, c]), children: l.jsx(Jle, { scope: t.__scopeAccordion, collapsible: a, children: l.jsx(ece, { ...s, ref: e }) }) }) }), XLe = P.forwardRef((t, e) => { const { value: n, defaultValue: r, onValueChange: i = () => { }, ...a } = t, [s, o] = Uo({ prop: n, defaultProp: r ?? [], onChange: i, caller: Zc }), c = P.useCallback(d => o((f = []) => [...f, d]), [o]), u = P.useCallback(d => o((f = []) => f.filter(h => h !== d)), [o]); return l.jsx(Qle, { scope: t.__scopeAccordion, value: s, onItemOpen: c, onItemClose: u, children: l.jsx(Jle, { scope: t.__scopeAccordion, collapsible: !0, children: l.jsx(ece, { ...a, ref: e }) }) }) }), [YLe, T2] = M2(Zc), ece = P.forwardRef((t, e) => { const { __scopeAccordion: n, disabled: r, dir: i, orientation: a = "vertical", ...s } = t, o = P.useRef(null), c = Mn(o, e), u = VLe(n), f = pp(i) === "ltr", h = Mt(t.onKeyDown, m => { if (!zLe.includes(m.key)) return; const g = m.target, x = u().filter(O => !O.ref.current?.disabled), v = x.findIndex(O => O.ref.current === g), b = x.length; if (v === -1) return; m.preventDefault(); let E = v; const M = 0, C = b - 1, N = () => { E = v + 1, E > C && (E = M) }, A = () => { E = v - 1, E < M && (E = C) }; switch (m.key) { case "Home": E = M; break; case "End": E = C; break; case "ArrowRight": a === "horizontal" && (f ? N() : A()); break; case "ArrowDown": a === "vertical" && N(); break; case "ArrowLeft": a === "horizontal" && (f ? A() : N()); break; case "ArrowUp": a === "vertical" && A(); break }const j = E % b; x[j].ref.current?.focus() }); return l.jsx(YLe, { scope: n, disabled: r, direction: i, orientation: a, children: l.jsx(KB.Slot, { scope: n, children: l.jsx(qt.div, { ...s, "data-orientation": a, ref: c, onKeyDown: r ? void 0 : h }) }) }) }), KC = "AccordionItem", [KLe, QB] = M2(KC), tce = P.forwardRef((t, e) => { const { __scopeAccordion: n, value: r, ...i } = t, a = T2(KC, n), s = WLe(KC, n), o = ZB(n), c = $l(), u = r && s.value.includes(r) || !1, d = a.disabled || t.disabled; return l.jsx(KLe, { scope: n, open: u, disabled: d, triggerId: c, children: l.jsx(ULe, { "data-orientation": a.orientation, "data-state": oce(u), ...o, ...i, ref: e, disabled: d, open: u, onOpenChange: f => { f ? s.onItemOpen(r) : s.onItemClose(r) } }) }) }); tce.displayName = KC; var nce = "AccordionHeader", rce = P.forwardRef((t, e) => { const { __scopeAccordion: n, ...r } = t, i = T2(Zc, n), a = QB(nce, n); return l.jsx(qt.h3, { "data-orientation": i.orientation, "data-state": oce(a.open), "data-disabled": a.disabled ? "" : void 0, ...r, ref: e }) }); rce.displayName = nce; var c4 = "AccordionTrigger", ice = P.forwardRef((t, e) => { const { __scopeAccordion: n, ...r } = t, i = T2(Zc, n), a = QB(c4, n), s = GLe(c4, n), o = ZB(n); return l.jsx(KB.ItemSlot, { scope: n, children: l.jsx(BLe, { "aria-disabled": a.open && !s.collapsible || void 0, "data-orientation": i.orientation, id: a.triggerId, ...o, ...r, ref: e }) }) }); ice.displayName = c4; var ace = "AccordionContent", sce = P.forwardRef((t, e) => { const { __scopeAccordion: n, ...r } = t, i = T2(Zc, n), a = QB(ace, n), s = ZB(n); return l.jsx($Le, { role: "region", "aria-labelledby": a.triggerId, "data-orientation": i.orientation, ...s, ...r, ref: e, style: { "--radix-accordion-content-height": "var(--radix-collapsible-content-height)", "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", ...t.style } }) }); sce.displayName = ace; function oce(t) { return t ? "open" : "closed" } var ZLe = Zle, QLe = tce, JLe = rce, lce = ice, cce = sce; const e4e = ZLe, uce = S.forwardRef(({ className: t, ...e }, n) => l.jsx(QLe, { ref: n, className: _t("border-b", t), ...e })); uce.displayName = "AccordionItem"; const dce = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsx(JLe, { className: "flex", children: l.jsxs(lce, { ref: r, className: _t("flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", t), ...n, children: [e, l.jsx(gA, { className: "h-4 w-4 shrink-0 transition-transform duration-200" })] }) })); dce.displayName = lce.displayName; const fce = S.forwardRef(({ className: t, children: e, ...n }, r) => l.jsx(cce, { ref: r, className: "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down", ...n, children: l.jsx("div", { className: _t("pb-4 pt-0", t), children: e }) })); fce.displayName = cce.displayName; function t4e() { const [t, e] = S.useState(""), [n, r] = S.useState(!1), [i, a] = S.useState(!1), s = [{ id: "getting-started", title: "Getting Started", icon: Ia, questions: [{ question: "How do I create an account on MockRise?", answer: "Creating an account is simple! Click the 'Sign Up' button on our homepage, enter your email and password, choose your role (Trainee or Interviewer), and complete the verification process. For interviewers, you'll need to provide additional information and wait for approval." }, { question: "What's the difference between Trainee and Interviewer roles?", answer: "Trainees use MockRise to practice interviews and improve their skills. Interviewers conduct mock interviews for trainees and earn money. Interviewers need to be approved by our team and provide relevant experience credentials." }, { question: "How much does MockRise cost?", answer: "MockRise offers a freemium model. Basic features are free for trainees, with premium features available through subscription plans. Interviewers earn money for conducting interviews, with MockRise taking a small commission." }, { question: "Do I need to download any software?", answer: "No downloads required! MockRise is a web-based platform that works in your browser. We recommend using Chrome, Firefox, or Safari for the best experience." }] }, { id: "interviews", title: "Interviews & Practice", icon: Qh, questions: [{ question: "What types of interviews can I practice?", answer: "MockRise supports technical interviews, behavioral interviews, system design sessions, coding challenges, and industry-specific interviews. You can choose from AI-powered interviews, peer practice, or family/friend sessions." }, { question: "How realistic are the AI interviews?", answer: "Our AI interviews are highly realistic, featuring natural conversation flow, follow-up questions, and industry-specific scenarios. The AI adapts to your responses and provides detailed feedback on your performance." }, { question: "Can I practice with real people?", answer: "Yes! MockRise offers peer-to-peer practice sessions where you can interview with other candidates, and family/friend mode where you can practice with people you know." }, { question: "How long do interviews typically last?", answer: "Interview duration varies by type: Technical interviews (30-60 minutes), Behavioral interviews (20-30 minutes), System design (45-90 minutes), and Coding challenges (15-45 minutes). You can set custom durations." }] }, { id: "feedback", title: "Feedback & Analytics", icon: Fu, questions: [{ question: "What kind of feedback do I receive?", answer: "You'll receive comprehensive feedback including communication skills, technical knowledge, problem-solving approach, confidence level, and specific improvement suggestions. Our AI analyzes your speech patterns, response quality, and interview performance." }, { question: "How detailed are the performance analytics?", answer: "Our analytics include progress tracking over time, skill assessments, confidence metrics, response time analysis, and personalized recommendations for improvement areas." }, { question: "Can I track my improvement over time?", answer: "Absolutely! MockRise provides detailed progress tracking with visual charts, skill development timelines, and performance comparisons to help you see your growth." }, { question: "Is my interview data private?", answer: "Yes, all your interview data is encrypted and private. We never share your personal information or interview recordings with third parties without your explicit consent." }] }, { id: "technical", title: "Technical Support", icon: h0, questions: [{ question: "What browsers are supported?", answer: "MockRise works best on Chrome, Firefox, Safari, and Edge. We recommend using the latest version of your browser for optimal performance." }, { question: "Do I need a microphone and camera?", answer: "A microphone is required for interviews. A camera is optional but recommended for a more realistic interview experience. We support both audio-only and video interviews." }, { question: "What if I experience technical issues during an interview?", answer: "If you encounter technical problems, you can pause the interview and resume later. Our support team is available 24/7 to help resolve any issues quickly." }, { question: "Can I use MockRise on mobile devices?", answer: "Yes! MockRise is fully responsive and works on smartphones and tablets. However, we recommend using a desktop or laptop for the best interview experience." }] }, { id: "billing", title: "Billing & Payments", icon: Vve, questions: [{ question: "What payment methods do you accept?", answer: "We accept all major credit cards, PayPal, and bank transfers. All payments are processed securely through our encrypted payment system." }, { question: "Can I cancel my subscription anytime?", answer: "Yes, you can cancel your subscription at any time from your account settings. Your access will continue until the end of your current billing period." }, { question: "Do you offer refunds?", answer: "We offer a 30-day money-back guarantee for all new subscriptions. If you're not satisfied with MockRise, contact our support team for a full refund." }, { question: "How do interviewers get paid?", answer: "Interviewers are paid weekly via bank transfer or PayPal. Payments are processed automatically, and you can track your earnings in your dashboard." }] }, { id: "safety", title: "Safety & Privacy", icon: cx, questions: [{ question: "How do you ensure user safety?", answer: "We have strict community guidelines, content moderation, and reporting systems. All users must verify their identity, and we monitor for inappropriate behavior." }, { question: "Can I report inappropriate behavior?", answer: "Yes, you can report any inappropriate behavior through our reporting system. We take all reports seriously and investigate promptly." }, { question: "Is my personal information secure?", answer: "Absolutely. We use enterprise-grade encryption, secure servers, and comply with GDPR and other privacy regulations. Your data is never sold or shared." }, { question: "Can I delete my account and data?", answer: "Yes, you can delete your account and all associated data at any time from your account settings. This action is irreversible, so please download any data you want to keep first." }] }], o = [{ question: "How do I get started with MockRise?", answer: "Simply create an account, choose your role, and start practicing! We'll guide you through your first interview.", category: "Getting Started", icon: Ia }, { question: "What makes MockRise different from other platforms?", answer: "MockRise combines AI technology with human expertise to provide the most realistic interview experience available.", category: "Platform", icon: ro }, { question: "Can I practice specific company interviews?", answer: "Yes! We have company-specific interview formats for major tech companies like Google, Amazon, Microsoft, and more.", category: "Interviews", icon: Qh }]; return l.jsxs("div", { className: "min-h-screen", children: [l.jsx(DA, {}), l.jsx("div", { className: "min-h-screen bg-gradient-to-br from-background via-background to-muted/20", children: l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsx(Rle, { title: "Got Questions?", subtitle: "Find answers to common questions about MockRise, interviews, and how to get the most out of our platform", badge: "Frequently Asked Questions", badgeIcon: bJ }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "container", children: l.jsxs("div", { className: "relative max-w-2xl mx-auto border border-border/50 rounded-lg overflow-hidden shadow-md", children: [l.jsx(lg, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { placeholder: "Search FAQs...", value: t, onChange: c => e(c.target.value), className: "pl-10 text-lg bg-background/50 border-border/50 focus:border-primary/50" })] }) }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .2 }, className: "container", children: [l.jsx("h2", { className: "text-2xl font-bold mb-6 text-center", children: "Popular Questions" }), l.jsx("div", { className: "grid md:grid-cols-3 gap-6", children: o.map((c, u) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: u * .1 }, whileHover: { y: -5 }, className: "cursor-pointer", children: l.jsxs(sn, { className: "p-6 hover-lift glass", variant: "glass", children: [l.jsxs("div", { className: "flex items-center gap-3 mb-4", children: [l.jsx("div", { className: "w-10 h-10 bg-primary/10 rounded-lg flex items-center justify-center", children: l.jsx(c.icon, { className: "h-5 w-5 text-primary" }) }), l.jsx(Jt, { variant: "outline", className: "text-xs hover:bg-primary/70 hover:text-white", children: c.category })] }), l.jsx("h3", { className: "font-semibold mb-2 hover:text-primary transition-colors", children: c.question }), l.jsx("p", { className: "text-sm text-muted-foreground", children: c.answer })] }) }, c.question)) })] }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .3 }, className: "container", children: [l.jsx("h2", { className: "text-2xl font-bold mb-6 text-center", children: "Browse by Category" }), l.jsx("div", { className: "space-y-6", children: s.map((c, u) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: u * .1 }, children: l.jsxs(sn, { className: "p-6 glass", variant: "glass", children: [l.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [l.jsx("div", { className: "w-12 h-12 bg-primary/10 rounded-lg flex items-center justify-center", children: l.jsx(c.icon, { className: "h-6 w-6 text-primary" }) }), l.jsx("h3", { className: "text-xl font-semibold", children: c.title })] }), l.jsx(e4e, { type: "single", collapsible: !0, className: "space-y-2", children: c.questions.map((d, f) => l.jsxs(uce, { value: `${u}-${f}`, className: "border-border/50", children: [l.jsx(dce, { className: "text-left hover:no-underline hover:text-primary transition-colors", children: d.question }), l.jsx(fce, { className: "text-muted-foreground pt-2", children: d.answer })] }, f)) })] }) }, c.id)) })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .4 }, className: "container", children: l.jsx(sn, { className: "p-8 text-center glass", variant: "glass", children: l.jsxs("div", { className: "max-w-2xl mx-auto", children: [l.jsx("div", { className: "w-16 h-16 bg-primary/10 rounded-full flex items-center justify-center mx-auto mb-6", children: l.jsx(ff, { className: "h-8 w-8 text-primary" }) }), l.jsx("h3", { className: "text-2xl font-bold mb-4", children: "Still Have Questions?" }), l.jsx("p", { className: "text-muted-foreground mb-6", children: "Can't find what you're looking for? Our support team is here to help!" }), l.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center", children: [l.jsxs(on, { className: "flex items-center gap-2", children: [l.jsx(ff, { className: "h-4 w-4" }), "Live Chat"] }), l.jsxs(on, { variant: "outline", className: "flex items-center gap-2", children: [l.jsx(Lu, { className: "h-4 w-4" }), "Email Support"] })] })] }) }) }), l.jsx("footer", { className: "bg-background border-t border-border py-12", children: l.jsxs("div", { className: "container mx-auto px-4", children: [l.jsxs("div", { className: "grid md:grid-cols-5 gap-8 mb-8", children: [l.jsxs("div", { children: [l.jsxs(yi, { to: "/", className: "flex items-center space-x-2 group", children: [l.jsxs("div", { className: "relative", children: [l.jsx(Ia, { className: "h-6 w-6 text-primary transition-all duration-300 group-hover:text-secondary group-hover:rotate-12" }), l.jsx("div", { className: "absolute inset-0 blur-lg bg-primary/20 group-hover:bg-secondary/30 transition-all duration-300 -z-10" })] }), l.jsx("span", { className: "text-xl font-bold gradient-text", children: "MockRise" })] }), l.jsx("p", { className: "text-sm text-muted-foreground mb-4 leading-relaxed", children: "Empowering job seekers with AI-powered interview practice for a brighter future." }), l.jsx("div", { className: "flex gap-2", children: [{ icon: d5, href: "https://facebook.com", label: "Facebook" }, { icon: g5, href: "https://twitter.com", label: "Twitter" }, { icon: p5, href: "https://instagram.com", label: "Instagram" }, { icon: BS, href: "https://linkedin.com", label: "LinkedIn" }].map((c, u) => l.jsx($e.a, { href: c.href, "aria-label": c.label, target: "_blank", rel: "noopener noreferrer", whileHover: { scale: 1.2, y: -2 }, whileTap: { scale: .95 }, className: "p-2 rounded-xl bg-muted/20 hover:bg-primary/10 hover:text-primary transition-all", children: l.jsx(c.icon, { className: "h-5 w-5" }) }, u)) })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Product" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("a", { href: "#features", className: "hover:text-primary transition-colors", children: "Features" }) }), l.jsx("li", { children: l.jsx("a", { href: "#", className: "hover:text-primary transition-colors", children: "Pricing" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Resources" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx(yi, { to: "/resources", className: "hover:text-primary transition-colors", children: "Resources" }) }), l.jsx("li", { children: l.jsx(yi, { to: "/faq", className: "hover:text-primary transition-colors", children: "FAQ" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Company" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsx("a", { href: "#about", className: "hover:text-primary transition-colors", children: "About Us" }) }), l.jsx("li", { children: l.jsx("a", { href: "#contact", className: "hover:text-primary transition-colors", children: "Contact" }) }), l.jsx("li", { children: l.jsx("a", { href: "#resources", className: "hover:text-primary transition-colors", children: "Careers" }) }), l.jsx("li", { children: l.jsx("a", { href: "#resources", className: "hover:text-primary transition-colors", children: "Blog" }) })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-semibold mb-4 text-lg", children: "Legal" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: l.jsxs("button", { onClick: () => r(!0), className: "hover:text-primary transition-colors flex items-center gap-2", children: [l.jsx(Zh, { className: "h-3 w-3" }), "Privacy Policy"] }) }), l.jsx("li", { children: l.jsxs("button", { onClick: () => a(!0), className: "hover:text-primary transition-colors flex items-center gap-2", children: [l.jsx(df, { className: "h-3 w-3" }), "Terms of Service"] }) })] })] })] }), l.jsx("div", { className: "border-t border-border pt-8 text-center text-sm text-muted-foreground", children: l.jsx("p", { children: " 2025 MockRise. All rights reserved." }) })] }) }), l.jsx(gx, { open: n, onOpenChange: r, type: "privacy" }), l.jsx(gx, { open: i, onOpenChange: a, type: "terms" })] }) })] }) } var JB = "Progress", e$ = 100, [n4e] = oa(JB), [r4e, i4e] = n4e(JB), hce = S.forwardRef((t, e) => { const { __scopeProgress: n, value: r = null, max: i, getValueLabel: a = a4e, ...s } = t; (i || i === 0) && !F7(i) && console.error(s4e(`${i}`, "Progress")); const o = F7(i) ? i : e$; r !== null && !U7(r, o) && console.error(o4e(`${r}`, "Progress")); const c = U7(r, o) ? r : null, u = ZC(c) ? a(c, o) : void 0; return l.jsx(r4e, { scope: n, value: c, max: o, children: l.jsx(qt.div, { "aria-valuemax": o, "aria-valuemin": 0, "aria-valuenow": ZC(c) ? c : void 0, "aria-valuetext": u, role: "progressbar", "data-state": gce(c, o), "data-value": c ?? void 0, "data-max": o, ...s, ref: e }) }) }); hce.displayName = JB; var pce = "ProgressIndicator", mce = S.forwardRef((t, e) => { const { __scopeProgress: n, ...r } = t, i = i4e(pce, n); return l.jsx(qt.div, { "data-state": gce(i.value, i.max), "data-value": i.value ?? void 0, "data-max": i.max, ...r, ref: e }) }); mce.displayName = pce; function a4e(t, e) { return `${Math.round(t / e * 100)}%` } function gce(t, e) { return t == null ? "indeterminate" : t === e ? "complete" : "loading" } function ZC(t) { return typeof t == "number" } function F7(t) { return ZC(t) && !isNaN(t) && t > 0 } function U7(t, e) { return ZC(t) && !isNaN(t) && t <= e && t >= 0 } function s4e(t, e) { return `Invalid prop \`max\` of value \`${t}\` supplied to \`${e}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${e$}\`.` } function o4e(t, e) {
	return `Invalid prop \`value\` of value \`${t}\` supplied to \`${e}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${e$} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`} var vce = hce, l4e = mce; const vu = S.forwardRef(({ className: t, value: e, ...n }, r) => l.jsx(vce, { ref: r, className: _t("relative h-4 w-full overflow-hidden rounded-full bg-secondary", t), ...n, children: l.jsx(l4e, { className: "h-full w-full flex-1 bg-primary transition-all", style: { transform: `translateX(-${100 - (e || 0)}%)` } }) })); vu.displayName = vce.displayName; var C2 = "Checkbox", [c4e] = oa(C2), [u4e, t$] = c4e(C2); function d4e(t) { const { __scopeCheckbox: e, checked: n, children: r, defaultChecked: i, disabled: a, form: s, name: o, onCheckedChange: c, required: u, value: d = "on", internal_do_not_use_render: f } = t, [h, m] = Uo({ prop: n, defaultProp: i ?? !1, onChange: c, caller: C2 }), [g, x] = S.useState(null), [v, b] = S.useState(null), E = S.useRef(!1), M = g ? !!s || !!g.closest("form") : !0, C = { checked: h, disabled: a, setChecked: m, control: g, setControl: x, name: o, form: s, value: d, hasConsumerStoppedPropagationRef: E, required: u, defaultChecked: Gh(i) ? !1 : i, isFormControl: M, bubbleInput: v, setBubbleInput: b }; return l.jsx(u4e, { scope: e, ...C, children: f4e(f) ? f(C) : r }) } var yce = "CheckboxTrigger", xce = S.forwardRef(({ __scopeCheckbox: t, onKeyDown: e, onClick: n, ...r }, i) => { const { control: a, value: s, disabled: o, checked: c, required: u, setControl: d, setChecked: f, hasConsumerStoppedPropagationRef: h, isFormControl: m, bubbleInput: g } = t$(yce, t), x = Mn(i, d), v = S.useRef(c); return S.useEffect(() => { const b = a?.form; if (b) { const E = () => f(v.current); return b.addEventListener("reset", E), () => b.removeEventListener("reset", E) } }, [a, f]), l.jsx(qt.button, { type: "button", role: "checkbox", "aria-checked": Gh(c) ? "mixed" : c, "aria-required": u, "data-state": Ece(c), "data-disabled": o ? "" : void 0, disabled: o, value: s, ...r, ref: x, onKeyDown: Mt(e, b => { b.key === "Enter" && b.preventDefault() }), onClick: Mt(n, b => { f(E => Gh(E) ? !0 : !E), g && m && (h.current = b.isPropagationStopped(), h.current || b.stopPropagation()) }) }) }); xce.displayName = yce; var n$ = S.forwardRef((t, e) => { const { __scopeCheckbox: n, name: r, checked: i, defaultChecked: a, required: s, disabled: o, value: c, onCheckedChange: u, form: d, ...f } = t; return l.jsx(d4e, { __scopeCheckbox: n, checked: i, defaultChecked: a, disabled: o, required: s, onCheckedChange: u, name: r, form: d, value: c, internal_do_not_use_render: ({ isFormControl: h }) => l.jsxs(l.Fragment, { children: [l.jsx(xce, { ...f, ref: e, __scopeCheckbox: n }), h && l.jsx(_ce, { __scopeCheckbox: n })] }) }) }); n$.displayName = C2; var bce = "CheckboxIndicator", wce = S.forwardRef((t, e) => { const { __scopeCheckbox: n, forceMount: r, ...i } = t, a = t$(bce, n); return l.jsx(Ka, { present: r || Gh(a.checked) || a.checked === !0, children: l.jsx(qt.span, { "data-state": Ece(a.checked), "data-disabled": a.disabled ? "" : void 0, ...i, ref: e, style: { pointerEvents: "none", ...t.style } }) }) }); wce.displayName = bce; var Sce = "CheckboxBubbleInput", _ce = S.forwardRef(({ __scopeCheckbox: t, ...e }, n) => { const { control: r, hasConsumerStoppedPropagationRef: i, checked: a, defaultChecked: s, required: o, disabled: c, name: u, value: d, form: f, bubbleInput: h, setBubbleInput: m } = t$(Sce, t), g = Mn(n, m), x = x_(a), v = WS(r); S.useEffect(() => { const E = h; if (!E) return; const M = window.HTMLInputElement.prototype, N = Object.getOwnPropertyDescriptor(M, "checked").set, A = !i.current; if (x !== a && N) { const j = new Event("click", { bubbles: A }); E.indeterminate = Gh(a), N.call(E, Gh(a) ? !1 : a), E.dispatchEvent(j) } }, [h, x, a, i]); const b = S.useRef(Gh(a) ? !1 : a); return l.jsx(qt.input, { type: "checkbox", "aria-hidden": !0, defaultChecked: s ?? b.current, required: o, disabled: c, name: u, value: d, form: f, ...e, tabIndex: -1, ref: g, style: { ...e.style, ...v, position: "absolute", pointerEvents: "none", opacity: 0, margin: 0, transform: "translateX(-100%)" } }) }); _ce.displayName = Sce; function f4e(t) { return typeof t == "function" } function Gh(t) { return t === "indeterminate" } function Ece(t) { return Gh(t) ? "indeterminate" : t ? "checked" : "unchecked" } const QC = S.forwardRef(({ className: t, ...e }, n) => l.jsx(n$, { ref: n, className: _t("peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ...e, children: l.jsx(wce, { className: _t("flex items-center justify-center text-current"), children: l.jsx(l5, { className: "h-4 w-4" }) }) })); QC.displayName = n$.displayName; var Mce = ["PageUp", "PageDown"], Tce = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Cce = { "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"], "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"], "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"], "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"] }, j0 = "Slider", [u4, h4e, p4e] = m0(j0), [Nce] = oa(j0, [p4e]), [m4e, N2] = Nce(j0), Ace = S.forwardRef((t, e) => { const { name: n, min: r = 0, max: i = 100, step: a = 1, orientation: s = "horizontal", disabled: o = !1, minStepsBetweenThumbs: c = 0, defaultValue: u = [r], value: d, onValueChange: f = () => { }, onValueCommit: h = () => { }, inverted: m = !1, form: g, ...x } = t, v = S.useRef(new Set), b = S.useRef(0), M = s === "horizontal" ? g4e : v4e, [C = [], N] = Uo({ prop: d, defaultProp: u, onChange: F => { [...v.current][b.current]?.focus(), f(F) } }), A = S.useRef(C); function j(F) { const B = S4e(C, F); D(F, B) } function O(F) { D(F, b.current) } function I() { const F = A.current[b.current]; C[b.current] !== F && h(C) } function D(F, B, { commit: G } = { commit: !1 }) { const z = T4e(a), q = C4e(Math.round((F - r) / a) * a + r, z), Y = A1(q, [r, i]); N((Z = []) => { const $ = b4e(Z, Y, B); if (M4e($, c * a)) { b.current = $.indexOf(Y); const V = String($) !== String(Z); return V && G && h($), V ? $ : Z } else return Z }) } return l.jsx(m4e, { scope: t.__scopeSlider, name: n, disabled: o, min: r, max: i, valueIndexToChangeRef: b, thumbs: v.current, values: C, orientation: s, form: g, children: l.jsx(u4.Provider, { scope: t.__scopeSlider, children: l.jsx(u4.Slot, { scope: t.__scopeSlider, children: l.jsx(M, { "aria-disabled": o, "data-disabled": o ? "" : void 0, ...x, ref: e, onPointerDown: Mt(x.onPointerDown, () => { o || (A.current = C) }), min: r, max: i, inverted: m, onSlideStart: o ? void 0 : j, onSlideMove: o ? void 0 : O, onSlideEnd: o ? void 0 : I, onHomeKeyDown: () => !o && D(r, 0, { commit: !0 }), onEndKeyDown: () => !o && D(i, C.length - 1, { commit: !0 }), onStepKeyDown: ({ event: F, direction: B }) => { if (!o) { const q = Mce.includes(F.key) || F.shiftKey && Tce.includes(F.key) ? 10 : 1, Y = b.current, Z = C[Y], $ = a * q * B; D(Z + $, Y, { commit: !0 }) } } }) }) }) }) }); Ace.displayName = j0; var [Pce, jce] = Nce(j0, { startEdge: "left", endEdge: "right", size: "width", direction: 1 }), g4e = S.forwardRef((t, e) => { const { min: n, max: r, dir: i, inverted: a, onSlideStart: s, onSlideMove: o, onSlideEnd: c, onStepKeyDown: u, ...d } = t, [f, h] = S.useState(null), m = Mn(e, M => h(M)), g = S.useRef(void 0), x = pp(i), v = x === "ltr", b = v && !a || !v && a; function E(M) { const C = g.current || f.getBoundingClientRect(), N = [0, C.width], j = r$(N, b ? [n, r] : [r, n]); return g.current = C, j(M - C.left) } return l.jsx(Pce, { scope: t.__scopeSlider, startEdge: b ? "left" : "right", endEdge: b ? "right" : "left", direction: b ? 1 : -1, size: "width", children: l.jsx(Rce, { dir: x, "data-orientation": "horizontal", ...d, ref: m, style: { ...d.style, "--radix-slider-thumb-transform": "translateX(-50%)" }, onSlideStart: M => { const C = E(M.clientX); s?.(C) }, onSlideMove: M => { const C = E(M.clientX); o?.(C) }, onSlideEnd: () => { g.current = void 0, c?.() }, onStepKeyDown: M => { const N = Cce[b ? "from-left" : "from-right"].includes(M.key); u?.({ event: M, direction: N ? -1 : 1 }) } }) }) }), v4e = S.forwardRef((t, e) => { const { min: n, max: r, inverted: i, onSlideStart: a, onSlideMove: s, onSlideEnd: o, onStepKeyDown: c, ...u } = t, d = S.useRef(null), f = Mn(e, d), h = S.useRef(void 0), m = !i; function g(x) { const v = h.current || d.current.getBoundingClientRect(), b = [0, v.height], M = r$(b, m ? [r, n] : [n, r]); return h.current = v, M(x - v.top) } return l.jsx(Pce, { scope: t.__scopeSlider, startEdge: m ? "bottom" : "top", endEdge: m ? "top" : "bottom", size: "height", direction: m ? 1 : -1, children: l.jsx(Rce, { "data-orientation": "vertical", ...u, ref: f, style: { ...u.style, "--radix-slider-thumb-transform": "translateY(50%)" }, onSlideStart: x => { const v = g(x.clientY); a?.(v) }, onSlideMove: x => { const v = g(x.clientY); s?.(v) }, onSlideEnd: () => { h.current = void 0, o?.() }, onStepKeyDown: x => { const b = Cce[m ? "from-bottom" : "from-top"].includes(x.key); c?.({ event: x, direction: b ? -1 : 1 }) } }) }) }), Rce = S.forwardRef((t, e) => { const { __scopeSlider: n, onSlideStart: r, onSlideMove: i, onSlideEnd: a, onHomeKeyDown: s, onEndKeyDown: o, onStepKeyDown: c, ...u } = t, d = N2(j0, n); return l.jsx(qt.span, { ...u, ref: e, onKeyDown: Mt(t.onKeyDown, f => { f.key === "Home" ? (s(f), f.preventDefault()) : f.key === "End" ? (o(f), f.preventDefault()) : Mce.concat(Tce).includes(f.key) && (c(f), f.preventDefault()) }), onPointerDown: Mt(t.onPointerDown, f => { const h = f.target; h.setPointerCapture(f.pointerId), f.preventDefault(), d.thumbs.has(h) ? h.focus() : r(f) }), onPointerMove: Mt(t.onPointerMove, f => { f.target.hasPointerCapture(f.pointerId) && i(f) }), onPointerUp: Mt(t.onPointerUp, f => { const h = f.target; h.hasPointerCapture(f.pointerId) && (h.releasePointerCapture(f.pointerId), a(f)) }) }) }), kce = "SliderTrack", Ice = S.forwardRef((t, e) => { const { __scopeSlider: n, ...r } = t, i = N2(kce, n); return l.jsx(qt.span, { "data-disabled": i.disabled ? "" : void 0, "data-orientation": i.orientation, ...r, ref: e }) }); Ice.displayName = kce; var d4 = "SliderRange", Oce = S.forwardRef((t, e) => { const { __scopeSlider: n, ...r } = t, i = N2(d4, n), a = jce(d4, n), s = S.useRef(null), o = Mn(e, s), c = i.values.length, u = i.values.map(h => Fce(h, i.min, i.max)), d = c > 1 ? Math.min(...u) : 0, f = 100 - Math.max(...u); return l.jsx(qt.span, { "data-orientation": i.orientation, "data-disabled": i.disabled ? "" : void 0, ...r, ref: o, style: { ...t.style, [a.startEdge]: d + "%", [a.endEdge]: f + "%" } }) }); Oce.displayName = d4; var f4 = "SliderThumb", Dce = S.forwardRef((t, e) => { const n = h4e(t.__scopeSlider), [r, i] = S.useState(null), a = Mn(e, o => i(o)), s = S.useMemo(() => r ? n().findIndex(o => o.ref.current === r) : -1, [n, r]); return l.jsx(y4e, { ...t, ref: a, index: s }) }), y4e = S.forwardRef((t, e) => { const { __scopeSlider: n, index: r, name: i, ...a } = t, s = N2(f4, n), o = jce(f4, n), [c, u] = S.useState(null), d = Mn(e, E => u(E)), f = c ? s.form || !!c.closest("form") : !0, h = WS(c), m = s.values[r], g = m === void 0 ? 0 : Fce(m, s.min, s.max), x = w4e(r, s.values.length), v = h?.[o.size], b = v ? _4e(v, g, o.direction) : 0; return S.useEffect(() => { if (c) return s.thumbs.add(c), () => { s.thumbs.delete(c) } }, [c, s.thumbs]), l.jsxs("span", { style: { transform: "var(--radix-slider-thumb-transform)", position: "absolute", [o.startEdge]: `calc(${g}% + ${b}px)` }, children: [l.jsx(u4.ItemSlot, { scope: t.__scopeSlider, children: l.jsx(qt.span, { role: "slider", "aria-label": t["aria-label"] || x, "aria-valuemin": s.min, "aria-valuenow": m, "aria-valuemax": s.max, "aria-orientation": s.orientation, "data-orientation": s.orientation, "data-disabled": s.disabled ? "" : void 0, tabIndex: s.disabled ? void 0 : 0, ...a, ref: d, style: m === void 0 ? { display: "none" } : t.style, onFocus: Mt(t.onFocus, () => { s.valueIndexToChangeRef.current = r }) }) }), f && l.jsx(Lce, { name: i ?? (s.name ? s.name + (s.values.length > 1 ? "[]" : "") : void 0), form: s.form, value: m }, r)] }) }); Dce.displayName = f4; var x4e = "RadioBubbleInput", Lce = S.forwardRef(({ __scopeSlider: t, value: e, ...n }, r) => { const i = S.useRef(null), a = Mn(i, r), s = x_(e); return S.useEffect(() => { const o = i.current; if (!o) return; const c = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(c, "value").set; if (s !== e && d) { const f = new Event("input", { bubbles: !0 }); d.call(o, e), o.dispatchEvent(f) } }, [s, e]), l.jsx(qt.input, { style: { display: "none" }, ...n, ref: a, defaultValue: e }) }); Lce.displayName = x4e; function b4e(t = [], e, n) { const r = [...t]; return r[n] = e, r.sort((i, a) => i - a) } function Fce(t, e, n) { const a = 100 / (n - e) * (t - e); return A1(a, [0, 100]) } function w4e(t, e) { return e > 2 ? `Value ${t + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][t] : void 0 } function S4e(t, e) { if (t.length === 1) return 0; const n = t.map(i => Math.abs(i - e)), r = Math.min(...n); return n.indexOf(r) } function _4e(t, e, n) { const r = t / 2, a = r$([0, 50], [0, r]); return (r - a(e) * n) * n } function E4e(t) { return t.slice(0, -1).map((e, n) => t[n + 1] - e) } function M4e(t, e) { if (e > 0) { const n = E4e(t); return Math.min(...n) >= e } return !0 } function r$(t, e) { return n => { if (t[0] === t[1] || e[0] === e[1]) return e[0]; const r = (e[1] - e[0]) / (t[1] - t[0]); return e[0] + r * (n - t[0]) } } function T4e(t) { return (String(t).split(".")[1] || "").length } function C4e(t, e) { const n = Math.pow(10, e); return Math.round(t * n) / n } var Uce = Ace, N4e = Ice, A4e = Oce, P4e = Dce; const Bce = S.forwardRef(({ className: t, ...e }, n) => l.jsxs(Uce, { ref: n, className: _t("relative flex w-full touch-none select-none items-center", t), ...e, children: [l.jsx(N4e, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-secondary", children: l.jsx(A4e, { className: "absolute h-full bg-primary" }) }), l.jsx(P4e, { className: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" })] })); Bce.displayName = Uce.displayName; const Ag = S.forwardRef(({ className: t, ...e }, n) => l.jsx("textarea", { className: _t("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t), ref: n, ...e })); Ag.displayName = "Textarea"; const i$ = ({ data: t, size: e = 200, className: n }) => { const r = e / 2, i = e / 2, a = e * .35, s = t.length, o = (u, d) => { const f = u * 2 * Math.PI / s - Math.PI / 2, h = d / 100 * a; return { x: r + h * Math.cos(f), y: i + h * Math.sin(f) } }, c = t.map((u, d) => { const f = o(d, u.value); return `${d === 0 ? "M" : "L"} ${f.x} ${f.y}` }).join(" "); return l.jsx("div", { className: _t("relative", n), children: l.jsxs("svg", { width: e, height: e, className: "overflow-visible", children: [[.2, .4, .6, .8, 1].map((u, d) => l.jsx($e.circle, { cx: r, cy: i, r: a * u, fill: "none", stroke: "currentColor", strokeWidth: "1", opacity: .1, initial: { scale: 0 }, animate: { scale: 1 }, transition: { delay: d * .1 } }, d)), t.map((u, d) => { const f = d * 2 * Math.PI / s - Math.PI / 2, h = r + a * Math.cos(f), m = i + a * Math.sin(f); return l.jsx($e.line, { x1: r, y1: i, x2: h, y2: m, stroke: "currentColor", strokeWidth: "1", opacity: .1, initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { delay: d * .1 } }, d) }), l.jsx($e.path, { d: `${c} Z`, fill: "url(#radarGradient)", fillOpacity: .3, stroke: "currentColor", strokeWidth: "2", initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { duration: 1, delay: .5 } }), t.map((u, d) => { const f = o(d, u.value); return l.jsx($e.circle, { cx: f.x, cy: f.y, r: "4", fill: u.color || "currentColor", initial: { scale: 0 }, animate: { scale: 1 }, transition: { delay: .7 + d * .1 } }, d) }), t.map((u, d) => { const f = d * 2 * Math.PI / s - Math.PI / 2, h = a + 20, m = r + h * Math.cos(f), g = i + h * Math.sin(f); return l.jsx($e.text, { x: m, y: g, textAnchor: "middle", dominantBaseline: "middle", className: "text-xs font-medium fill-current", initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { delay: 1 + d * .1 }, children: u.skill }, d) }), l.jsx("defs", { children: l.jsxs("linearGradient", { id: "radarGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [l.jsx("stop", { offset: "0%", stopColor: "hsl(var(--primary))", stopOpacity: "0.8" }), l.jsx("stop", { offset: "100%", stopColor: "hsl(var(--secondary))", stopOpacity: "0.4" })] }) })] }) }) }, h4 = ({ value: t, max: e = 100, size: n = 120, strokeWidth: r = 8, className: i, showValue: a = !0, color: s = "hsl(var(--primary))" }) => { const o = (n - r) / 2, c = 2 * Math.PI * o, u = t / e * c, d = c - u; return l.jsxs("div", { className: _t("relative inline-flex items-center justify-center", i), children: [l.jsxs("svg", { width: n, height: n, className: "transform -rotate-90", children: [l.jsx($e.circle, { cx: n / 2, cy: n / 2, r: o, stroke: "currentColor", strokeWidth: r, fill: "none", opacity: .1, initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { duration: .5 } }), l.jsx($e.circle, { cx: n / 2, cy: n / 2, r: o, stroke: s, strokeWidth: r, fill: "none", strokeLinecap: "round", strokeDasharray: c, strokeDashoffset: d, initial: { strokeDashoffset: c }, animate: { strokeDashoffset: d }, transition: { duration: 1, ease: "easeInOut" } })] }), a && l.jsx($e.div, { className: "absolute inset-0 flex items-center justify-center", initial: { opacity: 0, scale: .5 }, animate: { opacity: 1, scale: 1 }, transition: { delay: .5, duration: .5 }, children: l.jsxs("span", { className: "text-2xl font-bold", children: [Math.round(t), "%"] }) })] }) }, j4e = ({ data: t, width: e = 300, height: n = 150, className: r, color: i = "hsl(var(--primary))" }) => { const a = Math.max(...t.map(d => d.y)), s = Math.min(...t.map(d => d.y)), o = a - s, c = (d, f) => { const h = f / (t.length - 1) * e, m = n - (d.y - s) / o * n; return { x: h, y: m } }, u = t.map((d, f) => { const { x: h, y: m } = c(d, f); return `${f === 0 ? "M" : "L"} ${h} ${m}` }).join(" "); return l.jsx("div", { className: _t("relative", r), children: l.jsxs("svg", { width: e, height: n, className: "overflow-visible", children: [[0, .25, .5, .75, 1].map((d, f) => l.jsx($e.line, { x1: 0, y1: n * d, x2: e, y2: n * d, stroke: "currentColor", strokeWidth: "1", opacity: .1, initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { delay: f * .1 } }, f)), l.jsx($e.path, { d: u, fill: "none", stroke: i, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { duration: 1.5, ease: "easeInOut" } }), t.map((d, f) => { const { x: h, y: m } = c(d, f); return l.jsx($e.circle, { cx: h, cy: m, r: "4", fill: i, initial: { scale: 0 }, animate: { scale: 1 }, transition: { delay: .5 + f * .1 } }, f) })] }) }) }; function R4e() { const [t, e] = S.useState("colors"), [n, r] = S.useState([50]), [i, a] = S.useState(!1), [s, o] = S.useState(!1), [c, u] = S.useState("option1"), [d, f] = S.useState(!1), [h, m] = S.useState(!1), g = { primary: [{ name: "Primary 50", value: "hsl(239, 100%, 97%)", hex: "#F0F4FF" }, { name: "Primary 100", value: "hsl(239, 100%, 94%)", hex: "#E0E9FF" }, { name: "Primary 200", value: "hsl(239, 100%, 88%)", hex: "#C1D3FF" }, { name: "Primary 300", value: "hsl(239, 100%, 80%)", hex: "#A2BDFF" }, { name: "Primary 400", value: "hsl(239, 100%, 70%)", hex: "#83A7FF" }, { name: "Primary 500", value: "hsl(239, 84%, 60%)", hex: "#6366F1" }, { name: "Primary 600", value: "hsl(239, 84%, 50%)", hex: "#4F46E5" }, { name: "Primary 700", value: "hsl(239, 84%, 40%)", hex: "#4338CA" }, { name: "Primary 800", value: "hsl(239, 84%, 30%)", hex: "#3730A3" }, { name: "Primary 900", value: "hsl(239, 84%, 20%)", hex: "#312E81" }], secondary: [{ name: "Secondary 50", value: "hsl(265, 100%, 97%)", hex: "#F5F3FF" }, { name: "Secondary 100", value: "hsl(265, 100%, 94%)", hex: "#EDE9FE" }, { name: "Secondary 200", value: "hsl(265, 100%, 88%)", hex: "#DDD6FE" }, { name: "Secondary 300", value: "hsl(265, 100%, 80%)", hex: "#C4B5FD" }, { name: "Secondary 400", value: "hsl(265, 100%, 70%)", hex: "#A78BFA" }, { name: "Secondary 500", value: "hsl(265, 75%, 65%)", hex: "#8B5CF6" }, { name: "Secondary 600", value: "hsl(265, 75%, 55%)", hex: "#7C3AED" }, { name: "Secondary 700", value: "hsl(265, 75%, 45%)", hex: "#6D28D9" }, { name: "Secondary 800", value: "hsl(265, 75%, 35%)", hex: "#5B21B6" }, { name: "Secondary 900", value: "hsl(265, 75%, 25%)", hex: "#4C1D95" }], accent: [{ name: "Accent 50", value: "hsl(158, 100%, 97%)", hex: "#F0FDF4" }, { name: "Accent 100", value: "hsl(158, 100%, 94%)", hex: "#DCFCE7" }, { name: "Accent 200", value: "hsl(158, 100%, 88%)", hex: "#BBF7D0" }, { name: "Accent 300", value: "hsl(158, 100%, 80%)", hex: "#86EFAC" }, { name: "Accent 400", value: "hsl(158, 100%, 70%)", hex: "#4ADE80" }, { name: "Accent 500", value: "hsl(158, 64%, 52%)", hex: "#22C55E" }, { name: "Accent 600", value: "hsl(158, 64%, 42%)", hex: "#16A34A" }, { name: "Accent 700", value: "hsl(158, 64%, 32%)", hex: "#15803D" }, { name: "Accent 800", value: "hsl(158, 64%, 22%)", hex: "#166534" }, { name: "Accent 900", value: "hsl(158, 64%, 12%)", hex: "#14532D" }] }, x = [{ name: "Display 1", size: "4.5rem", weight: "700", lineHeight: "1.1", usage: "Hero headings" }, { name: "Display 2", size: "3.75rem", weight: "700", lineHeight: "1.2", usage: "Section headings" }, { name: "H1", size: "3rem", weight: "600", lineHeight: "1.3", usage: "Page titles" }, { name: "H2", size: "2.25rem", weight: "600", lineHeight: "1.4", usage: "Section titles" }, { name: "H3", size: "1.875rem", weight: "600", lineHeight: "1.5", usage: "Subsection titles" }, { name: "H4", size: "1.5rem", weight: "600", lineHeight: "1.5", usage: "Card titles" }, { name: "H5", size: "1.25rem", weight: "600", lineHeight: "1.6", usage: "Component titles" }, { name: "H6", size: "1.125rem", weight: "600", lineHeight: "1.6", usage: "Small titles" }, { name: "Body Large", size: "1.125rem", weight: "400", lineHeight: "1.7", usage: "Large body text" }, { name: "Body", size: "1rem", weight: "400", lineHeight: "1.6", usage: "Regular body text" }, { name: "Body Small", size: "0.875rem", weight: "400", lineHeight: "1.5", usage: "Small body text" }, { name: "Caption", size: "0.75rem", weight: "400", lineHeight: "1.4", usage: "Captions and labels" }], v = [{ name: "xs", value: "0.25rem", pixels: "4px", usage: "Tight spacing" }, { name: "sm", value: "0.5rem", pixels: "8px", usage: "Small spacing" }, { name: "md", value: "1rem", pixels: "16px", usage: "Medium spacing" }, { name: "lg", value: "1.5rem", pixels: "24px", usage: "Large spacing" }, { name: "xl", value: "2rem", pixels: "32px", usage: "Extra large spacing" }, { name: "2xl", value: "3rem", pixels: "48px", usage: "Section spacing" }, { name: "3xl", value: "4rem", pixels: "64px", usage: "Page spacing" }, { name: "4xl", value: "6rem", pixels: "96px", usage: "Hero spacing" }], b = [{ name: "Default", variant: "default" }, { name: "Destructive", variant: "destructive" }, { name: "Outline", variant: "outline" }, { name: "Secondary", variant: "secondary" }, { name: "Ghost", variant: "ghost" }, { name: "Link", variant: "link" }, { name: "Gradient", variant: "gradient" }, { name: "Success", variant: "success" }, { name: "Warning", variant: "warning" }], E = [{ name: "Small", size: "sm" }, { name: "Default", size: "default" }, { name: "Large", size: "lg" }, { name: "Extra Large", size: "xl" }, { name: "Icon", size: "icon" }], M = [{ name: "Default", variant: "default" }, { name: "Secondary", variant: "secondary" }, { name: "Destructive", variant: "destructive" }, { name: "Outline", variant: "outline" }]; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "MockRise Design System" }), l.jsx("p", { className: "text-muted-foreground", children: "Comprehensive design system documentation and component library" })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, children: l.jsxs(Sp, { value: t, onValueChange: e, className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-6", children: [l.jsx(Rr, { value: "colors", children: "Colors" }), l.jsx(Rr, { value: "typography", children: "Typography" }), l.jsx(Rr, { value: "spacing", children: "Spacing" }), l.jsx(Rr, { value: "components", children: "Components" }), l.jsx(Rr, { value: "patterns", children: "Patterns" }), l.jsx(Rr, { value: "accessibility", children: "Accessibility" })] }), l.jsx(Dr, { value: "colors", className: "space-y-6", children: l.jsx("div", { className: "space-y-8", children: Object.entries(g).map(([C, N]) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .1 }, children: l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 capitalize flex items-center gap-2", children: [l.jsx(Qve, { className: "h-5 w-5 text-primary" }), C, " Colors"] }), l.jsx("div", { className: "grid grid-cols-2 md:grid-cols-5 gap-4", children: N.map((A, j) => l.jsxs("div", { className: "space-y-2", children: [l.jsx("div", { className: "w-full h-16 rounded-lg border border-border", style: { backgroundColor: A.value } }), l.jsxs("div", { className: "text-xs", children: [l.jsx("div", { className: "font-medium", children: A.name }), l.jsx("div", { className: "text-muted-foreground", children: A.hex }), l.jsx("div", { className: "text-muted-foreground", children: A.value })] })] }, j)) })] }) }, C)) }) }), l.jsx(Dr, { value: "typography", className: "space-y-6", children: l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(iye, { className: "h-5 w-5 text-primary" }), "Typography Scale"] }), l.jsx("div", { className: "space-y-4", children: x.map((C, N) => l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: N * .1 }, className: "p-4 rounded-lg border border-border", children: [l.jsxs("div", { className: "flex items-center justify-between mb-2", children: [l.jsx("span", { className: "font-medium", children: C.name }), l.jsxs("div", { className: "text-sm text-muted-foreground", children: [C.size, "  ", C.weight, "  ", C.lineHeight] })] }), l.jsx("div", { className: "text-foreground", style: { fontSize: C.size, fontWeight: C.weight, lineHeight: C.lineHeight }, children: "The quick brown fox jumps over the lazy dog" }), l.jsxs("div", { className: "text-xs text-muted-foreground mt-1", children: ["Usage: ", C.usage] })] }, C.name)) })] }) }), l.jsx(Dr, { value: "spacing", className: "space-y-6", children: l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(x8, { className: "h-5 w-5 text-primary" }), "Spacing Scale"] }), l.jsx("div", { className: "space-y-4", children: v.map((C, N) => l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: N * .1 }, className: "flex items-center gap-4", children: [l.jsx("div", { className: "w-16 text-sm font-medium", children: C.name }), l.jsx("div", { className: "flex-1", children: l.jsx("div", { className: "bg-primary rounded", style: { width: C.value, height: "1rem" } }) }), l.jsx("div", { className: "text-sm text-muted-foreground w-20", children: C.value }), l.jsx("div", { className: "text-sm text-muted-foreground w-12", children: C.pixels }), l.jsx("div", { className: "text-sm text-muted-foreground w-32", children: C.usage })] }, C.name)) })] }) }), l.jsxs(Dr, { value: "components", className: "space-y-6", children: [l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(vA, { className: "h-5 w-5 text-primary" }), "Buttons"] }), l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Button Variants" }), l.jsx("div", { className: "flex flex-wrap gap-3", children: b.map(C => l.jsx(on, { variant: C.variant, size: "default", children: C.name }, C.name)) })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Button Sizes" }), l.jsx("div", { className: "flex flex-wrap items-center gap-3", children: E.map(C => l.jsx(on, { variant: "default", size: C.size, children: C.name }, C.name)) })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Button States" }), l.jsxs("div", { className: "flex flex-wrap gap-3", children: [l.jsx(on, { variant: "default", children: "Default" }), l.jsx(on, { variant: "default", disabled: !0, children: "Disabled" }), l.jsx(on, { variant: "default", loading: !0, children: "Loading" }), l.jsx(on, { variant: "default", className: "animate-pulse", children: "Pulsing" })] })] })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(Ia, { className: "h-5 w-5 text-primary" }), "Badges"] }), l.jsxs("div", { className: "flex flex-wrap gap-3", children: [M.map(C => l.jsx(Jt, { variant: C.variant, children: C.name }, C.name)), l.jsx(Jt, { className: "bg-green-100 text-green-800", children: "Success" }), l.jsx(Jt, { className: "bg-yellow-100 text-yellow-800", children: "Warning" }), l.jsx(Jt, { className: "bg-blue-100 text-blue-800", children: "Info" })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(h0, { className: "h-5 w-5 text-primary" }), "Form Elements"] }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "input-example", children: "Input Field" }), l.jsx(fn, { id: "input-example", placeholder: "Enter text..." })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "textarea-example", children: "Textarea" }), l.jsx(Ag, { id: "textarea-example", placeholder: "Enter message..." })] }), l.jsxs("div", { children: [l.jsx(We, { children: "Select" }), l.jsxs(Jn, { children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select option" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "option1", children: "Option 1" }), l.jsx(ut, { value: "option2", children: "Option 2" }), l.jsx(ut, { value: "option3", children: "Option 3" })] })] })] })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center space-x-2", children: [l.jsx(QC, { id: "checkbox-example", checked: s, onCheckedChange: C => o(C === !0) }), l.jsx(We, { htmlFor: "checkbox-example", children: "Checkbox" })] }), l.jsx("div", { className: "flex items-center space-x-2", children: l.jsxs(w2, { value: c, onValueChange: u, children: [l.jsxs("div", { className: "flex items-center space-x-2", children: [l.jsx(Ax, { value: "option1", id: "radio1" }), l.jsx(We, { htmlFor: "radio1", children: "Option 1" })] }), l.jsxs("div", { className: "flex items-center space-x-2", children: [l.jsx(Ax, { value: "option2", id: "radio2" }), l.jsx(We, { htmlFor: "radio2", children: "Option 2" })] })] }) }), l.jsxs("div", { className: "flex items-center space-x-2", children: [l.jsx(Aa, { id: "switch-example", checked: i, onCheckedChange: a }), l.jsx(We, { htmlFor: "switch-example", children: "Switch" })] }), l.jsxs("div", { children: [l.jsx(We, { children: "Slider" }), l.jsx(Bce, { value: n, onValueChange: r, max: 100, step: 1, className: "w-full" }), l.jsxs("div", { className: "text-sm text-muted-foreground", children: ["Value: ", n[0]] })] })] })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(s5, { className: "h-5 w-5 text-primary" }), "Progress & Status"] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { children: "Progress Bar" }), l.jsx(vu, { value: 75, className: "mt-2" })] }), l.jsxs("div", { className: "flex items-center gap-4", children: [l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(oi, { className: "h-4 w-4 text-green-500" }), l.jsx("span", { className: "text-sm", children: "Success" })] }), l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(p0, { className: "h-4 w-4 text-yellow-500" }), l.jsx("span", { className: "text-sm", children: "Warning" })] }), l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(LS, { className: "h-4 w-4 text-red-500" }), l.jsx("span", { className: "text-sm", children: "Error" })] }), l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(h5, { className: "h-4 w-4 text-blue-500" }), l.jsx("span", { className: "text-sm", children: "Info" })] })] })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(v1, { className: "h-5 w-5 text-primary" }), "Animated Charts"] }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [l.jsxs("div", { className: "text-center", children: [l.jsx("h4", { className: "text-lg font-medium mb-4", children: "Radar Chart" }), l.jsx(i$, { data: [{ skill: "Technical", value: 85, color: "hsl(var(--primary))" }, { skill: "Communication", value: 92, color: "hsl(var(--accent))" }, { skill: "Problem Solving", value: 78, color: "hsl(var(--secondary))" }, { skill: "Leadership", value: 88, color: "hsl(var(--warning))" }], size: 200 })] }), l.jsxs("div", { className: "text-center", children: [l.jsx("h4", { className: "text-lg font-medium mb-4", children: "Circular Progress" }), l.jsx(h4, { value: 75, size: 120 })] })] })] })] }), l.jsx(Dr, { value: "patterns", className: "space-y-6", children: l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(x8, { className: "h-5 w-5 text-primary" }), "Design Patterns"] }), l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Card Patterns" }), l.jsxs("div", { className: "grid md:grid-cols-3 gap-4", children: [l.jsxs(sn, { className: "p-4", variant: "default", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Default Card" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Standard card with subtle border" })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Elevated Card" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Card with enhanced shadow" })] }), l.jsxs(sn, { className: "p-4", variant: "glass", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Glass Card" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Glass morphism effect" })] })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Animation Patterns" }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-4", children: [l.jsxs($e.div, { whileHover: { scale: 1.05 }, whileTap: { scale: .95 }, className: "p-4 rounded-lg border border-border cursor-pointer", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Hover Scale" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Hover to see scale effect" })] }), l.jsxs($e.div, { whileHover: { y: -2 }, className: "p-4 rounded-lg border border-border cursor-pointer", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Hover Lift" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Hover to see lift effect" })] })] })] })] })] }) }), l.jsx(Dr, { value: "accessibility", className: "space-y-6", children: l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(Qh, { className: "h-5 w-5 text-primary" }), "Accessibility Guidelines"] }), l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Color Contrast" }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-4", children: [l.jsxs("div", { className: "p-4 rounded-lg bg-primary text-primary-foreground", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Primary Text" }), l.jsx("p", { className: "text-sm", children: "WCAG AA compliant contrast ratio" })] }), l.jsxs("div", { className: "p-4 rounded-lg bg-muted text-muted-foreground", children: [l.jsx("h5", { className: "font-medium mb-2", children: "Muted Text" }), l.jsx("p", { className: "text-sm", children: "Sufficient contrast for readability" })] })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Focus States" }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(on, { className: "focus:ring-2 focus:ring-primary focus:ring-offset-2", children: "Focusable Button" }), l.jsx(fn, { placeholder: "Focusable input", className: "focus:ring-2 focus:ring-primary" })] })] }), l.jsxs("div", { children: [l.jsx("h4", { className: "text-lg font-medium mb-3", children: "Semantic HTML" }), l.jsxs("div", { className: "space-y-2 text-sm", children: [l.jsx("div", { children: " Use proper heading hierarchy (h1, h2, h3...)" }), l.jsx("div", { children: " Include alt text for images" }), l.jsx("div", { children: " Use ARIA labels for complex interactions" }), l.jsx("div", { children: " Ensure keyboard navigation works" }), l.jsx("div", { children: " Provide screen reader friendly content" })] })] })] })] }) })] }) })] }) } function a$() { const { user: t } = La(), { addNotification: e } = OS(); S.useEffect(() => { if (!(!t || t.role !== "interviewer")) { if (t.status === "approved" && t.isApproved) { const n = `interviewer-approved-${t.id}`; sessionStorage.getItem(n) || (e({ title: "Application Approved", message: "Your interviewer application has been approved. You now have access to the interviewer dashboard.", type: "success" }), sessionStorage.setItem(n, "true")) } else if (t.status === "rejected") { const n = `interviewer-rejected-${t.id}`; sessionStorage.getItem(n) || (e({ title: "Application Rejected", message: "Your interviewer application has been rejected. Please contact support if you have questions.", type: "error" }), sessionStorage.setItem(n, "true")) } } }, [t, e]) } function k4e() { a$(); const t = ui(), { logout: e } = La(), n = async () => { await e(), t("/") }; return l.jsx("div", { className: "min-h-screen hero-gradient flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .95 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .5 }, className: "w-full max-w-md", children: l.jsxs(sn, { className: "p-8 glass", variant: "glass", children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-8 group", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsx($e.div, { initial: { scale: 0 }, animate: { scale: 1 }, transition: { delay: .2, type: "spring", stiffness: 200 }, className: "flex justify-center mb-6", children: l.jsx("div", { className: "w-20 h-20 bg-primary/10 rounded-full flex items-center justify-center", children: l.jsx(ni, { className: "h-10 w-10 text-primary" }) }) }), l.jsxs("div", { className: "text-center space-y-4", children: [l.jsx("h1", { className: "text-2xl font-bold", children: "Application Under Review" }), l.jsx("p", { className: "text-muted-foreground", children: "Thank you for applying to become an interviewer! Your application is currently being reviewed by our team." }), l.jsxs("div", { className: "bg-muted/20 rounded-lg p-4 space-y-3", children: [l.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [l.jsx(oi, { className: "h-4 w-4 text-accent" }), l.jsx("span", { children: "Application submitted successfully" })] }), l.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [l.jsx(ni, { className: "h-4 w-4 text-warning" }), l.jsx("span", { children: "Under review (typically 2-3 business days)" })] }), l.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [l.jsx(Lu, { className: "h-4 w-4" }), l.jsx("span", { children: "You'll receive an email notification once reviewed" })] })] }), l.jsxs("div", { className: "space-y-3", children: [l.jsxs(on, { onClick: () => window.location.href = "mailto:support@mockrise.com", variant: "outline", className: "w-full", children: [l.jsx(Lu, { className: "h-4 w-4 mr-2" }), "Contact Support"] }), l.jsxs(on, { onClick: n, variant: "ghost", className: "w-full", children: [l.jsx(f0, { className: "h-4 w-4 mr-2" }), "Back to Home"] })] })] })] }) }) }) } function I4e() { a$(); const t = ui(), { logout: e } = La(), n = async () => { sessionStorage.removeItem("has-seen-rejection"), await e(), t("/login?signup=true&role=interviewer") }, r = async () => { sessionStorage.setItem("has-seen-rejection", "true"), await e(), t("/") }; return l.jsx("div", { className: "min-h-screen hero-gradient flex items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .95 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .5 }, className: "w-full max-w-md", children: l.jsxs(sn, { className: "p-8 glass", variant: "glass", children: [l.jsxs(yi, { to: "/", className: "flex items-center justify-center space-x-2 mb-8 group", children: [l.jsx(Ia, { className: "h-8 w-8 text-primary transition-all duration-300 group-hover:rotate-12" }), l.jsx("span", { className: "text-2xl font-bold gradient-text", children: "MockRise" })] }), l.jsx($e.div, { initial: { scale: 0 }, animate: { scale: 1 }, transition: { delay: .2, type: "spring", stiffness: 200 }, className: "flex justify-center mb-6", children: l.jsx("div", { className: "w-20 h-20 bg-destructive/10 rounded-full flex items-center justify-center", children: l.jsx(LS, { className: "h-10 w-10 text-destructive" }) }) }), l.jsxs("div", { className: "text-center space-y-4", children: [l.jsx("h1", { className: "text-2xl font-bold", children: "Application Not Approved" }), l.jsx("p", { className: "text-muted-foreground", children: "We appreciate your interest in becoming an interviewer. Unfortunately, we cannot approve your application at this time." }), l.jsx("div", { className: "bg-muted/20 rounded-lg p-4 space-y-3", children: l.jsxs("div", { className: "text-sm text-muted-foreground", children: [l.jsx("p", { className: "mb-2", children: "Common reasons for rejection include:" }), l.jsxs("ul", { className: "text-left space-y-1", children: [l.jsx("li", { children: " Insufficient experience in the field" }), l.jsx("li", { children: " Incomplete application information" }), l.jsx("li", { children: " Current capacity limitations" })] })] }) }), l.jsxs("div", { className: "space-y-3", children: [l.jsxs(on, { onClick: () => window.location.href = "mailto:support@mockrise.com", variant: "outline", className: "w-full", children: [l.jsx(Lu, { className: "h-4 w-4 mr-2" }), "Contact Support"] }), l.jsxs(on, { onClick: n, variant: "outline", className: "w-full", children: [l.jsx(xT, { className: "h-4 w-4 mr-2" }), "Apply Again"] }), l.jsxs(on, { onClick: r, variant: "ghost", className: "w-full", children: [l.jsx(f0, { className: "h-4 w-4 mr-2" }), "Back to Home"] })] })] })] }) }) }) } const $ce = { async uploadResume(t) { const e = new FormData; e.append("resume", t); const r = await fetch(`http://localhost:5000${jn.upload.resume}`, { method: "POST", body: e, credentials: "include" }); if (!r.ok) { const i = await r.json().catch(() => ({ error: "Upload failed" })); throw new Error(i.error || "Failed to upload resume") } return r.json() }, getResumeUrl(t) { return `http://localhost:5000${jn.upload.getResume(t)}` } }, O4e = Object.freeze(Object.defineProperty({ __proto__: null, uploadService: $ce }, Symbol.toStringTag, { value: "Module" })); function D4e() { const t = ui(), { user: e, loading: n } = La(), [r, i] = S.useState(null), [a, s] = S.useState(!1), [o, c] = S.useState(""), [u, d] = S.useState(""), [f, h] = S.useState(""), [m, g] = S.useState(null), [x, v] = S.useState({}); S.useEffect(() => { if (!n) { if (!e) { t("/login", { replace: !0 }); return } if (!e.oauthRolePending) if (e.role === "interviewer" && e.status === "pending_verification") t("/pending-verification", { replace: !0 }); else if (e.role === "interviewer" && e.status === "rejected") t("/rejected-notice", { replace: !0 }); else { const C = e.role === "super_admin" ? "admin" : e.role; t(`/dashboard/${C}`, { replace: !0 }) } } }, [e, n, t]); const b = C => { if (C.target.files && C.target.files[0]) { const N = C.target.files[0]; if (N.type !== "application/pdf") { dt.error("Please upload a PDF file only."), g(null); return } g(N), v(A => ({ ...A, resume: void 0 })) } else g(null) }, E = () => { const C = {}; return r ? (r === "interviewer" && (o || (C.yearsExperience = "Years of experience is required."), u.trim() || (C.expertiseArea = "Area of expertise is required."), f.trim() ? /^https?:\/\/(www\.)?linkedin\.com\/.*$/.test(f) || (C.linkedinUrl = "Please enter a valid LinkedIn URL.") : C.linkedinUrl = "LinkedIn URL is required.", m || (C.resume = "Resume upload is required.")), v(C), Object.keys(C).length === 0) : (dt.error("Please select a role"), !1) }, M = async () => { if (E()) { s(!0); try { const C = { role: r }; if (r === "interviewer" && (C.experience = o, C.expertise = u, C.linkedin = f, m)) try { const A = await $ce.uploadResume(m); C.resume = A.data.url } catch (A) { dt.error(A.message || "Failed to upload resume. Please try again."), s(!1); return } const N = await Lc.assignRole(C); N.success && (dt.success(`Role assigned successfully! Welcome as a ${r}.`), N.redirect ? window.location.href = N.redirect : r === "interviewer" ? t("/pending-verification", { replace: !0 }) : t("/dashboard/trainee", { replace: !0 })) } catch (C) { dt.error(C.message || "Failed to assign role. Please try again.") } finally { s(!1) } } }; return n ? l.jsx(ef, { children: l.jsx("div", { className: "relative z-10 flex min-h-screen items-center justify-center p-4", children: l.jsx(sn, { className: "p-8", children: l.jsx("div", { className: "flex items-center justify-center", children: l.jsx(sa, { className: "h-8 w-8 animate-spin text-primary" }) }) }) }) }) : l.jsx(ef, { children: l.jsx("div", { className: "relative z-10 flex min-h-screen items-center justify-center p-4", children: l.jsx($e.div, { initial: { opacity: 0, scale: .9 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .5 }, className: "w-full max-w-2xl", children: l.jsxs(sn, { className: "p-8 space-y-6", variant: "glass", children: [l.jsxs("div", { className: "text-center", children: [l.jsx(Ia, { className: "mx-auto h-12 w-12 text-primary mb-4" }), l.jsx("h2", { className: "text-3xl font-bold mb-2", children: "Choose Your Role" }), l.jsx("p", { className: "text-muted-foreground", children: "Please select the role that best describes you" })] }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-4 mt-8", children: [l.jsx($e.div, { whileHover: { scale: 1.02 }, whileTap: { scale: .98 }, children: l.jsx(sn, { className: `p-6 cursor-pointer transition-all ${r === "trainee" ? "ring-2 ring-primary border-primary" : "hover:border-primary/50"}`, variant: "elevated", onClick: () => { i("trainee"), c(""), d(""), h(""), g(null), v({}) }, children: l.jsxs("div", { className: "flex flex-col items-center text-center space-y-4", children: [l.jsx("div", { className: `p-4 rounded-full ${r === "trainee" ? "bg-primary/10" : "bg-muted"}`, children: l.jsx(hf, { className: `h-8 w-8 ${r === "trainee" ? "text-primary" : "text-muted-foreground"}` }) }), l.jsxs("div", { children: [l.jsx("h3", { className: "text-xl font-semibold mb-2", children: "Trainee" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Practice interview skills and get feedback to improve your performance" })] }), r === "trainee"] }) }) }), l.jsx($e.div, { whileHover: { scale: 1.02 }, whileTap: { scale: .98 }, children: l.jsx(sn, { className: `p-6 cursor-pointer transition-all ${r === "interviewer" ? "ring-2 ring-primary border-primary" : "hover:border-primary/50"}`, variant: "elevated", onClick: () => { i("interviewer"), v({}) }, children: l.jsxs("div", { className: "flex flex-col items-center text-center space-y-4", children: [l.jsx("div", { className: `p-4 rounded-full ${r === "interviewer" ? "bg-primary/10" : "bg-muted"}`, children: l.jsx(G3, { className: `h-8 w-8 ${r === "interviewer" ? "text-primary" : "text-muted-foreground"}` }) }), l.jsxs("div", { children: [l.jsx("h3", { className: "text-xl font-semibold mb-2", children: "Interviewer" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Conduct interviews and help trainees improve. Requires admin approval." })] }), r === "interviewer"] }) }) })] }), r === "interviewer" && l.jsxs($e.div, { initial: { opacity: 0, height: 0 }, animate: { opacity: 1, height: "auto" }, exit: { opacity: 0, height: 0 }, className: "space-y-4 mt-4 pt-4 border-t border-border", children: [l.jsx("div", { className: "bg-primary/10 border border-primary/20 rounded-lg p-4 mb-4", children: l.jsxs("p", { className: "text-sm text-muted-foreground", children: [l.jsx("strong", { children: "Note:" }), " Please complete the following information. This will help reduce the chance of rejection."] }) }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "yearsExperience", children: "Years of Experience *" }), l.jsxs(Jn, { onValueChange: c, value: o, children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select your experience" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "0-2", children: "0-2 years" }), l.jsx(ut, { value: "2-5", children: "2-5 years" }), l.jsx(ut, { value: "5-10", children: "5-10 years" }), l.jsx(ut, { value: "10+", children: "10+ years" })] })] }), x.yearsExperience && l.jsx("p", { className: "text-sm text-destructive", children: x.yearsExperience })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "expertiseArea", children: "Area of Expertise *" }), l.jsxs("div", { className: "relative", children: [l.jsx(G3, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "expertiseArea", type: "text", placeholder: "e.g., Frontend Development, UX/UI Design", className: "pl-10", value: u, onChange: C => { d(C.target.value), v(N => ({ ...N, expertiseArea: void 0 })) } })] }), x.expertiseArea && l.jsx("p", { className: "text-sm text-destructive", children: x.expertiseArea })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "linkedinUrl", children: "LinkedIn Profile *" }), l.jsxs("div", { className: "relative", children: [l.jsx(BS, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "linkedinUrl", type: "url", placeholder: "https://linkedin.com/in/yourprofile", className: "pl-10", value: f, onChange: C => { h(C.target.value), v(N => ({ ...N, linkedinUrl: void 0 })) } })] }), x.linkedinUrl && l.jsx("p", { className: "text-sm text-destructive", children: x.linkedinUrl })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "resume", children: "Upload Resume (PDF only) *" }), l.jsxs("div", { className: "relative", children: [l.jsx($S, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground z-10" }), l.jsx(fn, { id: "resume", type: "file", accept: ".pdf", className: "pl-10 file:text-sm file:font-medium file:text-primary", onChange: b })] }), m && l.jsxs("p", { className: "text-sm text-muted-foreground", children: ["Selected: ", m.name] }), x.resume && l.jsx("p", { className: "text-sm text-destructive", children: x.resume })] })] }), l.jsx(on, { onClick: M, disabled: !r || a, className: "w-full mt-6", motionProps: { whileHover: { scale: 1.02 }, whileTap: { scale: .98 } }, children: a ? l.jsxs(l.Fragment, { children: [l.jsx(sa, { className: "h-4 w-4 mr-2 animate-spin" }), r === "interviewer" ? "Submitting Application..." : "Assigning Role..."] }) : l.jsxs(l.Fragment, { children: [r === "interviewer" ? "Submit Application" : "Continue", l.jsx(o5, { className: "h-4 w-4 ml-2" })] }) })] }) }) }) }) } function L4e() { const t = ui(), { user: e } = La(), n = () => { if (!e) { t("/login"); return } switch (e.role) { case "admin": case "super_admin": case "hr_admin": t("/admin"); break; case "interviewer": t("/interviewer"); break; default: t("/dashboard") } }; return l.jsx("div", { className: "min-h-screen flex items-center justify-center bg-background", children: l.jsxs("div", { className: "text-center space-y-6 p-8 max-w-md", children: [l.jsx("div", { className: "flex justify-center", children: l.jsx(cx, { className: "h-24 w-24 text-destructive opacity-80" }) }), l.jsx("h1", { className: "text-3xl font-bold tracking-tight", children: "Access Denied" }), l.jsx("p", { className: "text-muted-foreground text-lg", children: "Sorry, you don't have permission to access this page. Please contact your administrator if you believe this is a mistake." }), l.jsx("div", { className: "pt-4", children: l.jsxs(vt, { onClick: n, className: "gap-2", size: "lg", children: [l.jsx(f0, { className: "h-4 w-4" }), "Back to Safety"] }) })] }) }) } const F4e = l.jsxs(l.Fragment, { children: [l.jsx(Gn, { path: cr.HOME, element: l.jsx(E3e, {}) }), l.jsx(Gn, { path: cr.LOGIN, element: l.jsx(gLe, {}) }), l.jsx(Gn, { path: cr.FORGOT_PASSWORD, element: l.jsx(vLe, {}) }), l.jsx(Gn, { path: cr.RESET_PASSWORD, element: l.jsx(yLe, {}) }), l.jsx(Gn, { path: cr.PRICING, element: l.jsx(ELe, {}) }), l.jsx(Gn, { path: cr.RESOURCES, element: l.jsx(OLe, {}) }), l.jsx(Gn, { path: cr.FAQ, element: l.jsx(t4e, {}) }), l.jsx(Gn, { path: cr.STYLE_GUIDE, element: l.jsx(R4e, {}) }), l.jsx(Gn, { path: cr.PENDING_VERIFICATION, element: l.jsx(k4e, {}) }), l.jsx(Gn, { path: cr.REJECTED_NOTICE, element: l.jsx(I4e, {}) }), l.jsx(Gn, { path: cr.OAUTH_ROLE_SELECTION, element: l.jsx(D4e, {}) }), l.jsx(Gn, { path: cr.UNAUTHORIZED, element: l.jsx(L4e, {}) })] }); function qM({ children: t, requiredRoles: e }) { const { user: n, loading: r, isAuthorized: i, fetchUser: a } = La(), s = fs(); if (S.useEffect(() => { !r && !n && a() }, []), r) return null; if (!n) return l.jsx(Ay, { to: "/login", state: { from: s }, replace: !0 }); if (!i(e)) return l.jsx(Ay, { to: "/unauthorized", replace: !0 }); if (n.role === "interviewer" && e.includes("interviewer")) { if (n.status === "pending_verification") return l.jsx(Ay, { to: "/pending-verification", replace: !0 }); if (n.status === "rejected") return l.jsx(Ay, { to: "/rejected-notice", replace: !0 }); if (n.status !== "approved") return l.jsx(Ay, { to: "/pending-verification", replace: !0 }) } return l.jsx(l.Fragment, { children: t }) } function U4e({ config: t, userRole: e }) { const n = fs(), r = a => n.pathname === a, i = t.sidebarItems.filter(a => a.requiredRoles ? e && a.requiredRoles.includes(e) : !0); return l.jsx("aside", { className: "hidden lg:block w-64 border-r border-border min-h-[calc(100vh-4rem)] bg-card/50 overflow-hidden", children: l.jsx("nav", { className: "space-y-2 p-4", children: i.map(a => { const s = r(a.href); return l.jsx(yi, { to: a.href, className: "block", children: l.jsxs(vt, { variant: s ? "secondary" : "ghost", className: _t("w-full justify-start group transition-all hover:bg-muted hover:text-black duration-200", "min-w-0 overflow-hidden", s && "bg-primary/10 text-primary hover:bg-primary/20"), children: [l.jsx(a.icon, { className: "mr-2 h-4 w-4 flex-shrink-0" }), l.jsx("span", { className: "truncate flex-1 text-left", children: a.name }), s && l.jsx(DS, { className: "ml-2 h-4 w-4 flex-shrink-0 transition-transform group-hover:translate-x-1" })] }) }, a.name) }) }) }) } function B4e() {
	const [t, e] = S.useState(!1), n = ui(), r = Xc(), { user: i } = La(), { notifications: a, markAsRead: s, markAllAsRead: o, unreadCount: c, refreshNotifications: u } = OS(), d = Cs({ mutationFn: v => Jd.deleteNotification(v), onSuccess: () => { r.invalidateQueries({ queryKey: ["notifications"] }), u(), dt.success("Notification deleted") }, onError: () => { dt.error("Failed to delete notification") } }), f = (v, b) => { v.stopPropagation(), d.mutate(b) }, h = () => { if (!i) return "/dashboard/trainee/notifications"; switch (i.role) { case "admin": return "/dashboard/admin/notifications"; case "interviewer": return "/dashboard/interviewer/notifications"; case "trainee": return "/dashboard/trainee/notifications"; default: return "/dashboard/trainee/notifications" } }, m = v => { const E = new Date().getTime() - v.getTime(), M = Math.floor(E / 1e3), C = Math.floor(M / 60), N = Math.floor(C / 60), A = Math.floor(N / 24); return A > 0 ? `${A} day${A !== 1 ? "s" : ""} ago` : N > 0 ? `${N} hour${N !== 1 ? "s" : ""} ago` : C > 0 ? `${C} minute${C !== 1 ? "s" : ""} ago` : "Just now" }, g = v => { switch (v) { case "success": return oi; case "warning": return ji; case "error": return ji; default: return h5 } }, x = v => { switch (v) { case "success": return "text-accent"; case "warning": return "text-warning"; case "error": return "text-destructive"; default: return "text-primary" } }; return l.jsxs(l.Fragment, {
		children: [l.jsxs(on, { variant: "ghost", size: "icon", onClick: () => e(!t), className: "relative hover:bg-muted hover:text-primary transition-colors duration-200", children: [l.jsx(lx, { className: "h-5 w-5" }), c > 0 && l.jsx(Jt, { className: "absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center p-0 bg-destructive text-xs", children: c })] }), l.jsx(YS, {
			children: t && l.jsxs(l.Fragment, {
				children: [l.jsx($e.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black/20 backdrop-blur-sm z-40", onClick: () => e(!1) }), l.jsxs($e.div, {
					initial: { opacity: 0, x: 300 }, animate: { opacity: 1, x: 0 }, exit: { opacity: 0, x: 300 }, transition: { type: "spring", damping: 25, stiffness: 200 }, className: "fixed top-16 right-2 sm:right-4 w-[calc(100vw-1rem)] sm:w-80 max-w-[calc(100vw-1rem)] sm:max-w-[calc(100vw-2rem)] bg-background border border-border rounded-lg shadow-lg z-50 max-h-[calc(100vh-5rem)] overflow-hidden", children: [l.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-border", children: [l.jsx("h3", { className: "font-semibold", children: "Notifications" }), l.jsxs("div", { className: "flex items-center gap-2", children: [c > 0 && l.jsx(on, { variant: "ghost", size: "sm", onClick: o, className: "text-xs", children: "Mark all read" }), l.jsx(on, { variant: "ghost", size: "icon", onClick: () => e(!1), children: l.jsx(Pa, { className: "h-4 w-4" }) })] })] }), l.jsx("div", {
						className: "max-h-96 overflow-y-auto", children: a.length === 0 ? l.jsxs("div", { className: "p-8 text-center text-muted-foreground", children: [l.jsx(lx, { className: "h-12 w-12 mx-auto mb-4 opacity-50" }), l.jsx("p", { children: "No notifications" })] }) : l.jsx("div", {
							className: "divide-y divide-border", children: a.map(v => {
								const b = g(v.type), E = x(v.type), M = v.message.split(`
`).length, C = v.message.length > 180 || M > 3; return l.jsx($e.div, { initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, className: `p-4 hover:bg-muted/50 transition-colors cursor-pointer group relative ${v.isRead ? "" : "bg-primary/5"}`, onClick: () => { C ? (e(!1), n(h(), { state: { notificationId: v.id } })) : (s(v.id), v.title.toLowerCase().includes("pending interviewer") && (e(!1), n("/dashboard/admin/pending-interviewers"))) }, children: l.jsxs("div", { className: "flex items-start gap-3", children: [l.jsx(b, { className: `h-5 w-5 mt-0.5 flex-shrink-0 ${E}` }), l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [l.jsx("h4", { className: "font-medium text-sm truncate", children: v.title }), !v.isRead && l.jsx("div", { className: "w-2 h-2 bg-primary rounded-full flex-shrink-0" })] }), l.jsx("p", { className: "text-xs text-muted-foreground mb-2 whitespace-pre-wrap break-words line-clamp-3", children: v.message }), C && l.jsx("p", { className: "text-xs text-primary italic mb-2", children: "Click to view full message..." }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(ni, { className: "h-3 w-3 text-muted-foreground flex-shrink-0" }), l.jsx("span", { className: "text-xs text-muted-foreground", children: m(v.timestamp) })] }), !v.id.startsWith("client-") && l.jsx(vt, { variant: "ghost", size: "icon", className: "h-6 w-6 opacity-0 group-hover:opacity-100 hover:bg-destructive/10 hover:text-destructive transition-opacity flex-shrink-0", onClick: N => f(N, v.id), disabled: d.isPending, children: l.jsx(Bg, { className: "h-3 w-3" }) })] })] })] }) }, v.id)
							})
						})
					}), l.jsx("div", { className: "p-4 border-t border-border", children: l.jsx(on, { variant: "outline", className: "w-full", onClick: () => { e(!1), n(h()) }, children: "View all notifications" }) })]
				})]
			})
		})]
	})
} const $4e = { basePath: "/dashboard", sidebarItems: [{ name: "Dashboard", href: "/dashboard/trainee", icon: f5 }, { name: "Schedule Interview", href: "/dashboard/trainee/schedule", icon: li }, { name: "My Sessions", href: "/dashboard/trainee/sessions", icon: ff }, { name: "Speech Analysis", href: "/dashboard/trainee/speech-analysis", icon: VT }, { name: "Feedback", href: "/dashboard/trainee/feedback", icon: mA }, { name: "Settings", href: "/dashboard/trainee/settings", icon: h0 }] }, z4e = { basePath: "/interviewer", sidebarItems: [{ name: "Dashboard", href: "/dashboard/interviewer", icon: f5 }, { name: "Assigned Interviews", href: "/dashboard/interviewer/assigned", icon: li }, { name: "Availability Management", href: "/dashboard/interviewer/availability", icon: ni }, { name: "Question Bank", href: "/dashboard/interviewer/questions", icon: Kh }, { name: "Feedback Review", href: "/dashboard/interviewer/feedback", icon: ff }, { name: "Performance Stats", href: "/dashboard/interviewer/stats", icon: Ug }, { name: "Settings", href: "/dashboard/interviewer/settings", icon: h0 }] }, V4e = { basePath: "/admin", sidebarItems: [{ name: "Dashboard", href: "/dashboard/admin", icon: f5 }, { name: "Pending Interviewer Applications", href: "/dashboard/admin/pending-interviewers", icon: aye, requiredRoles: ["admin", "super_admin", "hr_admin"] }, { name: "Users Management", href: "/dashboard/admin/users", icon: qc, requiredRoles: ["admin", "super_admin", "hr_admin"] }, { name: "Interviews Management", href: "/dashboard/admin/interviews", icon: qve, requiredRoles: ["admin", "super_admin", "hr_admin"] }, { name: "Resources Management", href: "/dashboard/admin/resources", icon: TJ, requiredRoles: ["admin", "super_admin", "hr_admin"] }, { name: "Analytics", href: "/dashboard/admin/analytics", icon: v1, requiredRoles: ["admin", "super_admin", "hr_admin"] }, { name: "System Config", href: "/dashboard/admin/config", icon: zve, requiredRoles: ["admin", "super_admin", "hr_admin"] }] }, t1 = { async getPending() { return Yn.get(jn.interviewers.pending) }, async approve(t) { return Yn.put(jn.interviewers.approve(t), {}) }, async reject(t) { return Yn.put(jn.interviewers.reject(t), {}) } }; function H4e() { const { user: t } = La(), { addNotification: e } = OS(), n = S.useRef(0), r = S.useRef(null); S.useEffect(() => { if (!t || t.role !== "admin" && t.role !== "super_admin" || !e) return; const i = async () => { try { const o = (await t1.getPending()).count || 0; if (n.current > 0 && o > n.current) { const c = o - n.current; try { e({ title: "New Pending Interviewer Application" + (c > 1 ? "s" : ""), message: `${c} new interviewer application${c > 1 ? "s" : ""} ${c > 1 ? "have" : "has"} been submitted and is awaiting review.`, type: "info" }) } catch { } } n.current = o } catch { } }, a = setTimeout(() => { i() }, 1e3); return r.current = setInterval(i, 3e4), () => { clearTimeout(a), r.current && clearInterval(r.current) } }, [t, e]), S.useEffect(() => { if (!t || t.role !== "admin" && t.role !== "super_admin") return; const a = setTimeout(async () => { try { const s = await t1.getPending(); n.current = s.count || 0 } catch { n.current = 0 } }, 500); return () => clearTimeout(a) }, [t]) } function W4e() { return a$(), H4e(), null } function pk() { const t = fs(), e = ui(), { user: n, loading: r, logout: i } = La(); if (r) return l.jsx("div", { children: "Loading..." }); if (!n) return l.jsx(Ay, { to: "/login", replace: !0 }); const s = n.role === "super_admin" || n.role === "admin" || n.role === "hr_admin" ? V4e : n.role === "interviewer" ? z4e : $4e; return l.jsxs("div", { className: "min-h-screen bg-background", children: [l.jsx(W4e, {}), l.jsx("header", { className: "sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60", children: l.jsxs("div", { className: "container flex h-16 items-center justify-between px-4 sm:px-6", children: [l.jsxs(yi, { to: "/", className: "flex items-center space-x-2 group min-w-0", children: [l.jsx(Ia, { className: "h-5 w-5 sm:h-6 sm:w-6 text-primary transition-all duration-300 group-hover:rotate-12 flex-shrink-0" }), l.jsx("span", { className: "text-lg sm:text-xl font-bold gradient-text truncate", children: "MockRise" })] }), l.jsxs("div", { className: "flex items-center space-x-2 sm:space-x-4 flex-shrink-0", children: [l.jsx(uL, {}), l.jsx(B4e, {}), l.jsxs(e_, { children: [l.jsx(t_, { asChild: !0, children: l.jsx(vt, { variant: "ghost", className: "relative h-10 w-10 rounded-full", children: l.jsxs(Vc, { children: [l.jsx(xf, { src: `https://api.dicebear.com/7.x/avataaars/svg?seed=${n.name || n.email || "user"}` }), l.jsx(Hc, { children: n.name ? n.name.substring(0, 2).toUpperCase() : n.email ? n.email.substring(0, 2).toUpperCase() : "U" })] }) }) }), l.jsxs(T0, { align: "end", className: "w-56", children: [l.jsx(Yre, { children: l.jsxs("div", { className: "flex flex-col space-y-1", children: [l.jsx("p", { className: "text-sm font-medium", children: n.name || n.email || "User" }), l.jsx("p", { className: "text-xs text-muted-foreground", children: n.email || "No email" })] }) }), l.jsx(OL, {}), l.jsxs(Xs, { onClick: () => { n.role === "super_admin" || n.role === "admin" || n.role === "hr_admin" ? e("/dashboard/admin/profile") : n.role === "interviewer" ? e("/dashboard/interviewer/settings/profile") : e("/dashboard/trainee/settings/profile") }, children: [l.jsx(hf, { className: "mr-2 h-4 w-4" }), "Profile"] }), (n.role === "trainee" || n.role === "interviewer") && l.jsxs(Xs, { onClick: () => { const o = n.role === "interviewer" ? "interviewer" : "trainee"; e(`/dashboard/${o}/settings`) }, children: [l.jsx(h0, { className: "mr-2 h-4 w-4" }), "Settings"] }), l.jsx(OL, {}), l.jsxs(Xs, { className: "text-destructive", onClick: i, children: [l.jsx(CJ, { className: "mr-2 h-4 w-4" }), "Log out"] })] })] })] })] }) }), l.jsxs("div", { className: "flex", children: [l.jsx(U4e, { config: s, userRole: n.role }), l.jsx("main", { className: "flex-1 p-4 sm:p-6 lg:p-8 pb-20 lg:pb-8 max-w-full overflow-x-hidden", children: l.jsx(fve, {}) })] }), l.jsx("nav", { className: "lg:hidden fixed bottom-0 left-0 right-0 border-t border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 z-40", children: l.jsx("div", { className: "flex justify-around items-center p-2 gap-1", children: s.sidebarItems.slice(0, 4).map(o => { const c = t.pathname === o.href; return l.jsx(yi, { to: o.href, className: "flex-1", children: l.jsxs(vt, { variant: "ghost", size: "sm", className: _t("flex-col h-auto py-2 px-2 sm:px-3 w-full", c && "text-primary bg-primary/10"), children: [l.jsx(o.icon, { className: "h-4 w-4 sm:h-5 sm:w-5 mb-1" }), l.jsx("span", { className: "text-[10px] sm:text-xs truncate", children: o.name.split(" ")[0] })] }) }, o.name) }) }) })] }) } const s$ = { async getTraineeDashboard() { return Yn.get(jn.dashboard.trainee) }, async getInterviewerDashboard() { return Yn.get(jn.dashboard.interviewer) }, async getAdminDashboard() { return Yn.get(jn.dashboard.admin) } }; function On(t) { const e = Object.prototype.toString.call(t); return t instanceof Date || typeof t == "object" && e === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || e === "[object Number]" || typeof t == "string" || e === "[object String]" ? new Date(t) : new Date(NaN) } function co(t, e) { return t instanceof Date ? new t.constructor(e) : new Date(e) } function Es(t, e) { const n = On(t); return isNaN(e) ? co(t, NaN) : (e && n.setDate(n.getDate() + e), n) } function Wl(t, e) { const n = On(t); if (isNaN(e)) return co(t, NaN); if (!e) return n; const r = n.getDate(), i = co(t, n.getTime()); i.setMonth(n.getMonth() + e + 1, 0); const a = i.getDate(); return r >= a ? i : (n.setFullYear(i.getFullYear(), i.getMonth(), r), n) } const o$ = 6048e5, G4e = 864e5, zce = 6e4, Vce = 36e5, XM = 43200, B7 = 1440; let q4e = {}; function R0() { return q4e } function Hu(t, e) { const n = R0(), r = e?.weekStartsOn ?? e?.locale?.options?.weekStartsOn ?? n.weekStartsOn ?? n.locale?.options?.weekStartsOn ?? 0, i = On(t), a = i.getDay(), s = (a < r ? 7 : 0) + a - r; return i.setDate(i.getDate() - s), i.setHours(0, 0, 0, 0), i } function Pg(t) { return Hu(t, { weekStartsOn: 1 }) } function Hce(t) { const e = On(t), n = e.getFullYear(), r = co(t, 0); r.setFullYear(n + 1, 0, 4), r.setHours(0, 0, 0, 0); const i = Pg(r), a = co(t, 0); a.setFullYear(n, 0, 4), a.setHours(0, 0, 0, 0); const s = Pg(a); return e.getTime() >= i.getTime() ? n + 1 : e.getTime() >= s.getTime() ? n : n - 1 } function vi(t) { const e = On(t); return e.setHours(0, 0, 0, 0), e } function Px(t) { const e = On(t), n = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())); return n.setUTCFullYear(e.getFullYear()), +t - +n } function Su(t, e) { const n = vi(t), r = vi(e), i = +n - Px(n), a = +r - Px(r); return Math.round((i - a) / G4e) } function X4e(t) { const e = Hce(t), n = co(t, 0); return n.setFullYear(e, 0, 4), n.setHours(0, 0, 0, 0), Pg(n) } function p4(t, e) { const n = e * 7; return Es(t, n) } function m4(t, e) { return Wl(t, e * 12) } function Wce(t) { let e; return t.forEach(function (n) { const r = On(n); (e === void 0 || e < r || isNaN(Number(r))) && (e = r) }), e || new Date(NaN) } function Gce(t) { let e; return t.forEach(n => { const r = On(n); (!e || e > r || isNaN(+r)) && (e = r) }), e || new Date(NaN) } function IT(t, e) { const n = On(t), r = On(e), i = n.getTime() - r.getTime(); return i < 0 ? -1 : i > 0 ? 1 : i } function l$(t) { return co(t, Date.now()) } function $i(t, e) { const n = vi(t), r = vi(e); return +n == +r } function c$(t) { return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]" } function Y4e(t) { if (!c$(t) && typeof t != "number") return !1; const e = On(t); return !isNaN(Number(e)) } function jx(t, e) { const n = On(t), r = On(e), i = n.getFullYear() - r.getFullYear(), a = n.getMonth() - r.getMonth(); return i * 12 + a } function K4e(t, e, n) { const r = Hu(t, n), i = Hu(e, n), a = +r - Px(r), s = +i - Px(i); return Math.round((a - s) / o$) } function Z4e(t) { return e => { const r = (t ? Math[t] : Math.trunc)(e); return r === 0 ? 0 : r } } function Q4e(t, e) { return +On(t) - +On(e) } function J4e(t) { const e = On(t); return e.setHours(23, 59, 59, 999), e } function A2(t) { const e = On(t), n = e.getMonth(); return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(23, 59, 59, 999), e } function eFe(t) { const e = On(t); return +J4e(e) == +A2(e) } function tFe(t, e) { const n = On(t), r = On(e), i = IT(n, r), a = Math.abs(jx(n, r)); let s; if (a < 1) s = 0; else { n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30), n.setMonth(n.getMonth() - i * a); let o = IT(n, r) === -i; eFe(On(t)) && a === 1 && IT(t, r) === 1 && (o = !1), s = i * (a - Number(o)) } return s === 0 ? 0 : s } function nFe(t, e, n) { const r = Q4e(t, e) / 1e3; return Z4e(n?.roundingMethod)(r) } function ds(t) { const e = On(t); return e.setDate(1), e.setHours(0, 0, 0, 0), e } function u$(t) { const e = On(t), n = co(t, 0); return n.setFullYear(e.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n } function d$(t, e) { const n = R0(), r = e?.weekStartsOn ?? e?.locale?.options?.weekStartsOn ?? n.weekStartsOn ?? n.locale?.options?.weekStartsOn ?? 0, i = On(t), a = i.getDay(), s = (a < r ? -7 : 0) + 6 - (a - r); return i.setDate(i.getDate() + s), i.setHours(23, 59, 59, 999), i } function qce(t) { return d$(t, { weekStartsOn: 1 }) } const rFe = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, iFe = (t, e, n) => { let r; const i = rFe[t]; return typeof i == "string" ? r = i : e === 1 ? r = i.one : r = i.other.replace("{{count}}", e.toString()), n?.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r }; function mk(t) { return (e = {}) => { const n = e.width ? String(e.width) : t.defaultWidth; return t.formats[n] || t.formats[t.defaultWidth] } } const aFe = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, sFe = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, oFe = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, lFe = { date: mk({ formats: aFe, defaultWidth: "full" }), time: mk({ formats: sFe, defaultWidth: "full" }), dateTime: mk({ formats: oFe, defaultWidth: "full" }) }, cFe = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, uFe = (t, e, n, r) => cFe[t]; function hw(t) { return (e, n) => { const r = n?.context ? String(n.context) : "standalone"; let i; if (r === "formatting" && t.formattingValues) { const s = t.defaultFormattingWidth || t.defaultWidth, o = n?.width ? String(n.width) : s; i = t.formattingValues[o] || t.formattingValues[s] } else { const s = t.defaultWidth, o = n?.width ? String(n.width) : t.defaultWidth; i = t.values[o] || t.values[s] } const a = t.argumentCallback ? t.argumentCallback(e) : e; return i[a] } } const dFe = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, fFe = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, hFe = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, pFe = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, mFe = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, gFe = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, vFe = (t, e) => { const n = Number(t), r = n % 100; if (r > 20 || r < 10) switch (r % 10) { case 1: return n + "st"; case 2: return n + "nd"; case 3: return n + "rd" }return n + "th" }, yFe = { ordinalNumber: vFe, era: hw({ values: dFe, defaultWidth: "wide" }), quarter: hw({ values: fFe, defaultWidth: "wide", argumentCallback: t => t - 1 }), month: hw({ values: hFe, defaultWidth: "wide" }), day: hw({ values: pFe, defaultWidth: "wide" }), dayPeriod: hw({ values: mFe, defaultWidth: "wide", formattingValues: gFe, defaultFormattingWidth: "wide" }) }; function pw(t) { return (e, n = {}) => { const r = n.width, i = r && t.matchPatterns[r] || t.matchPatterns[t.defaultMatchWidth], a = e.match(i); if (!a) return null; const s = a[0], o = r && t.parsePatterns[r] || t.parsePatterns[t.defaultParseWidth], c = Array.isArray(o) ? bFe(o, f => f.test(s)) : xFe(o, f => f.test(s)); let u; u = t.valueCallback ? t.valueCallback(c) : c, u = n.valueCallback ? n.valueCallback(u) : u; const d = e.slice(s.length); return { value: u, rest: d } } } function xFe(t, e) { for (const n in t) if (Object.prototype.hasOwnProperty.call(t, n) && e(t[n])) return n } function bFe(t, e) { for (let n = 0; n < t.length; n++)if (e(t[n])) return n } function wFe(t) { return (e, n = {}) => { const r = e.match(t.matchPattern); if (!r) return null; const i = r[0], a = e.match(t.parsePattern); if (!a) return null; let s = t.valueCallback ? t.valueCallback(a[0]) : a[0]; s = n.valueCallback ? n.valueCallback(s) : s; const o = e.slice(i.length); return { value: s, rest: o } } } const SFe = /^(\d+)(th|st|nd|rd)?/i, _Fe = /\d+/i, EFe = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, MFe = { any: [/^b/i, /^(a|c)/i] }, TFe = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, CFe = { any: [/1/i, /2/i, /3/i, /4/i] }, NFe = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, AFe = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, PFe = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, jFe = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, RFe = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, kFe = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, IFe = { ordinalNumber: wFe({ matchPattern: SFe, parsePattern: _Fe, valueCallback: t => parseInt(t, 10) }), era: pw({ matchPatterns: EFe, defaultMatchWidth: "wide", parsePatterns: MFe, defaultParseWidth: "any" }), quarter: pw({ matchPatterns: TFe, defaultMatchWidth: "wide", parsePatterns: CFe, defaultParseWidth: "any", valueCallback: t => t + 1 }), month: pw({ matchPatterns: NFe, defaultMatchWidth: "wide", parsePatterns: AFe, defaultParseWidth: "any" }), day: pw({ matchPatterns: PFe, defaultMatchWidth: "wide", parsePatterns: jFe, defaultParseWidth: "any" }), dayPeriod: pw({ matchPatterns: RFe, defaultMatchWidth: "any", parsePatterns: kFe, defaultParseWidth: "any" }) }, b_ = { code: "en-US", formatDistance: iFe, formatLong: lFe, formatRelative: uFe, localize: yFe, match: IFe, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }; function OFe(t) { const e = On(t); return Su(e, u$(e)) + 1 } function Xce(t) { const e = On(t), n = +Pg(e) - +X4e(e); return Math.round(n / o$) + 1 } function Yce(t, e) { const n = On(t), r = n.getFullYear(), i = R0(), a = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? i.firstWeekContainsDate ?? i.locale?.options?.firstWeekContainsDate ?? 1, s = co(t, 0); s.setFullYear(r + 1, 0, a), s.setHours(0, 0, 0, 0); const o = Hu(s, e), c = co(t, 0); c.setFullYear(r, 0, a), c.setHours(0, 0, 0, 0); const u = Hu(c, e); return n.getTime() >= o.getTime() ? r + 1 : n.getTime() >= u.getTime() ? r : r - 1 } function DFe(t, e) { const n = R0(), r = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? n.firstWeekContainsDate ?? n.locale?.options?.firstWeekContainsDate ?? 1, i = Yce(t, e), a = co(t, 0); return a.setFullYear(i, 0, r), a.setHours(0, 0, 0, 0), Hu(a, e) } function Kce(t, e) { const n = On(t), r = +Hu(n, e) - +DFe(n, e); return Math.round(r / o$) + 1 } function Gr(t, e) { const n = t < 0 ? "-" : "", r = Math.abs(t).toString().padStart(e, "0"); return n + r } const Eh = { y(t, e) { const n = t.getFullYear(), r = n > 0 ? n : 1 - n; return Gr(e === "yy" ? r % 100 : r, e.length) }, M(t, e) { const n = t.getMonth(); return e === "M" ? String(n + 1) : Gr(n + 1, 2) }, d(t, e) { return Gr(t.getDate(), e.length) }, a(t, e) { const n = t.getHours() / 12 >= 1 ? "pm" : "am"; switch (e) { case "a": case "aa": return n.toUpperCase(); case "aaa": return n; case "aaaaa": return n[0]; case "aaaa": default: return n === "am" ? "a.m." : "p.m." } }, h(t, e) { return Gr(t.getHours() % 12 || 12, e.length) }, H(t, e) { return Gr(t.getHours(), e.length) }, m(t, e) { return Gr(t.getMinutes(), e.length) }, s(t, e) { return Gr(t.getSeconds(), e.length) }, S(t, e) { const n = e.length, r = t.getMilliseconds(), i = Math.trunc(r * Math.pow(10, n - 3)); return Gr(i, e.length) } }, Sy = { midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, $7 = { G: function (t, e, n) { const r = t.getFullYear() > 0 ? 1 : 0; switch (e) { case "G": case "GG": case "GGG": return n.era(r, { width: "abbreviated" }); case "GGGGG": return n.era(r, { width: "narrow" }); case "GGGG": default: return n.era(r, { width: "wide" }) } }, y: function (t, e, n) { if (e === "yo") { const r = t.getFullYear(), i = r > 0 ? r : 1 - r; return n.ordinalNumber(i, { unit: "year" }) } return Eh.y(t, e) }, Y: function (t, e, n, r) { const i = Yce(t, r), a = i > 0 ? i : 1 - i; if (e === "YY") { const s = a % 100; return Gr(s, 2) } return e === "Yo" ? n.ordinalNumber(a, { unit: "year" }) : Gr(a, e.length) }, R: function (t, e) { const n = Hce(t); return Gr(n, e.length) }, u: function (t, e) { const n = t.getFullYear(); return Gr(n, e.length) }, Q: function (t, e, n) { const r = Math.ceil((t.getMonth() + 1) / 3); switch (e) { case "Q": return String(r); case "QQ": return Gr(r, 2); case "Qo": return n.ordinalNumber(r, { unit: "quarter" }); case "QQQ": return n.quarter(r, { width: "abbreviated", context: "formatting" }); case "QQQQQ": return n.quarter(r, { width: "narrow", context: "formatting" }); case "QQQQ": default: return n.quarter(r, { width: "wide", context: "formatting" }) } }, q: function (t, e, n) { const r = Math.ceil((t.getMonth() + 1) / 3); switch (e) { case "q": return String(r); case "qq": return Gr(r, 2); case "qo": return n.ordinalNumber(r, { unit: "quarter" }); case "qqq": return n.quarter(r, { width: "abbreviated", context: "standalone" }); case "qqqqq": return n.quarter(r, { width: "narrow", context: "standalone" }); case "qqqq": default: return n.quarter(r, { width: "wide", context: "standalone" }) } }, M: function (t, e, n) { const r = t.getMonth(); switch (e) { case "M": case "MM": return Eh.M(t, e); case "Mo": return n.ordinalNumber(r + 1, { unit: "month" }); case "MMM": return n.month(r, { width: "abbreviated", context: "formatting" }); case "MMMMM": return n.month(r, { width: "narrow", context: "formatting" }); case "MMMM": default: return n.month(r, { width: "wide", context: "formatting" }) } }, L: function (t, e, n) { const r = t.getMonth(); switch (e) { case "L": return String(r + 1); case "LL": return Gr(r + 1, 2); case "Lo": return n.ordinalNumber(r + 1, { unit: "month" }); case "LLL": return n.month(r, { width: "abbreviated", context: "standalone" }); case "LLLLL": return n.month(r, { width: "narrow", context: "standalone" }); case "LLLL": default: return n.month(r, { width: "wide", context: "standalone" }) } }, w: function (t, e, n, r) { const i = Kce(t, r); return e === "wo" ? n.ordinalNumber(i, { unit: "week" }) : Gr(i, e.length) }, I: function (t, e, n) { const r = Xce(t); return e === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Gr(r, e.length) }, d: function (t, e, n) { return e === "do" ? n.ordinalNumber(t.getDate(), { unit: "date" }) : Eh.d(t, e) }, D: function (t, e, n) { const r = OFe(t); return e === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Gr(r, e.length) }, E: function (t, e, n) { const r = t.getDay(); switch (e) { case "E": case "EE": case "EEE": return n.day(r, { width: "abbreviated", context: "formatting" }); case "EEEEE": return n.day(r, { width: "narrow", context: "formatting" }); case "EEEEEE": return n.day(r, { width: "short", context: "formatting" }); case "EEEE": default: return n.day(r, { width: "wide", context: "formatting" }) } }, e: function (t, e, n, r) { const i = t.getDay(), a = (i - r.weekStartsOn + 8) % 7 || 7; switch (e) { case "e": return String(a); case "ee": return Gr(a, 2); case "eo": return n.ordinalNumber(a, { unit: "day" }); case "eee": return n.day(i, { width: "abbreviated", context: "formatting" }); case "eeeee": return n.day(i, { width: "narrow", context: "formatting" }); case "eeeeee": return n.day(i, { width: "short", context: "formatting" }); case "eeee": default: return n.day(i, { width: "wide", context: "formatting" }) } }, c: function (t, e, n, r) { const i = t.getDay(), a = (i - r.weekStartsOn + 8) % 7 || 7; switch (e) { case "c": return String(a); case "cc": return Gr(a, e.length); case "co": return n.ordinalNumber(a, { unit: "day" }); case "ccc": return n.day(i, { width: "abbreviated", context: "standalone" }); case "ccccc": return n.day(i, { width: "narrow", context: "standalone" }); case "cccccc": return n.day(i, { width: "short", context: "standalone" }); case "cccc": default: return n.day(i, { width: "wide", context: "standalone" }) } }, i: function (t, e, n) { const r = t.getDay(), i = r === 0 ? 7 : r; switch (e) { case "i": return String(i); case "ii": return Gr(i, e.length); case "io": return n.ordinalNumber(i, { unit: "day" }); case "iii": return n.day(r, { width: "abbreviated", context: "formatting" }); case "iiiii": return n.day(r, { width: "narrow", context: "formatting" }); case "iiiiii": return n.day(r, { width: "short", context: "formatting" }); case "iiii": default: return n.day(r, { width: "wide", context: "formatting" }) } }, a: function (t, e, n) { const i = t.getHours() / 12 >= 1 ? "pm" : "am"; switch (e) { case "a": case "aa": return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }); case "aaa": return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "aaaaa": return n.dayPeriod(i, { width: "narrow", context: "formatting" }); case "aaaa": default: return n.dayPeriod(i, { width: "wide", context: "formatting" }) } }, b: function (t, e, n) { const r = t.getHours(); let i; switch (r === 12 ? i = Sy.noon : r === 0 ? i = Sy.midnight : i = r / 12 >= 1 ? "pm" : "am", e) { case "b": case "bb": return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }); case "bbb": return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "bbbbb": return n.dayPeriod(i, { width: "narrow", context: "formatting" }); case "bbbb": default: return n.dayPeriod(i, { width: "wide", context: "formatting" }) } }, B: function (t, e, n) { const r = t.getHours(); let i; switch (r >= 17 ? i = Sy.evening : r >= 12 ? i = Sy.afternoon : r >= 4 ? i = Sy.morning : i = Sy.night, e) { case "B": case "BB": case "BBB": return n.dayPeriod(i, { width: "abbreviated", context: "formatting" }); case "BBBBB": return n.dayPeriod(i, { width: "narrow", context: "formatting" }); case "BBBB": default: return n.dayPeriod(i, { width: "wide", context: "formatting" }) } }, h: function (t, e, n) { if (e === "ho") { let r = t.getHours() % 12; return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" }) } return Eh.h(t, e) }, H: function (t, e, n) { return e === "Ho" ? n.ordinalNumber(t.getHours(), { unit: "hour" }) : Eh.H(t, e) }, K: function (t, e, n) { const r = t.getHours() % 12; return e === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Gr(r, e.length) }, k: function (t, e, n) { let r = t.getHours(); return r === 0 && (r = 24), e === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Gr(r, e.length) }, m: function (t, e, n) { return e === "mo" ? n.ordinalNumber(t.getMinutes(), { unit: "minute" }) : Eh.m(t, e) }, s: function (t, e, n) { return e === "so" ? n.ordinalNumber(t.getSeconds(), { unit: "second" }) : Eh.s(t, e) }, S: function (t, e) { return Eh.S(t, e) }, X: function (t, e, n) { const r = t.getTimezoneOffset(); if (r === 0) return "Z"; switch (e) { case "X": return V7(r); case "XXXX": case "XX": return $m(r); case "XXXXX": case "XXX": default: return $m(r, ":") } }, x: function (t, e, n) { const r = t.getTimezoneOffset(); switch (e) { case "x": return V7(r); case "xxxx": case "xx": return $m(r); case "xxxxx": case "xxx": default: return $m(r, ":") } }, O: function (t, e, n) { const r = t.getTimezoneOffset(); switch (e) { case "O": case "OO": case "OOO": return "GMT" + z7(r, ":"); case "OOOO": default: return "GMT" + $m(r, ":") } }, z: function (t, e, n) { const r = t.getTimezoneOffset(); switch (e) { case "z": case "zz": case "zzz": return "GMT" + z7(r, ":"); case "zzzz": default: return "GMT" + $m(r, ":") } }, t: function (t, e, n) { const r = Math.trunc(t.getTime() / 1e3); return Gr(r, e.length) }, T: function (t, e, n) { const r = t.getTime(); return Gr(r, e.length) } }; function z7(t, e = "") { const n = t > 0 ? "-" : "+", r = Math.abs(t), i = Math.trunc(r / 60), a = r % 60; return a === 0 ? n + String(i) : n + String(i) + e + Gr(a, 2) } function V7(t, e) { return t % 60 === 0 ? (t > 0 ? "-" : "+") + Gr(Math.abs(t) / 60, 2) : $m(t, e) } function $m(t, e = "") { const n = t > 0 ? "-" : "+", r = Math.abs(t), i = Gr(Math.trunc(r / 60), 2), a = Gr(r % 60, 2); return n + i + e + a } const H7 = (t, e) => { switch (t) { case "P": return e.date({ width: "short" }); case "PP": return e.date({ width: "medium" }); case "PPP": return e.date({ width: "long" }); case "PPPP": default: return e.date({ width: "full" }) } }, Zce = (t, e) => { switch (t) { case "p": return e.time({ width: "short" }); case "pp": return e.time({ width: "medium" }); case "ppp": return e.time({ width: "long" }); case "pppp": default: return e.time({ width: "full" }) } }, LFe = (t, e) => { const n = t.match(/(P+)(p+)?/) || [], r = n[1], i = n[2]; if (!i) return H7(t, e); let a; switch (r) { case "P": a = e.dateTime({ width: "short" }); break; case "PP": a = e.dateTime({ width: "medium" }); break; case "PPP": a = e.dateTime({ width: "long" }); break; case "PPPP": default: a = e.dateTime({ width: "full" }); break }return a.replace("{{date}}", H7(r, e)).replace("{{time}}", Zce(i, e)) }, FFe = { p: Zce, P: LFe }, UFe = /^D+$/, BFe = /^Y+$/, $Fe = ["D", "DD", "YY", "YYYY"]; function zFe(t) { return UFe.test(t) } function VFe(t) { return BFe.test(t) } function HFe(t, e, n) { const r = WFe(t, e, n); if (console.warn(r), $Fe.includes(t)) throw new RangeError(r) } function WFe(t, e, n) { const r = t[0] === "Y" ? "years" : "days of the month"; return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${e}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md` } const GFe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, qFe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, XFe = /^'([^]*?)'?$/, YFe = /''/g, KFe = /[a-zA-Z]/; function xr(t, e, n) { const r = R0(), i = n?.locale ?? r.locale ?? b_, a = n?.firstWeekContainsDate ?? n?.locale?.options?.firstWeekContainsDate ?? r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1, s = n?.weekStartsOn ?? n?.locale?.options?.weekStartsOn ?? r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0, o = On(t); if (!Y4e(o)) throw new RangeError("Invalid time value"); let c = e.match(qFe).map(d => { const f = d[0]; if (f === "p" || f === "P") { const h = FFe[f]; return h(d, i.formatLong) } return d }).join("").match(GFe).map(d => { if (d === "''") return { isToken: !1, value: "'" }; const f = d[0]; if (f === "'") return { isToken: !1, value: ZFe(d) }; if ($7[f]) return { isToken: !0, value: d }; if (f.match(KFe)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + f + "`"); return { isToken: !1, value: d } }); i.localize.preprocessor && (c = i.localize.preprocessor(o, c)); const u = { firstWeekContainsDate: a, weekStartsOn: s, locale: i }; return c.map(d => { if (!d.isToken) return d.value; const f = d.value; (!n?.useAdditionalWeekYearTokens && VFe(f) || !n?.useAdditionalDayOfYearTokens && zFe(f)) && HFe(f, e, String(t)); const h = $7[f[0]]; return h(o, f, i.localize, u) }).join("") } function ZFe(t) { const e = t.match(XFe); return e ? e[1].replace(YFe, "'") : t } function QFe(t, e, n) { const r = R0(), i = n?.locale ?? r.locale ?? b_, a = 2520, s = IT(t, e); if (isNaN(s)) throw new RangeError("Invalid time value"); const o = Object.assign({}, n, { addSuffix: n?.addSuffix, comparison: s }); let c, u; s > 0 ? (c = On(e), u = On(t)) : (c = On(t), u = On(e)); const d = nFe(u, c), f = (Px(u) - Px(c)) / 1e3, h = Math.round((d - f) / 60); let m; if (h < 2) return n?.includeSeconds ? d < 5 ? i.formatDistance("lessThanXSeconds", 5, o) : d < 10 ? i.formatDistance("lessThanXSeconds", 10, o) : d < 20 ? i.formatDistance("lessThanXSeconds", 20, o) : d < 40 ? i.formatDistance("halfAMinute", 0, o) : d < 60 ? i.formatDistance("lessThanXMinutes", 1, o) : i.formatDistance("xMinutes", 1, o) : h === 0 ? i.formatDistance("lessThanXMinutes", 1, o) : i.formatDistance("xMinutes", h, o); if (h < 45) return i.formatDistance("xMinutes", h, o); if (h < 90) return i.formatDistance("aboutXHours", 1, o); if (h < B7) { const g = Math.round(h / 60); return i.formatDistance("aboutXHours", g, o) } else { if (h < a) return i.formatDistance("xDays", 1, o); if (h < XM) { const g = Math.round(h / B7); return i.formatDistance("xDays", g, o) } else if (h < XM * 2) return m = Math.round(h / XM), i.formatDistance("aboutXMonths", m, o) } if (m = tFe(u, c), m < 12) { const g = Math.round(h / XM); return i.formatDistance("xMonths", g, o) } else { const g = m % 12, x = Math.trunc(m / 12); return g < 3 ? i.formatDistance("aboutXYears", x, o) : g < 9 ? i.formatDistance("overXYears", x, o) : i.formatDistance("almostXYears", x + 1, o) } } function JFe(t, e) { return QFe(t, l$(t), e) } function e5e(t) { const e = On(t), n = e.getFullYear(), r = e.getMonth(), i = co(t, 0); return i.setFullYear(n, r + 1, 0), i.setHours(0, 0, 0, 0), i.getDate() } function t5e(t) { return Math.trunc(+On(t) / 1e3) } function n5e(t) { const e = On(t), n = e.getMonth(); return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(0, 0, 0, 0), e } function r5e(t, e) { return K4e(n5e(t), ds(t), e) + 1 } function g4(t, e) { const n = On(t), r = On(e); return n.getTime() > r.getTime() } function tf(t, e) { const n = On(t), r = On(e); return +n < +r } function i5e(t, e) { const n = On(t), r = On(e); return +n == +r } function Rx(t) { return +On(t) < Date.now() } function f$(t, e) { const n = On(t), r = On(e); return n.getFullYear() === r.getFullYear() && n.getMonth() === r.getMonth() } function a5e(t, e) { const n = On(t), r = On(e); return n.getFullYear() === r.getFullYear() } function k0(t) { return $i(t, l$(t)) } function w_(t) { return $i(t, Es(l$(t), 1)) } function OT(t, e) { return Es(t, -e) } function ao(t, e) { const r = c5e(t); let i; if (r.date) { const c = u5e(r.date, 2); i = d5e(c.restDateString, c.year) } if (!i || isNaN(i.getTime())) return new Date(NaN); const a = i.getTime(); let s = 0, o; if (r.time && (s = f5e(r.time), isNaN(s))) return new Date(NaN); if (r.timezone) { if (o = h5e(r.timezone), isNaN(o)) return new Date(NaN) } else { const c = new Date(a + s), u = new Date(0); return u.setFullYear(c.getUTCFullYear(), c.getUTCMonth(), c.getUTCDate()), u.setHours(c.getUTCHours(), c.getUTCMinutes(), c.getUTCSeconds(), c.getUTCMilliseconds()), u } return new Date(a + s + o) } const YM = { dateTimeDelimiter: /[T ]/, timeZoneDelimiter: /[Z ]/i, timezone: /([Z+-].*)$/ }, s5e = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, o5e = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, l5e = /^([+-])(\d{2})(?::?(\d{2}))?$/; function c5e(t) { const e = {}, n = t.split(YM.dateTimeDelimiter); let r; if (n.length > 2) return e; if (/:/.test(n[0]) ? r = n[0] : (e.date = n[0], r = n[1], YM.timeZoneDelimiter.test(e.date) && (e.date = t.split(YM.timeZoneDelimiter)[0], r = t.substr(e.date.length, t.length))), r) { const i = YM.timezone.exec(r); i ? (e.time = r.replace(i[1], ""), e.timezone = i[1]) : e.time = r } return e } function u5e(t, e) { const n = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)"), r = t.match(n); if (!r) return { year: NaN, restDateString: "" }; const i = r[1] ? parseInt(r[1]) : null, a = r[2] ? parseInt(r[2]) : null; return { year: a === null ? i : a * 100, restDateString: t.slice((r[1] || r[2]).length) } } function d5e(t, e) { if (e === null) return new Date(NaN); const n = t.match(s5e); if (!n) return new Date(NaN); const r = !!n[4], i = mw(n[1]), a = mw(n[2]) - 1, s = mw(n[3]), o = mw(n[4]), c = mw(n[5]) - 1; if (r) return y5e(e, o, c) ? p5e(e, o, c) : new Date(NaN); { const u = new Date(0); return !g5e(e, a, s) || !v5e(e, i) ? new Date(NaN) : (u.setUTCFullYear(e, a, Math.max(i, s)), u) } } function mw(t) { return t ? parseInt(t) : 1 } function f5e(t) { const e = t.match(o5e); if (!e) return NaN; const n = gk(e[1]), r = gk(e[2]), i = gk(e[3]); return x5e(n, r, i) ? n * Vce + r * zce + i * 1e3 : NaN } function gk(t) { return t && parseFloat(t.replace(",", ".")) || 0 } function h5e(t) { if (t === "Z") return 0; const e = t.match(l5e); if (!e) return 0; const n = e[1] === "+" ? -1 : 1, r = parseInt(e[2]), i = e[3] && parseInt(e[3]) || 0; return b5e(r, i) ? n * (r * Vce + i * zce) : NaN } function p5e(t, e, n) { const r = new Date(0); r.setUTCFullYear(t, 0, 4); const i = r.getUTCDay() || 7, a = (e - 1) * 7 + n + 1 - i; return r.setUTCDate(r.getUTCDate() + a), r } const m5e = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function Qce(t) { return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0 } function g5e(t, e, n) { return e >= 0 && e <= 11 && n >= 1 && n <= (m5e[e] || (Qce(t) ? 29 : 28)) } function v5e(t, e) { return e >= 1 && e <= (Qce(t) ? 366 : 365) } function y5e(t, e, n) { return e >= 1 && e <= 53 && n >= 0 && n <= 6 } function x5e(t, e, n) { return t === 24 ? e === 0 && n === 0 : n >= 0 && n < 60 && e >= 0 && e < 60 && t >= 0 && t < 25 } function b5e(t, e) { return e >= 0 && e <= 59 } function vk(t, e) { const n = On(t), r = n.getFullYear(), i = n.getDate(), a = co(t, 0); a.setFullYear(r, e, 15), a.setHours(0, 0, 0, 0); const s = e5e(a); return n.setMonth(e, Math.min(i, s)), n } function W7(t, e) { const n = On(t); return isNaN(+n) ? co(t, NaN) : (n.setFullYear(e), n) } function Rh() { return vi(Date.now()) } function w5e(t, e) { return Wl(t, -e) } function G7(t, e) { const { years: n = 0, months: r = 0, weeks: i = 0, days: a = 0, hours: s = 0, minutes: o = 0, seconds: c = 0 } = e, u = w5e(t, r + n * 12), d = OT(u, a + i * 7), f = o + s * 60, m = (c + f * 60) * 1e3; return co(t, d.getTime() - m) } function Ks({ className: t, ...e }) { return l.jsx("div", { className: _t("animate-pulse rounded-md bg-muted", t), ...e }) } const S5e = t => { switch (t) { case "ai": return ro; case "peer": return qc; case "family": return US; case "live": return Fo; default: return ro } }, _5e = t => { switch (t) { case "ai": return "AI-Powered Interview"; case "peer": return "Peer-to-Peer"; case "family": return "Family & Friends"; case "live": return "Live Mock Interview"; default: return "Interview" } }, E5e = t => { if (!t) return "Date TBD"; try { const e = ao(t); return k0(e) ? "Today" : w_(e) ? "Tomorrow" : xr(e, "EEE, MMM d") } catch { return "Date TBD" } }; function M5e() { const t = ui(), { user: e } = La(), { data: n, isLoading: r, error: i } = oo({ queryKey: ["traineeDashboard"], queryFn: () => s$.getTraineeDashboard(), staleTime: 3e4 }), a = n?.data?.stats, s = n?.data?.upcomingSessions || []; if (r) return l.jsxs("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx(Ks, { className: "h-9 w-64 mb-2" }), l.jsx(Ks, { className: "h-5 w-96" })] }), l.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6", children: [1, 2, 3, 4].map(u => l.jsxs(Lt, { className: "p-6", children: [l.jsx(Ks, { className: "h-5 w-24 mb-4" }), l.jsx(Ks, { className: "h-8 w-20 mb-2" }), l.jsx(Ks, { className: "h-4 w-32" })] }, u)) })] }); if (i) return l.jsx("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: l.jsx("div", { className: "flex items-center justify-center h-64", children: l.jsxs("div", { className: "text-center", children: [l.jsx(ji, { className: "h-12 w-12 text-destructive mx-auto mb-4" }), l.jsx("p", { className: "text-lg font-semibold mb-2", children: "Failed to load dashboard" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "Please try refreshing the page" }), l.jsx(vt, { onClick: () => window.location.reload(), children: "Refresh" })] }) }) }); const o = e?.name || "Trainee", c = s.length; return l.jsxs("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsxs("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: ["Welcome back, ", o, "! "] }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: c > 0 ? `You have ${c} upcoming session${c > 1 ? "s" : ""} this week.` : "Ready to practice? Schedule your next interview session." })] }), l.jsxs("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6", children: [l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: .1 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(li, { className: "h-6 w-6 sm:h-8 sm:w-8 text-primary" }), l.jsx("div", { className: "text-right", children: l.jsx("div", { className: "text-2xl sm:text-3xl font-bold", children: a?.totalInterviews || 0 }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Total Interviews" }), l.jsxs("p", { className: "text-xs text-muted-foreground", children: [a?.completedSessions || 0, " completed"] })] })] }) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: .2 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(ni, { className: "h-6 w-6 sm:h-8 sm:w-8 text-accent" }), l.jsx("div", { className: "text-right", children: l.jsx("div", { className: "text-2xl sm:text-3xl font-bold", children: a?.upcomingCount || 0 }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Upcoming Sessions" }), l.jsx("p", { className: "text-xs text-muted-foreground", children: "Scheduled interviews" })] })] }) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: .3 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(oi, { className: "h-6 w-6 sm:h-8 sm:w-8 text-success" }), l.jsx("div", { className: "text-right", children: l.jsx("div", { className: "text-2xl sm:text-3xl font-bold", children: a?.completedThisMonth || 0 }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "This Month" }), l.jsx("p", { className: "text-xs text-muted-foreground", children: "Completed interviews" })] })] }) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: .4 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(Fu, { className: "h-6 w-6 sm:h-8 sm:w-8 text-warning" }), l.jsx("div", { className: "text-right", children: l.jsxs("div", { className: "text-2xl sm:text-3xl font-bold", children: [a?.completionRate || 0, "%"] }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Completion Rate" }), l.jsxs("p", { className: "text-xs text-muted-foreground", children: [a?.completedSessions || 0, " completed sessions"] })] })] }) })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .2 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4 sm:mb-6", children: [l.jsx("h2", { className: "text-lg sm:text-xl font-semibold", children: "Upcoming Sessions" }), l.jsxs(vt, { variant: "ghost", size: "sm", onClick: () => t(cr.TRAINEE_SESSIONS), className: "text-xs sm:text-sm", children: ["View All", l.jsx(o5, { className: "ml-2 h-3 w-3 sm:h-4 sm:w-4" })] })] }), l.jsx("div", { className: "space-y-3 sm:space-y-4", children: s.length > 0 ? s.map((u, d) => { const f = S5e(u.mode), h = _5e(u.mode); return l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .4, delay: d * .1 }, className: "p-3 sm:p-4 rounded-lg border border-border hover:border-primary transition-colors cursor-pointer", onClick: () => t(`${cr.TRAINEE_SESSIONS}/${u._id}`), children: [l.jsxs("div", { className: "flex items-start justify-between mb-2", children: [l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [l.jsx(f, { className: "h-4 w-4 sm:h-5 sm:w-5 text-primary flex-shrink-0" }), l.jsx("h3", { className: "text-sm sm:text-base font-semibold truncate", children: h })] }), l.jsxs("p", { className: "text-xs sm:text-sm text-muted-foreground", children: [E5e(u.scheduledDate), " at ", u.timeSlot] })] }), l.jsx(oi, { className: "h-4 w-4 sm:h-5 sm:w-5 text-accent flex-shrink-0" })] }), l.jsxs("div", { className: "flex items-center gap-2 sm:gap-4 text-xs text-muted-foreground flex-wrap", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-3 w-3" }), u.duration, " min"] }), u.difficulty && l.jsx(Jt, { variant: "outline", className: "text-xs", children: u.difficulty }), u.language && l.jsx(Jt, { variant: "secondary", className: "text-xs", children: u.language }), u.interviewer && l.jsxs("span", { className: "text-xs", children: ["with ", u.interviewer.name] })] })] }, u._id) }) : l.jsxs("div", { className: "text-center py-8 sm:py-12", children: [l.jsx(li, { className: "h-12 w-12 sm:h-16 sm:w-16 text-muted-foreground mx-auto mb-4" }), l.jsx("p", { className: "text-sm sm:text-base font-medium mb-2", children: "No upcoming sessions" }), l.jsx("p", { className: "text-xs sm:text-sm text-muted-foreground mb-4", children: "Schedule your first interview session to get started" }), l.jsx(vt, { onClick: () => t(cr.TRAINEE_SCHEDULE), children: "Schedule Interview" })] }) })] }) })] }) } var Ln = function () { return Ln = Object.assign || function (e) { for (var n, r = 1, i = arguments.length; r < i; r++) { n = arguments[r]; for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]) } return e }, Ln.apply(this, arguments) }; function T5e(t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n } function Jce(t, e, n) { for (var r = 0, i = e.length, a; r < i; r++)(a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), a[r] = e[r]); return t.concat(a || Array.prototype.slice.call(e)) } function S_(t) { return t.mode === "multiple" } function __(t) { return t.mode === "range" } function P2(t) { return t.mode === "single" } var C5e = { root: "rdp", multiple_months: "rdp-multiple_months", with_weeknumber: "rdp-with_weeknumber", vhidden: "rdp-vhidden", button_reset: "rdp-button_reset", button: "rdp-button", caption: "rdp-caption", caption_start: "rdp-caption_start", caption_end: "rdp-caption_end", caption_between: "rdp-caption_between", caption_label: "rdp-caption_label", caption_dropdowns: "rdp-caption_dropdowns", dropdown: "rdp-dropdown", dropdown_month: "rdp-dropdown_month", dropdown_year: "rdp-dropdown_year", dropdown_icon: "rdp-dropdown_icon", months: "rdp-months", month: "rdp-month", table: "rdp-table", tbody: "rdp-tbody", tfoot: "rdp-tfoot", head: "rdp-head", head_row: "rdp-head_row", head_cell: "rdp-head_cell", nav: "rdp-nav", nav_button: "rdp-nav_button", nav_button_previous: "rdp-nav_button_previous", nav_button_next: "rdp-nav_button_next", nav_icon: "rdp-nav_icon", row: "rdp-row", weeknumber: "rdp-weeknumber", cell: "rdp-cell", day: "rdp-day", day_today: "rdp-day_today", day_outside: "rdp-day_outside", day_selected: "rdp-day_selected", day_disabled: "rdp-day_disabled", day_hidden: "rdp-day_hidden", day_range_start: "rdp-day_range_start", day_range_end: "rdp-day_range_end", day_range_middle: "rdp-day_range_middle" }; function N5e(t, e) { return xr(t, "LLLL y", e) } function A5e(t, e) { return xr(t, "d", e) } function P5e(t, e) { return xr(t, "LLLL", e) } function j5e(t) { return "".concat(t) } function R5e(t, e) { return xr(t, "cccccc", e) } function k5e(t, e) { return xr(t, "yyyy", e) } var I5e = Object.freeze({ __proto__: null, formatCaption: N5e, formatDay: A5e, formatMonthCaption: P5e, formatWeekNumber: j5e, formatWeekdayName: R5e, formatYearCaption: k5e }), O5e = function (t, e, n) { return xr(t, "do MMMM (EEEE)", n) }, D5e = function () { return "Month: " }, L5e = function () { return "Go to next month" }, F5e = function () { return "Go to previous month" }, U5e = function (t, e) { return xr(t, "cccc", e) }, B5e = function (t) { return "Week n. ".concat(t) }, $5e = function () { return "Year: " }, z5e = Object.freeze({ __proto__: null, labelDay: O5e, labelMonthDropdown: D5e, labelNext: L5e, labelPrevious: F5e, labelWeekNumber: B5e, labelWeekday: U5e, labelYearDropdown: $5e }); function V5e() { var t = "buttons", e = C5e, n = b_, r = {}, i = {}, a = 1, s = {}, o = new Date; return { captionLayout: t, classNames: e, formatters: I5e, labels: z5e, locale: n, modifiersClassNames: r, modifiers: i, numberOfMonths: a, styles: s, today: o, mode: "default" } } function H5e(t) { var e = t.fromYear, n = t.toYear, r = t.fromMonth, i = t.toMonth, a = t.fromDate, s = t.toDate; return r ? a = ds(r) : e && (a = new Date(e, 0, 1)), i ? s = A2(i) : n && (s = new Date(n, 11, 31)), { fromDate: a ? vi(a) : void 0, toDate: s ? vi(s) : void 0 } } var eue = S.createContext(void 0); function W5e(t) { var e, n = t.initialProps, r = V5e(), i = H5e(n), a = i.fromDate, s = i.toDate, o = (e = n.captionLayout) !== null && e !== void 0 ? e : r.captionLayout; o !== "buttons" && (!a || !s) && (o = "buttons"); var c; (P2(n) || S_(n) || __(n)) && (c = n.onSelect); var u = Ln(Ln(Ln({}, r), n), { captionLayout: o, classNames: Ln(Ln({}, r.classNames), n.classNames), components: Ln({}, n.components), formatters: Ln(Ln({}, r.formatters), n.formatters), fromDate: a, labels: Ln(Ln({}, r.labels), n.labels), mode: n.mode || r.mode, modifiers: Ln(Ln({}, r.modifiers), n.modifiers), modifiersClassNames: Ln(Ln({}, r.modifiersClassNames), n.modifiersClassNames), onSelect: c, styles: Ln(Ln({}, r.styles), n.styles), toDate: s }); return l.jsx(eue.Provider, { value: u, children: t.children }) } function wi() { var t = S.useContext(eue); if (!t) throw new Error("useDayPicker must be used within a DayPickerProvider."); return t } function tue(t) { var e = wi(), n = e.locale, r = e.classNames, i = e.styles, a = e.formatters.formatCaption; return l.jsx("div", { className: r.caption_label, style: i.caption_label, "aria-live": "polite", role: "presentation", id: t.id, children: a(t.displayMonth, { locale: n }) }) } function G5e(t) { return l.jsx("svg", Ln({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, t, { children: l.jsx("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" }) })) } function nue(t) { var e, n, r = t.onChange, i = t.value, a = t.children, s = t.caption, o = t.className, c = t.style, u = wi(), d = (n = (e = u.components) === null || e === void 0 ? void 0 : e.IconDropdown) !== null && n !== void 0 ? n : G5e; return l.jsxs("div", { className: o, style: c, children: [l.jsx("span", { className: u.classNames.vhidden, children: t["aria-label"] }), l.jsx("select", { name: t.name, "aria-label": t["aria-label"], className: u.classNames.dropdown, style: u.styles.dropdown, value: i, onChange: r, children: a }), l.jsxs("div", { className: u.classNames.caption_label, style: u.styles.caption_label, "aria-hidden": "true", children: [s, l.jsx(d, { className: u.classNames.dropdown_icon, style: u.styles.dropdown_icon })] })] }) } function q5e(t) { var e, n = wi(), r = n.fromDate, i = n.toDate, a = n.styles, s = n.locale, o = n.formatters.formatMonthCaption, c = n.classNames, u = n.components, d = n.labels.labelMonthDropdown; if (!r) return l.jsx(l.Fragment, {}); if (!i) return l.jsx(l.Fragment, {}); var f = []; if (a5e(r, i)) for (var h = ds(r), m = r.getMonth(); m <= i.getMonth(); m++)f.push(vk(h, m)); else for (var h = ds(new Date), m = 0; m <= 11; m++)f.push(vk(h, m)); var g = function (v) { var b = Number(v.target.value), E = vk(ds(t.displayMonth), b); t.onChange(E) }, x = (e = u?.Dropdown) !== null && e !== void 0 ? e : nue; return l.jsx(x, { name: "months", "aria-label": d(), className: c.dropdown_month, style: a.dropdown_month, onChange: g, value: t.displayMonth.getMonth(), caption: o(t.displayMonth, { locale: s }), children: f.map(function (v) { return l.jsx("option", { value: v.getMonth(), children: o(v, { locale: s }) }, v.getMonth()) }) }) } function X5e(t) { var e, n = t.displayMonth, r = wi(), i = r.fromDate, a = r.toDate, s = r.locale, o = r.styles, c = r.classNames, u = r.components, d = r.formatters.formatYearCaption, f = r.labels.labelYearDropdown, h = []; if (!i) return l.jsx(l.Fragment, {}); if (!a) return l.jsx(l.Fragment, {}); for (var m = i.getFullYear(), g = a.getFullYear(), x = m; x <= g; x++)h.push(W7(u$(new Date), x)); var v = function (E) { var M = W7(ds(n), Number(E.target.value)); t.onChange(M) }, b = (e = u?.Dropdown) !== null && e !== void 0 ? e : nue; return l.jsx(b, { name: "years", "aria-label": f(), className: c.dropdown_year, style: o.dropdown_year, onChange: v, value: n.getFullYear(), caption: d(n, { locale: s }), children: h.map(function (E) { return l.jsx("option", { value: E.getFullYear(), children: d(E, { locale: s }) }, E.getFullYear()) }) }) } function Y5e(t, e) { var n = S.useState(t), r = n[0], i = n[1], a = e === void 0 ? r : e; return [a, i] } function K5e(t) { var e = t.month, n = t.defaultMonth, r = t.today, i = e || n || r || new Date, a = t.toDate, s = t.fromDate, o = t.numberOfMonths, c = o === void 0 ? 1 : o; if (a && jx(a, i) < 0) { var u = -1 * (c - 1); i = Wl(a, u) } return s && jx(i, s) < 0 && (i = s), ds(i) } function Z5e() { var t = wi(), e = K5e(t), n = Y5e(e, t.month), r = n[0], i = n[1], a = function (s) { var o; if (!t.disableNavigation) { var c = ds(s); i(c), (o = t.onMonthChange) === null || o === void 0 || o.call(t, c) } }; return [r, a] } function Q5e(t, e) { for (var n = e.reverseMonths, r = e.numberOfMonths, i = ds(t), a = ds(Wl(i, r)), s = jx(a, i), o = [], c = 0; c < s; c++) { var u = Wl(i, c); o.push(u) } return n && (o = o.reverse()), o } function J5e(t, e) { if (!e.disableNavigation) { var n = e.toDate, r = e.pagedNavigation, i = e.numberOfMonths, a = i === void 0 ? 1 : i, s = r ? a : 1, o = ds(t); if (!n) return Wl(o, s); var c = jx(n, t); if (!(c < a)) return Wl(o, s) } } function eUe(t, e) { if (!e.disableNavigation) { var n = e.fromDate, r = e.pagedNavigation, i = e.numberOfMonths, a = i === void 0 ? 1 : i, s = r ? a : 1, o = ds(t); if (!n) return Wl(o, -s); var c = jx(o, n); if (!(c <= 0)) return Wl(o, -s) } } var rue = S.createContext(void 0); function tUe(t) { var e = wi(), n = Z5e(), r = n[0], i = n[1], a = Q5e(r, e), s = J5e(r, e), o = eUe(r, e), c = function (f) { return a.some(function (h) { return f$(f, h) }) }, u = function (f, h) { c(f) || (h && tf(f, h) ? i(Wl(f, 1 + e.numberOfMonths * -1)) : i(f)) }, d = { currentMonth: r, displayMonths: a, goToMonth: i, goToDate: u, previousMonth: o, nextMonth: s, isDateDisplayed: c }; return l.jsx(rue.Provider, { value: d, children: t.children }) } function I0() { var t = S.useContext(rue); if (!t) throw new Error("useNavigation must be used within a NavigationProvider"); return t } function q7(t) { var e, n = wi(), r = n.classNames, i = n.styles, a = n.components, s = I0().goToMonth, o = function (d) { s(Wl(d, t.displayIndex ? -t.displayIndex : 0)) }, c = (e = a?.CaptionLabel) !== null && e !== void 0 ? e : tue, u = l.jsx(c, { id: t.id, displayMonth: t.displayMonth }); return l.jsxs("div", { className: r.caption_dropdowns, style: i.caption_dropdowns, children: [l.jsx("div", { className: r.vhidden, children: u }), l.jsx(q5e, { onChange: o, displayMonth: t.displayMonth }), l.jsx(X5e, { onChange: o, displayMonth: t.displayMonth })] }) } function nUe(t) { return l.jsx("svg", Ln({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, t, { children: l.jsx("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" }) })) } function rUe(t) { return l.jsx("svg", Ln({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, t, { children: l.jsx("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" }) })) } var JC = S.forwardRef(function (t, e) { var n = wi(), r = n.classNames, i = n.styles, a = [r.button_reset, r.button]; t.className && a.push(t.className); var s = a.join(" "), o = Ln(Ln({}, i.button_reset), i.button); return t.style && Object.assign(o, t.style), l.jsx("button", Ln({}, t, { ref: e, type: "button", className: s, style: o })) }); function iUe(t) { var e, n, r = wi(), i = r.dir, a = r.locale, s = r.classNames, o = r.styles, c = r.labels, u = c.labelPrevious, d = c.labelNext, f = r.components; if (!t.nextMonth && !t.previousMonth) return l.jsx(l.Fragment, {}); var h = u(t.previousMonth, { locale: a }), m = [s.nav_button, s.nav_button_previous].join(" "), g = d(t.nextMonth, { locale: a }), x = [s.nav_button, s.nav_button_next].join(" "), v = (e = f?.IconRight) !== null && e !== void 0 ? e : rUe, b = (n = f?.IconLeft) !== null && n !== void 0 ? n : nUe; return l.jsxs("div", { className: s.nav, style: o.nav, children: [!t.hidePrevious && l.jsx(JC, { name: "previous-month", "aria-label": h, className: m, style: o.nav_button_previous, disabled: !t.previousMonth, onClick: t.onPreviousClick, children: i === "rtl" ? l.jsx(v, { className: s.nav_icon, style: o.nav_icon }) : l.jsx(b, { className: s.nav_icon, style: o.nav_icon }) }), !t.hideNext && l.jsx(JC, { name: "next-month", "aria-label": g, className: x, style: o.nav_button_next, disabled: !t.nextMonth, onClick: t.onNextClick, children: i === "rtl" ? l.jsx(b, { className: s.nav_icon, style: o.nav_icon }) : l.jsx(v, { className: s.nav_icon, style: o.nav_icon }) })] }) } function X7(t) { var e = wi().numberOfMonths, n = I0(), r = n.previousMonth, i = n.nextMonth, a = n.goToMonth, s = n.displayMonths, o = s.findIndex(function (g) { return f$(t.displayMonth, g) }), c = o === 0, u = o === s.length - 1, d = e > 1 && (c || !u), f = e > 1 && (u || !c), h = function () { r && a(r) }, m = function () { i && a(i) }; return l.jsx(iUe, { displayMonth: t.displayMonth, hideNext: d, hidePrevious: f, nextMonth: i, previousMonth: r, onPreviousClick: h, onNextClick: m }) } function aUe(t) { var e, n = wi(), r = n.classNames, i = n.disableNavigation, a = n.styles, s = n.captionLayout, o = n.components, c = (e = o?.CaptionLabel) !== null && e !== void 0 ? e : tue, u; return i ? u = l.jsx(c, { id: t.id, displayMonth: t.displayMonth }) : s === "dropdown" ? u = l.jsx(q7, { displayMonth: t.displayMonth, id: t.id }) : s === "dropdown-buttons" ? u = l.jsxs(l.Fragment, { children: [l.jsx(q7, { displayMonth: t.displayMonth, displayIndex: t.displayIndex, id: t.id }), l.jsx(X7, { displayMonth: t.displayMonth, displayIndex: t.displayIndex, id: t.id })] }) : u = l.jsxs(l.Fragment, { children: [l.jsx(c, { id: t.id, displayMonth: t.displayMonth, displayIndex: t.displayIndex }), l.jsx(X7, { displayMonth: t.displayMonth, id: t.id })] }), l.jsx("div", { className: r.caption, style: a.caption, children: u }) } function sUe(t) { var e = wi(), n = e.footer, r = e.styles, i = e.classNames.tfoot; return n ? l.jsx("tfoot", { className: i, style: r.tfoot, children: l.jsx("tr", { children: l.jsx("td", { colSpan: 8, children: n }) }) }) : l.jsx(l.Fragment, {}) } function oUe(t, e, n) { for (var r = n ? Pg(new Date) : Hu(new Date, { locale: t, weekStartsOn: e }), i = [], a = 0; a < 7; a++) { var s = Es(r, a); i.push(s) } return i } function lUe() { var t = wi(), e = t.classNames, n = t.styles, r = t.showWeekNumber, i = t.locale, a = t.weekStartsOn, s = t.ISOWeek, o = t.formatters.formatWeekdayName, c = t.labels.labelWeekday, u = oUe(i, a, s); return l.jsxs("tr", { style: n.head_row, className: e.head_row, children: [r && l.jsx("td", { style: n.head_cell, className: e.head_cell }), u.map(function (d, f) { return l.jsx("th", { scope: "col", className: e.head_cell, style: n.head_cell, "aria-label": c(d, { locale: i }), children: o(d, { locale: i }) }, f) })] }) } function cUe() { var t, e = wi(), n = e.classNames, r = e.styles, i = e.components, a = (t = i?.HeadRow) !== null && t !== void 0 ? t : lUe; return l.jsx("thead", { style: r.head, className: n.head, children: l.jsx(a, {}) }) } function uUe(t) { var e = wi(), n = e.locale, r = e.formatters.formatDay; return l.jsx(l.Fragment, { children: r(t.date, { locale: n }) }) } var h$ = S.createContext(void 0); function dUe(t) { if (!S_(t.initialProps)) { var e = { selected: void 0, modifiers: { disabled: [] } }; return l.jsx(h$.Provider, { value: e, children: t.children }) } return l.jsx(fUe, { initialProps: t.initialProps, children: t.children }) } function fUe(t) { var e = t.initialProps, n = t.children, r = e.selected, i = e.min, a = e.max, s = function (u, d, f) { var h, m; (h = e.onDayClick) === null || h === void 0 || h.call(e, u, d, f); var g = !!(d.selected && i && r?.length === i); if (!g) { var x = !!(!d.selected && a && r?.length === a); if (!x) { var v = r ? Jce([], r) : []; if (d.selected) { var b = v.findIndex(function (E) { return $i(u, E) }); v.splice(b, 1) } else v.push(u); (m = e.onSelect) === null || m === void 0 || m.call(e, v, u, d, f) } } }, o = { disabled: [] }; r && o.disabled.push(function (u) { var d = a && r.length > a - 1, f = r.some(function (h) { return $i(h, u) }); return !!(d && !f) }); var c = { selected: r, onDayClick: s, modifiers: o }; return l.jsx(h$.Provider, { value: c, children: n }) } function p$() { var t = S.useContext(h$); if (!t) throw new Error("useSelectMultiple must be used within a SelectMultipleProvider"); return t } function hUe(t, e) { var n = e || {}, r = n.from, i = n.to; return r && i ? $i(i, t) && $i(r, t) ? void 0 : $i(i, t) ? { from: i, to: void 0 } : $i(r, t) ? void 0 : g4(r, t) ? { from: t, to: i } : { from: r, to: t } : i ? g4(t, i) ? { from: i, to: t } : { from: t, to: i } : r ? tf(t, r) ? { from: t, to: r } : { from: r, to: t } : { from: t, to: void 0 } } var m$ = S.createContext(void 0); function pUe(t) { if (!__(t.initialProps)) { var e = { selected: void 0, modifiers: { range_start: [], range_end: [], range_middle: [], disabled: [] } }; return l.jsx(m$.Provider, { value: e, children: t.children }) } return l.jsx(mUe, { initialProps: t.initialProps, children: t.children }) } function mUe(t) { var e = t.initialProps, n = t.children, r = e.selected, i = r || {}, a = i.from, s = i.to, o = e.min, c = e.max, u = function (m, g, x) { var v, b; (v = e.onDayClick) === null || v === void 0 || v.call(e, m, g, x); var E = hUe(m, r); (b = e.onSelect) === null || b === void 0 || b.call(e, E, m, g, x) }, d = { range_start: [], range_end: [], range_middle: [], disabled: [] }; if (a ? (d.range_start = [a], s ? (d.range_end = [s], $i(a, s) || (d.range_middle = [{ after: a, before: s }])) : d.range_end = [a]) : s && (d.range_start = [s], d.range_end = [s]), o && (a && !s && d.disabled.push({ after: OT(a, o - 1), before: Es(a, o - 1) }), a && s && d.disabled.push({ after: a, before: Es(a, o - 1) }), !a && s && d.disabled.push({ after: OT(s, o - 1), before: Es(s, o - 1) })), c) { if (a && !s && (d.disabled.push({ before: Es(a, -c + 1) }), d.disabled.push({ after: Es(a, c - 1) })), a && s) { var f = Su(s, a) + 1, h = c - f; d.disabled.push({ before: OT(a, h) }), d.disabled.push({ after: Es(s, h) }) } !a && s && (d.disabled.push({ before: Es(s, -c + 1) }), d.disabled.push({ after: Es(s, c - 1) })) } return l.jsx(m$.Provider, { value: { selected: r, onDayClick: u, modifiers: d }, children: n }) } function g$() { var t = S.useContext(m$); if (!t) throw new Error("useSelectRange must be used within a SelectRangeProvider"); return t } function DT(t) { return Array.isArray(t) ? Jce([], t) : t !== void 0 ? [t] : [] } function gUe(t) { var e = {}; return Object.entries(t).forEach(function (n) { var r = n[0], i = n[1]; e[r] = DT(i) }), e } var Wc; (function (t) { t.Outside = "outside", t.Disabled = "disabled", t.Selected = "selected", t.Hidden = "hidden", t.Today = "today", t.RangeStart = "range_start", t.RangeEnd = "range_end", t.RangeMiddle = "range_middle" })(Wc || (Wc = {})); var vUe = Wc.Selected, Hd = Wc.Disabled, yUe = Wc.Hidden, xUe = Wc.Today, yk = Wc.RangeEnd, xk = Wc.RangeMiddle, bk = Wc.RangeStart, bUe = Wc.Outside; function wUe(t, e, n) { var r, i = (r = {}, r[vUe] = DT(t.selected), r[Hd] = DT(t.disabled), r[yUe] = DT(t.hidden), r[xUe] = [t.today], r[yk] = [], r[xk] = [], r[bk] = [], r[bUe] = [], r); return t.fromDate && i[Hd].push({ before: t.fromDate }), t.toDate && i[Hd].push({ after: t.toDate }), S_(t) ? i[Hd] = i[Hd].concat(e.modifiers[Hd]) : __(t) && (i[Hd] = i[Hd].concat(n.modifiers[Hd]), i[bk] = n.modifiers[bk], i[xk] = n.modifiers[xk], i[yk] = n.modifiers[yk]), i } var iue = S.createContext(void 0); function SUe(t) { var e = wi(), n = p$(), r = g$(), i = wUe(e, n, r), a = gUe(e.modifiers), s = Ln(Ln({}, i), a); return l.jsx(iue.Provider, { value: s, children: t.children }) } function aue() { var t = S.useContext(iue); if (!t) throw new Error("useModifiers must be used within a ModifiersProvider"); return t } function _Ue(t) { return !!(t && typeof t == "object" && "before" in t && "after" in t) } function EUe(t) { return !!(t && typeof t == "object" && "from" in t) } function MUe(t) { return !!(t && typeof t == "object" && "after" in t) } function TUe(t) { return !!(t && typeof t == "object" && "before" in t) } function CUe(t) { return !!(t && typeof t == "object" && "dayOfWeek" in t) } function NUe(t, e) { var n, r = e.from, i = e.to; if (r && i) { var a = Su(i, r) < 0; a && (n = [i, r], r = n[0], i = n[1]); var s = Su(t, r) >= 0 && Su(i, t) >= 0; return s } return i ? $i(i, t) : r ? $i(r, t) : !1 } function AUe(t) { return c$(t) } function PUe(t) { return Array.isArray(t) && t.every(c$) } function jUe(t, e) { return e.some(function (n) { if (typeof n == "boolean") return n; if (AUe(n)) return $i(t, n); if (PUe(n)) return n.includes(t); if (EUe(n)) return NUe(t, n); if (CUe(n)) return n.dayOfWeek.includes(t.getDay()); if (_Ue(n)) { var r = Su(n.before, t), i = Su(n.after, t), a = r > 0, s = i < 0, o = g4(n.before, n.after); return o ? s && a : a || s } return MUe(n) ? Su(t, n.after) > 0 : TUe(n) ? Su(n.before, t) > 0 : typeof n == "function" ? n(t) : !1 }) } function v$(t, e, n) { var r = Object.keys(e).reduce(function (a, s) { var o = e[s]; return jUe(t, o) && a.push(s), a }, []), i = {}; return r.forEach(function (a) { return i[a] = !0 }), n && !f$(t, n) && (i.outside = !0), i } function RUe(t, e) { for (var n = ds(t[0]), r = A2(t[t.length - 1]), i, a, s = n; s <= r;) { var o = v$(s, e), c = !o.disabled && !o.hidden; if (!c) { s = Es(s, 1); continue } if (o.selected) return s; o.today && !a && (a = s), i || (i = s), s = Es(s, 1) } return a || i } var kUe = 365; function sue(t, e) { var n = e.moveBy, r = e.direction, i = e.context, a = e.modifiers, s = e.retry, o = s === void 0 ? { count: 0, lastFocused: t } : s, c = i.weekStartsOn, u = i.fromDate, d = i.toDate, f = i.locale, h = { day: Es, week: p4, month: Wl, year: m4, startOfWeek: function (v) { return i.ISOWeek ? Pg(v) : Hu(v, { locale: f, weekStartsOn: c }) }, endOfWeek: function (v) { return i.ISOWeek ? qce(v) : d$(v, { locale: f, weekStartsOn: c }) } }, m = h[n](t, r === "after" ? 1 : -1); r === "before" && u ? m = Wce([u, m]) : r === "after" && d && (m = Gce([d, m])); var g = !0; if (a) { var x = v$(m, a); g = !x.disabled && !x.hidden } return g ? m : o.count > kUe ? o.lastFocused : sue(m, { moveBy: n, direction: r, context: i, modifiers: a, retry: Ln(Ln({}, o), { count: o.count + 1 }) }) } var oue = S.createContext(void 0); function IUe(t) { var e = I0(), n = aue(), r = S.useState(), i = r[0], a = r[1], s = S.useState(), o = s[0], c = s[1], u = RUe(e.displayMonths, n), d = i ?? (o && e.isDateDisplayed(o)) ? o : u, f = function () { c(i), a(void 0) }, h = function (v) { a(v) }, m = wi(), g = function (v, b) { if (i) { var E = sue(i, { moveBy: v, direction: b, context: m, modifiers: n }); $i(i, E) || (e.goToDate(E, i), h(E)) } }, x = { focusedDay: i, focusTarget: d, blur: f, focus: h, focusDayAfter: function () { return g("day", "after") }, focusDayBefore: function () { return g("day", "before") }, focusWeekAfter: function () { return g("week", "after") }, focusWeekBefore: function () { return g("week", "before") }, focusMonthBefore: function () { return g("month", "before") }, focusMonthAfter: function () { return g("month", "after") }, focusYearBefore: function () { return g("year", "before") }, focusYearAfter: function () { return g("year", "after") }, focusStartOfWeek: function () { return g("startOfWeek", "before") }, focusEndOfWeek: function () { return g("endOfWeek", "after") } }; return l.jsx(oue.Provider, { value: x, children: t.children }) } function y$() { var t = S.useContext(oue); if (!t) throw new Error("useFocusContext must be used within a FocusProvider"); return t } function OUe(t, e) { var n = aue(), r = v$(t, n, e); return r } var x$ = S.createContext(void 0); function DUe(t) { if (!P2(t.initialProps)) { var e = { selected: void 0 }; return l.jsx(x$.Provider, { value: e, children: t.children }) } return l.jsx(LUe, { initialProps: t.initialProps, children: t.children }) } function LUe(t) { var e = t.initialProps, n = t.children, r = function (a, s, o) { var c, u, d; if ((c = e.onDayClick) === null || c === void 0 || c.call(e, a, s, o), s.selected && !e.required) { (u = e.onSelect) === null || u === void 0 || u.call(e, void 0, a, s, o); return } (d = e.onSelect) === null || d === void 0 || d.call(e, a, a, s, o) }, i = { selected: e.selected, onDayClick: r }; return l.jsx(x$.Provider, { value: i, children: n }) } function lue() { var t = S.useContext(x$); if (!t) throw new Error("useSelectSingle must be used within a SelectSingleProvider"); return t } function FUe(t, e) { var n = wi(), r = lue(), i = p$(), a = g$(), s = y$(), o = s.focusDayAfter, c = s.focusDayBefore, u = s.focusWeekAfter, d = s.focusWeekBefore, f = s.blur, h = s.focus, m = s.focusMonthBefore, g = s.focusMonthAfter, x = s.focusYearBefore, v = s.focusYearAfter, b = s.focusStartOfWeek, E = s.focusEndOfWeek, M = function (Z) { var $, V, K, X; P2(n) ? ($ = r.onDayClick) === null || $ === void 0 || $.call(r, t, e, Z) : S_(n) ? (V = i.onDayClick) === null || V === void 0 || V.call(i, t, e, Z) : __(n) ? (K = a.onDayClick) === null || K === void 0 || K.call(a, t, e, Z) : (X = n.onDayClick) === null || X === void 0 || X.call(n, t, e, Z) }, C = function (Z) { var $; h(t), ($ = n.onDayFocus) === null || $ === void 0 || $.call(n, t, e, Z) }, N = function (Z) { var $; f(), ($ = n.onDayBlur) === null || $ === void 0 || $.call(n, t, e, Z) }, A = function (Z) { var $; ($ = n.onDayMouseEnter) === null || $ === void 0 || $.call(n, t, e, Z) }, j = function (Z) { var $; ($ = n.onDayMouseLeave) === null || $ === void 0 || $.call(n, t, e, Z) }, O = function (Z) { var $; ($ = n.onDayPointerEnter) === null || $ === void 0 || $.call(n, t, e, Z) }, I = function (Z) { var $; ($ = n.onDayPointerLeave) === null || $ === void 0 || $.call(n, t, e, Z) }, D = function (Z) { var $; ($ = n.onDayTouchCancel) === null || $ === void 0 || $.call(n, t, e, Z) }, F = function (Z) { var $; ($ = n.onDayTouchEnd) === null || $ === void 0 || $.call(n, t, e, Z) }, B = function (Z) { var $; ($ = n.onDayTouchMove) === null || $ === void 0 || $.call(n, t, e, Z) }, G = function (Z) { var $; ($ = n.onDayTouchStart) === null || $ === void 0 || $.call(n, t, e, Z) }, z = function (Z) { var $; ($ = n.onDayKeyUp) === null || $ === void 0 || $.call(n, t, e, Z) }, q = function (Z) { var $; switch (Z.key) { case "ArrowLeft": Z.preventDefault(), Z.stopPropagation(), n.dir === "rtl" ? o() : c(); break; case "ArrowRight": Z.preventDefault(), Z.stopPropagation(), n.dir === "rtl" ? c() : o(); break; case "ArrowDown": Z.preventDefault(), Z.stopPropagation(), u(); break; case "ArrowUp": Z.preventDefault(), Z.stopPropagation(), d(); break; case "PageUp": Z.preventDefault(), Z.stopPropagation(), Z.shiftKey ? x() : m(); break; case "PageDown": Z.preventDefault(), Z.stopPropagation(), Z.shiftKey ? v() : g(); break; case "Home": Z.preventDefault(), Z.stopPropagation(), b(); break; case "End": Z.preventDefault(), Z.stopPropagation(), E(); break }($ = n.onDayKeyDown) === null || $ === void 0 || $.call(n, t, e, Z) }, Y = { onClick: M, onFocus: C, onBlur: N, onKeyDown: q, onKeyUp: z, onMouseEnter: A, onMouseLeave: j, onPointerEnter: O, onPointerLeave: I, onTouchCancel: D, onTouchEnd: F, onTouchMove: B, onTouchStart: G }; return Y } function UUe() { var t = wi(), e = lue(), n = p$(), r = g$(), i = P2(t) ? e.selected : S_(t) ? n.selected : __(t) ? r.selected : void 0; return i } function BUe(t) { return Object.values(Wc).includes(t) } function $Ue(t, e) { var n = [t.classNames.day]; return Object.keys(e).forEach(function (r) { var i = t.modifiersClassNames[r]; if (i) n.push(i); else if (BUe(r)) { var a = t.classNames["day_".concat(r)]; a && n.push(a) } }), n } function zUe(t, e) { var n = Ln({}, t.styles.day); return Object.keys(e).forEach(function (r) { var i; n = Ln(Ln({}, n), (i = t.modifiersStyles) === null || i === void 0 ? void 0 : i[r]) }), n } function VUe(t, e, n) { var r, i, a, s = wi(), o = y$(), c = OUe(t, e), u = FUe(t, c), d = UUe(), f = !!(s.onDayClick || s.mode !== "default"); S.useEffect(function () { var A; c.outside || o.focusedDay && f && $i(o.focusedDay, t) && ((A = n.current) === null || A === void 0 || A.focus()) }, [o.focusedDay, t, n, f, c.outside]); var h = $Ue(s, c).join(" "), m = zUe(s, c), g = !!(c.outside && !s.showOutsideDays || c.hidden), x = (a = (i = s.components) === null || i === void 0 ? void 0 : i.DayContent) !== null && a !== void 0 ? a : uUe, v = l.jsx(x, { date: t, displayMonth: e, activeModifiers: c }), b = { style: m, className: h, children: v, role: "gridcell" }, E = o.focusTarget && $i(o.focusTarget, t) && !c.outside, M = o.focusedDay && $i(o.focusedDay, t), C = Ln(Ln(Ln({}, b), (r = { disabled: c.disabled, role: "gridcell" }, r["aria-selected"] = c.selected, r.tabIndex = M || E ? 0 : -1, r)), u), N = { isButton: f, isHidden: g, activeModifiers: c, selectedDays: d, buttonProps: C, divProps: b }; return N } function HUe(t) { var e = S.useRef(null), n = VUe(t.date, t.displayMonth, e); return n.isHidden ? l.jsx("div", { role: "gridcell" }) : n.isButton ? l.jsx(JC, Ln({ name: "day", ref: e }, n.buttonProps)) : l.jsx("div", Ln({}, n.divProps)) } function WUe(t) { var e = t.number, n = t.dates, r = wi(), i = r.onWeekNumberClick, a = r.styles, s = r.classNames, o = r.locale, c = r.labels.labelWeekNumber, u = r.formatters.formatWeekNumber, d = u(Number(e), { locale: o }); if (!i) return l.jsx("span", { className: s.weeknumber, style: a.weeknumber, children: d }); var f = c(Number(e), { locale: o }), h = function (m) { i(e, n, m) }; return l.jsx(JC, { name: "week-number", "aria-label": f, className: s.weeknumber, style: a.weeknumber, onClick: h, children: d }) } function GUe(t) { var e, n, r = wi(), i = r.styles, a = r.classNames, s = r.showWeekNumber, o = r.components, c = (e = o?.Day) !== null && e !== void 0 ? e : HUe, u = (n = o?.WeekNumber) !== null && n !== void 0 ? n : WUe, d; return s && (d = l.jsx("td", { className: a.cell, style: i.cell, children: l.jsx(u, { number: t.weekNumber, dates: t.dates }) })), l.jsxs("tr", { className: a.row, style: i.row, children: [d, t.dates.map(function (f) { return l.jsx("td", { className: a.cell, style: i.cell, role: "presentation", children: l.jsx(c, { displayMonth: t.displayMonth, date: f }) }, t5e(f)) })] }) } function Y7(t, e, n) { for (var r = n?.ISOWeek ? qce(e) : d$(e, n), i = n?.ISOWeek ? Pg(t) : Hu(t, n), a = Su(r, i), s = [], o = 0; o <= a; o++)s.push(Es(i, o)); var c = s.reduce(function (u, d) { var f = n?.ISOWeek ? Xce(d) : Kce(d, n), h = u.find(function (m) { return m.weekNumber === f }); return h ? (h.dates.push(d), u) : (u.push({ weekNumber: f, dates: [d] }), u) }, []); return c } function qUe(t, e) { var n = Y7(ds(t), A2(t), e); if (e?.useFixedWeeks) { var r = r5e(t, e); if (r < 6) { var i = n[n.length - 1], a = i.dates[i.dates.length - 1], s = p4(a, 6 - r), o = Y7(p4(a, 1), s, e); n.push.apply(n, o) } } return n } function XUe(t) { var e, n, r, i = wi(), a = i.locale, s = i.classNames, o = i.styles, c = i.hideHead, u = i.fixedWeeks, d = i.components, f = i.weekStartsOn, h = i.firstWeekContainsDate, m = i.ISOWeek, g = qUe(t.displayMonth, { useFixedWeeks: !!u, ISOWeek: m, locale: a, weekStartsOn: f, firstWeekContainsDate: h }), x = (e = d?.Head) !== null && e !== void 0 ? e : cUe, v = (n = d?.Row) !== null && n !== void 0 ? n : GUe, b = (r = d?.Footer) !== null && r !== void 0 ? r : sUe; return l.jsxs("table", { id: t.id, className: s.table, style: o.table, role: "grid", "aria-labelledby": t["aria-labelledby"], children: [!c && l.jsx(x, {}), l.jsx("tbody", { className: s.tbody, style: o.tbody, children: g.map(function (E) { return l.jsx(v, { displayMonth: t.displayMonth, dates: E.dates, weekNumber: E.weekNumber }, E.weekNumber) }) }), l.jsx(b, { displayMonth: t.displayMonth })] }) } function YUe() { return !!(typeof window < "u" && window.document && window.document.createElement) } var KUe = YUe() ? S.useLayoutEffect : S.useEffect, wk = !1, ZUe = 0; function K7() { return "react-day-picker-".concat(++ZUe) } function QUe(t) { var e, n = t ?? (wk ? K7() : null), r = S.useState(n), i = r[0], a = r[1]; return KUe(function () { i === null && a(K7()) }, []), S.useEffect(function () { wk === !1 && (wk = !0) }, []), (e = t ?? i) !== null && e !== void 0 ? e : void 0 } function JUe(t) { var e, n, r = wi(), i = r.dir, a = r.classNames, s = r.styles, o = r.components, c = I0().displayMonths, u = QUe(r.id ? "".concat(r.id, "-").concat(t.displayIndex) : void 0), d = r.id ? "".concat(r.id, "-grid-").concat(t.displayIndex) : void 0, f = [a.month], h = s.month, m = t.displayIndex === 0, g = t.displayIndex === c.length - 1, x = !m && !g; i === "rtl" && (e = [m, g], g = e[0], m = e[1]), m && (f.push(a.caption_start), h = Ln(Ln({}, h), s.caption_start)), g && (f.push(a.caption_end), h = Ln(Ln({}, h), s.caption_end)), x && (f.push(a.caption_between), h = Ln(Ln({}, h), s.caption_between)); var v = (n = o?.Caption) !== null && n !== void 0 ? n : aUe; return l.jsxs("div", { className: f.join(" "), style: h, children: [l.jsx(v, { id: u, displayMonth: t.displayMonth, displayIndex: t.displayIndex }), l.jsx(XUe, { id: d, "aria-labelledby": u, displayMonth: t.displayMonth })] }, t.displayIndex) } function eBe(t) { var e = wi(), n = e.classNames, r = e.styles; return l.jsx("div", { className: n.months, style: r.months, children: t.children }) } function tBe(t) { var e, n, r = t.initialProps, i = wi(), a = y$(), s = I0(), o = S.useState(!1), c = o[0], u = o[1]; S.useEffect(function () { i.initialFocus && a.focusTarget && (c || (a.focus(a.focusTarget), u(!0))) }, [i.initialFocus, c, a.focus, a.focusTarget, a]); var d = [i.classNames.root, i.className]; i.numberOfMonths > 1 && d.push(i.classNames.multiple_months), i.showWeekNumber && d.push(i.classNames.with_weeknumber); var f = Ln(Ln({}, i.styles.root), i.style), h = Object.keys(r).filter(function (g) { return g.startsWith("data-") }).reduce(function (g, x) { var v; return Ln(Ln({}, g), (v = {}, v[x] = r[x], v)) }, {}), m = (n = (e = r.components) === null || e === void 0 ? void 0 : e.Months) !== null && n !== void 0 ? n : eBe; return l.jsx("div", Ln({ className: d.join(" "), style: f, dir: i.dir, id: i.id, nonce: r.nonce, title: r.title, lang: r.lang }, h, { children: l.jsx(m, { children: s.displayMonths.map(function (g, x) { return l.jsx(JUe, { displayIndex: x, displayMonth: g }, x) }) }) })) } function nBe(t) { var e = t.children, n = T5e(t, ["children"]); return l.jsx(W5e, { initialProps: n, children: l.jsx(tUe, { children: l.jsx(DUe, { initialProps: n, children: l.jsx(dUe, { initialProps: n, children: l.jsx(pUe, { initialProps: n, children: l.jsx(SUe, { children: l.jsx(IUe, { children: e }) }) }) }) }) }) }) } function cue(t) { return l.jsx(nBe, Ln({}, t, { children: l.jsx(tBe, { initialProps: t }) })) } function kx({ className: t, classNames: e, showOutsideDays: n = !0, ...r }) { return l.jsx(cue, { showOutsideDays: n, className: _t("p-3", t), classNames: { months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0", month: "space-y-4", caption: "flex justify-center pt-1 relative items-center", caption_label: "text-sm font-medium", nav: "space-x-1 flex items-center", nav_button: _t(b1({ variant: "outline" }), "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"), nav_button_previous: "absolute left-1", nav_button_next: "absolute right-1", table: "w-full border-collapse space-y-1", head_row: "flex", head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]", row: "flex w-full mt-2", cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20", day: _t(b1({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100"), day_range_end: "day-range-end", day_selected: "bg-accent text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground", day_today: "bg-accent text-accent-foreground", day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30", day_disabled: "text-muted-foreground opacity-50", day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground", day_hidden: "invisible", ...e }, components: { IconLeft: ({ ...i }) => l.jsx(c5, { className: "h-4 w-4" }), IconRight: ({ ...i }) => l.jsx(DS, { className: "h-4 w-4" }) }, ...r }) } kx.displayName = "Calendar"; const eN = { async getAvailableSlots(t, e) { const n = typeof t == "string" ? t : xr(t, "yyyy-MM-dd"); return Yn.get(`${jn.bookings.getSlots}?date=${n}&mode=${e}`) }, async createBooking(t) { return Yn.post(jn.bookings.create, t) }, async getBookings(t) { const e = new URLSearchParams; t?.status && e.append("status", t.status), t?.mode && e.append("mode", t.mode); const n = e.toString() ? `?${e.toString()}` : ""; return Yn.get(`${jn.bookings.getAll}${n}`) }, async rescheduleBooking(t, e) { return Yn.put(jn.bookings.reschedule(t), e) } }, rBe = Object.keys(Qd); function iBe() { const t = ui(), e = Xc(), [n, r] = S.useState(1), [i, a] = S.useState("ai"), [s, o] = S.useState(new Date), [c, u] = S.useState(""), [d, f] = S.useState(""), [h, m] = S.useState(""), [g, x] = S.useState("30"), [v, b] = S.useState("intermediate"), [E, M] = S.useState(""), [C, N] = S.useState("english"), [A, j] = S.useState(!1), [O, I] = S.useState(!1), D = [{ value: "ai", icon: ro, title: "AI-Powered Interview", description: "Practice with our advanced AI interviewer", color: "text-primary" }, { value: "peer", icon: qc, title: "Peer-to-Peer", description: "Connect with another candidate", color: "text-secondary" }, { value: "family", icon: US, title: "Family & Friends", description: "Invite someone you trust", color: "text-accent" }, { value: "live", icon: Fo, title: "Live Mock Interview", description: "Join a real-time mock interview with a verified interviewer", color: "text-primary" }], { data: F, isLoading: B } = oo({ queryKey: ["availableSlots", s, i], queryFn: () => !s || !i ? Promise.resolve({ success: !0, data: { slots: [] } }) : eN.getAvailableSlots(s, i), enabled: !!s && !!i && n >= 2 }), z = (F?.data?.slots || []).filter(ce => { if (!s) return !1; if ($i(s, new Date)) { const be = new Date, de = be.getHours(), ae = be.getMinutes(), se = de * 60 + ae, he = 30, [Ae, Ce, fe] = ce.time.split(/[: ]/); let oe = parseInt(Ae); fe === "PM" && oe !== 12 && (oe += 12), fe === "AM" && oe === 12 && (oe = 0); const xe = parseInt(Ce); return oe * 60 + xe > se + he } return !0 }), q = Cs({ mutationFn: ce => eN.createBooking(ce), onSuccess: () => { dt.success("Interview booked successfully!"), e.invalidateQueries({ queryKey: ["userSessions"] }), t(cr.TRAINEE_SESSIONS) }, onError: ce => { dt.error(ce.message || "Failed to book interview. Please try again.") } }); S.useEffect(() => { u(""), f(""), m("") }, [s, i]); const Y = () => !!i, Z = () => s ? i === "live" ? !!c && !!h : !!c : !1, $ = () => !(!g || !C || !v || !E || ["ai", "live"].includes(i) && !A), V = () => { n === 1 && Y() ? r(2) : n === 2 && Z() ? r(3) : n === 3 && $() && r(4) }, K = () => { n > 1 && r(ce => ce - 1) }, X = () => { if (!s) { dt.error("Please select a date"); return } if (!c) { dt.error("Please select a time slot"); return } if (["peer", "family", "live"].includes(i) && !E) { dt.error("Please select a focus area"); return } if (!E) { dt.error("Please select a focus area"); return } const be = { mode: i, scheduledDate: xr(s, "yyyy-MM-dd"), timeSlot: c, duration: parseInt(g), language: C, difficulty: v, focusArea: E, consentFlags: { recording: A, dataUsage: O }, interviewerId: h || void 0, slotId: d || void 0 }; q.mutate(be) }, Q = ce => { ce.available && (u(ce.time), ce.id && f(ce.id), ce.interviewer?.id && m(ce.interviewer.id)) }, re = ce => xr(ce, "EEEE, MMMM d, yyyy"); return l.jsxs("div", { className: "w-full max-w-4xl mx-auto space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "Schedule Interview" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Complete the steps below to book your interview session" })] }), l.jsx("div", { className: "flex items-center justify-between mb-6 sm:mb-8 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-border scrollbar-track-transparent", children: [1, 2, 3, 4].map(ce => l.jsxs("div", { className: "flex items-center flex-1 min-w-[80px] sm:min-w-0", children: [l.jsxs("div", { className: "flex flex-col items-center flex-1 w-full", children: [l.jsx("div", { className: `w-8 h-8 sm:w-10 sm:h-10 rounded-full flex items-center justify-center border-2 transition-all flex-shrink-0 ${n >= ce ? "bg-primary border-primary text-primary-foreground" : "border-muted-foreground text-muted-foreground"}`, children: n > ce ? l.jsx(oi, { className: "w-5 h-5 sm:w-6 sm:h-6" }) : l.jsx("span", { className: "font-semibold text-sm sm:text-base", children: ce }) }), l.jsxs("span", { className: `text-[10px] sm:text-xs mt-1 sm:mt-2 text-center whitespace-nowrap ${n >= ce ? "text-primary font-medium" : "text-muted-foreground"}`, children: [ce === 1 && "Select Mode", ce === 2 && "Date & Time", ce === 3 && "Requirements", ce === 4 && "Confirmation"] })] }), ce < 4 && l.jsx("div", { className: `h-0.5 flex-1 mx-1 sm:mx-2 hidden sm:block ${n > ce ? "bg-primary" : "bg-muted"}` })] }, ce)) }), l.jsx(YS, { mode: "wait", children: l.jsxs($e.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, exit: { opacity: 0, x: -20 }, transition: { duration: .3 }, children: [n === 1 && l.jsxs(Lt, { className: "p-6", children: [l.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Select Interview Mode" }), l.jsx(w2, { value: i, onValueChange: ce => a(ce), children: l.jsx("div", { className: "space-y-3", children: D.map((ce, be) => l.jsx($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .4, delay: be * .1 }, children: l.jsxs(We, { htmlFor: ce.value, className: `flex items-start space-x-3 p-4 rounded-lg border-2 cursor-pointer transition-all hover:bg-muted/50 ${i === ce.value ? "border-primary bg-primary/5" : "border-border"}`, children: [l.jsx(Ax, { value: ce.value, id: ce.value, className: "mt-1" }), l.jsxs("div", { className: "flex-1", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [l.jsx(ce.icon, { className: `h-5 w-5 ${ce.color}` }), l.jsx("span", { className: "font-semibold", children: ce.title })] }), l.jsx("p", { className: "text-sm text-muted-foreground", children: ce.description })] })] }) }, ce.value)) }) })] }), n === 2 && l.jsxs("div", { className: "space-y-6", children: [l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(li, { className: "h-5 w-5 text-primary" }), "Select Date"] }), l.jsx(kx, { mode: "single", selected: s, onSelect: ce => { o(ce), u(""), f(""), m("") }, className: "rounded-md mx-auto flex justify-center items-center", disabled: ce => { const be = vi(new Date), de = vi(ce); return tf(de, be) } })] }), s && l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(ni, { className: "h-5 w-5 text-primary" }), "Available Times"] }), B ? l.jsxs("div", { className: "flex items-center justify-center py-8", children: [l.jsx(sa, { className: "h-6 w-6 animate-spin text-primary" }), l.jsx("span", { className: "ml-2 text-muted-foreground", children: "Loading available slots..." })] }) : z && z.length > 0 ? l.jsx("div", { className: "grid grid-cols-2 gap-3", children: z.map((ce, be) => { let de = !1; if (s && $i(s, new Date)) { const ae = new Date, se = ae.getHours(), he = ae.getMinutes(), Ae = se * 60 + he, Ce = 30, [fe, oe, xe] = ce.time.split(/[: ]/); let _e = parseInt(fe); xe === "PM" && _e !== 12 && (_e += 12), xe === "AM" && _e === 12 && (_e = 0); const je = parseInt(oe); de = _e * 60 + je <= Ae + Ce } return l.jsx($e.div, { initial: { opacity: 0, scale: .9 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .2, delay: be * .05 }, children: l.jsx(vt, { variant: c === ce.time && h === (ce.interviewer?.id || "") ? "default" : "outline", disabled: !ce.available || de, className: `w-full transition-all ${c === ce.time && h === (ce.interviewer?.id || "") ? "bg-primary text-primary-foreground" : de || !ce.available ? "opacity-50 cursor-not-allowed" : "hover:bg-primary hover:text-primary-foreground"}`, onClick: () => !de && ce.available && Q(ce), children: l.jsxs("div", { className: "flex flex-col items-start", children: [l.jsx("span", { children: ce.time }), ce.interviewer && l.jsx("span", { className: "text-xs opacity-80", children: ce.interviewer.name })] }) }) }, ce.id || ce.time || be) }) }) : l.jsx("div", { className: "text-center py-8 text-muted-foreground", children: "No available slots for this date. Please select another date." })] })] }), n === 3 && l.jsxs(Lt, { className: "p-6", children: [l.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Additional Requirements" }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "duration", children: "Duration" }), l.jsxs(Jn, { value: g, onValueChange: x, children: [l.jsx(qn, { id: "duration", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "30", children: "30 minutes" }), l.jsx(ut, { value: "45", children: "45 minutes" }), l.jsx(ut, { value: "60", children: "60 minutes" }), l.jsx(ut, { value: "90", children: "90 minutes" })] })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "difficulty", children: "Difficulty Level" }), l.jsxs(Jn, { value: v, onValueChange: b, children: [l.jsx(qn, { id: "difficulty", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "beginner", children: "Beginner" }), l.jsx(ut, { value: "intermediate", children: "Intermediate" }), l.jsx(ut, { value: "advanced", children: "Advanced" }), l.jsx(ut, { value: "expert", children: "Expert" })] })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "focus", children: "Focus Area *" }), l.jsxs(Jn, { value: E, onValueChange: M, children: [l.jsx(qn, { id: "focus", children: l.jsx(er, { placeholder: "Select a focus area" }) }), l.jsx(Xn, { children: rBe.map(ce => l.jsx(ut, { value: ce, children: ce }, ce)) })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "language", children: "Language" }), l.jsxs(Jn, { value: C, onValueChange: ce => N(ce), children: [l.jsx(qn, { id: "language", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "english", children: "English" }), l.jsx(ut, { value: "arabic", children: "Arabic" })] })] })] }), (i === "ai" || i === "live") && l.jsxs("div", { className: "space-y-3 pt-4 border-t", children: [l.jsxs("div", { className: "flex items-start space-x-3", children: [l.jsx(QC, { id: "recording", checked: A, onCheckedChange: ce => j(ce === !0) }), l.jsxs("div", { className: "space-y-1", children: [l.jsx(We, { htmlFor: "recording", className: "cursor-pointer", children: "Recording Consent *" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "I consent to this session being recorded for review and feedback purposes." })] })] }), l.jsxs("div", { className: "flex items-start space-x-3", children: [l.jsx(QC, { id: "dataUsage", checked: O, onCheckedChange: ce => I(ce === !0) }), l.jsxs("div", { className: "space-y-1", children: [l.jsx(We, { htmlFor: "dataUsage", className: "cursor-pointer", children: "Data Usage Consent" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "I consent to my session data being used for improving the platform." })] })] })] })] })] }), n === 4 && l.jsxs(Lt, { className: "p-6", children: [l.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Review Your Booking" }), l.jsx("div", { className: "space-y-4", children: l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Mode" }), l.jsx("p", { className: "font-semibold", children: D.find(ce => ce.value === i)?.title })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Date" }), l.jsx("p", { className: "font-semibold", children: s ? re(s) : "Not selected" })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Time" }), l.jsx("p", { className: "font-semibold", children: c || "Not selected" })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Duration" }), l.jsxs("p", { className: "font-semibold", children: [g, " minutes"] })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Language" }), l.jsx("p", { className: "font-semibold", children: C.charAt(0).toUpperCase() + C.slice(1) })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Difficulty" }), l.jsx("p", { className: "font-semibold", children: v.charAt(0).toUpperCase() + v.slice(1) })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Focus Area" }), l.jsx("p", { className: "font-semibold", children: E || "Not selected" })] })] }) })] })] }, n) }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs(vt, { variant: "outline", onClick: K, disabled: n === 1, children: [l.jsx(c5, { className: "w-4 h-4 mr-2" }), "Back"] }), n < 4 ? l.jsxs(vt, { onClick: V, disabled: n === 1 && !Y() || n === 2 && !Z() || n === 3 && !$(), children: ["Next", l.jsx(DS, { className: "w-4 h-4 ml-2" })] }) : l.jsx(vt, { onClick: X, disabled: q.isPending, size: "lg", className: "bg-gradient-primary text-primary-foreground", children: q.isPending ? l.jsxs(l.Fragment, { children: [l.jsx(sa, { className: "w-4 h-4 mr-2 animate-spin" }), "Booking..."] }) : l.jsxs(l.Fragment, { children: [l.jsx(oi, { className: "w-4 h-4 mr-2" }), "Confirm Booking"] }) })] })] }) } const Z7 = t => { switch (t) { case "ai": return ro; case "peer": return qc; case "family": return US; case "live": return Fo; default: return ro } }, KM = t => { switch (t) { case "ai": return "AI-Powered Interview"; case "peer": return "Peer-to-Peer"; case "family": return "Family & Friends"; case "live": return "Live Mock Interview"; default: return "Interview" } }, aBe = t => { if (!t) return "Date not set"; try { const e = ao(t); return !e || isNaN(e.getTime()) ? "Invalid date" : k0(e) ? "Today" : w_(e) ? "Tomorrow" : xr(e, "MMM d, yyyy") } catch { return "Invalid date" } }, sBe = t => { if (!t) return "Date not set"; try { const e = ao(t); if (!e || isNaN(e.getTime())) return "Invalid date"; const r = Math.floor((new Date().getTime() - e.getTime()) / (1e3 * 60 * 60 * 24)); return r === 0 ? "Today" : r === 1 ? "Yesterday" : r < 7 ? `${r} days ago` : r < 30 ? `${Math.floor(r / 7)} week${Math.floor(r / 7) > 1 ? "s" : ""} ago` : xr(e, "MMM d, yyyy") } catch { return "Invalid date" } }; function oBe() { const t = ui(); Xc(); const { data: e, isLoading: n, error: r, refetch: i } = oo({ queryKey: ["userSessions"], queryFn: () => eN.getBookings() }), a = e?.data || [], s = u => { if (!u) return null; try { return ao(u) } catch { return null } }, o = a.filter(u => { if (!u.scheduledDate) return !1; const d = s(u.scheduledDate); return d ? !Rx(d) && u.status !== "completed" && u.status !== "cancelled" : !1 }).sort((u, d) => { const f = s(u.scheduledDate), h = s(d.scheduledDate); if (!f || !h) return !f && !h ? 0 : f ? -1 : 1; const m = f.getTime(), g = h.getTime(); return m !== g ? m - g : (u.timeSlot || "").localeCompare(d.timeSlot || "") }), c = a.filter(u => { if (!u.scheduledDate) return u.status === "completed" || u.status === "cancelled"; const d = s(u.scheduledDate); return d ? Rx(d) || u.status === "completed" || u.status === "cancelled" : u.status === "completed" || u.status === "cancelled" }).sort((u, d) => { const f = s(u.scheduledDate), h = s(d.scheduledDate); if (!f || !h) return !f && !h ? 0 : f ? -1 : 1; const m = f.getTime(), g = h.getTime(); return m !== g ? g - m : (d.timeSlot || "").localeCompare(u.timeSlot || "") }); return S.useEffect(() => { i() }, [i]), r ? l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "My Sessions" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Manage your scheduled and completed interview sessions" })] }), l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(ji, { className: "h-12 w-12 text-destructive mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "Failed to load sessions" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: r instanceof Error ? r.message : "An error occurred while loading your sessions" }), l.jsx(vt, { onClick: () => i(), children: "Try Again" })] })] }) : l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "My Sessions" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Manage your scheduled and completed interview sessions" })] }), n ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(sa, { className: "h-12 w-12 animate-spin text-primary mx-auto mb-4" }), l.jsx("p", { className: "text-muted-foreground", children: "Loading your sessions..." })] }) : l.jsxs(Sp, { defaultValue: "upcoming", className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-2 max-w-md", children: [l.jsxs(Rr, { value: "upcoming", children: ["Upcoming (", o.length, ")"] }), l.jsxs(Rr, { value: "past", children: ["Past Sessions (", c.length, ")"] })] }), l.jsx(Dr, { value: "upcoming", className: "space-y-4", children: o.length === 0 ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(li, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "No upcoming sessions" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "Schedule your first interview session to get started" }), l.jsx(vt, { onClick: () => t(cr.TRAINEE_SCHEDULE), children: "Schedule Session" })] }) : l.jsx(l.Fragment, { children: o.map((u, d) => { const f = Z7(u.mode); return l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: d * .1 }, children: l.jsx(Lt, { className: "p-6 hover-lift", children: l.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-center justify-between gap-4", children: [l.jsxs("div", { className: "flex items-start gap-4", children: [l.jsx("div", { className: "p-3 rounded-lg bg-primary/10", children: l.jsx(f, { className: "h-6 w-6 text-primary" }) }), l.jsxs("div", { className: "flex-1", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [l.jsx("h3", { className: "text-lg font-semibold", children: KM(u.mode) }), u.focusArea && l.jsx(Jt, { variant: "outline", children: u.focusArea })] }), l.jsxs("div", { className: "flex flex-wrap items-center gap-4 text-sm text-muted-foreground", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(li, { className: "h-4 w-4" }), aBe(u.scheduledDate)] }), l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-4 w-4" }), u.timeSlot || "Time not set", "  ", u.duration || 0, " min"] }), l.jsx(Jt, { variant: "secondary", children: KM(u.mode) }), u.difficulty && l.jsx(Jt, { variant: "outline", children: u.difficulty.charAt(0).toUpperCase() + u.difficulty.slice(1) }), u.status && l.jsx(Jt, { variant: u.status === "cancelled" ? "destructive" : "secondary", className: `rounded-full ${u.status === "scheduled" ? "bg-blue-500 text-white hover:bg-blue-600 border-blue-600" : u.status === "completed" ? "bg-green-500 text-white hover:bg-green-600 border-green-600" : u.status === "in_progress" ? "bg-yellow-500 text-white hover:bg-yellow-600 border-yellow-600" : ""}`, children: u.status.replace("_", " ").charAt(0).toUpperCase() + u.status.replace("_", " ").slice(1) })] }), u.interviewerId && typeof u.interviewerId == "object" && l.jsxs("p", { className: "text-sm text-muted-foreground mt-2", children: ["Interviewer: ", u.interviewerId.name] })] })] }), l.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [u.status?.toLowerCase() !== "in_progress" && l.jsxs(l.Fragment, { children: [l.jsxs(vt, { variant: "outline", size: "sm", onClick: () => { t(`/dashboard/trainee/sessions/${u._id}/reschedule`) }, children: [l.jsx(Bve, { className: "h-4 w-4 mr-2" }), "Reschedule"] }), l.jsxs(vt, { size: "sm", onClick: () => { u.mode === "ai" ? t(`/dashboard/trainee/sessions/${u._id}`) : u.mode === "live" || u.mode === "family" ? t(`/dashboard/trainee/sessions/${u._id}`) : u.mode === "peer" ? t(`/dashboard/trainee/sessions/${u._id}`) : t(`/dashboard/trainee/sessions/${u._id}`) }, className: "bg-gradient-primary text-primary-foreground text-xs sm:text-sm", children: [l.jsx(yg, { className: "h-3 w-3 sm:h-4 sm:w-4 sm:mr-2" }), l.jsx("span", { children: "Start" })] })] }), u.status === "in_progress" && l.jsxs(vt, { size: "sm", onClick: () => { t(`/dashboard/trainee/sessions/${u._id}`) }, className: "bg-gradient-primary text-primary-foreground text-xs sm:text-sm", children: [l.jsx(yg, { className: "h-3 w-3 sm:h-4 sm:w-4 sm:mr-2" }), l.jsx("span", { children: "Join Session" })] })] })] }) }) }, u._id) }) }) }), l.jsx(Dr, { value: "past", className: "space-y-4", children: c.length === 0 ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(li, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "No past sessions" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "Your completed interview sessions will appear here" }), l.jsx(vt, { onClick: () => t(cr.TRAINEE_SCHEDULE), children: "Schedule New Session" })] }) : l.jsx(l.Fragment, { children: c.map((u, d) => { const f = Z7(u.mode); return l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: d * .1 }, children: l.jsx(Lt, { className: "p-6 hover-lift", children: l.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-center justify-between gap-4", children: [l.jsxs("div", { className: "flex items-start gap-4", children: [l.jsx("div", { className: "p-3 rounded-lg bg-muted", children: l.jsx(f, { className: "h-6 w-6 text-muted-foreground" }) }), l.jsxs("div", { className: "flex-1", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [l.jsx("h3", { className: "text-lg font-semibold", children: KM(u.mode) }), u.focusArea && l.jsx(Jt, { variant: "outline", children: u.focusArea })] }), l.jsxs("div", { className: "flex flex-wrap items-center gap-4 text-sm text-muted-foreground", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(li, { className: "h-4 w-4" }), sBe(u.scheduledDate)] }), l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-4 w-4" }), u.timeSlot || "Time not set", "  ", u.duration || 0, " min"] }), l.jsx(Jt, { variant: "secondary", children: KM(u.mode) }), u.status && l.jsx(Jt, { variant: u.status === "cancelled" ? "destructive" : "secondary", className: `rounded-full ${u.status === "scheduled" ? "bg-blue-500 text-white hover:bg-blue-600 border-blue-600" : u.status === "completed" ? "bg-green-500 text-white hover:bg-green-600 border-green-600" : u.status === "in_progress" ? "bg-yellow-500 text-white hover:bg-yellow-600 border-yellow-600" : ""}`, children: u.status.replace("_", " ").charAt(0).toUpperCase() + u.status.replace("_", " ").slice(1) })] })] })] }), l.jsx("div", { className: "flex items-center gap-4", children: u.status === "completed" && l.jsxs(l.Fragment, { children: [l.jsxs(vt, { variant: "outline", size: "sm", onClick: () => { u.mode === "ai" ? t(cr.TRAINEE_FEEDBACK, { state: { sessionId: u._id } }) : t(`/dashboard/trainee/sessions/${u._id}`) }, children: [l.jsx(Du, { className: "h-4 w-4 mr-2" }), "View Details"] }), l.jsx(vt, { variant: "outline", size: "sm", onClick: () => { t(cr.TRAINEE_FEEDBACK, { state: { sessionId: u._id } }) }, children: "View Feedback" })] }) })] }) }) }, u._id) }) }) })] })] }) } function lBe() { const [t, e] = S.useState(!1), [n, r] = S.useState(!1), [i, a] = S.useState(""), [s, o] = S.useState(0), [c] = S.useState(27), u = ["Tell me about yourself and your professional background.", "What interests you most about this role?", "Describe a challenging project you've worked on.", "How do you handle tight deadlines?", "Where do you see yourself in 5 years?"], d = ["Provide specific examples from your experience", "Use the STAR method (Situation, Task, Action, Result)", "Maintain eye contact with the camera", "Speak clearly and at a moderate pace"], f = () => { dt.success("Session ended. Generating feedback...") }, h = () => { s < u.length - 1 && (o(s + 1), dt.success("Next question loaded")) }; return l.jsxs("div", { className: "max-w-7xl space-y-6 pb-20 lg:pb-8", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "AI Interview Session" }), l.jsxs("div", { className: "flex items-center gap-4 text-sm text-muted-foreground", children: [l.jsxs(Jt, { variant: "secondary", className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-3 w-3" }), c, " min remaining"] }), l.jsxs(Jt, { variant: "secondary", className: "flex items-center gap-1", children: [l.jsx(ro, { className: "h-3 w-3" }), "Question ", s + 1, " of ", u.length] })] })] }), l.jsx("div", { className: "flex items-center gap-2", children: l.jsx(vu, { value: s / u.length * 100, className: "w-32" }) })] }), l.jsxs("div", { className: "grid lg:grid-cols-3 gap-6", children: [l.jsxs("div", { className: "lg:col-span-2 space-y-6", children: [l.jsx(Lt, { className: "p-0 overflow-hidden", children: l.jsxs("div", { className: "aspect-video bg-muted relative flex items-center justify-center", children: [n ? l.jsxs("div", { className: "text-center", children: [l.jsx(b8, { className: "h-12 w-12 text-muted-foreground mx-auto mb-2" }), l.jsx("p", { className: "text-muted-foreground", children: "Camera is off" })] }) : l.jsx("div", { className: "w-full h-full bg-gradient-to-br from-primary/20 to-secondary/20 flex items-center justify-center", children: l.jsxs("div", { className: "text-center", children: [l.jsx(Fo, { className: "h-12 w-12 text-muted-foreground mx-auto mb-2" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Your video feed" })] }) }), l.jsx("div", { className: "absolute bottom-4 right-4 w-32 h-24 rounded-lg overflow-hidden border-2 border-primary shadow-lg", children: l.jsx("div", { className: "w-full h-full bg-gradient-to-br from-secondary/40 to-accent/40 flex items-center justify-center", children: l.jsx(ro, { className: "h-8 w-8 text-primary" }) }) }), l.jsxs("div", { className: "absolute bottom-4 left-1/2 -translate-x-1/2 flex items-center gap-3", children: [l.jsx(vt, { size: "icon", variant: t ? "destructive" : "secondary", onClick: () => e(!t), className: "rounded-full h-12 w-12", children: t ? l.jsx(NJ, { className: "h-5 w-5" }) : l.jsx(VT, { className: "h-5 w-5" }) }), l.jsx(vt, { size: "icon", variant: n ? "destructive" : "secondary", onClick: () => r(!n), className: "rounded-full h-12 w-12", children: n ? l.jsx(b8, { className: "h-5 w-5" }) : l.jsx(Fo, { className: "h-5 w-5" }) }), l.jsx(vt, { size: "icon", variant: "destructive", onClick: f, className: "rounded-full h-12 w-12", children: l.jsx(eye, { className: "h-5 w-5" }) })] })] }) }), l.jsx(Lt, { className: "p-6", children: l.jsxs("div", { className: "flex items-start gap-4", children: [l.jsx(ff, { className: "h-6 w-6 text-primary mt-1" }), l.jsxs("div", { className: "flex-1", children: [l.jsx("h3", { className: "font-semibold mb-2", children: "Current Question" }), l.jsx(YS, { mode: "wait", children: l.jsx($e.p, { initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, transition: { duration: .3 }, className: "text-lg text-foreground/90", children: u[s] }, s) }), l.jsx(vt, { onClick: h, disabled: s === u.length - 1, className: "mt-4", children: "Next Question" })] })] }) }), l.jsxs(Lt, { className: "p-6", children: [l.jsx("h3", { className: "font-semibold mb-4", children: "Your Notes" }), l.jsx(Ag, { placeholder: "Take notes during the interview...", value: i, onChange: m => a(m.target.value), className: "min-h-[120px]" })] })] }), l.jsxs("div", { className: "space-y-6", children: [l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(ro, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "font-semibold", children: "AI Feedback" })] }), l.jsx("div", { className: "space-y-3", children: d.map((m, g) => l.jsx($e.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .4, delay: g * .1 }, className: "p-3 rounded-lg bg-muted/50 text-sm", children: l.jsx("p", { className: "text-muted-foreground", children: m }) }, g)) })] }), l.jsxs(Lt, { className: "p-6", children: [l.jsx("h3", { className: "font-semibold mb-4", children: "Live Metrics" }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsxs("div", { className: "flex justify-between text-sm mb-2", children: [l.jsx("span", { children: "Clarity" }), l.jsx("span", { className: "text-accent font-medium", children: "Good" })] }), l.jsx(vu, { value: 78, className: "h-2" })] }), l.jsxs("div", { children: [l.jsxs("div", { className: "flex justify-between text-sm mb-2", children: [l.jsx("span", { children: "Pacing" }), l.jsx("span", { className: "text-accent font-medium", children: "Great" })] }), l.jsx(vu, { value: 85, className: "h-2" })] }), l.jsxs("div", { children: [l.jsxs("div", { className: "flex justify-between text-sm mb-2", children: [l.jsx("span", { children: "Eye Contact" }), l.jsx("span", { className: "text-warning font-medium", children: "Needs Work" })] }), l.jsx(vu, { value: 62, className: "h-2" })] }), l.jsxs("div", { children: [l.jsxs("div", { className: "flex justify-between text-sm mb-2", children: [l.jsx("span", { children: "Confidence" }), l.jsx("span", { className: "text-accent font-medium", children: "Excellent" })] }), l.jsx(vu, { value: 92, className: "h-2" })] })] })] }), l.jsxs(Lt, { className: "p-6 bg-primary/5 border-primary/20", children: [l.jsx("h3", { className: "font-semibold mb-3", children: " Quick Tip" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Remember to smile and maintain a positive body language. It significantly improves your interview performance!" })] })] })] })] }) } const { getAvailableSlots: cBe, rescheduleBooking: uBe, getBookings: dBe } = eN, fBe = async () => ({ data: (await dBe()).data }); function hBe() { const t = ui(), { sessionId: e } = Zge(), n = Xc(), [r, i] = S.useState(1), { data: a, isLoading: s } = oo({ queryKey: ["userSessions"], queryFn: fBe }), c = (a?.data || []).find(Q => Q._id === e), [u, d] = S.useState(void 0), [f, h] = S.useState(""), [m, g] = S.useState(""), [x, v] = S.useState(""), [b, E] = S.useState(""), [M, C] = S.useState(""), [N, A] = S.useState(""), [j, O] = S.useState("english"); S.useEffect(() => { if (c) { let Q; if (c.scheduledDate) try { Q = ao(c.scheduledDate), isNaN(Q.getTime()) && (Q = void 0) } catch { Q = void 0 } Q && d(Q), c.timeSlot && h(c.timeSlot), E(c.duration.toString()), C(c.difficulty || "intermediate"), A(c.focusArea || ""), O(c.language || "english") } }, [c]); const I = Object.keys(Qd), { data: D, isLoading: F } = oo({ queryKey: ["availableSlots", u, c?.mode], queryFn: () => !u || !c?.mode ? Promise.resolve({ success: !0, data: { date: "", mode: c?.mode || "ai", slots: [] } }) : cBe(u, c.mode), enabled: !!u && !!c?.mode && r >= 1 }), B = D?.data?.slots || [], G = Cs({ mutationFn: Q => { if (!e) throw new Error("Session ID is required"); return uBe(e, Q) }, onSuccess: () => { dt.success("Session rescheduled successfully!"), n.invalidateQueries({ queryKey: ["userSessions"] }), t("/dashboard/trainee/sessions") }, onError: Q => { dt.error(Q.message || "Failed to reschedule session. Please try again.") } }), z = S.useRef(""); S.useEffect(() => { if (!u) { h(""), g(""), v(""), z.current = ""; return } const Q = `${u.getFullYear()}-${u.getMonth()}-${u.getDate()}`; z.current && Q !== z.current && (h(""), g(""), v("")), Q !== z.current && (z.current = Q) }, [u?.getFullYear(), u?.getMonth(), u?.getDate(), c?.mode]); const q = () => u ? c?.mode === "live" ? !!f && !!m : !!f : !1, Y = () => !(!b || !j || !M || !N), Z = () => { r === 1 && q() ? i(2) : r === 2 && Y() && i(3) }, $ = () => { r > 1 && i(Q => Q - 1) }, V = () => { if (!u) { dt.error("Please select a date"); return } if (!f) { dt.error("Please select a time slot"); return } if (c?.mode === "live" && !m) { dt.error("Please select an available time slot."); return } if (!u || isNaN(u.getTime())) { dt.error("Please select a valid date"); return } const re = { scheduledDate: xr(u, "yyyy-MM-dd"), timeSlot: f }; if (c?.mode === "live") { if (!m) { dt.error("Please select a time slot"); return } re.slotId = m, x && (re.interviewerId = x) } G.mutate(re) }, K = (Q, re, ce) => { g(Q), h(re), ce && v(ce) }, X = Q => { if (!Q || isNaN(Q.getTime())) return "Invalid date"; try { return xr(Q, "EEEE, MMMM d, yyyy") } catch { return "Invalid date" } }; return s ? l.jsx("div", { className: "max-w-4xl space-y-8 pb-20 lg:pb-8", children: l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(sa, { className: "h-12 w-12 text-primary mx-auto mb-4 animate-spin" }), l.jsx("p", { className: "text-muted-foreground", children: "Loading session details..." })] }) }) : c ? c.status === "completed" || c.status === "cancelled" ? l.jsx("div", { className: "max-w-4xl space-y-8 pb-20 lg:pb-8", children: l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "Cannot Reschedule" }), l.jsxs("p", { className: "text-muted-foreground mb-4", children: ["This session cannot be rescheduled because it is ", c.status === "completed" ? "already completed" : "cancelled", "."] }), l.jsx(vt, { onClick: () => t("/dashboard/trainee/sessions"), children: "Back to Sessions" })] }) }) : l.jsxs("div", { className: "w-full max-w-4xl mx-auto space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsxs(vt, { variant: "ghost", onClick: () => t("/dashboard/trainee/sessions"), className: "mb-4", size: "sm", children: [l.jsx(f0, { className: "w-4 h-4 mr-2" }), l.jsx("span", { className: "hidden sm:inline", children: "Back to Sessions" }), l.jsx("span", { className: "sm:hidden", children: "Back" })] }), l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "Reschedule Interview" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Update the date, time, and details for your interview session" })] }), c && l.jsxs(Lt, { className: "p-4 sm:p-6 bg-muted/50", children: [l.jsx("h3", { className: "font-semibold mb-3 text-base sm:text-lg", children: "Current Session Details" }), l.jsxs("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4 text-sm", children: [l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Date & Time" }), l.jsx("p", { className: "font-medium", children: (() => { try { if (c?.scheduledDate) { const Q = ao(c.scheduledDate); if (!isNaN(Q.getTime())) { const re = xr(Q, "EEEE, MMMM d, yyyy"), ce = c.timeSlot || "Time not set"; return `${re} at ${ce}` } } return c?.timeSlot ? `Date not set at ${c.timeSlot}` : "Date and time not set" } catch { return c?.timeSlot || "Date and time not set" } })() })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Duration" }), l.jsxs("p", { className: "font-medium", children: [c.duration, " minutes"] })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Language" }), l.jsx("p", { className: "font-medium capitalize", children: c.language })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Difficulty" }), l.jsx("p", { className: "font-medium capitalize", children: c.difficulty || "Not set" })] }), c.focusArea && l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Focus Area" }), l.jsx("p", { className: "font-medium", children: c.focusArea })] })] })] }), l.jsx("div", { className: "flex items-center justify-between mb-6 sm:mb-8 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-border scrollbar-track-transparent", children: [1, 2, 3].map(Q => l.jsxs("div", { className: "flex items-center flex-1 min-w-[100px] sm:min-w-0", children: [l.jsxs("div", { className: "flex flex-col items-center flex-1 w-full", children: [l.jsx("div", { className: `w-8 h-8 sm:w-10 sm:h-10 rounded-full flex items-center justify-center border-2 transition-all flex-shrink-0 ${r >= Q ? "bg-primary border-primary text-primary-foreground" : "border-muted-foreground text-muted-foreground"}`, children: r > Q ? l.jsx(oi, { className: "w-5 h-5 sm:w-6 sm:h-6" }) : l.jsx("span", { className: "font-semibold text-sm sm:text-base", children: Q }) }), l.jsxs("span", { className: `text-[10px] sm:text-xs mt-1 sm:mt-2 text-center whitespace-nowrap ${r >= Q ? "text-primary font-medium" : "text-muted-foreground"}`, children: [Q === 1 && "Date & Time", Q === 2 && "Details", Q === 3 && "Confirmation"] })] }), Q < 3 && l.jsx("div", { className: `h-0.5 flex-1 mx-1 sm:mx-2 hidden sm:block ${r > Q ? "bg-primary" : "bg-muted"}` })] }, Q)) }), l.jsx(YS, { mode: "wait", children: l.jsxs($e.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, exit: { opacity: 0, x: -20 }, transition: { duration: .3 }, children: [r === 1 && l.jsxs("div", { className: "space-y-6", children: [l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(li, { className: "h-5 w-5 text-primary" }), "Select New Date"] }), l.jsx(kx, { mode: "single", selected: u, onSelect: Q => { d(Q), h(""), g(""), v("") }, className: "rounded-md mx-auto flex justify-center items-center", disabled: Q => { const re = vi(new Date), ce = vi(Q); return tf(ce, re) } })] }), u && l.jsxs(l.Fragment, { children: [l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(ni, { className: "h-5 w-5 text-primary" }), "Available Times"] }), F ? l.jsxs("div", { className: "flex items-center justify-center py-8", children: [l.jsx(sa, { className: "h-6 w-6 animate-spin text-primary" }), l.jsx("span", { className: "ml-2 text-muted-foreground", children: "Loading available slots..." })] }) : B && B.length > 0 && u ? l.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-3 gap-3", children: B.map((Q, re) => { const ce = Q.time, [be, de] = ce.split(" "), [ae, se] = be.split(":"); let he = parseInt(ae); if (de === "PM" && he !== 12 && (he += 12), de === "AM" && he === 12 && (he = 0), !u || isNaN(u.getTime())) return null; const Ae = new Date(u); Ae.setHours(he, parseInt(se), 0, 0); const fe = tf(Ae, new Date), oe = m === Q.id; return l.jsx($e.div, { initial: { opacity: 0, scale: .9 }, animate: { opacity: 1, scale: 1 }, transition: { duration: .2, delay: re * .05 }, children: l.jsx(vt, { variant: oe ? "default" : "outline", disabled: fe, className: `w-full h-auto py-4 transition-all ${oe ? "bg-primary text-primary-foreground ring-2 ring-primary ring-offset-2" : fe ? "opacity-50 cursor-not-allowed" : "hover:bg-primary hover:text-primary-foreground"}`, onClick: () => K(Q.id || "", Q.time, Q.interviewer?.id || void 0), children: l.jsxs("div", { className: "flex flex-col items-center gap-1 w-full", children: [l.jsx("span", { className: "font-semibold text-base", children: Q.time }), Q.interviewer && l.jsxs(l.Fragment, { children: [l.jsx("span", { className: "text-xs opacity-90 font-medium", children: Q.interviewer.name }), l.jsx("span", { className: "text-[10px] opacity-75", children: "Interviewer" })] }), !Q.interviewer && c?.mode !== "live" && l.jsx("span", { className: "text-xs opacity-75", children: c?.mode === "ai" ? "AI Interview" : "Available" })] }) }) }, Q.id) }) }) : l.jsx("div", { className: "text-center py-8 text-muted-foreground", children: "No available slots for this date. Please select another date." })] }), m && f && l.jsx($e.div, { initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, transition: { duration: .3 }, children: l.jsx(Lt, { className: "p-4 sm:p-6 bg-primary/5 border-primary/20 border-2", children: l.jsxs("div", { className: "flex items-start justify-between gap-4", children: [l.jsxs("div", { className: "flex-1", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [l.jsx(oi, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "font-semibold text-base sm:text-lg", children: "Time Slot Selected" })] }), l.jsxs("div", { className: "space-y-2 text-sm sm:text-base", children: [l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(ni, { className: "h-4 w-4 text-primary" }), l.jsx("span", { className: "font-medium", children: f })] }), x && B.find(Q => Q.id === m)?.interviewer && l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(qc, { className: "h-4 w-4 text-primary" }), l.jsxs("span", { className: "text-muted-foreground", children: ["Interviewer: ", l.jsx("span", { className: "font-medium text-foreground", children: B.find(Q => Q.id === m)?.interviewer?.name })] })] }), u && l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(li, { className: "h-4 w-4 text-primary" }), l.jsx("span", { className: "text-muted-foreground", children: u ? X(u) : "Not selected" })] })] })] }), l.jsx("div", { className: "flex-shrink-0", children: l.jsx(vt, { variant: "ghost", size: "sm", onClick: () => { g(""), h(""), v("") }, className: "text-muted-foreground hover:text-foreground", children: "Change" }) })] }) }) })] })] }), r === 2 && l.jsxs(Lt, { className: "p-6", children: [l.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Update Session Details" }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "duration", children: "Duration" }), l.jsxs(Jn, { value: b, onValueChange: E, children: [l.jsx(qn, { id: "duration", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "30", children: "30 minutes" }), l.jsx(ut, { value: "45", children: "45 minutes" }), l.jsx(ut, { value: "60", children: "60 minutes" }), l.jsx(ut, { value: "90", children: "90 minutes" })] })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "difficulty", children: "Difficulty Level" }), l.jsxs(Jn, { value: M, onValueChange: C, children: [l.jsx(qn, { id: "difficulty", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "beginner", children: "Beginner" }), l.jsx(ut, { value: "intermediate", children: "Intermediate" }), l.jsx(ut, { value: "advanced", children: "Advanced" }), l.jsx(ut, { value: "expert", children: "Expert" })] })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "focus", children: "Focus Area *" }), l.jsxs(Jn, { value: N, onValueChange: A, children: [l.jsx(qn, { id: "focus", children: l.jsx(er, { placeholder: "Select a focus area" }) }), l.jsx(Xn, { children: I.map(Q => l.jsx(ut, { value: Q, children: Q }, Q)) })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "language", children: "Language" }), l.jsxs(Jn, { value: j, onValueChange: Q => O(Q), children: [l.jsx(qn, { id: "language", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "english", children: "English" }), l.jsx(ut, { value: "arabic", children: "Arabic" })] })] })] })] })] }), r === 3 && l.jsxs(Lt, { className: "p-6", children: [l.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Confirm Reschedule" }), l.jsx("div", { className: "space-y-4", children: l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Date" }), l.jsx("p", { className: "font-semibold", children: u ? X(u) : "Not selected" })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Time" }), l.jsx("p", { className: "font-semibold", children: f || "Not selected" })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Duration" }), l.jsxs("p", { className: "font-semibold", children: [b, " minutes"] })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Language" }), l.jsx("p", { className: "font-semibold", children: j.charAt(0).toUpperCase() + j.slice(1) })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Difficulty" }), l.jsx("p", { className: "font-semibold", children: M.charAt(0).toUpperCase() + M.slice(1) })] }), N && l.jsxs("div", { children: [l.jsx(We, { className: "text-muted-foreground", children: "Focus Area" }), l.jsx("p", { className: "font-semibold", children: N })] })] }) })] })] }, r) }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs(vt, { variant: "outline", onClick: $, disabled: r === 1, children: [l.jsx(c5, { className: "w-4 h-4 mr-2" }), "Back"] }), r < 3 ? l.jsxs(vt, { onClick: Z, disabled: r === 1 && !q() || r === 2 && !Y(), className: r === 1 && q() ? "bg-gradient-primary text-primary-foreground hover:opacity-90" : "", children: ["Next", l.jsx(DS, { className: "w-4 h-4 ml-2" })] }) : l.jsx(vt, { onClick: V, disabled: G.isPending, size: "lg", className: "bg-gradient-primary text-primary-foreground", children: G.isPending ? l.jsxs(l.Fragment, { children: [l.jsx(sa, { className: "w-4 h-4 mr-2 animate-spin" }), "Rescheduling..."] }) : l.jsxs(l.Fragment, { children: [l.jsx(oi, { className: "w-4 h-4 mr-2" }), "Confirm Reschedule"] }) })] })] }) : l.jsx("div", { className: "max-w-4xl space-y-8 pb-20 lg:pb-8", children: l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "Session Not Found" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "The session you're looking for doesn't exist or you don't have access to it." }), l.jsx(vt, { onClick: () => t("/dashboard/trainee/sessions"), children: "Back to Sessions" })] }) }) } function pBe() { const [t, e] = S.useState(!1), [n, r] = S.useState(!1), [i, a] = S.useState("overview"), s = { fluency: 85, clarity: 92, pace: 78, confidence: 88, vocabulary: 90, grammar: 87 }, o = [{ skill: "Fluency", value: s.fluency, color: "hsl(var(--primary))" }, { skill: "Clarity", value: s.clarity, color: "hsl(var(--accent))" }, { skill: "Pace", value: s.pace, color: "hsl(var(--secondary))" }, { skill: "Confidence", value: s.confidence, color: "hsl(var(--warning))" }, { skill: "Vocabulary", value: s.vocabulary, color: "hsl(var(--success))" }, { skill: "Grammar", value: s.grammar, color: "hsl(var(--destructive))" }], c = [{ label: "Positive", value: 75, color: "bg-success" }, { label: "Neutral", value: 20, color: "bg-muted" }, { label: "Negative", value: 5, color: "bg-destructive" }], u = [{ x: "Week 1", y: 65 }, { x: "Week 2", y: 72 }, { x: "Week 3", y: 78 }, { x: "Week 4", y: 85 }, { x: "Week 5", y: 88 }], d = "Good morning, thank you for having me here today. I'm really excited about this opportunity to discuss my qualifications for the software engineer position. I have over five years of experience in full-stack development, with a strong focus on React and Node.js. In my previous role at TechCorp, I led a team of four developers and successfully delivered three major projects that increased our application performance by 40%. I'm particularly passionate about creating scalable solutions and mentoring junior developers.", f = [{ category: "Fluency", issue: "Slight hesitation at 0:15", suggestion: "Practice smooth transitions between topics", severity: "low" }, { category: "Pace", issue: "Speaking too quickly in technical sections", suggestion: "Slow down when explaining complex concepts", severity: "medium" }, { category: "Confidence", issue: "Voice pitch drops at 1:30", suggestion: "Maintain consistent energy throughout", severity: "low" }], h = () => { e(!t), t || setTimeout(() => { e(!1) }, 5e3) }, m = () => { r(!n) }; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Speech Analysis" }), l.jsx("p", { className: "text-muted-foreground", children: "Analyze your speaking patterns and improve your communication skills" })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, children: l.jsxs(sn, { className: "p-6", variant: "glass", children: [l.jsxs("div", { className: "flex items-center justify-between mb-6", children: [l.jsxs("h2", { className: "text-xl font-semibold flex items-center gap-2", children: [l.jsx(VT, { className: "h-5 w-5 text-primary" }), "Record New Session"] }), l.jsx(Jt, { variant: "outline", className: "text-xs", children: "AI-Powered Analysis" })] }), l.jsxs("div", { className: "flex items-center gap-4", children: [l.jsx(on, { onClick: h, variant: t ? "destructive" : "default", size: "lg", className: "flex items-center gap-2", motionProps: { whileHover: { scale: 1.05 }, whileTap: { scale: .95 } }, children: t ? l.jsxs(l.Fragment, { children: [l.jsx(NJ, { className: "h-5 w-5" }), "Stop Recording"] }) : l.jsxs(l.Fragment, { children: [l.jsx(VT, { className: "h-5 w-5" }), "Start Recording"] }) }), l.jsxs(on, { variant: "outline", size: "lg", className: "flex items-center gap-2", children: [l.jsx($S, { className: "h-5 w-5" }), "Upload Audio"] }), t && l.jsxs($e.div, { initial: { scale: 0 }, animate: { scale: 1 }, className: "flex items-center gap-2 text-destructive", children: [l.jsx("div", { className: "w-3 h-3 bg-destructive rounded-full animate-pulse" }), l.jsx("span", { className: "text-sm font-medium", children: "Recording..." })] })] })] }) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .2 }, children: l.jsxs(Sp, { value: i, onValueChange: a, className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-4", children: [l.jsx(Rr, { value: "overview", children: "Overview" }), l.jsx(Rr, { value: "transcript", children: "Transcript" }), l.jsx(Rr, { value: "metrics", children: "Metrics" }), l.jsx(Rr, { value: "improvements", children: "Improvements" })] }), l.jsxs(Dr, { value: "overview", className: "space-y-6", children: [l.jsxs("div", { className: "grid lg:grid-cols-2 gap-6", children: [l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(Qh, { className: "h-5 w-5 text-primary" }), "Speech Skills Overview"] }), l.jsx("div", { className: "flex justify-center", children: l.jsx(i$, { data: o, size: 300 }) })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(Fu, { className: "h-5 w-5 text-accent" }), "Key Metrics"] }), l.jsx("div", { className: "space-y-4", children: Object.entries(s).map(([g, x]) => l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: .1 }, className: "space-y-2", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsx("span", { className: "text-sm font-medium capitalize", children: g.replace(/([A-Z])/g, " $1").trim() }), l.jsxs("span", { className: "text-sm font-bold", children: [x, "%"] })] }), l.jsx(vu, { value: x, className: "h-2" })] }, g)) })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(s5, { className: "h-5 w-5 text-secondary" }), "Progress Over Time"] }), l.jsx("div", { className: "flex justify-center", children: l.jsx(j4e, { data: u, width: 600, height: 200 }) })] })] }), l.jsx(Dr, { value: "transcript", className: "space-y-6", children: l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsxs("h3", { className: "text-lg font-semibold flex items-center gap-2", children: [l.jsx(ff, { className: "h-5 w-5 text-primary" }), "Speech Transcript"] }), l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsxs(on, { variant: "outline", size: "sm", onClick: m, className: "flex items-center gap-2", children: [n ? l.jsx(Jve, { className: "h-4 w-4" }) : l.jsx(yg, { className: "h-4 w-4" }), n ? "Pause" : "Play"] }), l.jsxs(on, { variant: "outline", size: "sm", className: "flex items-center gap-2", children: [l.jsx(FS, { className: "h-4 w-4" }), "Export"] })] })] }), l.jsx("div", { className: "bg-muted/50 rounded-lg p-4 max-h-96 overflow-y-auto", children: l.jsx("p", { className: "text-sm leading-relaxed whitespace-pre-wrap", children: d }) }), l.jsxs("div", { className: "flex items-center gap-4 mt-4 text-sm text-muted-foreground", children: [l.jsxs("div", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-4 w-4" }), "Duration: 2:15"] }), l.jsxs("div", { className: "flex items-center gap-1", children: [l.jsx(sye, { className: "h-4 w-4" }), "Words: 127"] }), l.jsxs("div", { className: "flex items-center gap-1", children: [l.jsx(ro, { className: "h-4 w-4" }), "AI Confidence: 94%"] })] })] }) }), l.jsxs(Dr, { value: "metrics", className: "space-y-6", children: [l.jsxs("div", { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-6", children: [l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Sentiment Analysis" }), l.jsx("div", { className: "space-y-4", children: c.map((g, x) => l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: x * .1 }, className: "flex items-center justify-between", children: [l.jsx("span", { className: "text-sm", children: g.label }), l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx("div", { className: "w-16 h-2 bg-muted rounded-full overflow-hidden", children: l.jsx($e.div, { className: `h-full ${g.color}`, initial: { width: 0 }, animate: { width: `${g.value}%` }, transition: { delay: .5 + x * .1, duration: .8 } }) }), l.jsxs("span", { className: "text-sm font-medium w-8", children: [g.value, "%"] })] })] }, g.label)) })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Speaking Pace" }), l.jsxs("div", { className: "text-center", children: [l.jsx(h4, { value: 78, size: 120, color: "hsl(var(--primary))" }), l.jsx("p", { className: "text-sm text-muted-foreground mt-2", children: "Words per minute" })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Confidence Score" }), l.jsxs("div", { className: "text-center", children: [l.jsx(h4, { value: 88, size: 120, color: "hsl(var(--accent))" }), l.jsx("p", { className: "text-sm text-muted-foreground mt-2", children: "Overall confidence" })] })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Detailed Analysis" }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [l.jsxs("div", { className: "space-y-4", children: [l.jsx("h4", { className: "font-medium", children: "Speech Quality" }), l.jsx("div", { className: "space-y-3", children: [{ label: "Clarity", value: 92, color: "bg-success" }, { label: "Volume", value: 85, color: "bg-primary" }, { label: "Tone", value: 88, color: "bg-accent" }].map((g, x) => l.jsxs("div", { className: "space-y-1", children: [l.jsxs("div", { className: "flex justify-between text-sm", children: [l.jsx("span", { children: g.label }), l.jsxs("span", { children: [g.value, "%"] })] }), l.jsx("div", { className: "w-full bg-muted rounded-full h-2", children: l.jsx($e.div, { className: `h-2 rounded-full ${g.color}`, initial: { width: 0 }, animate: { width: `${g.value}%` }, transition: { delay: .5 + x * .1, duration: .8 } }) })] }, g.label)) })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsx("h4", { className: "font-medium", children: "Content Analysis" }), l.jsx("div", { className: "space-y-3", children: [{ label: "Vocabulary", value: 90, color: "bg-secondary" }, { label: "Grammar", value: 87, color: "bg-warning" }, { label: "Structure", value: 82, color: "bg-destructive" }].map((g, x) => l.jsxs("div", { className: "space-y-1", children: [l.jsxs("div", { className: "flex justify-between text-sm", children: [l.jsx("span", { children: g.label }), l.jsxs("span", { children: [g.value, "%"] })] }), l.jsx("div", { className: "w-full bg-muted rounded-full h-2", children: l.jsx($e.div, { className: `h-2 rounded-full ${g.color}`, initial: { width: 0 }, animate: { width: `${g.value}%` }, transition: { delay: .5 + x * .1, duration: .8 } }) })] }, g.label)) })] })] })] })] }), l.jsxs(Dr, { value: "improvements", className: "space-y-6", children: [l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(Ug, { className: "h-5 w-5 text-warning" }), "Areas for Improvement"] }), l.jsx("div", { className: "space-y-4", children: f.map((g, x) => l.jsx($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: x * .1 }, className: "p-4 rounded-lg border border-border hover:border-primary/50 transition-colors", children: l.jsxs("div", { className: "flex items-start gap-3", children: [l.jsx("div", { className: "flex-shrink-0", children: g.severity === "high" ? l.jsx(ji, { className: "h-5 w-5 text-destructive" }) : g.severity === "medium" ? l.jsx(ji, { className: "h-5 w-5 text-warning" }) : l.jsx(oi, { className: "h-5 w-5 text-success" }) }), l.jsxs("div", { className: "flex-1 space-y-2", children: [l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(Jt, { variant: g.severity === "high" ? "destructive" : g.severity === "medium" ? "warning" : "secondary", className: "text-xs", children: g.category }), l.jsx("span", { className: "text-sm font-medium", children: g.issue })] }), l.jsx("p", { className: "text-sm text-muted-foreground", children: g.suggestion })] })] }) }, x)) })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Practice Recommendations" }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-4", children: [l.jsxs("div", { className: "space-y-3", children: [l.jsx("h4", { className: "font-medium", children: "Daily Exercises" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: " Practice tongue twisters for clarity" }), l.jsx("li", { children: " Record yourself reading aloud" }), l.jsx("li", { children: " Practice breathing exercises" }), l.jsx("li", { children: " Slow down when explaining complex topics" })] })] }), l.jsxs("div", { className: "space-y-3", children: [l.jsx("h4", { className: "font-medium", children: "Weekly Goals" }), l.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [l.jsx("li", { children: " Complete 3 mock interviews" }), l.jsx("li", { children: " Practice elevator pitch" }), l.jsx("li", { children: " Review and improve weak areas" }), l.jsx("li", { children: " Track progress with metrics" })] })] })] })] })] })] }) })] }) } function mBe() { const e = [{ name: "Technical Skills", score: 85, feedback: "Strong understanding of core concepts. Great problem-solving approach.", icon: ro, color: "text-primary" }, { name: "Communication", score: 78, feedback: "Clear articulation. Could improve on structuring responses using frameworks.", icon: ff, color: "text-secondary" }, { name: "Problem Solving", score: 92, feedback: "Excellent analytical skills. Good at breaking down complex problems.", icon: Qh, color: "text-accent" }, { name: "Cultural Fit", score: 80, feedback: "Good alignment with company values. Showed enthusiasm for the role.", icon: mA, color: "text-warning" }, { name: "Confidence & Clarity", score: 75, feedback: "Confident delivery. Maintain better eye contact to enhance engagement.", icon: Ug, color: "text-primary" }, { name: "Time Management", score: 88, feedback: "Great pacing. Answered all questions within allocated time.", icon: ni, color: "text-secondary" }], n = [{ date: "Today", type: "AI Technical", score: 87, duration: "45 min", status: "completed" }, { date: "Yesterday", type: "Peer-to-Peer", score: 82, duration: "60 min", status: "completed" }, { date: "3 days ago", type: "Behavioral", score: 79, duration: "30 min", status: "completed" }, { date: "1 week ago", type: "System Design", score: 85, duration: "90 min", status: "completed" }], r = ["Strong technical foundation", "Excellent problem-solving skills", "Good time management", "Clear and structured thinking"], i = ["Practice STAR method for behavioral questions", "Improve eye contact during video interviews", "Work on articulating thought process", "Enhance cultural fit responses"]; return l.jsxs("div", { className: "max-w-6xl space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Interview Feedback" }), l.jsx("p", { className: "text-muted-foreground", children: "Detailed performance analysis and recommendations for improvement" })] }), l.jsxs(Lt, { className: "p-8 bg-gradient-primary text-primary-foreground", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx("h2", { className: "text-2xl font-semibold", children: "Overall Performance" }), l.jsx("p", { className: "text-sm opacity-90", children: "Based on your last interview session" })] }), l.jsxs("div", { className: "text-center", children: [l.jsx("div", { className: "text-6xl font-bold mb-2", children: 87 }), l.jsx("div", { className: "text-sm opacity-90", children: "out of 100" })] })] }), l.jsxs("div", { className: "mt-6 flex items-center gap-4", children: [l.jsx(vu, { value: 87, className: "flex-1 bg-primary-foreground/20 h-3" }), l.jsxs(Jt, { className: "bg-accent text-accent-foreground", children: [l.jsx(Fu, { className: "h-3 w-3 mr-1" }), "+5% from last time"] })] })] }), l.jsxs(Sp, { defaultValue: "categories", className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-3", children: [l.jsx(Rr, { value: "categories", children: "By Category" }), l.jsx(Rr, { value: "history", children: "Session History" }), l.jsx(Rr, { value: "insights", children: "Insights" })] }), l.jsx(Dr, { value: "categories", className: "space-y-6", children: l.jsx("div", { className: "grid md:grid-cols-2 gap-6", children: e.map((a, s) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: s * .1 }, children: l.jsxs(Lt, { className: "p-6 hover-lift", children: [l.jsxs("div", { className: "flex items-start justify-between mb-4", children: [l.jsxs("div", { className: "flex items-center gap-3", children: [l.jsx(a.icon, { className: `h-6 w-6 ${a.color}` }), l.jsx("div", { children: l.jsx("h3", { className: "font-semibold", children: a.name }) })] }), l.jsx("span", { className: "text-2xl font-bold", children: a.score })] }), l.jsx(vu, { value: a.score, className: "mb-3 h-2" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: a.feedback })] }) }, a.name)) }) }), l.jsxs(Dr, { value: "history", className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx("h2", { className: "text-xl font-semibold", children: "Recent Sessions" }), l.jsxs(vt, { variant: "outline", size: "sm", children: [l.jsx(FS, { className: "h-4 w-4 mr-2" }), "Export Report"] })] }), n.map((a, s) => l.jsx($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .4, delay: s * .1 }, children: l.jsx(Lt, { className: "p-6", children: l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "flex items-center gap-4", children: [l.jsxs("div", { className: "text-center", children: [l.jsx("div", { className: "text-2xl font-bold", children: a.score }), l.jsx("div", { className: "text-xs text-muted-foreground", children: "Score" })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold mb-1", children: a.type }), l.jsxs("div", { className: "flex items-center gap-3 text-sm text-muted-foreground", children: [l.jsx("span", { children: a.date }), l.jsx("span", { children: "" }), l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-3 w-3" }), a.duration] })] })] })] }), l.jsx(vt, { variant: "outline", size: "sm", children: "View Details" })] }) }) }, s))] }), l.jsxs(Dr, { value: "insights", className: "space-y-6", children: [l.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(oi, { className: "h-5 w-5 text-accent" }), l.jsx("h3", { className: "text-xl font-semibold", children: "Your Strengths" })] }), l.jsx("div", { className: "space-y-3", children: r.map((a, s) => l.jsxs($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .4, delay: s * .1 }, className: "flex items-start gap-3 p-3 rounded-lg bg-accent/10", children: [l.jsx(oi, { className: "h-4 w-4 text-accent mt-0.5 flex-shrink-0" }), l.jsx("span", { className: "text-sm", children: a })] }, s)) })] }), l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(ji, { className: "h-5 w-5 text-warning" }), l.jsx("h3", { className: "text-xl font-semibold", children: "Areas to Improve" })] }), l.jsx("div", { className: "space-y-3", children: i.map((a, s) => l.jsxs($e.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .4, delay: s * .1 }, className: "flex items-start gap-3 p-3 rounded-lg bg-warning/10", children: [l.jsx(ji, { className: "h-4 w-4 text-warning mt-0.5 flex-shrink-0" }), l.jsx("span", { className: "text-sm", children: a })] }, s)) })] })] }), l.jsxs(Lt, { className: "p-6 bg-primary/5 border-primary/20", children: [l.jsx("h3", { className: "text-xl font-semibold mb-4", children: "Personalized Recommendations" }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex gap-3", children: [l.jsx(Qh, { className: "h-5 w-5 text-primary mt-0.5 flex-shrink-0" }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-medium mb-1", children: "Focus on Behavioral Questions" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Schedule 2-3 sessions focusing specifically on behavioral questions using the STAR method." })] })] }), l.jsxs("div", { className: "flex gap-3", children: [l.jsx(ro, { className: "h-5 w-5 text-primary mt-0.5 flex-shrink-0" }), l.jsxs("div", { children: [l.jsx("h4", { className: "font-medium mb-1", children: "Practice Video Presence" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Work on maintaining eye contact with the camera to build stronger engagement in virtual interviews." })] })] })] })] })] })] })] }) } const gBe = $g("relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground", { variants: { variant: { default: "bg-background text-foreground", destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive" } }, defaultVariants: { variant: "default" } }), tN = S.forwardRef(({ className: t, variant: e, ...n }, r) => l.jsx("div", { ref: r, role: "alert", className: _t(gBe({ variant: e }), t), ...n })); tN.displayName = "Alert"; const vBe = S.forwardRef(({ className: t, ...e }, n) => l.jsx("h5", { ref: n, className: _t("mb-1 font-medium leading-none tracking-tight", t), ...e })); vBe.displayName = "AlertTitle"; const nN = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { ref: n, className: _t("text-sm [&_p]:leading-relaxed", t), ...e })); nN.displayName = "AlertDescription"; function Q7() { const t = ui(), [e, n] = S.useState(!1), r = () => { dt.success("Settings saved successfully!") }, i = () => { dt.success("Logged out successfully!"), t("/") }, a = () => { dt.success("Account deletion initiated. You will receive an email confirmation."), n(!1), t("/") }; return l.jsxs("div", { className: "max-w-4xl space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Settings" }), l.jsx("p", { className: "text-muted-foreground", children: "Manage your account settings and preferences" })] }), l.jsxs(Sp, { defaultValue: "profile", className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-5", children: [l.jsx(Rr, { value: "profile", children: "Profile" }), l.jsx(Rr, { value: "notifications", children: "Notifications" }), l.jsx(Rr, { value: "privacy", children: "Privacy" }), l.jsx(Rr, { value: "preferences", children: "Preferences" }), l.jsx(Rr, { value: "account", children: "Account" })] }), l.jsx(Dr, { value: "profile", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-6 mb-6", children: [l.jsxs(Vc, { className: "h-24 w-24", children: [l.jsx(xf, { src: "https://api.dicebear.com/7.x/avataaars/svg?seed=John" }), l.jsx(Hc, { children: "JD" })] }), l.jsxs("div", { children: [l.jsxs(vt, { variant: "outline", size: "sm", children: [l.jsx($S, { className: "h-4 w-4 mr-2" }), "Upload Photo"] }), l.jsx("p", { className: "text-xs text-muted-foreground mt-2", children: "JPG, PNG or GIF. Max size 2MB." })] })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "grid sm:grid-cols-2 gap-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "firstName", children: "First Name" }), l.jsx(fn, { id: "firstName", defaultValue: "John" })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "lastName", children: "Last Name" }), l.jsx(fn, { id: "lastName", defaultValue: "Doe" })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "email", children: "Email" }), l.jsx(fn, { id: "email", type: "email", defaultValue: "john@example.com" })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "phone", children: "Phone Number" }), l.jsx(fn, { id: "phone", type: "tel", defaultValue: "+1 (555) 123-4567" })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "bio", children: "Bio" }), l.jsx(fn, { id: "bio", defaultValue: "Software Engineer passionate about web development" })] })] }), l.jsx("div", { className: "flex justify-end mt-6", children: l.jsx(vt, { onClick: r, children: "Save Changes" }) })] }) }), l.jsx(Dr, { value: "notifications", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(lx, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "text-lg font-semibold", children: "Email Notifications" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Interview Reminders" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Get notified about upcoming interviews" })] }), l.jsx(Aa, { defaultChecked: !0 })] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Feedback Available" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Receive notifications when feedback is ready" })] }), l.jsx(Aa, { defaultChecked: !0 })] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Weekly Progress Report" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Get weekly summaries of your progress" })] }), l.jsx(Aa, {})] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "New Features" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Updates about new platform features" })] }), l.jsx(Aa, {})] })] }), l.jsx(Na, { className: "my-6" }), l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(lx, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "text-lg font-semibold", children: "Push Notifications" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Session Starting Soon" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "15 minutes before your session starts" })] }), l.jsx(Aa, { defaultChecked: !0 })] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Peer Requests" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "When someone requests to practice with you" })] }), l.jsx(Aa, { defaultChecked: !0 })] })] }), l.jsx("div", { className: "flex justify-end mt-6", children: l.jsx(vt, { onClick: r, children: "Save Preferences" }) })] }) }), l.jsx(Dr, { value: "privacy", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(cx, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "text-lg font-semibold", children: "Privacy Settings" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Profile Visibility" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Make your profile visible to other users" })] }), l.jsx(Aa, { defaultChecked: !0 })] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Show Progress" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Display your progress to peer interviewers" })] }), l.jsx(Aa, {})] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Recording Consent" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Allow sessions to be recorded for feedback" })] }), l.jsx(Aa, { defaultChecked: !0 })] })] }), l.jsx(Na, { className: "my-6" }), l.jsxs("div", { className: "space-y-4", children: [l.jsx("h4", { className: "font-semibold", children: "Change Password" }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "currentPassword", children: "Current Password" }), l.jsx(fn, { id: "currentPassword", type: "password" })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "newPassword", children: "New Password" }), l.jsx(fn, { id: "newPassword", type: "password" })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "confirmPassword", children: "Confirm New Password" }), l.jsx(fn, { id: "confirmPassword", type: "password" })] }), l.jsx(vt, { children: "Update Password" })] }), l.jsx("div", { className: "flex justify-end mt-6", children: l.jsx(vt, { onClick: r, children: "Save Settings" }) })] }) }), l.jsx(Dr, { value: "preferences", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(EJ, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "text-lg font-semibold", children: "Language & Region" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "language", children: "Language" }), l.jsxs("select", { id: "language", className: "w-full h-10 px-3 rounded-md border border-input bg-background", children: [l.jsx("option", { value: "en", children: "English" }), l.jsx("option", { value: "ar", children: "Arabic ()" })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "timezone", children: "Timezone" }), l.jsxs("select", { id: "timezone", className: "w-full h-10 px-3 rounded-md border border-input bg-background", children: [l.jsx("option", { value: "utc", children: "UTC" }), l.jsx("option", { value: "est", children: "Eastern Time (ET)" }), l.jsx("option", { value: "pst", children: "Pacific Time (PT)" }), l.jsx("option", { value: "gmt", children: "GMT" })] })] })] }), l.jsx(Na, { className: "my-6" }), l.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [l.jsx(hf, { className: "h-5 w-5 text-primary" }), l.jsx("h3", { className: "text-lg font-semibold", children: "Interview Preferences" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "defaultDuration", children: "Default Session Duration" }), l.jsxs("select", { id: "defaultDuration", className: "w-full h-10 px-3 rounded-md border border-input bg-background", children: [l.jsx("option", { value: "30", children: "30 minutes" }), l.jsx("option", { value: "45", children: "45 minutes" }), l.jsx("option", { value: "60", children: "60 minutes" })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "defaultMode", children: "Preferred Interview Mode" }), l.jsxs("select", { id: "defaultMode", className: "w-full h-10 px-3 rounded-md border border-input bg-background", children: [l.jsx("option", { value: "ai", children: "AI-Powered" }), l.jsx("option", { value: "peer", children: "Peer-to-Peer" }), l.jsx("option", { value: "family", children: "Family & Friends" }), l.jsx("option", { value: "live", children: "Live Mock Interview" })] })] })] }), l.jsx("div", { className: "flex justify-end mt-6", children: l.jsx(vt, { onClick: r, children: "Save Preferences" }) })] }) }), l.jsx(Dr, { value: "account", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(hf, { className: "h-5 w-5 text-primary" }), "Account Management"] }), l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { className: "flex items-center justify-between p-4 border border-border rounded-lg", children: [l.jsxs("div", { children: [l.jsx("h4", { className: "font-medium", children: "Logout" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Sign out of your account" })] }), l.jsxs(vt, { variant: "outline", onClick: i, children: [l.jsx(CJ, { className: "h-4 w-4 mr-2" }), "Logout"] })] }), l.jsxs("div", { className: "flex items-center justify-between p-4 border border-border rounded-lg", children: [l.jsxs("div", { children: [l.jsx("h4", { className: "font-medium", children: "Privacy Policy" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Read our privacy policy" })] }), l.jsxs(vt, { variant: "outline", onClick: () => window.open("/privacy", "_blank"), children: [l.jsx(Xve, { className: "h-4 w-4 mr-2" }), "View Policy"] })] }), l.jsx(Na, {}), l.jsxs(tN, { className: "border-destructive/50 bg-destructive/5", children: [l.jsx(p0, { className: "h-4 w-4 text-destructive" }), l.jsx(nN, { children: l.jsxs("div", { className: "space-y-2", children: [l.jsx("p", { className: "font-medium text-destructive", children: "Danger Zone" }), l.jsx("p", { className: "text-sm", children: "Once you delete your account, there is no going back. Please be certain." })] }) })] }), l.jsxs("div", { className: "flex items-center justify-between p-4 border border-destructive/50 rounded-lg bg-destructive/5", children: [l.jsxs("div", { children: [l.jsx("h4", { className: "font-medium text-destructive", children: "Delete Account" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Permanently delete your account and all associated data" })] }), l.jsxs(sl, { open: e, onOpenChange: n, children: [l.jsx(OCe, { asChild: !0, children: l.jsxs(vt, { variant: "destructive", children: [l.jsx(Bg, { className: "h-4 w-4 mr-2" }), "Delete Account"] }) }), l.jsxs(jo, { children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Delete Account" }), l.jsx(ol, { children: "Are you sure you want to delete your account? This action cannot be undone. All your data, including interview history and progress, will be permanently deleted." })] }), l.jsxs("div", { className: "flex justify-end gap-2 mt-4", children: [l.jsx(vt, { variant: "outline", onClick: () => n(!1), children: "Cancel" }), l.jsx(vt, { variant: "destructive", onClick: a, children: "Delete Account" })] })] })] })] })] })] }) })] })] }) } const yBe = t => { switch (t) { case "success": return oi; case "warning": return ji; case "error": return ji; default: return h5 } }, xBe = t => { switch (t) { case "success": return "text-accent"; case "warning": return "text-warning"; case "error": return "text-destructive"; default: return "text-primary" } }; function Sk() { const t = Xc(), e = fs(), n = ui(), { refreshNotifications: r } = OS(), i = S.useRef({}), a = e.state?.notificationId, { data: s, isLoading: o, error: c } = oo({ queryKey: ["notifications", "all"], queryFn: () => Jd.getNotifications({ limit: 100 }) }), u = s?.data || [], d = Cs({ mutationFn: v => Jd.deleteNotification(v), onSuccess: () => { t.invalidateQueries({ queryKey: ["notifications"] }), r(), dt.success("Notification deleted") }, onError: () => { dt.error("Failed to delete notification") } }), f = Cs({ mutationFn: v => Jd.markAsRead(v), onSuccess: () => { t.invalidateQueries({ queryKey: ["notifications"] }), r() } }), h = Cs({ mutationFn: () => Jd.markAllAsRead(), onSuccess: () => { t.invalidateQueries({ queryKey: ["notifications"] }), r(), dt.success("All notifications marked as read") }, onError: () => { dt.error("Failed to mark all as read") } }), m = (v, b) => { v.stopPropagation(), d.mutate(b) }, g = v => { f.mutate(v) }, x = u.filter(v => !v.isRead).length; return S.useEffect(() => { if (!a || u.length === 0) return; const v = u.find(C => String(C._id) === String(a) || String(C._id?.toString()) === String(a)); if (!v) return; const b = () => { const C = i.current[v._id]; if (C) { const j = C.getBoundingClientRect().top + window.pageYOffset - 100; window.scrollTo({ top: Math.max(0, j), behavior: "smooth" }), v.isRead || f.mutate(v._id) } else setTimeout(b, 200) }, E = setTimeout(b, 500), M = setTimeout(() => { n(e.pathname, { replace: !0, state: null }) }, 2e3); return () => { clearTimeout(E), clearTimeout(M) } }, [a, u.length]), c ? l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Notifications" }), l.jsx("p", { className: "text-muted-foreground", children: "View and manage all your notifications" })] }), l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(ji, { className: "h-12 w-12 text-destructive mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "Failed to load notifications" }), l.jsx("p", { className: "text-muted-foreground", children: c instanceof Error ? c.message : "An error occurred" })] })] }) : l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Notifications" }), l.jsx("p", { className: "text-muted-foreground", children: "View and manage all your notifications" })] }), x > 0 && l.jsx(vt, { variant: "outline", onClick: () => h.mutate(), disabled: h.isPending, children: "Mark all as read" })] }), o ? l.jsx(Lt, { className: "p-12 text-center", children: l.jsx("p", { className: "text-muted-foreground", children: "Loading notifications..." }) }) : u.length === 0 ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(lx, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4 opacity-50" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "No notifications" }), l.jsx("p", { className: "text-muted-foreground", children: "You don't have any notifications yet" })] }) : l.jsx("div", { className: "space-y-4", children: u.map((v, b) => { const E = yBe(v.type), M = xBe(v.type), C = new Date(v.createdAt), N = a && String(a) === String(v._id); return l.jsx($e.div, { ref: A => { v._id && (i.current[v._id] = A) }, initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: b * .05 }, children: l.jsx(Lt, { className: `p-6 hover:bg-muted/50 transition-colors group ${v.isRead ? "" : "bg-primary/5 border-primary/20"} ${N ? "ring-2 ring-primary ring-offset-2 shadow-lg bg-primary/10" : ""}`, style: N ? { animation: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) 3" } : void 0, children: l.jsxs("div", { className: "flex items-start gap-4", children: [l.jsx("div", { className: `p-2 rounded-lg ${M} bg-background`, children: l.jsx(E, { className: "h-5 w-5" }) }), l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsxs("div", { className: "flex items-start justify-between gap-4 mb-2", children: [l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [l.jsx("h3", { className: "font-semibold text-lg", children: v.title }), !v.isRead && l.jsx(Jt, { variant: "default", className: "text-xs", children: "New" })] }), l.jsx("p", { className: "text-muted-foreground whitespace-pre-wrap break-words", children: v.message })] }), l.jsx(vt, { variant: "ghost", size: "icon", className: "h-8 w-8 flex-shrink-0 opacity-0 group-hover:opacity-100 hover:bg-destructive/10 hover:text-destructive transition-opacity", onClick: A => m(A, v._id), disabled: d.isPending, children: l.jsx(Bg, { className: "h-4 w-4" }) })] }), l.jsxs("div", { className: "flex items-center justify-between mt-4", children: [l.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [l.jsx(ni, { className: "h-4 w-4" }), l.jsx("span", { children: xr(C, "MMM d, yyyy 'at' h:mm a") })] }), !v.isRead && l.jsx(vt, { variant: "outline", size: "sm", onClick: () => g(v._id), disabled: f.isPending, children: "Mark as read" })] })] })] }) }) }, v._id) }) })] }) } const bBe = t => { if (!t) return "Date TBD"; try { const e = ao(t); return k0(e) ? "Today" : w_(e) ? "Tomorrow" : xr(e, "EEE, MMM d") } catch { return "Date TBD" } }, wBe = t => { switch (t) { case "ai": return "AI-Powered"; case "peer": return "Peer-to-Peer"; case "family": return "Family & Friends"; case "live": return "Live Mock"; default: return t } }, SBe = t => { switch (t?.toLowerCase()) { case "beginner": return "bg-green-100 text-green-800 border-green-200"; case "intermediate": return "bg-yellow-100 text-yellow-800 border-yellow-200"; case "advanced": case "expert": return "bg-red-100 text-red-800 border-red-200"; default: return "bg-gray-100 text-gray-800 border-gray-200" } }; function _Be() { const t = ui(), { user: e } = La(), { data: n, isLoading: r, error: i } = oo({ queryKey: ["interviewerDashboard"], queryFn: () => s$.getInterviewerDashboard(), staleTime: 3e4 }), a = n?.data?.stats, s = n?.data?.upcomingInterviews || []; if (r) return l.jsxs("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx(Ks, { className: "h-9 w-64 mb-2" }), l.jsx(Ks, { className: "h-5 w-96" })] }), l.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6", children: [1, 2, 3, 4].map(c => l.jsxs(Lt, { className: "p-6", children: [l.jsx(Ks, { className: "h-5 w-24 mb-4" }), l.jsx(Ks, { className: "h-8 w-20 mb-2" }), l.jsx(Ks, { className: "h-4 w-32" })] }, c)) })] }); if (i) return l.jsx("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: l.jsx("div", { className: "flex items-center justify-center h-64", children: l.jsxs("div", { className: "text-center", children: [l.jsx(ji, { className: "h-12 w-12 text-destructive mx-auto mb-4" }), l.jsx("p", { className: "text-lg font-semibold mb-2", children: "Failed to load dashboard" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "Please try refreshing the page" }), l.jsx(vt, { onClick: () => window.location.reload(), children: "Refresh" })] }) }) }); const o = e?.name || "Interviewer"; return l.jsxs("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsxs("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: ["Welcome back, ", o, "! "] }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Manage your assigned interviews and provide valuable feedback to candidates" })] }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6", children: [l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(qc, { className: "h-6 w-6 sm:h-8 sm:w-8 text-primary" }), l.jsx("div", { className: "text-right", children: l.jsx("div", { className: "text-2xl sm:text-3xl font-bold", children: a?.totalInterviews || 0 }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Total Interviews" }), l.jsxs("p", { className: "text-xs text-muted-foreground", children: [a?.completedInterviews || 0, " completed"] })] })] }), l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(oi, { className: "h-6 w-6 sm:h-8 sm:w-8 text-success" }), l.jsx("div", { className: "text-right", children: l.jsxs("div", { className: "text-2xl sm:text-3xl font-bold", children: [a?.completionRate || 0, "%"] }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Completion Rate" }), l.jsxs("p", { className: "text-xs text-muted-foreground", children: [a?.completedInterviews || 0, " / ", a?.totalInterviews || 0] })] })] }), l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(s5, { className: "h-6 w-6 sm:h-8 sm:w-8 text-accent" }), l.jsx("div", { className: "text-right", children: l.jsx("div", { className: "text-2xl sm:text-3xl font-bold", children: a?.activeSessions || 0 }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Active Sessions" }), l.jsx("p", { className: "text-xs text-muted-foreground", children: "Currently in progress" })] })] }), l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4", children: [l.jsx(li, { className: "h-6 w-6 sm:h-8 sm:w-8 text-warning" }), l.jsx("div", { className: "text-right", children: l.jsx("div", { className: "text-2xl sm:text-3xl font-bold", children: a?.todayCount || 0 }) })] }), l.jsxs("div", { className: "space-y-1", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium", children: "Today's Interviews" }), l.jsxs("p", { className: "text-xs text-muted-foreground", children: [s.length, " upcoming"] })] })] })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .2 }, children: l.jsxs(Lt, { className: "p-4 sm:p-6", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4 sm:mb-6", children: [l.jsxs("h2", { className: "text-lg sm:text-xl font-semibold flex items-center gap-2", children: [l.jsx(li, { className: "h-5 w-5 text-primary" }), "Assigned Interviews"] }), l.jsxs(vt, { variant: "ghost", size: "sm", onClick: () => t(cr.INTERVIEWER_ASSIGNED), className: "text-xs sm:text-sm", children: ["View All", l.jsx(o5, { className: "ml-2 h-3 w-3 sm:h-4 sm:w-4" })] })] }), l.jsx("div", { className: "space-y-3 sm:space-y-4", children: s.length > 0 ? s.map((c, u) => l.jsx($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: u * .1 }, className: "p-3 sm:p-4 rounded-lg border border-border hover:border-primary/50 transition-colors", children: l.jsxs("div", { className: "flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 sm:gap-4", children: [l.jsxs("div", { className: "flex items-center gap-3 sm:gap-4 flex-1 min-w-0", children: [l.jsx(Vc, { className: "h-10 w-10 sm:h-12 sm:w-12 flex-shrink-0", children: l.jsx(Hc, { children: c.trainee?.name?.split(" ").map(d => d[0]).join("").toUpperCase() || "U" }) }), l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsx("h3", { className: "text-sm sm:text-base font-semibold truncate", children: c.trainee?.name || "Trainee" }), l.jsxs("p", { className: "text-xs sm:text-sm text-muted-foreground", children: [bBe(c.scheduledDate), " at ", c.timeSlot] }), l.jsxs("div", { className: "flex items-center gap-2 mt-1 flex-wrap", children: [c.difficulty && l.jsx(Jt, { variant: "outline", className: `text-xs ${SBe(c.difficulty)}`, children: c.difficulty }), l.jsx(Jt, { variant: "secondary", className: "text-xs", children: wBe(c.mode) }), l.jsxs("span", { className: "text-xs text-muted-foreground flex items-center gap-1", children: [l.jsx(ni, { className: "h-3 w-3" }), c.duration, " min"] })] })] })] }), l.jsx("div", { className: "flex items-center gap-2 sm:flex-shrink-0", children: l.jsxs(vt, { size: "sm", variant: "outline", onClick: () => t(`${cr.INTERVIEWER_ASSIGNED}/${c._id}`), className: "text-xs sm:text-sm", children: [l.jsx(Fo, { className: "h-3 w-3 sm:h-4 sm:w-4 mr-1 sm:mr-2" }), "View Details"] }) })] }) }, c._id)) : l.jsxs("div", { className: "text-center py-8 sm:py-12", children: [l.jsx(li, { className: "h-12 w-12 sm:h-16 sm:w-16 text-muted-foreground mx-auto mb-4" }), l.jsx("p", { className: "text-sm sm:text-base font-medium mb-2", children: "No upcoming interviews" }), l.jsx("p", { className: "text-xs sm:text-sm text-muted-foreground mb-4", children: "Your assigned interviews will appear here" }), l.jsx(vt, { onClick: () => t(cr.INTERVIEWER_CALENDAR), children: "View Calendar" })] }) })] }) })] }) } const v4 = { async getAssignedInterviews(t) { const e = new URLSearchParams; t?.status && t.status !== "all" && e.append("status", t.status), t?.mode && t.mode !== "all" && e.append("mode", t.mode); const n = e.toString() ? `?${e.toString()}` : ""; return Yn.get(`${jn.interviewerInterviews.getAll}${n}`) }, async getAssignedInterviewById(t) { return Yn.get(jn.interviewerInterviews.getById(t)) }, async updateInterviewStatus(t, e) { return Yn.put(jn.interviewerInterviews.updateStatus(t), e) } }, J7 = t => { if (!t) return "Date not set"; try { const e = ao(t); return !e || isNaN(e.getTime()) ? "Invalid date" : k0(e) ? "Today" : w_(e) ? "Tomorrow" : xr(e, "MMM d, yyyy") } catch { return "Invalid date" } }, e9 = t => { switch (t) { case "scheduled": return "default"; case "in_progress": return "secondary"; case "completed": return "default"; case "cancelled": return "destructive"; case "no_show": return "destructive"; default: return "secondary" } }, t9 = t => { switch (t) { case "completed": return xJ; case "cancelled": case "no_show": return LS; case "in_progress": return p0; default: return li } }; function EBe() { const t = ui(), e = Xc(), { data: n, isLoading: r, error: i, refetch: a } = oo({ queryKey: ["interviewerAssignedInterviews"], queryFn: () => v4.getAssignedInterviews() }), s = Cs({ mutationFn: ({ id: g, status: x }) => v4.updateInterviewStatus(g, { status: x }), onSuccess: () => { dt.success("Interview status updated successfully"), e.invalidateQueries({ queryKey: ["interviewerAssignedInterviews"] }) }, onError: g => { dt.error(g.message || "Failed to update interview status") } }), o = n?.data || [], c = g => { if (!g) return null; try { return ao(g) } catch { return null } }, u = o.filter(g => { if (!g.scheduledDate) return !1; const x = c(g.scheduledDate); return x ? !Rx(x) && g.status !== "completed" && g.status !== "cancelled" : !1 }).sort((g, x) => { const v = c(g.scheduledDate), b = c(x.scheduledDate); if (!v || !b) return 0; const E = v.getTime(), M = b.getTime(); return E !== M ? E - M : (g.timeSlot || "").localeCompare(x.timeSlot || "") }), d = o.filter(g => { if (!g.scheduledDate) return g.status === "completed" || g.status === "cancelled"; const x = c(g.scheduledDate); return x ? Rx(x) || g.status === "completed" || g.status === "cancelled" : g.status === "completed" || g.status === "cancelled" }).sort((g, x) => { const v = c(g.scheduledDate), b = c(x.scheduledDate); if (!v || !b) return 0; const E = v.getTime(), M = b.getTime(); return E !== M ? M - E : (x.timeSlot || "").localeCompare(g.timeSlot || "") }), f = g => { s.mutate({ id: g._id, status: "in_progress" }), g.meetingLink ? window.open(g.meetingLink, "_blank") : t(`/dashboard/trainee/sessions/${g._id}`, { state: { isInterviewer: !0 } }) }, h = g => { g.meetingLink ? window.open(g.meetingLink, "_blank") : t(`/dashboard/trainee/sessions/${g._id}`, { state: { isInterviewer: !0 } }) }, m = g => { t(cr.INTERVIEWER_FEEDBACK, { state: { interviewId: g._id } }) }; return i ? l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Assigned Interviews" }), l.jsx("p", { className: "text-muted-foreground", children: "View and manage your assigned interview sessions" })] }), l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(ji, { className: "h-12 w-12 text-destructive mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "Failed to load interviews" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: i instanceof Error ? i.message : "An error occurred while loading interviews" }), l.jsx(vt, { onClick: () => a(), children: "Try Again" })] })] }) : l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { className: "flex justify-between items-center", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Assigned Interviews" }), l.jsx("p", { className: "text-muted-foreground", children: "View and manage your assigned interview sessions" })] }), l.jsxs(vt, { variant: "outline", onClick: () => t(cr.INTERVIEWER_CALENDAR), children: [l.jsx(li, { className: "mr-2 h-4 w-4" }), "View Calendar"] })] }), r ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(sa, { className: "h-12 w-12 animate-spin text-primary mx-auto mb-4" }), l.jsx("p", { className: "text-muted-foreground", children: "Loading assigned interviews..." })] }) : l.jsxs(Sp, { defaultValue: "upcoming", className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-2 max-w-md", children: [l.jsxs(Rr, { value: "upcoming", children: ["Upcoming (", u.length, ")"] }), l.jsxs(Rr, { value: "past", children: ["Past Interviews (", d.length, ")"] })] }), l.jsx(Dr, { value: "upcoming", className: "space-y-4", children: u.length === 0 ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(li, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "No upcoming interviews" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "You don't have any scheduled interviews at the moment" }), l.jsx(vt, { onClick: () => t(cr.INTERVIEWER_DASHBOARD), children: "View Dashboard" })] }) : l.jsx(l.Fragment, { children: u.map((g, x) => { const v = t9(g.status); return l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: x * .1 }, children: l.jsx(Lt, { className: "p-6 hover-lift", children: l.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-center justify-between gap-4", children: [l.jsxs("div", { className: "flex items-start gap-4 flex-1", children: [l.jsx("div", { className: "p-3 rounded-lg bg-primary/10", children: l.jsx(Fo, { className: "h-6 w-6 text-primary" }) }), l.jsxs("div", { className: "flex-1", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [l.jsx(hf, { className: "h-5 w-5 text-muted-foreground" }), l.jsx("h3", { className: "text-lg font-semibold", children: g.trainee?.name || "Unknown Trainee" }), g.focusArea && l.jsx(Jt, { variant: "outline", children: g.focusArea })] }), l.jsxs("div", { className: "flex flex-wrap items-center gap-4 text-sm text-muted-foreground", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(li, { className: "h-4 w-4" }), J7(g.scheduledDate)] }), l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-4 w-4" }), g.timeSlot || "Time not set", "  ", g.duration || 0, " min"] }), g.difficulty && l.jsx(Jt, { variant: "outline", children: g.difficulty.charAt(0).toUpperCase() + g.difficulty.slice(1) }), l.jsxs(Jt, { variant: e9(g.status), children: [l.jsx(v, { className: "h-3 w-3 mr-1" }), g.status.replace("_", " ").charAt(0).toUpperCase() + g.status.replace("_", " ").slice(1)] }), g.language && l.jsx(Jt, { variant: "secondary", children: g.language.charAt(0).toUpperCase() + g.language.slice(1) })] }), g.trainee?.email && l.jsxs("p", { className: "text-sm text-muted-foreground mt-2", children: ["Email: ", g.trainee.email] })] })] }), l.jsxs("div", { className: "flex items-center gap-2", children: [g.status === "scheduled" && l.jsxs(l.Fragment, { children: [l.jsxs(vt, { variant: "outline", size: "sm", onClick: () => m(g), children: [l.jsx(Du, { className: "h-4 w-4 mr-2" }), "View Details"] }), l.jsxs(vt, { size: "sm", onClick: () => f(g), className: "bg-gradient-primary text-primary-foreground", disabled: s.isPending, children: [s.isPending ? l.jsx(sa, { className: "h-4 w-4 mr-2 animate-spin" }) : l.jsx(yg, { className: "h-4 w-4 mr-2" }), "Start Interview"] })] }), g.status === "in_progress" && l.jsxs(vt, { size: "sm", onClick: () => h(g), className: "bg-gradient-primary text-primary-foreground", children: [l.jsx(Fo, { className: "h-4 w-4 mr-2" }), "Join Interview"] }), g.status === "cancelled" && l.jsx(Jt, { variant: "destructive", children: "Cancelled" })] })] }) }) }, g._id) }) }) }), l.jsx(Dr, { value: "past", className: "space-y-4", children: d.length === 0 ? l.jsxs(Lt, { className: "p-12 text-center", children: [l.jsx(li, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }), l.jsx("h3", { className: "text-lg font-semibold mb-2", children: "No past interviews" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "Your completed interview sessions will appear here" })] }) : l.jsx(l.Fragment, { children: d.map((g, x) => { const v = t9(g.status); return l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .4, delay: x * .1 }, children: l.jsx(Lt, { className: "p-6 hover-lift", children: l.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-center justify-between gap-4", children: [l.jsxs("div", { className: "flex items-start gap-4 flex-1", children: [l.jsx("div", { className: "p-3 rounded-lg bg-muted", children: l.jsx(Fo, { className: "h-6 w-6 text-muted-foreground" }) }), l.jsxs("div", { className: "flex-1", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [l.jsx(hf, { className: "h-5 w-5 text-muted-foreground" }), l.jsx("h3", { className: "text-lg font-semibold", children: g.trainee?.name || "Unknown Trainee" }), g.focusArea && l.jsx(Jt, { variant: "outline", children: g.focusArea })] }), l.jsxs("div", { className: "flex flex-wrap items-center gap-4 text-sm text-muted-foreground", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(li, { className: "h-4 w-4" }), J7(g.scheduledDate)] }), l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-4 w-4" }), g.timeSlot || "Time not set", "  ", g.duration || 0, " min"] }), l.jsxs(Jt, { variant: e9(g.status), children: [l.jsx(v, { className: "h-3 w-3 mr-1" }), g.status.replace("_", " ").charAt(0).toUpperCase() + g.status.replace("_", " ").slice(1)] })] }), g.trainee?.email && l.jsxs("p", { className: "text-sm text-muted-foreground mt-2", children: ["Email: ", g.trainee.email] })] })] }), l.jsxs("div", { className: "flex items-center gap-4", children: [g.status === "completed" && l.jsxs(l.Fragment, { children: [l.jsxs(vt, { variant: "outline", size: "sm", onClick: () => m(g), children: [l.jsx(Du, { className: "h-4 w-4 mr-2" }), "View Details"] }), l.jsxs(vt, { variant: "outline", size: "sm", onClick: () => { t(cr.INTERVIEWER_FEEDBACK, { state: { interviewId: g._id } }) }, children: [l.jsx(xJ, { className: "h-4 w-4 mr-2" }), "Review Feedback"] })] }), g.status === "cancelled" && l.jsx(Jt, { variant: "destructive", children: "Cancelled" })] })] }) }) }, g._id) }) }) })] })] }) } const LT = { async getAvailability(t) { const e = new URLSearchParams; t?.date && e.append("date", t.date), t?.mode && e.append("mode", t.mode), t?.includeBooked !== void 0 && e.append("includeBooked", t.includeBooked.toString()); const n = e.toString() ? `?${e.toString()}` : ""; return Yn.get(`${jn.interviewer.availability}${n}`) }, async addAvailability(t) { return Yn.post(jn.interviewer.addAvailability, { date: t.date, time: t.time, mode: t.mode || "live" }) }, async deleteAvailability(t) { return Yn.delete(jn.interviewer.deleteAvailability(t)) } }, MBe = t => { if (!t) return "Date not set"; try { const e = ao(t); return !e || isNaN(e.getTime()) ? "Invalid date" : k0(e) ? "Today" : w_(e) ? "Tomorrow" : xr(e, "MMM d, yyyy") } catch { return "Invalid date" } }, n9 = t => { switch (t) { case "scheduled": return "default"; case "in_progress": return "secondary"; case "completed": return "default"; case "cancelled": return "destructive"; case "no_show": return "destructive"; default: return "secondary" } }, r9 = t => { switch (t) { case "completed": return oi; case "cancelled": case "no_show": return LS; case "in_progress": return p0; default: return li } }; function TBe() { const t = ui(), [e, n] = S.useState(new Date), { data: r, isLoading: i, error: a } = oo({ queryKey: ["interviewerAssignedInterviews"], queryFn: () => v4.getAssignedInterviews() }), { data: s, isLoading: o, error: c } = oo({ queryKey: ["interviewerAvailability", e ? xr(e, "yyyy-MM-dd") : "all"], queryFn: () => { const E = e ? xr(e, "yyyy-MM-dd") : void 0; return LT.getAvailability({ date: E, mode: "live", includeBooked: !0 }) }, enabled: !!e }), u = r?.data || [], d = s?.data || [], f = E => { if (!E) return null; try { return ao(E) } catch { return null } }, h = e ? u.filter(E => { if (!E.scheduledDate) return !1; const M = f(E.scheduledDate); return M ? $i(M, e) : !1 }) : [], m = e ? d.filter(E => { const M = f(E.date); return M ? $i(M, e) : !1 }) : [], g = e ? (() => { const E = []; return h.forEach(M => { E.push({ time: M.timeSlot || "Unknown", type: "interview", interview: M }) }), m.forEach(M => { h.some(N => N.timeSlot === M.time) || E.push({ time: M.time, type: M.isBooked ? "booked" : "available", slot: M }) }), E.sort((M, C) => { const N = M.time.toLowerCase(), A = C.time.toLowerCase(); return N.localeCompare(A) }) })() : [], x = u.filter(E => { if (!E.scheduledDate) return !1; const M = f(E.scheduledDate); return M ? !Rx(vi(M)) && E.status !== "completed" && E.status !== "cancelled" : !1 }).sort((E, M) => { const C = f(E.scheduledDate), N = f(M.scheduledDate); if (!C || !N) return 0; const A = C.getTime(), j = N.getTime(); return A !== j ? A - j : (E.timeSlot || "").localeCompare(M.timeSlot || "") }).slice(0, 5), v = E => { t(cr.INTERVIEWER_ASSIGNED, { state: { interviewId: E._id } }) }, b = () => { t("/dashboard/interviewer/availability") }; return l.jsxs("div", { className: "max-w-7xl mx-auto space-y-6 pb-20 lg:pb-8", children: [l.jsxs("div", { className: "flex justify-between items-center flex-wrap gap-4", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "Interview Calendar" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "View your scheduled interviews and manage your availability" })] }), l.jsxs(vt, { variant: "outline", onClick: b, className: "flex-shrink-0", children: [l.jsx(ni, { className: "mr-2 h-4 w-4" }), "Manage Availability"] })] }), (a || c) && l.jsx(Lt, { className: "p-6 border-destructive", children: l.jsxs("div", { className: "flex items-center gap-3", children: [l.jsx(ji, { className: "h-5 w-5 text-destructive" }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-destructive", children: "Error Loading Data" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: a instanceof Error ? a.message : c instanceof Error ? c.message : "An error occurred while loading calendar data" })] })] }) }), l.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-6", children: [l.jsxs("div", { className: "lg:col-span-1", children: [l.jsxs(Lt, { className: "p-4 sm:p-6", children: [l.jsx("h2", { className: "text-lg font-semibold mb-4", children: "Select Date" }), l.jsx(kx, { mode: "single", selected: e, onSelect: n, className: "rounded-md", disabled: E => Rx(vi(E)) && !k0(E) })] }), !i && x.length > 0 && l.jsxs(Lt, { className: "p-4 sm:p-6 mt-6", children: [l.jsx("h2", { className: "text-lg font-semibold mb-4", children: "Upcoming Interviews" }), l.jsx("div", { className: "space-y-3", children: x.map(E => { const M = r9(E.status); return l.jsx($e.div, { initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, className: "p-3 border rounded-lg hover:border-primary/50 transition-colors cursor-pointer", onClick: () => v(E), children: l.jsxs("div", { className: "flex items-start justify-between gap-2", children: [l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsx("p", { className: "font-medium text-sm truncate", children: E.trainee?.name || "Unknown Trainee" }), l.jsx("p", { className: "text-xs text-muted-foreground", children: MBe(E.scheduledDate) }), l.jsx("p", { className: "text-xs text-muted-foreground", children: E.timeSlot || "Time not set" })] }), l.jsxs(Jt, { variant: n9(E.status), className: "flex-shrink-0", children: [l.jsx(M, { className: "h-3 w-3 mr-1" }), E.status.replace("_", " ")] })] }) }, E._id) }) }), l.jsx(vt, { variant: "outline", className: "w-full mt-4", onClick: () => t(cr.INTERVIEWER_ASSIGNED), children: "View All Interviews" })] })] }), l.jsx("div", { className: "lg:col-span-2", children: l.jsxs(Lt, { className: "p-4 sm:p-6", children: [l.jsx("div", { className: "flex items-center justify-between mb-6 flex-wrap gap-4", children: l.jsxs("div", { children: [l.jsx("h2", { className: "text-lg font-semibold", children: e ? xr(e, "EEEE, MMMM d, yyyy") : "Select a date to view schedule" }), e && l.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: [h.length, " interview", h.length !== 1 ? "s" : "", " scheduled", m.length > 0 && `  ${m.filter(E => !E.isBooked).length} available slot${m.filter(E => !E.isBooked).length !== 1 ? "s" : ""}`] })] }) }), (i || o && e) && l.jsxs("div", { className: "flex items-center justify-center py-12", children: [l.jsx(sa, { className: "h-8 w-8 animate-spin text-primary" }), l.jsx("span", { className: "ml-3 text-muted-foreground", children: "Loading schedule..." })] }), !i && !(o && e) && l.jsx(l.Fragment, { children: e ? g.length === 0 ? l.jsxs("div", { className: "text-center py-12", children: [l.jsx(ni, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "No interviews or availability slots scheduled for this date" }), l.jsx(vt, { variant: "outline", onClick: b, children: "Manage Availability" })] }) : l.jsx("div", { className: "space-y-3", children: g.map((E, M) => { const C = E.interview ? r9(E.interview.status) : li; return l.jsx($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .3, delay: M * .05 }, className: `p-4 border rounded-lg transition-all ${E.type === "interview" ? "border-primary/50 bg-primary/5 hover:border-primary" : E.type === "booked" ? "border-muted bg-muted/50" : "border-border hover:border-primary/30"} ${E.interview ? "cursor-pointer" : ""}`, onClick: () => E.interview && v(E.interview), children: l.jsxs("div", { className: "flex items-start justify-between gap-4", children: [l.jsxs("div", { className: "flex items-start gap-3 flex-1", children: [l.jsx("div", { className: "flex-shrink-0 w-20", children: l.jsx("p", { className: "text-sm font-semibold", children: E.time }) }), l.jsx("div", { className: "flex-1 min-w-0", children: E.type === "interview" && E.interview ? l.jsxs(l.Fragment, { children: [l.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [l.jsx(hf, { className: "h-4 w-4 text-muted-foreground" }), l.jsx("h3", { className: "font-semibold", children: E.interview.trainee?.name || "Unknown Trainee" })] }), l.jsxs("div", { className: "flex flex-wrap items-center gap-2 text-sm text-muted-foreground", children: [E.interview.focusArea && l.jsx(Jt, { variant: "outline", className: "text-xs", children: E.interview.focusArea }), E.interview.difficulty && l.jsx(Jt, { variant: "secondary", className: "text-xs", children: E.interview.difficulty }), l.jsxs("span", { children: [" ", E.interview.duration, " min"] }), E.interview.language && l.jsxs("span", { children: [" ", E.interview.language] })] }), E.interview.trainee?.email && l.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: E.interview.trainee.email })] }) : E.type === "booked" ? l.jsx("p", { className: "text-sm text-muted-foreground", children: "Slot booked (not assigned to you)" }) : l.jsx("p", { className: "text-sm text-muted-foreground", children: "Available slot - ready for booking" }) })] }), l.jsxs("div", { className: "flex-shrink-0", children: [E.interview && l.jsxs(Jt, { variant: n9(E.interview.status), className: "flex items-center gap-1", children: [l.jsx(C, { className: "h-3 w-3" }), E.interview.status.replace("_", " ")] }), E.type === "available" && l.jsxs(Jt, { variant: "outline", className: "flex items-center gap-1", children: [l.jsx(ni, { className: "h-3 w-3" }), "Available"] }), E.type === "booked" && !E.interview && l.jsx(Jt, { variant: "secondary", children: "Booked" })] })] }) }, E.time + (E.interview?._id || E.slot?._id || M)) }) }) : l.jsxs("div", { className: "text-center py-12", children: [l.jsx(li, { className: "h-12 w-12 text-muted-foreground mx-auto mb-4" }), l.jsx("p", { className: "text-muted-foreground", children: "Select a date from the calendar to view your schedule" })] }) })] }) })] })] }) } function CBe() { const [t] = S.useState([{ id: "1", text: "Explain the concept of dependency injection", category: "Software Design", difficulty: "Intermediate", tags: ["Design Patterns", "Architecture"] }]); return l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { className: "flex justify-between items-center", children: [l.jsx("h1", { className: "text-2xl font-bold", children: "Question Bank" }), l.jsxs(vt, { children: [l.jsx(HT, { className: "mr-2 h-4 w-4" }), "Add Question"] })] }), l.jsxs("div", { className: "flex gap-4 mb-6", children: [l.jsx("div", { className: "flex-1", children: l.jsx(fn, { placeholder: "Search questions...", className: "w-full" }) }), l.jsxs(vt, { variant: "outline", children: [l.jsx(_J, { className: "mr-2 h-4 w-4" }), "Filter"] })] }), l.jsx("div", { className: "grid gap-4", children: t.map(e => l.jsx(sn, { className: "p-4", children: l.jsxs("div", { className: "space-y-4", children: [l.jsx("h3", { className: "font-medium", children: e.text }), l.jsxs("div", { className: "flex gap-2", children: [l.jsx(Jt, { children: e.category }), l.jsx(Jt, { variant: "outline", children: e.difficulty }), e.tags.map(n => l.jsx(Jt, { variant: "secondary", children: n }, n))] })] }) }, e.id)) })] }) } function NBe() { const [t] = S.useState([{ id: "1", candidate: { name: "Sarah Chen", avatar: "/avatars/sarah.jpg", role: "Frontend Developer" }, date: "2025-11-02", rating: 4.5, strengths: ["Technical Knowledge", "Problem Solving"], improvements: ["Communication"], status: "pending", comment: "Demonstrated strong React knowledge and system design principles. Could improve on explaining thought process." }]); return l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { className: "flex justify-between items-center", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-2xl font-bold", children: "Feedback Review" }), l.jsx("p", { className: "text-muted-foreground", children: "Review and manage interview feedback" })] }), l.jsxs(Jn, { defaultValue: "all", children: [l.jsx(qn, { className: "w-[180px]", children: l.jsx(er, { placeholder: "Filter by status" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Feedback" }), l.jsx(ut, { value: "pending", children: "Pending Review" }), l.jsx(ut, { value: "reviewed", children: "Reviewed" })] })] })] }), l.jsxs("div", { className: "flex gap-4 mb-6", children: [l.jsx("div", { className: "flex-1", children: l.jsx(fn, { placeholder: "Search feedback..." }) }), l.jsxs(vt, { variant: "outline", children: [l.jsx(_J, { className: "mr-2 h-4 w-4" }), "More Filters"] })] }), l.jsx("div", { className: "grid gap-4", children: t.map(e => l.jsx(sn, { className: "p-6", children: l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex justify-between items-start", children: [l.jsxs("div", { className: "flex gap-4", children: [l.jsxs(Vc, { className: "h-12 w-12", children: [l.jsx(xf, { src: e.candidate.avatar, alt: e.candidate.name }), l.jsx(Hc, { children: e.candidate.name.slice(0, 2) })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-medium", children: e.candidate.name }), l.jsx("p", { className: "text-sm text-muted-foreground", children: e.candidate.role }), l.jsxs("div", { className: "flex items-center gap-2 mt-1", children: [l.jsx(Ug, { className: "h-4 w-4 text-yellow-400 fill-yellow-400" }), l.jsx("span", { children: e.rating }), l.jsx("span", { className: "text-muted-foreground", children: "" }), l.jsx("span", { className: "text-sm text-muted-foreground", children: new Date(e.date).toLocaleDateString() })] })] })] }), l.jsx(Jt, { variant: e.status === "pending" ? "secondary" : "default", className: e.status === "pending" ? "bg-yellow-100 text-yellow-800 hover:bg-yellow-100/80" : "bg-green-100 text-green-800 hover:bg-green-100/80", children: e.status === "pending" ? "Pending Review" : "Reviewed" })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx("p", { className: "text-sm leading-relaxed", children: e.comment }), l.jsxs("div", { className: "flex gap-4 mt-4", children: [l.jsxs("div", { children: [l.jsxs("h4", { className: "text-sm font-medium mb-2 flex items-center gap-2", children: [l.jsx(rye, { className: "h-4 w-4 text-green-500" }), "Strengths"] }), l.jsx("div", { className: "flex gap-2", children: e.strengths.map(n => l.jsx(Jt, { variant: "outline", className: "bg-green-50 text-green-700 border-green-200", children: n }, n)) })] }), l.jsxs("div", { children: [l.jsxs("h4", { className: "text-sm font-medium mb-2 flex items-center gap-2", children: [l.jsx(nye, { className: "h-4 w-4 text-yellow-500" }), "Areas for Improvement"] }), l.jsx("div", { className: "flex gap-2", children: e.improvements.map(n => l.jsx(Jt, { variant: "outline", className: "bg-yellow-50 text-yellow-700 border-yellow-200", children: n }, n)) })] })] })] }), l.jsxs("div", { className: "flex justify-end gap-2", children: [l.jsx(vt, { variant: "outline", size: "sm", children: "Edit Feedback" }), l.jsx(vt, { size: "sm", children: "Submit Review" })] })] }) }, e.id)) })] }) } var _k, i9; function Vo() { if (i9) return _k; i9 = 1; var t = Array.isArray; return _k = t, _k } var Ek, a9; function uue() { if (a9) return Ek; a9 = 1; var t = typeof OE == "object" && OE && OE.Object === Object && OE; return Ek = t, Ek } var Mk, s9; function ed() { if (s9) return Mk; s9 = 1; var t = uue(), e = typeof self == "object" && self && self.Object === Object && self, n = t || e || Function("return this")(); return Mk = n, Mk } var Tk, o9; function E_() { if (o9) return Tk; o9 = 1; var t = ed(), e = t.Symbol; return Tk = e, Tk } var Ck, l9; function ABe() { if (l9) return Ck; l9 = 1; var t = E_(), e = Object.prototype, n = e.hasOwnProperty, r = e.toString, i = t ? t.toStringTag : void 0; function a(s) { var o = n.call(s, i), c = s[i]; try { s[i] = void 0; var u = !0 } catch { } var d = r.call(s); return u && (o ? s[i] = c : delete s[i]), d } return Ck = a, Ck } var Nk, c9; function PBe() { if (c9) return Nk; c9 = 1; var t = Object.prototype, e = t.toString; function n(r) { return e.call(r) } return Nk = n, Nk } var Ak, u9; function Mf() { if (u9) return Ak; u9 = 1; var t = E_(), e = ABe(), n = PBe(), r = "[object Null]", i = "[object Undefined]", a = t ? t.toStringTag : void 0; function s(o) { return o == null ? o === void 0 ? i : r : a && a in Object(o) ? e(o) : n(o) } return Ak = s, Ak } var Pk, d9; function Tf() { if (d9) return Pk; d9 = 1; function t(e) { return e != null && typeof e == "object" } return Pk = t, Pk } var jk, f9; function O0() { if (f9) return jk; f9 = 1; var t = Mf(), e = Tf(), n = "[object Symbol]"; function r(i) { return typeof i == "symbol" || e(i) && t(i) == n } return jk = r, jk } var Rk, h9; function b$() { if (h9) return Rk; h9 = 1; var t = Vo(), e = O0(), n = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, r = /^\w*$/; function i(a, s) { if (t(a)) return !1; var o = typeof a; return o == "number" || o == "symbol" || o == "boolean" || a == null || e(a) ? !0 : r.test(a) || !n.test(a) || s != null && a in Object(s) } return Rk = i, Rk } var kk, p9; function _p() { if (p9) return kk; p9 = 1; function t(e) { var n = typeof e; return e != null && (n == "object" || n == "function") } return kk = t, kk } var Ik, m9; function w$() { if (m9) return Ik; m9 = 1; var t = Mf(), e = _p(), n = "[object AsyncFunction]", r = "[object Function]", i = "[object GeneratorFunction]", a = "[object Proxy]"; function s(o) { if (!e(o)) return !1; var c = t(o); return c == r || c == i || c == n || c == a } return Ik = s, Ik } var Ok, g9; function jBe() { if (g9) return Ok; g9 = 1; var t = ed(), e = t["__core-js_shared__"]; return Ok = e, Ok } var Dk, v9; function RBe() { if (v9) return Dk; v9 = 1; var t = jBe(), e = (function () { var r = /[^.]+$/.exec(t && t.keys && t.keys.IE_PROTO || ""); return r ? "Symbol(src)_1." + r : "" })(); function n(r) { return !!e && e in r } return Dk = n, Dk } var Lk, y9; function due() { if (y9) return Lk; y9 = 1; var t = Function.prototype, e = t.toString; function n(r) { if (r != null) { try { return e.call(r) } catch { } try { return r + "" } catch { } } return "" } return Lk = n, Lk } var Fk, x9; function kBe() { if (x9) return Fk; x9 = 1; var t = w$(), e = RBe(), n = _p(), r = due(), i = /[\\^$.*+?()[\]{}|]/g, a = /^\[object .+?Constructor\]$/, s = Function.prototype, o = Object.prototype, c = s.toString, u = o.hasOwnProperty, d = RegExp("^" + c.call(u).replace(i, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function f(h) { if (!n(h) || e(h)) return !1; var m = t(h) ? d : a; return m.test(r(h)) } return Fk = f, Fk } var Uk, b9; function IBe() { if (b9) return Uk; b9 = 1; function t(e, n) { return e?.[n] } return Uk = t, Uk } var Bk, w9; function Xg() { if (w9) return Bk; w9 = 1; var t = kBe(), e = IBe(); function n(r, i) { var a = e(r, i); return t(a) ? a : void 0 } return Bk = n, Bk } var $k, S9; function j2() { if (S9) return $k; S9 = 1; var t = Xg(), e = t(Object, "create"); return $k = e, $k } var zk, _9; function OBe() { if (_9) return zk; _9 = 1; var t = j2(); function e() { this.__data__ = t ? t(null) : {}, this.size = 0 } return zk = e, zk } var Vk, E9; function DBe() { if (E9) return Vk; E9 = 1; function t(e) { var n = this.has(e) && delete this.__data__[e]; return this.size -= n ? 1 : 0, n } return Vk = t, Vk } var Hk, M9; function LBe() { if (M9) return Hk; M9 = 1; var t = j2(), e = "__lodash_hash_undefined__", n = Object.prototype, r = n.hasOwnProperty; function i(a) { var s = this.__data__; if (t) { var o = s[a]; return o === e ? void 0 : o } return r.call(s, a) ? s[a] : void 0 } return Hk = i, Hk } var Wk, T9; function FBe() { if (T9) return Wk; T9 = 1; var t = j2(), e = Object.prototype, n = e.hasOwnProperty; function r(i) { var a = this.__data__; return t ? a[i] !== void 0 : n.call(a, i) } return Wk = r, Wk } var Gk, C9; function UBe() { if (C9) return Gk; C9 = 1; var t = j2(), e = "__lodash_hash_undefined__"; function n(r, i) { var a = this.__data__; return this.size += this.has(r) ? 0 : 1, a[r] = t && i === void 0 ? e : i, this } return Gk = n, Gk } var qk, N9; function BBe() { if (N9) return qk; N9 = 1; var t = OBe(), e = DBe(), n = LBe(), r = FBe(), i = UBe(); function a(s) { var o = -1, c = s == null ? 0 : s.length; for (this.clear(); ++o < c;) { var u = s[o]; this.set(u[0], u[1]) } } return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = n, a.prototype.has = r, a.prototype.set = i, qk = a, qk } var Xk, A9; function $Be() { if (A9) return Xk; A9 = 1; function t() { this.__data__ = [], this.size = 0 } return Xk = t, Xk } var Yk, P9; function S$() { if (P9) return Yk; P9 = 1; function t(e, n) { return e === n || e !== e && n !== n } return Yk = t, Yk } var Kk, j9; function R2() { if (j9) return Kk; j9 = 1; var t = S$(); function e(n, r) { for (var i = n.length; i--;)if (t(n[i][0], r)) return i; return -1 } return Kk = e, Kk } var Zk, R9; function zBe() { if (R9) return Zk; R9 = 1; var t = R2(), e = Array.prototype, n = e.splice; function r(i) { var a = this.__data__, s = t(a, i); if (s < 0) return !1; var o = a.length - 1; return s == o ? a.pop() : n.call(a, s, 1), --this.size, !0 } return Zk = r, Zk } var Qk, k9; function VBe() { if (k9) return Qk; k9 = 1; var t = R2(); function e(n) { var r = this.__data__, i = t(r, n); return i < 0 ? void 0 : r[i][1] } return Qk = e, Qk } var Jk, I9; function HBe() { if (I9) return Jk; I9 = 1; var t = R2(); function e(n) { return t(this.__data__, n) > -1 } return Jk = e, Jk } var eI, O9; function WBe() { if (O9) return eI; O9 = 1; var t = R2(); function e(n, r) { var i = this.__data__, a = t(i, n); return a < 0 ? (++this.size, i.push([n, r])) : i[a][1] = r, this } return eI = e, eI } var tI, D9; function k2() { if (D9) return tI; D9 = 1; var t = $Be(), e = zBe(), n = VBe(), r = HBe(), i = WBe(); function a(s) { var o = -1, c = s == null ? 0 : s.length; for (this.clear(); ++o < c;) { var u = s[o]; this.set(u[0], u[1]) } } return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = n, a.prototype.has = r, a.prototype.set = i, tI = a, tI } var nI, L9; function _$() { if (L9) return nI; L9 = 1; var t = Xg(), e = ed(), n = t(e, "Map"); return nI = n, nI } var rI, F9; function GBe() { if (F9) return rI; F9 = 1; var t = BBe(), e = k2(), n = _$(); function r() { this.size = 0, this.__data__ = { hash: new t, map: new (n || e), string: new t } } return rI = r, rI } var iI, U9; function qBe() { if (U9) return iI; U9 = 1; function t(e) { var n = typeof e; return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? e !== "__proto__" : e === null } return iI = t, iI } var aI, B9; function I2() { if (B9) return aI; B9 = 1; var t = qBe(); function e(n, r) { var i = n.__data__; return t(r) ? i[typeof r == "string" ? "string" : "hash"] : i.map } return aI = e, aI } var sI, $9; function XBe() { if ($9) return sI; $9 = 1; var t = I2(); function e(n) { var r = t(this, n).delete(n); return this.size -= r ? 1 : 0, r } return sI = e, sI } var oI, z9; function YBe() { if (z9) return oI; z9 = 1; var t = I2(); function e(n) { return t(this, n).get(n) } return oI = e, oI } var lI, V9; function KBe() { if (V9) return lI; V9 = 1; var t = I2(); function e(n) { return t(this, n).has(n) } return lI = e, lI } var cI, H9; function ZBe() { if (H9) return cI; H9 = 1; var t = I2(); function e(n, r) { var i = t(this, n), a = i.size; return i.set(n, r), this.size += i.size == a ? 0 : 1, this } return cI = e, cI } var uI, W9; function E$() { if (W9) return uI; W9 = 1; var t = GBe(), e = XBe(), n = YBe(), r = KBe(), i = ZBe(); function a(s) { var o = -1, c = s == null ? 0 : s.length; for (this.clear(); ++o < c;) { var u = s[o]; this.set(u[0], u[1]) } } return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = n, a.prototype.has = r, a.prototype.set = i, uI = a, uI } var dI, G9; function fue() { if (G9) return dI; G9 = 1; var t = E$(), e = "Expected a function"; function n(r, i) { if (typeof r != "function" || i != null && typeof i != "function") throw new TypeError(e); var a = function () { var s = arguments, o = i ? i.apply(this, s) : s[0], c = a.cache; if (c.has(o)) return c.get(o); var u = r.apply(this, s); return a.cache = c.set(o, u) || c, u }; return a.cache = new (n.Cache || t), a } return n.Cache = t, dI = n, dI } var fI, q9; function QBe() { if (q9) return fI; q9 = 1; var t = fue(), e = 500; function n(r) { var i = t(r, function (s) { return a.size === e && a.clear(), s }), a = i.cache; return i } return fI = n, fI } var hI, X9; function JBe() { if (X9) return hI; X9 = 1; var t = QBe(), e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, n = /\\(\\)?/g, r = t(function (i) { var a = []; return i.charCodeAt(0) === 46 && a.push(""), i.replace(e, function (s, o, c, u) { a.push(c ? u.replace(n, "$1") : o || s) }), a }); return hI = r, hI } var pI, Y9; function M$() { if (Y9) return pI; Y9 = 1; function t(e, n) { for (var r = -1, i = e == null ? 0 : e.length, a = Array(i); ++r < i;)a[r] = n(e[r], r, e); return a } return pI = t, pI } var mI, K9; function e$e() { if (K9) return mI; K9 = 1; var t = E_(), e = M$(), n = Vo(), r = O0(), i = t ? t.prototype : void 0, a = i ? i.toString : void 0; function s(o) { if (typeof o == "string") return o; if (n(o)) return e(o, s) + ""; if (r(o)) return a ? a.call(o) : ""; var c = o + ""; return c == "0" && 1 / o == -1 / 0 ? "-0" : c } return mI = s, mI } var gI, Z9; function hue() { if (Z9) return gI; Z9 = 1; var t = e$e(); function e(n) { return n == null ? "" : t(n) } return gI = e, gI } var vI, Q9; function pue() { if (Q9) return vI; Q9 = 1; var t = Vo(), e = b$(), n = JBe(), r = hue(); function i(a, s) { return t(a) ? a : e(a, s) ? [a] : n(r(a)) } return vI = i, vI } var yI, J9; function O2() { if (J9) return yI; J9 = 1; var t = O0(); function e(n) { if (typeof n == "string" || t(n)) return n; var r = n + ""; return r == "0" && 1 / n == -1 / 0 ? "-0" : r } return yI = e, yI } var xI, eG; function T$() { if (eG) return xI; eG = 1; var t = pue(), e = O2(); function n(r, i) { i = t(i, r); for (var a = 0, s = i.length; r != null && a < s;)r = r[e(i[a++])]; return a && a == s ? r : void 0 } return xI = n, xI } var bI, tG; function mue() { if (tG) return bI; tG = 1; var t = T$(); function e(n, r, i) { var a = n == null ? void 0 : t(n, r); return a === void 0 ? i : a } return bI = e, bI } var t$e = mue(); const pl = Fr(t$e); var wI, nG; function n$e() { if (nG) return wI; nG = 1; function t(e) { return e == null } return wI = t, wI } var r$e = n$e(); const An = Fr(r$e); var SI, rG; function i$e() { if (rG) return SI; rG = 1; var t = Mf(), e = Vo(), n = Tf(), r = "[object String]"; function i(a) { return typeof a == "string" || !e(a) && n(a) && t(a) == r } return SI = i, SI } var a$e = i$e(); const jg = Fr(a$e); var s$e = w$(); const Rn = Fr(s$e); var o$e = _p(); const D0 = Fr(o$e); var _I = { exports: {} }, zr = {};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var iG; function l$e() { if (iG) return zr; iG = 1; var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), o = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), g; g = Symbol.for("react.module.reference"); function x(v) { if (typeof v == "object" && v !== null) { var b = v.$$typeof; switch (b) { case t: switch (v = v.type, v) { case n: case i: case r: case u: case d: return v; default: switch (v = v && v.$$typeof, v) { case o: case s: case c: case h: case f: case a: return v; default: return b } }case e: return b } } } return zr.ContextConsumer = s, zr.ContextProvider = a, zr.Element = t, zr.ForwardRef = c, zr.Fragment = n, zr.Lazy = h, zr.Memo = f, zr.Portal = e, zr.Profiler = i, zr.StrictMode = r, zr.Suspense = u, zr.SuspenseList = d, zr.isAsyncMode = function () { return !1 }, zr.isConcurrentMode = function () { return !1 }, zr.isContextConsumer = function (v) { return x(v) === s }, zr.isContextProvider = function (v) { return x(v) === a }, zr.isElement = function (v) { return typeof v == "object" && v !== null && v.$$typeof === t }, zr.isForwardRef = function (v) { return x(v) === c }, zr.isFragment = function (v) { return x(v) === n }, zr.isLazy = function (v) { return x(v) === h }, zr.isMemo = function (v) { return x(v) === f }, zr.isPortal = function (v) { return x(v) === e }, zr.isProfiler = function (v) { return x(v) === i }, zr.isStrictMode = function (v) { return x(v) === r }, zr.isSuspense = function (v) { return x(v) === u }, zr.isSuspenseList = function (v) { return x(v) === d }, zr.isValidElementType = function (v) { return typeof v == "string" || typeof v == "function" || v === n || v === i || v === r || v === u || v === d || v === m || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === f || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === g || v.getModuleId !== void 0) }, zr.typeOf = x, zr } var aG; function c$e() { return aG || (aG = 1, _I.exports = l$e()), _I.exports } var u$e = c$e(), EI, sG; function gue() { if (sG) return EI; sG = 1; var t = Mf(), e = Tf(), n = "[object Number]"; function r(i) { return typeof i == "number" || e(i) && t(i) == n } return EI = r, EI } var MI, oG; function d$e() { if (oG) return MI; oG = 1; var t = gue(); function e(n) { return t(n) && n != +n } return MI = e, MI } var f$e = d$e(); const L0 = Fr(f$e); var h$e = gue(); const p$e = Fr(h$e); var Js = function (e) { return e === 0 ? 0 : e > 0 ? 1 : -1 }, tg = function (e) { return jg(e) && e.indexOf("%") === e.length - 1 }, It = function (e) { return p$e(e) && !L0(e) }, m$e = function (e) { return An(e) }, ka = function (e) { return It(e) || jg(e) }, g$e = 0, Ep = function (e) { var n = ++g$e; return "".concat(e || "").concat(n) }, eo = function (e, n) { var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1; if (!It(e) && !jg(e)) return r; var a; if (tg(e)) { var s = e.indexOf("%"); a = n * parseFloat(e.slice(0, s)) / 100 } else a = +e; return L0(a) && (a = r), i && a > n && (a = n), a }, kh = function (e) { if (!e) return null; var n = Object.keys(e); return n && n.length ? e[n[0]] : null }, v$e = function (e) { if (!Array.isArray(e)) return !1; for (var n = e.length, r = {}, i = 0; i < n; i++)if (!r[e[i]]) r[e[i]] = !0; else return !0; return !1 }, Di = function (e, n) { return It(e) && It(n) ? function (r) { return e + r * (n - e) } : function () { return n } }; function rN(t, e, n) { return !t || !t.length ? null : t.find(function (r) { return r && (typeof e == "function" ? e(r) : pl(r, e)) === n }) } var y$e = function (e) { if (!e || !e.length) return null; for (var n = e.length, r = 0, i = 0, a = 0, s = 0, o = 1 / 0, c = -1 / 0, u = 0, d = 0, f = 0; f < n; f++)u = e[f].cx || 0, d = e[f].cy || 0, r += u, i += d, a += u * d, s += u * u, o = Math.min(o, u), c = Math.max(c, u); var h = n * s !== r * r ? (n * a - r * i) / (n * s - r * r) : 0; return { xmin: o, xmax: c, a: h, b: (i - h * r) / n } }, x$e = function (e, n) { return It(e) && It(n) ? e - n : jg(e) && jg(n) ? e.localeCompare(n) : e instanceof Date && n instanceof Date ? e.getTime() - n.getTime() : String(e).localeCompare(String(n)) }; function tx(t, e) { for (var n in t) if ({}.hasOwnProperty.call(t, n) && (!{}.hasOwnProperty.call(e, n) || t[n] !== e[n])) return !1; for (var r in e) if ({}.hasOwnProperty.call(e, r) && !{}.hasOwnProperty.call(t, r)) return !1; return !0 } function y4(t) { "@babel/helpers - typeof"; return y4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, y4(t) } var b$e = ["viewBox", "children"], w$e = ["aria-activedescendant", "aria-atomic", "aria-autocomplete", "aria-busy", "aria-checked", "aria-colcount", "aria-colindex", "aria-colspan", "aria-controls", "aria-current", "aria-describedby", "aria-details", "aria-disabled", "aria-errormessage", "aria-expanded", "aria-flowto", "aria-haspopup", "aria-hidden", "aria-invalid", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-level", "aria-live", "aria-modal", "aria-multiline", "aria-multiselectable", "aria-orientation", "aria-owns", "aria-placeholder", "aria-posinset", "aria-pressed", "aria-readonly", "aria-relevant", "aria-required", "aria-roledescription", "aria-rowcount", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-setsize", "aria-sort", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext", "className", "color", "height", "id", "lang", "max", "media", "method", "min", "name", "style", "target", "width", "role", "tabIndex", "accentHeight", "accumulate", "additive", "alignmentBaseline", "allowReorder", "alphabetic", "amplitude", "arabicForm", "ascent", "attributeName", "attributeType", "autoReverse", "azimuth", "baseFrequency", "baselineShift", "baseProfile", "bbox", "begin", "bias", "by", "calcMode", "capHeight", "clip", "clipPath", "clipPathUnits", "clipRule", "colorInterpolation", "colorInterpolationFilters", "colorProfile", "colorRendering", "contentScriptType", "contentStyleType", "cursor", "cx", "cy", "d", "decelerate", "descent", "diffuseConstant", "direction", "display", "divisor", "dominantBaseline", "dur", "dx", "dy", "edgeMode", "elevation", "enableBackground", "end", "exponent", "externalResourcesRequired", "fill", "fillOpacity", "fillRule", "filter", "filterRes", "filterUnits", "floodColor", "floodOpacity", "focusable", "fontFamily", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontWeight", "format", "from", "fx", "fy", "g1", "g2", "glyphName", "glyphOrientationHorizontal", "glyphOrientationVertical", "glyphRef", "gradientTransform", "gradientUnits", "hanging", "horizAdvX", "horizOriginX", "href", "ideographic", "imageRendering", "in2", "in", "intercept", "k1", "k2", "k3", "k4", "k", "kernelMatrix", "kernelUnitLength", "kerning", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "letterSpacing", "lightingColor", "limitingConeAngle", "local", "markerEnd", "markerHeight", "markerMid", "markerStart", "markerUnits", "markerWidth", "mask", "maskContentUnits", "maskUnits", "mathematical", "mode", "numOctaves", "offset", "opacity", "operator", "order", "orient", "orientation", "origin", "overflow", "overlinePosition", "overlineThickness", "paintOrder", "panose1", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointerEvents", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "r", "radius", "refX", "refY", "renderingIntent", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "restart", "result", "rotate", "rx", "ry", "seed", "shapeRendering", "slope", "spacing", "specularConstant", "specularExponent", "speed", "spreadMethod", "startOffset", "stdDeviation", "stemh", "stemv", "stitchTiles", "stopColor", "stopOpacity", "strikethroughPosition", "strikethroughThickness", "string", "stroke", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textAnchor", "textDecoration", "textLength", "textRendering", "to", "transform", "u1", "u2", "underlinePosition", "underlineThickness", "unicode", "unicodeBidi", "unicodeRange", "unitsPerEm", "vAlphabetic", "values", "vectorEffect", "version", "vertAdvY", "vertOriginX", "vertOriginY", "vHanging", "vIdeographic", "viewTarget", "visibility", "vMathematical", "widths", "wordSpacing", "writingMode", "x1", "x2", "x", "xChannelSelector", "xHeight", "xlinkActuate", "xlinkArcrole", "xlinkHref", "xlinkRole", "xlinkShow", "xlinkTitle", "xlinkType", "xmlBase", "xmlLang", "xmlns", "xmlnsXlink", "xmlSpace", "y1", "y2", "y", "yChannelSelector", "z", "zoomAndPan", "ref", "key", "angle"], lG = ["points", "pathLength"], TI = { svg: b$e, polygon: lG, polyline: lG }, C$ = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], iN = function (e, n) { if (!e || typeof e == "function" || typeof e == "boolean") return null; var r = e; if (S.isValidElement(e) && (r = e.props), !D0(r)) return null; var i = {}; return Object.keys(r).forEach(function (a) { C$.includes(a) && (i[a] = n || function (s) { return r[a](r, s) }) }), i }, S$e = function (e, n, r) { return function (i) { return e(n, r, i), null } }, ap = function (e, n, r) { if (!D0(e) || y4(e) !== "object") return null; var i = null; return Object.keys(e).forEach(function (a) { var s = e[a]; C$.includes(a) && typeof s == "function" && (i || (i = {}), i[a] = S$e(s, n, r)) }), i }, _$e = ["children"], E$e = ["children"]; function cG(t, e) { if (t == null) return {}; var n = M$e(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function M$e(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function x4(t) { "@babel/helpers - typeof"; return x4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, x4(t) } var uG = { click: "onClick", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseover: "onMouseOver", mousemove: "onMouseMove", mouseout: "onMouseOut", mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", touchcancel: "onTouchCancel", touchend: "onTouchEnd", touchmove: "onTouchMove", touchstart: "onTouchStart", contextmenu: "onContextMenu", dblclick: "onDoubleClick" }, lf = function (e) { return typeof e == "string" ? e : e ? e.displayName || e.name || "Component" : "" }, dG = null, CI = null, N$ = function t(e) { if (e === dG && Array.isArray(CI)) return CI; var n = []; return S.Children.forEach(e, function (r) { An(r) || (u$e.isFragment(r) ? n = n.concat(t(r.props.children)) : n.push(r)) }), CI = n, dG = e, n }; function so(t, e) { var n = [], r = []; return Array.isArray(e) ? r = e.map(function (i) { return lf(i) }) : r = [lf(e)], N$(t).forEach(function (i) { var a = pl(i, "type.displayName") || pl(i, "type.name"); r.indexOf(a) !== -1 && n.push(i) }), n } function al(t, e) { var n = so(t, e); return n && n[0] } var fG = function (e) { if (!e || !e.props) return !1; var n = e.props, r = n.width, i = n.height; return !(!It(r) || r <= 0 || !It(i) || i <= 0) }, T$e = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"], C$e = function (e) { return e && e.type && jg(e.type) && T$e.indexOf(e.type) >= 0 }, vue = function (e) { return e && x4(e) === "object" && "clipDot" in e }, N$e = function (e, n, r, i) { var a, s = (a = TI?.[i]) !== null && a !== void 0 ? a : []; return n.startsWith("data-") || !Rn(e) && (i && s.includes(n) || w$e.includes(n)) || r && C$.includes(n) }, vn = function (e, n, r) { if (!e || typeof e == "function" || typeof e == "boolean") return null; var i = e; if (S.isValidElement(e) && (i = e.props), !D0(i)) return null; var a = {}; return Object.keys(i).forEach(function (s) { var o; N$e((o = i) === null || o === void 0 ? void 0 : o[s], s, n, r) && (a[s] = i[s]) }), a }, b4 = function t(e, n) { if (e === n) return !0; var r = S.Children.count(e); if (r !== S.Children.count(n)) return !1; if (r === 0) return !0; if (r === 1) return hG(Array.isArray(e) ? e[0] : e, Array.isArray(n) ? n[0] : n); for (var i = 0; i < r; i++) { var a = e[i], s = n[i]; if (Array.isArray(a) || Array.isArray(s)) { if (!t(a, s)) return !1 } else if (!hG(a, s)) return !1 } return !0 }, hG = function (e, n) { if (An(e) && An(n)) return !0; if (!An(e) && !An(n)) { var r = e.props || {}, i = r.children, a = cG(r, _$e), s = n.props || {}, o = s.children, c = cG(s, E$e); return i && o ? tx(a, c) && b4(i, o) : !i && !o ? tx(a, c) : !1 } return !1 }, pG = function (e, n) { var r = [], i = {}; return N$(e).forEach(function (a, s) { if (C$e(a)) r.push(a); else if (a) { var o = lf(a.type), c = n[o] || {}, u = c.handler, d = c.once; if (u && (!d || !i[o])) { var f = u(a, o, s); r.push(f), i[o] = !0 } } }), r }, A$e = function (e) { var n = e && e.type; return n && uG[n] ? uG[n] : null }, P$e = function (e, n) { return N$(n).indexOf(e) }, j$e = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"]; function w4() { return w4 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, w4.apply(this, arguments) } function R$e(t, e) { if (t == null) return {}; var n = k$e(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function k$e(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function S4(t) { var e = t.children, n = t.width, r = t.height, i = t.viewBox, a = t.className, s = t.style, o = t.title, c = t.desc, u = R$e(t, j$e), d = i || { width: n, height: r, x: 0, y: 0 }, f = zn("recharts-surface", a); return P.createElement("svg", w4({}, vn(u, !0, "svg"), { className: f, width: n, height: r, style: s, viewBox: "".concat(d.x, " ").concat(d.y, " ").concat(d.width, " ").concat(d.height) }), P.createElement("title", null, o), P.createElement("desc", null, c), e) } var I$e = ["children", "className"]; function _4() { return _4 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, _4.apply(this, arguments) } function O$e(t, e) { if (t == null) return {}; var n = D$e(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function D$e(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } var ar = P.forwardRef(function (t, e) { var n = t.children, r = t.className, i = O$e(t, I$e), a = zn("recharts-layer", r); return P.createElement("g", _4({ className: a }, vn(i, !0), { ref: e }), n) }), Bc = function (e, n) { for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), a = 2; a < r; a++)i[a - 2] = arguments[a] }, NI, mG; function L$e() { if (mG) return NI; mG = 1; function t(e, n, r) { var i = -1, a = e.length; n < 0 && (n = -n > a ? 0 : a + n), r = r > a ? a : r, r < 0 && (r += a), a = n > r ? 0 : r - n >>> 0, n >>>= 0; for (var s = Array(a); ++i < a;)s[i] = e[i + n]; return s } return NI = t, NI } var AI, gG; function F$e() { if (gG) return AI; gG = 1; var t = L$e(); function e(n, r, i) { var a = n.length; return i = i === void 0 ? a : i, !r && i >= a ? n : t(n, r, i) } return AI = e, AI } var PI, vG; function yue() { if (vG) return PI; vG = 1; var t = "\\ud800-\\udfff", e = "\\u0300-\\u036f", n = "\\ufe20-\\ufe2f", r = "\\u20d0-\\u20ff", i = e + n + r, a = "\\ufe0e\\ufe0f", s = "\\u200d", o = RegExp("[" + s + t + i + a + "]"); function c(u) { return o.test(u) } return PI = c, PI } var jI, yG; function U$e() { if (yG) return jI; yG = 1; function t(e) { return e.split("") } return jI = t, jI } var RI, xG; function B$e() { if (xG) return RI; xG = 1; var t = "\\ud800-\\udfff", e = "\\u0300-\\u036f", n = "\\ufe20-\\ufe2f", r = "\\u20d0-\\u20ff", i = e + n + r, a = "\\ufe0e\\ufe0f", s = "[" + t + "]", o = "[" + i + "]", c = "\\ud83c[\\udffb-\\udfff]", u = "(?:" + o + "|" + c + ")", d = "[^" + t + "]", f = "(?:\\ud83c[\\udde6-\\uddff]){2}", h = "[\\ud800-\\udbff][\\udc00-\\udfff]", m = "\\u200d", g = u + "?", x = "[" + a + "]?", v = "(?:" + m + "(?:" + [d, f, h].join("|") + ")" + x + g + ")*", b = x + g + v, E = "(?:" + [d + o + "?", o, f, h, s].join("|") + ")", M = RegExp(c + "(?=" + c + ")|" + E + b, "g"); function C(N) { return N.match(M) || [] } return RI = C, RI } var kI, bG; function $$e() { if (bG) return kI; bG = 1; var t = U$e(), e = yue(), n = B$e(); function r(i) { return e(i) ? n(i) : t(i) } return kI = r, kI } var II, wG; function z$e() { if (wG) return II; wG = 1; var t = F$e(), e = yue(), n = $$e(), r = hue(); function i(a) { return function (s) { s = r(s); var o = e(s) ? n(s) : void 0, c = o ? o[0] : s.charAt(0), u = o ? t(o, 1).join("") : s.slice(1); return c[a]() + u } } return II = i, II } var OI, SG; function V$e() { if (SG) return OI; SG = 1; var t = z$e(), e = t("toUpperCase"); return OI = e, OI } var H$e = V$e(); const D2 = Fr(H$e); function mi(t) { return function () { return t } } const xue = Math.cos, aN = Math.sin, Qc = Math.sqrt, sN = Math.PI, L2 = 2 * sN, E4 = Math.PI, M4 = 2 * E4, zm = 1e-6, W$e = M4 - zm; function bue(t) { this._ += t[0]; for (let e = 1, n = t.length; e < n; ++e)this._ += arguments[e] + t[e] } function G$e(t) { let e = Math.floor(t); if (!(e >= 0)) throw new Error(`invalid digits: ${t}`); if (e > 15) return bue; const n = 10 ** e; return function (r) { this._ += r[0]; for (let i = 1, a = r.length; i < a; ++i)this._ += Math.round(arguments[i] * n) / n + r[i] } } class q$e { constructor(e) { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = e == null ? bue : G$e(e) } moveTo(e, n) { this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +n}` } closePath() { this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`) } lineTo(e, n) { this._append`L${this._x1 = +e},${this._y1 = +n}` } quadraticCurveTo(e, n, r, i) { this._append`Q${+e},${+n},${this._x1 = +r},${this._y1 = +i}` } bezierCurveTo(e, n, r, i, a, s) { this._append`C${+e},${+n},${+r},${+i},${this._x1 = +a},${this._y1 = +s}` } arcTo(e, n, r, i, a) { if (e = +e, n = +n, r = +r, i = +i, a = +a, a < 0) throw new Error(`negative radius: ${a}`); let s = this._x1, o = this._y1, c = r - e, u = i - n, d = s - e, f = o - n, h = d * d + f * f; if (this._x1 === null) this._append`M${this._x1 = e},${this._y1 = n}`; else if (h > zm) if (!(Math.abs(f * c - u * d) > zm) || !a) this._append`L${this._x1 = e},${this._y1 = n}`; else { let m = r - s, g = i - o, x = c * c + u * u, v = m * m + g * g, b = Math.sqrt(x), E = Math.sqrt(h), M = a * Math.tan((E4 - Math.acos((x + h - v) / (2 * b * E))) / 2), C = M / E, N = M / b; Math.abs(C - 1) > zm && this._append`L${e + C * d},${n + C * f}`, this._append`A${a},${a},0,0,${+(f * m > d * g)},${this._x1 = e + N * c},${this._y1 = n + N * u}` } } arc(e, n, r, i, a, s) { if (e = +e, n = +n, r = +r, s = !!s, r < 0) throw new Error(`negative radius: ${r}`); let o = r * Math.cos(i), c = r * Math.sin(i), u = e + o, d = n + c, f = 1 ^ s, h = s ? i - a : a - i; this._x1 === null ? this._append`M${u},${d}` : (Math.abs(this._x1 - u) > zm || Math.abs(this._y1 - d) > zm) && this._append`L${u},${d}`, r && (h < 0 && (h = h % M4 + M4), h > W$e ? this._append`A${r},${r},0,1,${f},${e - o},${n - c}A${r},${r},0,1,${f},${this._x1 = u},${this._y1 = d}` : h > zm && this._append`A${r},${r},0,${+(h >= E4)},${f},${this._x1 = e + r * Math.cos(a)},${this._y1 = n + r * Math.sin(a)}`) } rect(e, n, r, i) { this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z` } toString() { return this._ } } function A$(t) { let e = 3; return t.digits = function (n) { if (!arguments.length) return e; if (n == null) e = null; else { const r = Math.floor(n); if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`); e = r } return t }, () => new q$e(e) } function P$(t) { return typeof t == "object" && "length" in t ? t : Array.from(t) } function wue(t) { this._context = t } wue.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._point = 0 }, lineEnd: function () { (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, e) { switch (t = +t, e = +e, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e); break; case 1: this._point = 2; default: this._context.lineTo(t, e); break } } }; function F2(t) { return new wue(t) } function Sue(t) { return t[0] } function _ue(t) { return t[1] } function Eue(t, e) { var n = mi(!0), r = null, i = F2, a = null, s = A$(o); t = typeof t == "function" ? t : t === void 0 ? Sue : mi(t), e = typeof e == "function" ? e : e === void 0 ? _ue : mi(e); function o(c) { var u, d = (c = P$(c)).length, f, h = !1, m; for (r == null && (a = i(m = s())), u = 0; u <= d; ++u)!(u < d && n(f = c[u], u, c)) === h && ((h = !h) ? a.lineStart() : a.lineEnd()), h && a.point(+t(f, u, c), +e(f, u, c)); if (m) return a = null, m + "" || null } return o.x = function (c) { return arguments.length ? (t = typeof c == "function" ? c : mi(+c), o) : t }, o.y = function (c) { return arguments.length ? (e = typeof c == "function" ? c : mi(+c), o) : e }, o.defined = function (c) { return arguments.length ? (n = typeof c == "function" ? c : mi(!!c), o) : n }, o.curve = function (c) { return arguments.length ? (i = c, r != null && (a = i(r)), o) : i }, o.context = function (c) { return arguments.length ? (c == null ? r = a = null : a = i(r = c), o) : r }, o } function ZM(t, e, n) { var r = null, i = mi(!0), a = null, s = F2, o = null, c = A$(u); t = typeof t == "function" ? t : t === void 0 ? Sue : mi(+t), e = typeof e == "function" ? e : mi(e === void 0 ? 0 : +e), n = typeof n == "function" ? n : n === void 0 ? _ue : mi(+n); function u(f) { var h, m, g, x = (f = P$(f)).length, v, b = !1, E, M = new Array(x), C = new Array(x); for (a == null && (o = s(E = c())), h = 0; h <= x; ++h) { if (!(h < x && i(v = f[h], h, f)) === b) if (b = !b) m = h, o.areaStart(), o.lineStart(); else { for (o.lineEnd(), o.lineStart(), g = h - 1; g >= m; --g)o.point(M[g], C[g]); o.lineEnd(), o.areaEnd() } b && (M[h] = +t(v, h, f), C[h] = +e(v, h, f), o.point(r ? +r(v, h, f) : M[h], n ? +n(v, h, f) : C[h])) } if (E) return o = null, E + "" || null } function d() { return Eue().defined(i).curve(s).context(a) } return u.x = function (f) { return arguments.length ? (t = typeof f == "function" ? f : mi(+f), r = null, u) : t }, u.x0 = function (f) { return arguments.length ? (t = typeof f == "function" ? f : mi(+f), u) : t }, u.x1 = function (f) { return arguments.length ? (r = f == null ? null : typeof f == "function" ? f : mi(+f), u) : r }, u.y = function (f) { return arguments.length ? (e = typeof f == "function" ? f : mi(+f), n = null, u) : e }, u.y0 = function (f) { return arguments.length ? (e = typeof f == "function" ? f : mi(+f), u) : e }, u.y1 = function (f) { return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : mi(+f), u) : n }, u.lineX0 = u.lineY0 = function () { return d().x(t).y(e) }, u.lineY1 = function () { return d().x(t).y(n) }, u.lineX1 = function () { return d().x(r).y(e) }, u.defined = function (f) { return arguments.length ? (i = typeof f == "function" ? f : mi(!!f), u) : i }, u.curve = function (f) { return arguments.length ? (s = f, a != null && (o = s(a)), u) : s }, u.context = function (f) { return arguments.length ? (f == null ? a = o = null : o = s(a = f), u) : a }, u } class Mue { constructor(e, n) { this._context = e, this._x = n } areaStart() { this._line = 0 } areaEnd() { this._line = NaN } lineStart() { this._point = 0 } lineEnd() { (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line } point(e, n) { switch (e = +e, n = +n, this._point) { case 0: { this._point = 1, this._line ? this._context.lineTo(e, n) : this._context.moveTo(e, n); break } case 1: this._point = 2; default: { this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, n, e, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, e, this._y0, e, n); break } }this._x0 = e, this._y0 = n } } function X$e(t) { return new Mue(t, !0) } function Y$e(t) { return new Mue(t, !1) } const j$ = { draw(t, e) { const n = Qc(e / sN); t.moveTo(n, 0), t.arc(0, 0, n, 0, L2) } }, K$e = { draw(t, e) { const n = Qc(e / 5) / 2; t.moveTo(-3 * n, -n), t.lineTo(-n, -n), t.lineTo(-n, -3 * n), t.lineTo(n, -3 * n), t.lineTo(n, -n), t.lineTo(3 * n, -n), t.lineTo(3 * n, n), t.lineTo(n, n), t.lineTo(n, 3 * n), t.lineTo(-n, 3 * n), t.lineTo(-n, n), t.lineTo(-3 * n, n), t.closePath() } }, Tue = Qc(1 / 3), Z$e = Tue * 2, Q$e = { draw(t, e) { const n = Qc(e / Z$e), r = n * Tue; t.moveTo(0, -n), t.lineTo(r, 0), t.lineTo(0, n), t.lineTo(-r, 0), t.closePath() } }, J$e = { draw(t, e) { const n = Qc(e), r = -n / 2; t.rect(r, r, n, n) } }, eze = .8908130915292852, Cue = aN(sN / 10) / aN(7 * sN / 10), tze = aN(L2 / 10) * Cue, nze = -xue(L2 / 10) * Cue, rze = { draw(t, e) { const n = Qc(e * eze), r = tze * n, i = nze * n; t.moveTo(0, -n), t.lineTo(r, i); for (let a = 1; a < 5; ++a) { const s = L2 * a / 5, o = xue(s), c = aN(s); t.lineTo(c * n, -o * n), t.lineTo(o * r - c * i, c * r + o * i) } t.closePath() } }, DI = Qc(3), ize = { draw(t, e) { const n = -Qc(e / (DI * 3)); t.moveTo(0, n * 2), t.lineTo(-DI * n, -n), t.lineTo(DI * n, -n), t.closePath() } }, jl = -.5, Rl = Qc(3) / 2, T4 = 1 / Qc(12), aze = (T4 / 2 + 1) * 3, sze = { draw(t, e) { const n = Qc(e / aze), r = n / 2, i = n * T4, a = r, s = n * T4 + n, o = -a, c = s; t.moveTo(r, i), t.lineTo(a, s), t.lineTo(o, c), t.lineTo(jl * r - Rl * i, Rl * r + jl * i), t.lineTo(jl * a - Rl * s, Rl * a + jl * s), t.lineTo(jl * o - Rl * c, Rl * o + jl * c), t.lineTo(jl * r + Rl * i, jl * i - Rl * r), t.lineTo(jl * a + Rl * s, jl * s - Rl * a), t.lineTo(jl * o + Rl * c, jl * c - Rl * o), t.closePath() } }; function oze(t, e) { let n = null, r = A$(i); t = typeof t == "function" ? t : mi(t || j$), e = typeof e == "function" ? e : mi(e === void 0 ? 64 : +e); function i() { let a; if (n || (n = a = r()), t.apply(this, arguments).draw(n, +e.apply(this, arguments)), a) return n = null, a + "" || null } return i.type = function (a) { return arguments.length ? (t = typeof a == "function" ? a : mi(a), i) : t }, i.size = function (a) { return arguments.length ? (e = typeof a == "function" ? a : mi(+a), i) : e }, i.context = function (a) { return arguments.length ? (n = a ?? null, i) : n }, i } function oN() { } function lN(t, e, n) { t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + e) / 6, (t._y0 + 4 * t._y1 + n) / 6) } function Nue(t) { this._context = t } Nue.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 3: lN(this, this._x1, this._y1); case 2: this._context.lineTo(this._x1, this._y1); break }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, e) { switch (t = +t, e = +e, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e); break; case 1: this._point = 2; break; case 2: this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); default: lN(this, t, e); break }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e } }; function lze(t) { return new Nue(t) } function Aue(t) { this._context = t } Aue.prototype = { areaStart: oN, areaEnd: oN, lineStart: function () { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 1: { this._context.moveTo(this._x2, this._y2), this._context.closePath(); break } case 2: { this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath(); break } case 3: { this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4); break } } }, point: function (t, e) { switch (t = +t, e = +e, this._point) { case 0: this._point = 1, this._x2 = t, this._y2 = e; break; case 1: this._point = 2, this._x3 = t, this._y3 = e; break; case 2: this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6); break; default: lN(this, t, e); break }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e } }; function cze(t) { return new Aue(t) } function Pue(t) { this._context = t } Pue.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function () { (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, e) { switch (t = +t, e = +e, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3; var n = (this._x0 + 4 * this._x1 + t) / 6, r = (this._y0 + 4 * this._y1 + e) / 6; this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r); break; case 3: this._point = 4; default: lN(this, t, e); break }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e } }; function uze(t) { return new Pue(t) } function jue(t) { this._context = t } jue.prototype = { areaStart: oN, areaEnd: oN, lineStart: function () { this._point = 0 }, lineEnd: function () { this._point && this._context.closePath() }, point: function (t, e) { t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e)) } }; function dze(t) { return new jue(t) } function _G(t) { return t < 0 ? -1 : 1 } function EG(t, e, n) { var r = t._x1 - t._x0, i = e - t._x1, a = (t._y1 - t._y0) / (r || i < 0 && -0), s = (n - t._y1) / (i || r < 0 && -0), o = (a * i + s * r) / (r + i); return (_G(a) + _G(s)) * Math.min(Math.abs(a), Math.abs(s), .5 * Math.abs(o)) || 0 } function MG(t, e) { var n = t._x1 - t._x0; return n ? (3 * (t._y1 - t._y0) / n - e) / 2 : e } function LI(t, e, n) { var r = t._x0, i = t._y0, a = t._x1, s = t._y1, o = (a - r) / 3; t._context.bezierCurveTo(r + o, i + o * e, a - o, s - o * n, a, s) } function cN(t) { this._context = t } cN.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0 }, lineEnd: function () { switch (this._point) { case 2: this._context.lineTo(this._x1, this._y1); break; case 3: LI(this, this._t0, MG(this, this._t0)); break }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line }, point: function (t, e) { var n = NaN; if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) { switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e); break; case 1: this._point = 2; break; case 2: this._point = 3, LI(this, MG(this, n = EG(this, t, e)), n); break; default: LI(this, this._t0, n = EG(this, t, e)); break }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = n } } }; function Rue(t) { this._context = new kue(t) } (Rue.prototype = Object.create(cN.prototype)).point = function (t, e) { cN.prototype.point.call(this, e, t) }; function kue(t) { this._context = t } kue.prototype = { moveTo: function (t, e) { this._context.moveTo(e, t) }, closePath: function () { this._context.closePath() }, lineTo: function (t, e) { this._context.lineTo(e, t) }, bezierCurveTo: function (t, e, n, r, i, a) { this._context.bezierCurveTo(e, t, r, n, a, i) } }; function fze(t) { return new cN(t) } function hze(t) { return new Rue(t) } function Iue(t) { this._context = t } Iue.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x = [], this._y = [] }, lineEnd: function () { var t = this._x, e = this._y, n = t.length; if (n) if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), n === 2) this._context.lineTo(t[1], e[1]); else for (var r = TG(t), i = TG(e), a = 0, s = 1; s < n; ++a, ++s)this._context.bezierCurveTo(r[0][a], i[0][a], r[1][a], i[1][a], t[s], e[s]); (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null }, point: function (t, e) { this._x.push(+t), this._y.push(+e) } }; function TG(t) { var e, n = t.length - 1, r, i = new Array(n), a = new Array(n), s = new Array(n); for (i[0] = 0, a[0] = 2, s[0] = t[0] + 2 * t[1], e = 1; e < n - 1; ++e)i[e] = 1, a[e] = 4, s[e] = 4 * t[e] + 2 * t[e + 1]; for (i[n - 1] = 2, a[n - 1] = 7, s[n - 1] = 8 * t[n - 1] + t[n], e = 1; e < n; ++e)r = i[e] / a[e - 1], a[e] -= r, s[e] -= r * s[e - 1]; for (i[n - 1] = s[n - 1] / a[n - 1], e = n - 2; e >= 0; --e)i[e] = (s[e] - i[e + 1]) / a[e]; for (a[n - 1] = (t[n] + i[n - 1]) / 2, e = 0; e < n - 1; ++e)a[e] = 2 * t[e + 1] - i[e + 1]; return [i, a] } function pze(t) { return new Iue(t) } function U2(t, e) { this._context = t, this._t = e } U2.prototype = { areaStart: function () { this._line = 0 }, areaEnd: function () { this._line = NaN }, lineStart: function () { this._x = this._y = NaN, this._point = 0 }, lineEnd: function () { 0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line) }, point: function (t, e) { switch (t = +t, e = +e, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e); break; case 1: this._point = 2; default: { if (this._t <= 0) this._context.lineTo(this._x, e), this._context.lineTo(t, e); else { var n = this._x * (1 - this._t) + t * this._t; this._context.lineTo(n, this._y), this._context.lineTo(n, e) } break } }this._x = t, this._y = e } }; function mze(t) { return new U2(t, .5) } function gze(t) { return new U2(t, 0) } function vze(t) { return new U2(t, 1) } function Ix(t, e) { if ((s = t.length) > 1) for (var n = 1, r, i, a = t[e[0]], s, o = a.length; n < s; ++n)for (i = a, a = t[e[n]], r = 0; r < o; ++r)a[r][1] += a[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1] } function C4(t) { for (var e = t.length, n = new Array(e); --e >= 0;)n[e] = e; return n } function yze(t, e) { return t[e] } function xze(t) { const e = []; return e.key = t, e } function bze() { var t = mi([]), e = C4, n = Ix, r = yze; function i(a) { var s = Array.from(t.apply(this, arguments), xze), o, c = s.length, u = -1, d; for (const f of a) for (o = 0, ++u; o < c; ++o)(s[o][u] = [0, +r(f, s[o].key, u, a)]).data = f; for (o = 0, d = P$(e(s)); o < c; ++o)s[d[o]].index = o; return n(s, d), s } return i.keys = function (a) { return arguments.length ? (t = typeof a == "function" ? a : mi(Array.from(a)), i) : t }, i.value = function (a) { return arguments.length ? (r = typeof a == "function" ? a : mi(+a), i) : r }, i.order = function (a) { return arguments.length ? (e = a == null ? C4 : typeof a == "function" ? a : mi(Array.from(a)), i) : e }, i.offset = function (a) { return arguments.length ? (n = a ?? Ix, i) : n }, i } function wze(t, e) { if ((r = t.length) > 0) { for (var n, r, i = 0, a = t[0].length, s; i < a; ++i) { for (s = n = 0; n < r; ++n)s += t[n][i][1] || 0; if (s) for (n = 0; n < r; ++n)t[n][i][1] /= s } Ix(t, e) } } function Sze(t, e) { if ((i = t.length) > 0) { for (var n = 0, r = t[e[0]], i, a = r.length; n < a; ++n) { for (var s = 0, o = 0; s < i; ++s)o += t[s][n][1] || 0; r[n][1] += r[n][0] = -o / 2 } Ix(t, e) } } function _ze(t, e) { if (!(!((s = t.length) > 0) || !((a = (i = t[e[0]]).length) > 0))) { for (var n = 0, r = 1, i, a, s; r < a; ++r) { for (var o = 0, c = 0, u = 0; o < s; ++o) { for (var d = t[e[o]], f = d[r][1] || 0, h = d[r - 1][1] || 0, m = (f - h) / 2, g = 0; g < o; ++g) { var x = t[e[g]], v = x[r][1] || 0, b = x[r - 1][1] || 0; m += v - b } c += f, u += m * f } i[r - 1][1] += i[r - 1][0] = n, c && (n -= u / c) } i[r - 1][1] += i[r - 1][0] = n, Ix(t, e) } } function X1(t) { "@babel/helpers - typeof"; return X1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, X1(t) } var Eze = ["type", "size", "sizeType"]; function N4() { return N4 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, N4.apply(this, arguments) } function CG(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function NG(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? CG(Object(n), !0).forEach(function (r) { Mze(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : CG(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Mze(t, e, n) { return e = Tze(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Tze(t) { var e = Cze(t, "string"); return X1(e) == "symbol" ? e : e + "" } function Cze(t, e) { if (X1(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (X1(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function Nze(t, e) { if (t == null) return {}; var n = Aze(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function Aze(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } var Oue = { symbolCircle: j$, symbolCross: K$e, symbolDiamond: Q$e, symbolSquare: J$e, symbolStar: rze, symbolTriangle: ize, symbolWye: sze }, Pze = Math.PI / 180, jze = function (e) { var n = "symbol".concat(D2(e)); return Oue[n] || j$ }, Rze = function (e, n, r) { if (n === "area") return e; switch (r) { case "cross": return 5 * e * e / 9; case "diamond": return .5 * e * e / Math.sqrt(3); case "square": return e * e; case "star": { var i = 18 * Pze; return 1.25 * e * e * (Math.tan(i) - Math.tan(i * 2) * Math.pow(Math.tan(i), 2)) } case "triangle": return Math.sqrt(3) * e * e / 4; case "wye": return (21 - 10 * Math.sqrt(3)) * e * e / 8; default: return Math.PI * e * e / 4 } }, kze = function (e, n) { Oue["symbol".concat(D2(e))] = n }, B2 = function (e) { var n = e.type, r = n === void 0 ? "circle" : n, i = e.size, a = i === void 0 ? 64 : i, s = e.sizeType, o = s === void 0 ? "area" : s, c = Nze(e, Eze), u = NG(NG({}, c), {}, { type: r, size: a, sizeType: o }), d = function () { var v = jze(r), b = oze().type(v).size(Rze(a, o, r)); return b() }, f = u.className, h = u.cx, m = u.cy, g = vn(u, !0); return h === +h && m === +m && a === +a ? P.createElement("path", N4({}, g, { className: zn("recharts-symbols", f), transform: "translate(".concat(h, ", ").concat(m, ")"), d: d() })) : null }; B2.registerSymbol = kze; function Ox(t) { "@babel/helpers - typeof"; return Ox = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Ox(t) } function A4() { return A4 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, A4.apply(this, arguments) } function AG(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ize(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? AG(Object(n), !0).forEach(function (r) { Y1(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : AG(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Oze(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Dze(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Lue(r.key), r) } } function Lze(t, e, n) { return e && Dze(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function Fze(t, e, n) { return e = uN(e), Uze(t, Due() ? Reflect.construct(e, n || [], uN(t).constructor) : e.apply(t, n)) } function Uze(t, e) { if (e && (Ox(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Bze(t) } function Bze(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Due() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Due = function () { return !!t })() } function uN(t) { return uN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, uN(t) } function $ze(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && P4(t, e) } function P4(t, e) { return P4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, P4(t, e) } function Y1(t, e, n) { return e = Lue(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Lue(t) { var e = zze(t, "string"); return Ox(e) == "symbol" ? e : e + "" } function zze(t, e) { if (Ox(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Ox(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var kl = 32, R$ = (function (t) {
	function e() { return Oze(this, e), Fze(this, e, arguments) } return $ze(e, t), Lze(e, [{
		key: "renderIcon", value: function (r) {
			var i = this.props.inactiveColor, a = kl / 2, s = kl / 6, o = kl / 3, c = r.inactive ? i : r.color; if (r.type === "plainline") return P.createElement("line", { strokeWidth: 4, fill: "none", stroke: c, strokeDasharray: r.payload.strokeDasharray, x1: 0, y1: a, x2: kl, y2: a, className: "recharts-legend-icon" }); if (r.type === "line") return P.createElement("path", {
				strokeWidth: 4, fill: "none", stroke: c, d: "M0,".concat(a, "h").concat(o, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(2 * o, ",").concat(a, `
            H`).concat(kl, "M").concat(2 * o, ",").concat(a, `
            A`).concat(s, ",").concat(s, ",0,1,1,").concat(o, ",").concat(a), className: "recharts-legend-icon"
			}); if (r.type === "rect") return P.createElement("path", { stroke: "none", fill: c, d: "M0,".concat(kl / 8, "h").concat(kl, "v").concat(kl * 3 / 4, "h").concat(-kl, "z"), className: "recharts-legend-icon" }); if (P.isValidElement(r.legendIcon)) { var u = Ize({}, r); return delete u.legendIcon, P.cloneElement(r.legendIcon, u) } return P.createElement(B2, { fill: c, cx: a, cy: a, size: kl, sizeType: "diameter", type: r.type })
		}
	}, { key: "renderItems", value: function () { var r = this, i = this.props, a = i.payload, s = i.iconSize, o = i.layout, c = i.formatter, u = i.inactiveColor, d = { x: 0, y: 0, width: kl, height: kl }, f = { display: o === "horizontal" ? "inline-block" : "block", marginRight: 10 }, h = { display: "inline-block", verticalAlign: "middle", marginRight: 4 }; return a.map(function (m, g) { var x = m.formatter || c, v = zn(Y1(Y1({ "recharts-legend-item": !0 }, "legend-item-".concat(g), !0), "inactive", m.inactive)); if (m.type === "none") return null; var b = Rn(m.value) ? null : m.value; Bc(!Rn(m.value), `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`); var E = m.inactive ? u : m.color; return P.createElement("li", A4({ className: v, style: f, key: "legend-item-".concat(g) }, ap(r.props, m, g)), P.createElement(S4, { width: s, height: s, viewBox: d, style: h }, r.renderIcon(m)), P.createElement("span", { className: "recharts-legend-item-text", style: { color: E } }, x ? x(b, m, g) : b)) }) } }, { key: "render", value: function () { var r = this.props, i = r.payload, a = r.layout, s = r.align; if (!i || !i.length) return null; var o = { padding: 0, margin: 0, textAlign: a === "horizontal" ? s : "left" }; return P.createElement("ul", { className: "recharts-default-legend", style: o }, this.renderItems()) } }])
})(S.PureComponent); Y1(R$, "displayName", "Legend"); Y1(R$, "defaultProps", { iconSize: 14, layout: "horizontal", align: "center", verticalAlign: "middle", inactiveColor: "#ccc" }); var FI, PG; function Vze() { if (PG) return FI; PG = 1; var t = k2(); function e() { this.__data__ = new t, this.size = 0 } return FI = e, FI } var UI, jG; function Hze() { if (jG) return UI; jG = 1; function t(e) { var n = this.__data__, r = n.delete(e); return this.size = n.size, r } return UI = t, UI } var BI, RG; function Wze() { if (RG) return BI; RG = 1; function t(e) { return this.__data__.get(e) } return BI = t, BI } var $I, kG; function Gze() { if (kG) return $I; kG = 1; function t(e) { return this.__data__.has(e) } return $I = t, $I } var zI, IG; function qze() { if (IG) return zI; IG = 1; var t = k2(), e = _$(), n = E$(), r = 200; function i(a, s) { var o = this.__data__; if (o instanceof t) { var c = o.__data__; if (!e || c.length < r - 1) return c.push([a, s]), this.size = ++o.size, this; o = this.__data__ = new n(c) } return o.set(a, s), this.size = o.size, this } return zI = i, zI } var VI, OG; function Fue() { if (OG) return VI; OG = 1; var t = k2(), e = Vze(), n = Hze(), r = Wze(), i = Gze(), a = qze(); function s(o) { var c = this.__data__ = new t(o); this.size = c.size } return s.prototype.clear = e, s.prototype.delete = n, s.prototype.get = r, s.prototype.has = i, s.prototype.set = a, VI = s, VI } var HI, DG; function Xze() { if (DG) return HI; DG = 1; var t = "__lodash_hash_undefined__"; function e(n) { return this.__data__.set(n, t), this } return HI = e, HI } var WI, LG; function Yze() { if (LG) return WI; LG = 1; function t(e) { return this.__data__.has(e) } return WI = t, WI } var GI, FG; function Uue() { if (FG) return GI; FG = 1; var t = E$(), e = Xze(), n = Yze(); function r(i) { var a = -1, s = i == null ? 0 : i.length; for (this.__data__ = new t; ++a < s;)this.add(i[a]) } return r.prototype.add = r.prototype.push = e, r.prototype.has = n, GI = r, GI } var qI, UG; function Bue() { if (UG) return qI; UG = 1; function t(e, n) { for (var r = -1, i = e == null ? 0 : e.length; ++r < i;)if (n(e[r], r, e)) return !0; return !1 } return qI = t, qI } var XI, BG; function $ue() { if (BG) return XI; BG = 1; function t(e, n) { return e.has(n) } return XI = t, XI } var YI, $G; function zue() { if ($G) return YI; $G = 1; var t = Uue(), e = Bue(), n = $ue(), r = 1, i = 2; function a(s, o, c, u, d, f) { var h = c & r, m = s.length, g = o.length; if (m != g && !(h && g > m)) return !1; var x = f.get(s), v = f.get(o); if (x && v) return x == o && v == s; var b = -1, E = !0, M = c & i ? new t : void 0; for (f.set(s, o), f.set(o, s); ++b < m;) { var C = s[b], N = o[b]; if (u) var A = h ? u(N, C, b, o, s, f) : u(C, N, b, s, o, f); if (A !== void 0) { if (A) continue; E = !1; break } if (M) { if (!e(o, function (j, O) { if (!n(M, O) && (C === j || d(C, j, c, u, f))) return M.push(O) })) { E = !1; break } } else if (!(C === N || d(C, N, c, u, f))) { E = !1; break } } return f.delete(s), f.delete(o), E } return YI = a, YI } var KI, zG; function Kze() { if (zG) return KI; zG = 1; var t = ed(), e = t.Uint8Array; return KI = e, KI } var ZI, VG; function Zze() { if (VG) return ZI; VG = 1; function t(e) { var n = -1, r = Array(e.size); return e.forEach(function (i, a) { r[++n] = [a, i] }), r } return ZI = t, ZI } var QI, HG; function k$() { if (HG) return QI; HG = 1; function t(e) { var n = -1, r = Array(e.size); return e.forEach(function (i) { r[++n] = i }), r } return QI = t, QI } var JI, WG; function Qze() { if (WG) return JI; WG = 1; var t = E_(), e = Kze(), n = S$(), r = zue(), i = Zze(), a = k$(), s = 1, o = 2, c = "[object Boolean]", u = "[object Date]", d = "[object Error]", f = "[object Map]", h = "[object Number]", m = "[object RegExp]", g = "[object Set]", x = "[object String]", v = "[object Symbol]", b = "[object ArrayBuffer]", E = "[object DataView]", M = t ? t.prototype : void 0, C = M ? M.valueOf : void 0; function N(A, j, O, I, D, F, B) { switch (O) { case E: if (A.byteLength != j.byteLength || A.byteOffset != j.byteOffset) return !1; A = A.buffer, j = j.buffer; case b: return !(A.byteLength != j.byteLength || !F(new e(A), new e(j))); case c: case u: case h: return n(+A, +j); case d: return A.name == j.name && A.message == j.message; case m: case x: return A == j + ""; case f: var G = i; case g: var z = I & s; if (G || (G = a), A.size != j.size && !z) return !1; var q = B.get(A); if (q) return q == j; I |= o, B.set(A, j); var Y = r(G(A), G(j), I, D, F, B); return B.delete(A), Y; case v: if (C) return C.call(A) == C.call(j) }return !1 } return JI = N, JI } var eO, GG; function Vue() { if (GG) return eO; GG = 1; function t(e, n) { for (var r = -1, i = n.length, a = e.length; ++r < i;)e[a + r] = n[r]; return e } return eO = t, eO } var tO, qG; function Jze() { if (qG) return tO; qG = 1; var t = Vue(), e = Vo(); function n(r, i, a) { var s = i(r); return e(r) ? s : t(s, a(r)) } return tO = n, tO } var nO, XG; function e6e() { if (XG) return nO; XG = 1; function t(e, n) { for (var r = -1, i = e == null ? 0 : e.length, a = 0, s = []; ++r < i;) { var o = e[r]; n(o, r, e) && (s[a++] = o) } return s } return nO = t, nO } var rO, YG; function t6e() { if (YG) return rO; YG = 1; function t() { return [] } return rO = t, rO } var iO, KG; function n6e() { if (KG) return iO; KG = 1; var t = e6e(), e = t6e(), n = Object.prototype, r = n.propertyIsEnumerable, i = Object.getOwnPropertySymbols, a = i ? function (s) { return s == null ? [] : (s = Object(s), t(i(s), function (o) { return r.call(s, o) })) } : e; return iO = a, iO } var aO, ZG; function r6e() { if (ZG) return aO; ZG = 1; function t(e, n) { for (var r = -1, i = Array(e); ++r < e;)i[r] = n(r); return i } return aO = t, aO } var sO, QG; function i6e() { if (QG) return sO; QG = 1; var t = Mf(), e = Tf(), n = "[object Arguments]"; function r(i) { return e(i) && t(i) == n } return sO = r, sO } var oO, JG; function I$() { if (JG) return oO; JG = 1; var t = i6e(), e = Tf(), n = Object.prototype, r = n.hasOwnProperty, i = n.propertyIsEnumerable, a = t((function () { return arguments })()) ? t : function (s) { return e(s) && r.call(s, "callee") && !i.call(s, "callee") }; return oO = a, oO } var Dw = { exports: {} }, lO, eq; function a6e() { if (eq) return lO; eq = 1; function t() { return !1 } return lO = t, lO } Dw.exports; var tq; function Hue() { return tq || (tq = 1, (function (t, e) { var n = ed(), r = a6e(), i = e && !e.nodeType && e, a = i && !0 && t && !t.nodeType && t, s = a && a.exports === i, o = s ? n.Buffer : void 0, c = o ? o.isBuffer : void 0, u = c || r; t.exports = u })(Dw, Dw.exports)), Dw.exports } var cO, nq; function O$() { if (nq) return cO; nq = 1; var t = 9007199254740991, e = /^(?:0|[1-9]\d*)$/; function n(r, i) { var a = typeof r; return i = i ?? t, !!i && (a == "number" || a != "symbol" && e.test(r)) && r > -1 && r % 1 == 0 && r < i } return cO = n, cO } var uO, rq; function D$() { if (rq) return uO; rq = 1; var t = 9007199254740991; function e(n) { return typeof n == "number" && n > -1 && n % 1 == 0 && n <= t } return uO = e, uO } var dO, iq; function s6e() { if (iq) return dO; iq = 1; var t = Mf(), e = D$(), n = Tf(), r = "[object Arguments]", i = "[object Array]", a = "[object Boolean]", s = "[object Date]", o = "[object Error]", c = "[object Function]", u = "[object Map]", d = "[object Number]", f = "[object Object]", h = "[object RegExp]", m = "[object Set]", g = "[object String]", x = "[object WeakMap]", v = "[object ArrayBuffer]", b = "[object DataView]", E = "[object Float32Array]", M = "[object Float64Array]", C = "[object Int8Array]", N = "[object Int16Array]", A = "[object Int32Array]", j = "[object Uint8Array]", O = "[object Uint8ClampedArray]", I = "[object Uint16Array]", D = "[object Uint32Array]", F = {}; F[E] = F[M] = F[C] = F[N] = F[A] = F[j] = F[O] = F[I] = F[D] = !0, F[r] = F[i] = F[v] = F[a] = F[b] = F[s] = F[o] = F[c] = F[u] = F[d] = F[f] = F[h] = F[m] = F[g] = F[x] = !1; function B(G) { return n(G) && e(G.length) && !!F[t(G)] } return dO = B, dO } var fO, aq; function Wue() { if (aq) return fO; aq = 1; function t(e) { return function (n) { return e(n) } } return fO = t, fO } var Lw = { exports: {} }; Lw.exports; var sq; function o6e() { return sq || (sq = 1, (function (t, e) { var n = uue(), r = e && !e.nodeType && e, i = r && !0 && t && !t.nodeType && t, a = i && i.exports === r, s = a && n.process, o = (function () { try { var c = i && i.require && i.require("util").types; return c || s && s.binding && s.binding("util") } catch { } })(); t.exports = o })(Lw, Lw.exports)), Lw.exports } var hO, oq; function Gue() { if (oq) return hO; oq = 1; var t = s6e(), e = Wue(), n = o6e(), r = n && n.isTypedArray, i = r ? e(r) : t; return hO = i, hO } var pO, lq; function l6e() { if (lq) return pO; lq = 1; var t = r6e(), e = I$(), n = Vo(), r = Hue(), i = O$(), a = Gue(), s = Object.prototype, o = s.hasOwnProperty; function c(u, d) { var f = n(u), h = !f && e(u), m = !f && !h && r(u), g = !f && !h && !m && a(u), x = f || h || m || g, v = x ? t(u.length, String) : [], b = v.length; for (var E in u) (d || o.call(u, E)) && !(x && (E == "length" || m && (E == "offset" || E == "parent") || g && (E == "buffer" || E == "byteLength" || E == "byteOffset") || i(E, b))) && v.push(E); return v } return pO = c, pO } var mO, cq; function c6e() { if (cq) return mO; cq = 1; var t = Object.prototype; function e(n) { var r = n && n.constructor, i = typeof r == "function" && r.prototype || t; return n === i } return mO = e, mO } var gO, uq; function que() { if (uq) return gO; uq = 1; function t(e, n) { return function (r) { return e(n(r)) } } return gO = t, gO } var vO, dq; function u6e() { if (dq) return vO; dq = 1; var t = que(), e = t(Object.keys, Object); return vO = e, vO } var yO, fq; function d6e() { if (fq) return yO; fq = 1; var t = c6e(), e = u6e(), n = Object.prototype, r = n.hasOwnProperty; function i(a) { if (!t(a)) return e(a); var s = []; for (var o in Object(a)) r.call(a, o) && o != "constructor" && s.push(o); return s } return yO = i, yO } var xO, hq; function M_() { if (hq) return xO; hq = 1; var t = w$(), e = D$(); function n(r) { return r != null && e(r.length) && !t(r) } return xO = n, xO } var bO, pq; function $2() { if (pq) return bO; pq = 1; var t = l6e(), e = d6e(), n = M_(); function r(i) { return n(i) ? t(i) : e(i) } return bO = r, bO } var wO, mq; function f6e() { if (mq) return wO; mq = 1; var t = Jze(), e = n6e(), n = $2(); function r(i) { return t(i, n, e) } return wO = r, wO } var SO, gq; function h6e() { if (gq) return SO; gq = 1; var t = f6e(), e = 1, n = Object.prototype, r = n.hasOwnProperty; function i(a, s, o, c, u, d) { var f = o & e, h = t(a), m = h.length, g = t(s), x = g.length; if (m != x && !f) return !1; for (var v = m; v--;) { var b = h[v]; if (!(f ? b in s : r.call(s, b))) return !1 } var E = d.get(a), M = d.get(s); if (E && M) return E == s && M == a; var C = !0; d.set(a, s), d.set(s, a); for (var N = f; ++v < m;) { b = h[v]; var A = a[b], j = s[b]; if (c) var O = f ? c(j, A, b, s, a, d) : c(A, j, b, a, s, d); if (!(O === void 0 ? A === j || u(A, j, o, c, d) : O)) { C = !1; break } N || (N = b == "constructor") } if (C && !N) { var I = a.constructor, D = s.constructor; I != D && "constructor" in a && "constructor" in s && !(typeof I == "function" && I instanceof I && typeof D == "function" && D instanceof D) && (C = !1) } return d.delete(a), d.delete(s), C } return SO = i, SO } var _O, vq; function p6e() { if (vq) return _O; vq = 1; var t = Xg(), e = ed(), n = t(e, "DataView"); return _O = n, _O } var EO, yq; function m6e() { if (yq) return EO; yq = 1; var t = Xg(), e = ed(), n = t(e, "Promise"); return EO = n, EO } var MO, xq; function Xue() { if (xq) return MO; xq = 1; var t = Xg(), e = ed(), n = t(e, "Set"); return MO = n, MO } var TO, bq; function g6e() { if (bq) return TO; bq = 1; var t = Xg(), e = ed(), n = t(e, "WeakMap"); return TO = n, TO } var CO, wq; function v6e() { if (wq) return CO; wq = 1; var t = p6e(), e = _$(), n = m6e(), r = Xue(), i = g6e(), a = Mf(), s = due(), o = "[object Map]", c = "[object Object]", u = "[object Promise]", d = "[object Set]", f = "[object WeakMap]", h = "[object DataView]", m = s(t), g = s(e), x = s(n), v = s(r), b = s(i), E = a; return (t && E(new t(new ArrayBuffer(1))) != h || e && E(new e) != o || n && E(n.resolve()) != u || r && E(new r) != d || i && E(new i) != f) && (E = function (M) { var C = a(M), N = C == c ? M.constructor : void 0, A = N ? s(N) : ""; if (A) switch (A) { case m: return h; case g: return o; case x: return u; case v: return d; case b: return f }return C }), CO = E, CO } var NO, Sq; function y6e() { if (Sq) return NO; Sq = 1; var t = Fue(), e = zue(), n = Qze(), r = h6e(), i = v6e(), a = Vo(), s = Hue(), o = Gue(), c = 1, u = "[object Arguments]", d = "[object Array]", f = "[object Object]", h = Object.prototype, m = h.hasOwnProperty; function g(x, v, b, E, M, C) { var N = a(x), A = a(v), j = N ? d : i(x), O = A ? d : i(v); j = j == u ? f : j, O = O == u ? f : O; var I = j == f, D = O == f, F = j == O; if (F && s(x)) { if (!s(v)) return !1; N = !0, I = !1 } if (F && !I) return C || (C = new t), N || o(x) ? e(x, v, b, E, M, C) : n(x, v, j, b, E, M, C); if (!(b & c)) { var B = I && m.call(x, "__wrapped__"), G = D && m.call(v, "__wrapped__"); if (B || G) { var z = B ? x.value() : x, q = G ? v.value() : v; return C || (C = new t), M(z, q, b, E, C) } } return F ? (C || (C = new t), r(x, v, b, E, M, C)) : !1 } return NO = g, NO } var AO, _q; function L$() { if (_q) return AO; _q = 1; var t = y6e(), e = Tf(); function n(r, i, a, s, o) { return r === i ? !0 : r == null || i == null || !e(r) && !e(i) ? r !== r && i !== i : t(r, i, a, s, n, o) } return AO = n, AO } var PO, Eq; function x6e() { if (Eq) return PO; Eq = 1; var t = Fue(), e = L$(), n = 1, r = 2; function i(a, s, o, c) { var u = o.length, d = u, f = !c; if (a == null) return !d; for (a = Object(a); u--;) { var h = o[u]; if (f && h[2] ? h[1] !== a[h[0]] : !(h[0] in a)) return !1 } for (; ++u < d;) { h = o[u]; var m = h[0], g = a[m], x = h[1]; if (f && h[2]) { if (g === void 0 && !(m in a)) return !1 } else { var v = new t; if (c) var b = c(g, x, m, a, s, v); if (!(b === void 0 ? e(x, g, n | r, c, v) : b)) return !1 } } return !0 } return PO = i, PO } var jO, Mq; function Yue() { if (Mq) return jO; Mq = 1; var t = _p(); function e(n) { return n === n && !t(n) } return jO = e, jO } var RO, Tq; function b6e() { if (Tq) return RO; Tq = 1; var t = Yue(), e = $2(); function n(r) { for (var i = e(r), a = i.length; a--;) { var s = i[a], o = r[s]; i[a] = [s, o, t(o)] } return i } return RO = n, RO } var kO, Cq; function Kue() { if (Cq) return kO; Cq = 1; function t(e, n) { return function (r) { return r == null ? !1 : r[e] === n && (n !== void 0 || e in Object(r)) } } return kO = t, kO } var IO, Nq; function w6e() { if (Nq) return IO; Nq = 1; var t = x6e(), e = b6e(), n = Kue(); function r(i) { var a = e(i); return a.length == 1 && a[0][2] ? n(a[0][0], a[0][1]) : function (s) { return s === i || t(s, i, a) } } return IO = r, IO } var OO, Aq; function S6e() { if (Aq) return OO; Aq = 1; function t(e, n) { return e != null && n in Object(e) } return OO = t, OO } var DO, Pq; function _6e() { if (Pq) return DO; Pq = 1; var t = pue(), e = I$(), n = Vo(), r = O$(), i = D$(), a = O2(); function s(o, c, u) { c = t(c, o); for (var d = -1, f = c.length, h = !1; ++d < f;) { var m = a(c[d]); if (!(h = o != null && u(o, m))) break; o = o[m] } return h || ++d != f ? h : (f = o == null ? 0 : o.length, !!f && i(f) && r(m, f) && (n(o) || e(o))) } return DO = s, DO } var LO, jq; function E6e() { if (jq) return LO; jq = 1; var t = S6e(), e = _6e(); function n(r, i) { return r != null && e(r, i, t) } return LO = n, LO } var FO, Rq; function M6e() { if (Rq) return FO; Rq = 1; var t = L$(), e = mue(), n = E6e(), r = b$(), i = Yue(), a = Kue(), s = O2(), o = 1, c = 2; function u(d, f) { return r(d) && i(f) ? a(s(d), f) : function (h) { var m = e(h, d); return m === void 0 && m === f ? n(h, d) : t(f, m, o | c) } } return FO = u, FO } var UO, kq; function F0() { if (kq) return UO; kq = 1; function t(e) { return e } return UO = t, UO } var BO, Iq; function T6e() { if (Iq) return BO; Iq = 1; function t(e) { return function (n) { return n?.[e] } } return BO = t, BO } var $O, Oq; function C6e() { if (Oq) return $O; Oq = 1; var t = T$(); function e(n) { return function (r) { return t(r, n) } } return $O = e, $O } var zO, Dq; function N6e() { if (Dq) return zO; Dq = 1; var t = T6e(), e = C6e(), n = b$(), r = O2(); function i(a) { return n(a) ? t(r(a)) : e(a) } return zO = i, zO } var VO, Lq; function td() { if (Lq) return VO; Lq = 1; var t = w6e(), e = M6e(), n = F0(), r = Vo(), i = N6e(); function a(s) { return typeof s == "function" ? s : s == null ? n : typeof s == "object" ? r(s) ? e(s[0], s[1]) : t(s) : i(s) } return VO = a, VO } var HO, Fq; function Zue() { if (Fq) return HO; Fq = 1; function t(e, n, r, i) { for (var a = e.length, s = r + (i ? 1 : -1); i ? s-- : ++s < a;)if (n(e[s], s, e)) return s; return -1 } return HO = t, HO } var WO, Uq; function A6e() { if (Uq) return WO; Uq = 1; function t(e) { return e !== e } return WO = t, WO } var GO, Bq; function P6e() { if (Bq) return GO; Bq = 1; function t(e, n, r) { for (var i = r - 1, a = e.length; ++i < a;)if (e[i] === n) return i; return -1 } return GO = t, GO } var qO, $q; function j6e() { if ($q) return qO; $q = 1; var t = Zue(), e = A6e(), n = P6e(); function r(i, a, s) { return a === a ? n(i, a, s) : t(i, e, s) } return qO = r, qO } var XO, zq; function R6e() { if (zq) return XO; zq = 1; var t = j6e(); function e(n, r) { var i = n == null ? 0 : n.length; return !!i && t(n, r, 0) > -1 } return XO = e, XO } var YO, Vq; function k6e() { if (Vq) return YO; Vq = 1; function t(e, n, r) { for (var i = -1, a = e == null ? 0 : e.length; ++i < a;)if (r(n, e[i])) return !0; return !1 } return YO = t, YO } var KO, Hq; function I6e() { if (Hq) return KO; Hq = 1; function t() { } return KO = t, KO } var ZO, Wq; function O6e() { if (Wq) return ZO; Wq = 1; var t = Xue(), e = I6e(), n = k$(), r = 1 / 0, i = t && 1 / n(new t([, -0]))[1] == r ? function (a) { return new t(a) } : e; return ZO = i, ZO } var QO, Gq; function D6e() { if (Gq) return QO; Gq = 1; var t = Uue(), e = R6e(), n = k6e(), r = $ue(), i = O6e(), a = k$(), s = 200; function o(c, u, d) { var f = -1, h = e, m = c.length, g = !0, x = [], v = x; if (d) g = !1, h = n; else if (m >= s) { var b = u ? null : i(c); if (b) return a(b); g = !1, h = r, v = new t } else v = u ? [] : x; e: for (; ++f < m;) { var E = c[f], M = u ? u(E) : E; if (E = d || E !== 0 ? E : 0, g && M === M) { for (var C = v.length; C--;)if (v[C] === M) continue e; u && v.push(M), x.push(E) } else h(v, M, d) || (v !== x && v.push(M), x.push(E)) } return x } return QO = o, QO } var JO, qq; function L6e() { if (qq) return JO; qq = 1; var t = td(), e = D6e(); function n(r, i) { return r && r.length ? e(r, t(i, 2)) : [] } return JO = n, JO } var F6e = L6e(); const Xq = Fr(F6e); function Que(t, e, n) { return e === !0 ? Xq(t, n) : Rn(e) ? Xq(t, e) : t } function Dx(t) { "@babel/helpers - typeof"; return Dx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Dx(t) } var U6e = ["ref"]; function Yq(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Wd(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? Yq(Object(n), !0).forEach(function (r) { z2(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Yq(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function B6e(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Kq(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, ede(r.key), r) } } function $6e(t, e, n) { return e && Kq(t.prototype, e), n && Kq(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function z6e(t, e, n) { return e = dN(e), V6e(t, Jue() ? Reflect.construct(e, n || [], dN(t).constructor) : e.apply(t, n)) } function V6e(t, e) { if (e && (Dx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return H6e(t) } function H6e(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Jue() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Jue = function () { return !!t })() } function dN(t) { return dN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, dN(t) } function W6e(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && j4(t, e) } function j4(t, e) { return j4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, j4(t, e) } function z2(t, e, n) { return e = ede(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ede(t) { var e = G6e(t, "string"); return Dx(e) == "symbol" ? e : e + "" } function G6e(t, e) { if (Dx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Dx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } function q6e(t, e) { if (t == null) return {}; var n = X6e(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function X6e(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function Y6e(t) { return t.value } function K6e(t, e) { if (P.isValidElement(t)) return P.cloneElement(t, e); if (typeof t == "function") return P.createElement(t, e); e.ref; var n = q6e(e, U6e); return P.createElement(R$, n) } var Zq = 1, Ru = (function (t) { function e() { var n; B6e(this, e); for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; return n = z6e(this, e, [].concat(i)), z2(n, "lastBoundingBox", { width: -1, height: -1 }), n } return W6e(e, t), $6e(e, [{ key: "componentDidMount", value: function () { this.updateBBox() } }, { key: "componentDidUpdate", value: function () { this.updateBBox() } }, { key: "getBBox", value: function () { if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) { var r = this.wrapperNode.getBoundingClientRect(); return r.height = this.wrapperNode.offsetHeight, r.width = this.wrapperNode.offsetWidth, r } return null } }, { key: "updateBBox", value: function () { var r = this.props.onBBoxUpdate, i = this.getBBox(); i ? (Math.abs(i.width - this.lastBoundingBox.width) > Zq || Math.abs(i.height - this.lastBoundingBox.height) > Zq) && (this.lastBoundingBox.width = i.width, this.lastBoundingBox.height = i.height, r && r(i)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, r && r(null)) } }, { key: "getBBoxSnapshot", value: function () { return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? Wd({}, this.lastBoundingBox) : { width: 0, height: 0 } } }, { key: "getDefaultPosition", value: function (r) { var i = this.props, a = i.layout, s = i.align, o = i.verticalAlign, c = i.margin, u = i.chartWidth, d = i.chartHeight, f, h; if (!r || (r.left === void 0 || r.left === null) && (r.right === void 0 || r.right === null)) if (s === "center" && a === "vertical") { var m = this.getBBoxSnapshot(); f = { left: ((u || 0) - m.width) / 2 } } else f = s === "right" ? { right: c && c.right || 0 } : { left: c && c.left || 0 }; if (!r || (r.top === void 0 || r.top === null) && (r.bottom === void 0 || r.bottom === null)) if (o === "middle") { var g = this.getBBoxSnapshot(); h = { top: ((d || 0) - g.height) / 2 } } else h = o === "bottom" ? { bottom: c && c.bottom || 0 } : { top: c && c.top || 0 }; return Wd(Wd({}, f), h) } }, { key: "render", value: function () { var r = this, i = this.props, a = i.content, s = i.width, o = i.height, c = i.wrapperStyle, u = i.payloadUniqBy, d = i.payload, f = Wd(Wd({ position: "absolute", width: s || "auto", height: o || "auto" }, this.getDefaultPosition(c)), c); return P.createElement("div", { className: "recharts-legend-wrapper", style: f, ref: function (m) { r.wrapperNode = m } }, K6e(a, Wd(Wd({}, this.props), {}, { payload: Que(d, u, Y6e) }))) } }], [{ key: "getWithHeight", value: function (r, i) { var a = Wd(Wd({}, this.defaultProps), r.props), s = a.layout; return s === "vertical" && It(r.props.height) ? { height: r.props.height } : s === "horizontal" ? { width: r.props.width || i } : null } }]) })(S.PureComponent); z2(Ru, "displayName", "Legend"); z2(Ru, "defaultProps", { iconSize: 14, layout: "horizontal", align: "center", verticalAlign: "bottom" }); var eD, Qq; function Z6e() { if (Qq) return eD; Qq = 1; var t = E_(), e = I$(), n = Vo(), r = t ? t.isConcatSpreadable : void 0; function i(a) { return n(a) || e(a) || !!(r && a && a[r]) } return eD = i, eD } var tD, Jq; function tde() { if (Jq) return tD; Jq = 1; var t = Vue(), e = Z6e(); function n(r, i, a, s, o) { var c = -1, u = r.length; for (a || (a = e), o || (o = []); ++c < u;) { var d = r[c]; i > 0 && a(d) ? i > 1 ? n(d, i - 1, a, s, o) : t(o, d) : s || (o[o.length] = d) } return o } return tD = n, tD } var nD, eX; function Q6e() { if (eX) return nD; eX = 1; function t(e) { return function (n, r, i) { for (var a = -1, s = Object(n), o = i(n), c = o.length; c--;) { var u = o[e ? c : ++a]; if (r(s[u], u, s) === !1) break } return n } } return nD = t, nD } var rD, tX; function J6e() { if (tX) return rD; tX = 1; var t = Q6e(), e = t(); return rD = e, rD } var iD, nX; function nde() { if (nX) return iD; nX = 1; var t = J6e(), e = $2(); function n(r, i) { return r && t(r, i, e) } return iD = n, iD } var aD, rX; function e8e() { if (rX) return aD; rX = 1; var t = M_(); function e(n, r) { return function (i, a) { if (i == null) return i; if (!t(i)) return n(i, a); for (var s = i.length, o = r ? s : -1, c = Object(i); (r ? o-- : ++o < s) && a(c[o], o, c) !== !1;); return i } } return aD = e, aD } var sD, iX; function F$() { if (iX) return sD; iX = 1; var t = nde(), e = e8e(), n = e(t); return sD = n, sD } var oD, aX; function rde() { if (aX) return oD; aX = 1; var t = F$(), e = M_(); function n(r, i) { var a = -1, s = e(r) ? Array(r.length) : []; return t(r, function (o, c, u) { s[++a] = i(o, c, u) }), s } return oD = n, oD } var lD, sX; function t8e() { if (sX) return lD; sX = 1; function t(e, n) { var r = e.length; for (e.sort(n); r--;)e[r] = e[r].value; return e } return lD = t, lD } var cD, oX; function n8e() { if (oX) return cD; oX = 1; var t = O0(); function e(n, r) { if (n !== r) { var i = n !== void 0, a = n === null, s = n === n, o = t(n), c = r !== void 0, u = r === null, d = r === r, f = t(r); if (!u && !f && !o && n > r || o && c && d && !u && !f || a && c && d || !i && d || !s) return 1; if (!a && !o && !f && n < r || f && i && s && !a && !o || u && i && s || !c && s || !d) return -1 } return 0 } return cD = e, cD } var uD, lX; function r8e() { if (lX) return uD; lX = 1; var t = n8e(); function e(n, r, i) { for (var a = -1, s = n.criteria, o = r.criteria, c = s.length, u = i.length; ++a < c;) { var d = t(s[a], o[a]); if (d) { if (a >= u) return d; var f = i[a]; return d * (f == "desc" ? -1 : 1) } } return n.index - r.index } return uD = e, uD } var dD, cX; function i8e() { if (cX) return dD; cX = 1; var t = M$(), e = T$(), n = td(), r = rde(), i = t8e(), a = Wue(), s = r8e(), o = F0(), c = Vo(); function u(d, f, h) { f.length ? f = t(f, function (x) { return c(x) ? function (v) { return e(v, x.length === 1 ? x[0] : x) } : x }) : f = [o]; var m = -1; f = t(f, a(n)); var g = r(d, function (x, v, b) { var E = t(f, function (M) { return M(x) }); return { criteria: E, index: ++m, value: x } }); return i(g, function (x, v) { return s(x, v, h) }) } return dD = u, dD } var fD, uX; function a8e() { if (uX) return fD; uX = 1; function t(e, n, r) { switch (r.length) { case 0: return e.call(n); case 1: return e.call(n, r[0]); case 2: return e.call(n, r[0], r[1]); case 3: return e.call(n, r[0], r[1], r[2]) }return e.apply(n, r) } return fD = t, fD } var hD, dX; function s8e() { if (dX) return hD; dX = 1; var t = a8e(), e = Math.max; function n(r, i, a) { return i = e(i === void 0 ? r.length - 1 : i, 0), function () { for (var s = arguments, o = -1, c = e(s.length - i, 0), u = Array(c); ++o < c;)u[o] = s[i + o]; o = -1; for (var d = Array(i + 1); ++o < i;)d[o] = s[o]; return d[i] = a(u), t(r, this, d) } } return hD = n, hD } var pD, fX; function o8e() { if (fX) return pD; fX = 1; function t(e) { return function () { return e } } return pD = t, pD } var mD, hX; function ide() { if (hX) return mD; hX = 1; var t = Xg(), e = (function () { try { var n = t(Object, "defineProperty"); return n({}, "", {}), n } catch { } })(); return mD = e, mD } var gD, pX; function l8e() { if (pX) return gD; pX = 1; var t = o8e(), e = ide(), n = F0(), r = e ? function (i, a) { return e(i, "toString", { configurable: !0, enumerable: !1, value: t(a), writable: !0 }) } : n; return gD = r, gD } var vD, mX; function c8e() { if (mX) return vD; mX = 1; var t = 800, e = 16, n = Date.now; function r(i) { var a = 0, s = 0; return function () { var o = n(), c = e - (o - s); if (s = o, c > 0) { if (++a >= t) return arguments[0] } else a = 0; return i.apply(void 0, arguments) } } return vD = r, vD } var yD, gX; function u8e() { if (gX) return yD; gX = 1; var t = l8e(), e = c8e(), n = e(t); return yD = n, yD } var xD, vX; function d8e() { if (vX) return xD; vX = 1; var t = F0(), e = s8e(), n = u8e(); function r(i, a) { return n(e(i, a, t), i + "") } return xD = r, xD } var bD, yX; function V2() { if (yX) return bD; yX = 1; var t = S$(), e = M_(), n = O$(), r = _p(); function i(a, s, o) { if (!r(o)) return !1; var c = typeof s; return (c == "number" ? e(o) && n(s, o.length) : c == "string" && s in o) ? t(o[s], a) : !1 } return bD = i, bD } var wD, xX; function f8e() { if (xX) return wD; xX = 1; var t = tde(), e = i8e(), n = d8e(), r = V2(), i = n(function (a, s) { if (a == null) return []; var o = s.length; return o > 1 && r(a, s[0], s[1]) ? s = [] : o > 2 && r(s[0], s[1], s[2]) && (s = [s[0]]), e(a, t(s, 1), []) }); return wD = i, wD } var h8e = f8e(); const U$ = Fr(h8e); function K1(t) { "@babel/helpers - typeof"; return K1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, K1(t) } function R4() { return R4 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, R4.apply(this, arguments) } function p8e(t, e) { return y8e(t) || v8e(t, e) || g8e(t, e) || m8e() } function m8e() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function g8e(t, e) { if (t) { if (typeof t == "string") return bX(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bX(t, e) } } function bX(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function v8e(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function y8e(t) { if (Array.isArray(t)) return t } function wX(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function SD(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? wX(Object(n), !0).forEach(function (r) { x8e(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : wX(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function x8e(t, e, n) { return e = b8e(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function b8e(t) { var e = w8e(t, "string"); return K1(e) == "symbol" ? e : e + "" } function w8e(t, e) { if (K1(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (K1(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function S8e(t) { return Array.isArray(t) && ka(t[0]) && ka(t[1]) ? t.join(" ~ ") : t } var _8e = function (e) { var n = e.separator, r = n === void 0 ? " : " : n, i = e.contentStyle, a = i === void 0 ? {} : i, s = e.itemStyle, o = s === void 0 ? {} : s, c = e.labelStyle, u = c === void 0 ? {} : c, d = e.payload, f = e.formatter, h = e.itemSorter, m = e.wrapperClassName, g = e.labelClassName, x = e.label, v = e.labelFormatter, b = e.accessibilityLayer, E = b === void 0 ? !1 : b, M = function () { if (d && d.length) { var B = { padding: 0, margin: 0 }, G = (h ? U$(d, h) : d).map(function (z, q) { if (z.type === "none") return null; var Y = SD({ display: "block", paddingTop: 4, paddingBottom: 4, color: z.color || "#000" }, o), Z = z.formatter || f || S8e, $ = z.value, V = z.name, K = $, X = V; if (Z && K != null && X != null) { var Q = Z($, V, z, q, d); if (Array.isArray(Q)) { var re = p8e(Q, 2); K = re[0], X = re[1] } else K = Q } return P.createElement("li", { className: "recharts-tooltip-item", key: "tooltip-item-".concat(q), style: Y }, ka(X) ? P.createElement("span", { className: "recharts-tooltip-item-name" }, X) : null, ka(X) ? P.createElement("span", { className: "recharts-tooltip-item-separator" }, r) : null, P.createElement("span", { className: "recharts-tooltip-item-value" }, K), P.createElement("span", { className: "recharts-tooltip-item-unit" }, z.unit || "")) }); return P.createElement("ul", { className: "recharts-tooltip-item-list", style: B }, G) } return null }, C = SD({ margin: 0, padding: 10, backgroundColor: "#fff", border: "1px solid #ccc", whiteSpace: "nowrap" }, a), N = SD({ margin: 0 }, u), A = !An(x), j = A ? x : "", O = zn("recharts-default-tooltip", m), I = zn("recharts-tooltip-label", g); A && v && d !== void 0 && d !== null && (j = v(x, d)); var D = E ? { role: "status", "aria-live": "assertive" } : {}; return P.createElement("div", R4({ className: O, style: C }, D), P.createElement("p", { className: I, style: N }, P.isValidElement(j) ? j : "".concat(j)), M()) }; function Z1(t) { "@babel/helpers - typeof"; return Z1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Z1(t) } function QM(t, e, n) { return e = E8e(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function E8e(t) { var e = M8e(t, "string"); return Z1(e) == "symbol" ? e : e + "" } function M8e(t, e) { if (Z1(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Z1(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var gw = "recharts-tooltip-wrapper", T8e = { visibility: "hidden" }; function C8e(t) { var e = t.coordinate, n = t.translateX, r = t.translateY; return zn(gw, QM(QM(QM(QM({}, "".concat(gw, "-right"), It(n) && e && It(e.x) && n >= e.x), "".concat(gw, "-left"), It(n) && e && It(e.x) && n < e.x), "".concat(gw, "-bottom"), It(r) && e && It(e.y) && r >= e.y), "".concat(gw, "-top"), It(r) && e && It(e.y) && r < e.y)) } function SX(t) { var e = t.allowEscapeViewBox, n = t.coordinate, r = t.key, i = t.offsetTopLeft, a = t.position, s = t.reverseDirection, o = t.tooltipDimension, c = t.viewBox, u = t.viewBoxDimension; if (a && It(a[r])) return a[r]; var d = n[r] - o - i, f = n[r] + i; if (e[r]) return s[r] ? d : f; if (s[r]) { var h = d, m = c[r]; return h < m ? Math.max(f, c[r]) : Math.max(d, c[r]) } var g = f + o, x = c[r] + u; return g > x ? Math.max(d, c[r]) : Math.max(f, c[r]) } function N8e(t) { var e = t.translateX, n = t.translateY, r = t.useTranslate3d; return { transform: r ? "translate3d(".concat(e, "px, ").concat(n, "px, 0)") : "translate(".concat(e, "px, ").concat(n, "px)") } } function A8e(t) { var e = t.allowEscapeViewBox, n = t.coordinate, r = t.offsetTopLeft, i = t.position, a = t.reverseDirection, s = t.tooltipBox, o = t.useTranslate3d, c = t.viewBox, u, d, f; return s.height > 0 && s.width > 0 && n ? (d = SX({ allowEscapeViewBox: e, coordinate: n, key: "x", offsetTopLeft: r, position: i, reverseDirection: a, tooltipDimension: s.width, viewBox: c, viewBoxDimension: c.width }), f = SX({ allowEscapeViewBox: e, coordinate: n, key: "y", offsetTopLeft: r, position: i, reverseDirection: a, tooltipDimension: s.height, viewBox: c, viewBoxDimension: c.height }), u = N8e({ translateX: d, translateY: f, useTranslate3d: o })) : u = T8e, { cssProperties: u, cssClasses: C8e({ translateX: d, translateY: f, coordinate: n }) } } function Lx(t) { "@babel/helpers - typeof"; return Lx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Lx(t) } function _X(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function EX(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? _X(Object(n), !0).forEach(function (r) { I4(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _X(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function P8e(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function j8e(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, sde(r.key), r) } } function R8e(t, e, n) { return e && j8e(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function k8e(t, e, n) { return e = fN(e), I8e(t, ade() ? Reflect.construct(e, n || [], fN(t).constructor) : e.apply(t, n)) } function I8e(t, e) { if (e && (Lx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return O8e(t) } function O8e(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function ade() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (ade = function () { return !!t })() } function fN(t) { return fN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, fN(t) } function D8e(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && k4(t, e) } function k4(t, e) { return k4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, k4(t, e) } function I4(t, e, n) { return e = sde(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function sde(t) { var e = L8e(t, "string"); return Lx(e) == "symbol" ? e : e + "" } function L8e(t, e) { if (Lx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Lx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var MX = 1, F8e = (function (t) { function e() { var n; P8e(this, e); for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; return n = k8e(this, e, [].concat(i)), I4(n, "state", { dismissed: !1, dismissedAtCoordinate: { x: 0, y: 0 }, lastBoundingBox: { width: -1, height: -1 } }), I4(n, "handleKeyDown", function (s) { if (s.key === "Escape") { var o, c, u, d; n.setState({ dismissed: !0, dismissedAtCoordinate: { x: (o = (c = n.props.coordinate) === null || c === void 0 ? void 0 : c.x) !== null && o !== void 0 ? o : 0, y: (u = (d = n.props.coordinate) === null || d === void 0 ? void 0 : d.y) !== null && u !== void 0 ? u : 0 } }) } }), n } return D8e(e, t), R8e(e, [{ key: "updateBBox", value: function () { if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) { var r = this.wrapperNode.getBoundingClientRect(); (Math.abs(r.width - this.state.lastBoundingBox.width) > MX || Math.abs(r.height - this.state.lastBoundingBox.height) > MX) && this.setState({ lastBoundingBox: { width: r.width, height: r.height } }) } else (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({ lastBoundingBox: { width: -1, height: -1 } }) } }, { key: "componentDidMount", value: function () { document.addEventListener("keydown", this.handleKeyDown), this.updateBBox() } }, { key: "componentWillUnmount", value: function () { document.removeEventListener("keydown", this.handleKeyDown) } }, { key: "componentDidUpdate", value: function () { var r, i; this.props.active && this.updateBBox(), this.state.dismissed && (((r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !== this.state.dismissedAtCoordinate.x || ((i = this.props.coordinate) === null || i === void 0 ? void 0 : i.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1) } }, { key: "render", value: function () { var r = this, i = this.props, a = i.active, s = i.allowEscapeViewBox, o = i.animationDuration, c = i.animationEasing, u = i.children, d = i.coordinate, f = i.hasPayload, h = i.isAnimationActive, m = i.offset, g = i.position, x = i.reverseDirection, v = i.useTranslate3d, b = i.viewBox, E = i.wrapperStyle, M = A8e({ allowEscapeViewBox: s, coordinate: d, offsetTopLeft: m, position: g, reverseDirection: x, tooltipBox: this.state.lastBoundingBox, useTranslate3d: v, viewBox: b }), C = M.cssClasses, N = M.cssProperties, A = EX(EX({ transition: h && a ? "transform ".concat(o, "ms ").concat(c) : void 0 }, N), {}, { pointerEvents: "none", visibility: !this.state.dismissed && a && f ? "visible" : "hidden", position: "absolute", top: 0, left: 0 }, E); return P.createElement("div", { tabIndex: -1, className: C, style: A, ref: function (O) { r.wrapperNode = O } }, u) } }]) })(S.PureComponent), U8e = function () { return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout) }, Cf = { isSsr: U8e() }; function Fx(t) { "@babel/helpers - typeof"; return Fx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Fx(t) } function TX(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function CX(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? TX(Object(n), !0).forEach(function (r) { B$(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : TX(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function B8e(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function $8e(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, lde(r.key), r) } } function z8e(t, e, n) { return e && $8e(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function V8e(t, e, n) { return e = hN(e), H8e(t, ode() ? Reflect.construct(e, n || [], hN(t).constructor) : e.apply(t, n)) } function H8e(t, e) { if (e && (Fx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return W8e(t) } function W8e(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function ode() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (ode = function () { return !!t })() } function hN(t) { return hN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, hN(t) } function G8e(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && O4(t, e) } function O4(t, e) { return O4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, O4(t, e) } function B$(t, e, n) { return e = lde(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function lde(t) { var e = q8e(t, "string"); return Fx(e) == "symbol" ? e : e + "" } function q8e(t, e) { if (Fx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Fx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } function X8e(t) { return t.dataKey } function Y8e(t, e) { return P.isValidElement(t) ? P.cloneElement(t, e) : typeof t == "function" ? P.createElement(t, e) : P.createElement(_8e, e) } var Po = (function (t) { function e() { return B8e(this, e), V8e(this, e, arguments) } return G8e(e, t), z8e(e, [{ key: "render", value: function () { var r = this, i = this.props, a = i.active, s = i.allowEscapeViewBox, o = i.animationDuration, c = i.animationEasing, u = i.content, d = i.coordinate, f = i.filterNull, h = i.isAnimationActive, m = i.offset, g = i.payload, x = i.payloadUniqBy, v = i.position, b = i.reverseDirection, E = i.useTranslate3d, M = i.viewBox, C = i.wrapperStyle, N = g ?? []; f && N.length && (N = Que(g.filter(function (j) { return j.value != null && (j.hide !== !0 || r.props.includeHidden) }), x, X8e)); var A = N.length > 0; return P.createElement(F8e, { allowEscapeViewBox: s, animationDuration: o, animationEasing: c, isAnimationActive: h, active: a, coordinate: d, hasPayload: A, offset: m, position: v, reverseDirection: b, useTranslate3d: E, viewBox: M, wrapperStyle: C }, Y8e(u, CX(CX({}, this.props), {}, { payload: N }))) } }]) })(S.PureComponent); B$(Po, "displayName", "Tooltip"); B$(Po, "defaultProps", { accessibilityLayer: !1, allowEscapeViewBox: { x: !1, y: !1 }, animationDuration: 400, animationEasing: "ease", contentStyle: {}, coordinate: { x: 0, y: 0 }, cursor: !0, cursorStyle: {}, filterNull: !0, isAnimationActive: !Cf.isSsr, itemStyle: {}, labelStyle: {}, offset: 10, reverseDirection: { x: !1, y: !1 }, separator: " : ", trigger: "hover", useTranslate3d: !1, viewBox: { x: 0, y: 0, height: 0, width: 0 }, wrapperStyle: {} }); var _D, NX; function K8e() { if (NX) return _D; NX = 1; var t = ed(), e = function () { return t.Date.now() }; return _D = e, _D } var ED, AX; function Z8e() { if (AX) return ED; AX = 1; var t = /\s/; function e(n) { for (var r = n.length; r-- && t.test(n.charAt(r));); return r } return ED = e, ED } var MD, PX; function Q8e() { if (PX) return MD; PX = 1; var t = Z8e(), e = /^\s+/; function n(r) { return r && r.slice(0, t(r) + 1).replace(e, "") } return MD = n, MD } var TD, jX; function cde() { if (jX) return TD; jX = 1; var t = Q8e(), e = _p(), n = O0(), r = NaN, i = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt; function c(u) { if (typeof u == "number") return u; if (n(u)) return r; if (e(u)) { var d = typeof u.valueOf == "function" ? u.valueOf() : u; u = e(d) ? d + "" : d } if (typeof u != "string") return u === 0 ? u : +u; u = t(u); var f = a.test(u); return f || s.test(u) ? o(u.slice(2), f ? 2 : 8) : i.test(u) ? r : +u } return TD = c, TD } var CD, RX; function J8e() { if (RX) return CD; RX = 1; var t = _p(), e = K8e(), n = cde(), r = "Expected a function", i = Math.max, a = Math.min; function s(o, c, u) { var d, f, h, m, g, x, v = 0, b = !1, E = !1, M = !0; if (typeof o != "function") throw new TypeError(r); c = n(c) || 0, t(u) && (b = !!u.leading, E = "maxWait" in u, h = E ? i(n(u.maxWait) || 0, c) : h, M = "trailing" in u ? !!u.trailing : M); function C(G) { var z = d, q = f; return d = f = void 0, v = G, m = o.apply(q, z), m } function N(G) { return v = G, g = setTimeout(O, c), b ? C(G) : m } function A(G) { var z = G - x, q = G - v, Y = c - z; return E ? a(Y, h - q) : Y } function j(G) { var z = G - x, q = G - v; return x === void 0 || z >= c || z < 0 || E && q >= h } function O() { var G = e(); if (j(G)) return I(G); g = setTimeout(O, A(G)) } function I(G) { return g = void 0, M && d ? C(G) : (d = f = void 0, m) } function D() { g !== void 0 && clearTimeout(g), v = 0, d = x = f = g = void 0 } function F() { return g === void 0 ? m : I(e()) } function B() { var G = e(), z = j(G); if (d = arguments, f = this, x = G, z) { if (g === void 0) return N(x); if (E) return clearTimeout(g), g = setTimeout(O, c), C(x) } return g === void 0 && (g = setTimeout(O, c)), m } return B.cancel = D, B.flush = F, B } return CD = s, CD } var ND, kX; function eVe() { if (kX) return ND; kX = 1; var t = J8e(), e = _p(), n = "Expected a function"; function r(i, a, s) { var o = !0, c = !0; if (typeof i != "function") throw new TypeError(n); return e(s) && (o = "leading" in s ? !!s.leading : o, c = "trailing" in s ? !!s.trailing : c), t(i, a, { leading: o, maxWait: a, trailing: c }) } return ND = r, ND } var tVe = eVe(); const ude = Fr(tVe); function Q1(t) { "@babel/helpers - typeof"; return Q1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Q1(t) } function IX(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function JM(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? IX(Object(n), !0).forEach(function (r) { nVe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : IX(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function nVe(t, e, n) { return e = rVe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function rVe(t) { var e = iVe(t, "string"); return Q1(e) == "symbol" ? e : e + "" } function iVe(t, e) { if (Q1(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Q1(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function aVe(t, e) { return cVe(t) || lVe(t, e) || oVe(t, e) || sVe() } function sVe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function oVe(t, e) { if (t) { if (typeof t == "string") return OX(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return OX(t, e) } } function OX(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function lVe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function cVe(t) { if (Array.isArray(t)) return t } var Mp = S.forwardRef(function (t, e) {
	var n = t.aspect, r = t.initialDimension, i = r === void 0 ? { width: -1, height: -1 } : r, a = t.width, s = a === void 0 ? "100%" : a, o = t.height, c = o === void 0 ? "100%" : o, u = t.minWidth, d = u === void 0 ? 0 : u, f = t.minHeight, h = t.maxHeight, m = t.children, g = t.debounce, x = g === void 0 ? 0 : g, v = t.id, b = t.className, E = t.onResize, M = t.style, C = M === void 0 ? {} : M, N = S.useRef(null), A = S.useRef(); A.current = E, S.useImperativeHandle(e, function () { return Object.defineProperty(N.current, "current", { get: function () { return console.warn("The usage of ref.current.current is deprecated and will no longer be supported."), N.current }, configurable: !0 }) }); var j = S.useState({ containerWidth: i.width, containerHeight: i.height }), O = aVe(j, 2), I = O[0], D = O[1], F = S.useCallback(function (G, z) { D(function (q) { var Y = Math.round(G), Z = Math.round(z); return q.containerWidth === Y && q.containerHeight === Z ? q : { containerWidth: Y, containerHeight: Z } }) }, []); S.useEffect(function () { var G = function (V) { var K, X = V[0].contentRect, Q = X.width, re = X.height; F(Q, re), (K = A.current) === null || K === void 0 || K.call(A, Q, re) }; x > 0 && (G = ude(G, x, { trailing: !0, leading: !1 })); var z = new ResizeObserver(G), q = N.current.getBoundingClientRect(), Y = q.width, Z = q.height; return F(Y, Z), z.observe(N.current), function () { z.disconnect() } }, [F, x]); var B = S.useMemo(function () {
		var G = I.containerWidth, z = I.containerHeight; if (G < 0 || z < 0) return null; Bc(tg(s) || tg(c), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, s, c), Bc(!n || n > 0, "The aspect(%s) must be greater than zero.", n); var q = tg(s) ? G : s, Y = tg(c) ? z : c; n && n > 0 && (q ? Y = q / n : Y && (q = Y * n), h && Y > h && (Y = h)), Bc(q > 0 || Y > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, q, Y, s, c, d, f, n); var Z = !Array.isArray(m) && lf(m.type).endsWith("Chart"); return P.Children.map(m, function ($) { return P.isValidElement($) ? S.cloneElement($, JM({ width: q, height: Y }, Z ? { style: JM({ height: "100%", width: "100%", maxHeight: Y, maxWidth: q }, $.props.style) } : {})) : $ })
	}, [n, m, c, h, f, d, I, s]); return P.createElement("div", { id: v ? "".concat(v) : void 0, className: zn("recharts-responsive-container", b), style: JM(JM({}, C), {}, { width: s, height: c, minWidth: d, minHeight: f, maxHeight: h }), ref: N }, B)
}), H2 = function (e) { return null }; H2.displayName = "Cell"; function J1(t) { "@babel/helpers - typeof"; return J1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, J1(t) } function DX(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function D4(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? DX(Object(n), !0).forEach(function (r) { uVe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : DX(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function uVe(t, e, n) { return e = dVe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function dVe(t) { var e = fVe(t, "string"); return J1(e) == "symbol" ? e : e + "" } function fVe(t, e) { if (J1(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (J1(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var _y = { widthCache: {}, cacheCount: 0 }, hVe = 2e3, pVe = { position: "absolute", top: "-20000px", left: 0, padding: 0, margin: 0, border: "none", whiteSpace: "pre" }, LX = "recharts_measurement_span"; function mVe(t) { var e = D4({}, t); return Object.keys(e).forEach(function (n) { e[n] || delete e[n] }), e } var n1 = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (e == null || Cf.isSsr) return { width: 0, height: 0 }; var r = mVe(n), i = JSON.stringify({ text: e, copyStyle: r }); if (_y.widthCache[i]) return _y.widthCache[i]; try { var a = document.getElementById(LX); a || (a = document.createElement("span"), a.setAttribute("id", LX), a.setAttribute("aria-hidden", "true"), document.body.appendChild(a)); var s = D4(D4({}, pVe), r); Object.assign(a.style, s), a.textContent = "".concat(e); var o = a.getBoundingClientRect(), c = { width: o.width, height: o.height }; return _y.widthCache[i] = c, ++_y.cacheCount > hVe && (_y.cacheCount = 0, _y.widthCache = {}), c } catch { return { width: 0, height: 0 } } }, gVe = function (e) { return { top: e.top + window.scrollY - document.documentElement.clientTop, left: e.left + window.scrollX - document.documentElement.clientLeft } }; function eS(t) { "@babel/helpers - typeof"; return eS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, eS(t) } function pN(t, e) { return bVe(t) || xVe(t, e) || yVe(t, e) || vVe() } function vVe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function yVe(t, e) { if (t) { if (typeof t == "string") return FX(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FX(t, e) } } function FX(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function xVe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e === 0) { if (Object(n) !== n) return; c = !1 } else for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function bVe(t) { if (Array.isArray(t)) return t } function wVe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function UX(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, _Ve(r.key), r) } } function SVe(t, e, n) { return e && UX(t.prototype, e), n && UX(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function _Ve(t) { var e = EVe(t, "string"); return eS(e) == "symbol" ? e : e + "" } function EVe(t, e) { if (eS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (eS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var BX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, $X = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, MVe = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, TVe = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, dde = { cm: 96 / 2.54, mm: 96 / 25.4, pt: 96 / 72, pc: 96 / 6, in: 96, Q: 96 / (2.54 * 40), px: 1 }, CVe = Object.keys(dde), Hy = "NaN"; function NVe(t, e) { return t * dde[e] } var eT = (function () { function t(e, n) { wVe(this, t), this.num = e, this.unit = n, this.num = e, this.unit = n, Number.isNaN(e) && (this.unit = ""), n !== "" && !MVe.test(n) && (this.num = NaN, this.unit = ""), CVe.includes(n) && (this.num = NVe(e, n), this.unit = "px") } return SVe(t, [{ key: "add", value: function (n) { return this.unit !== n.unit ? new t(NaN, "") : new t(this.num + n.num, this.unit) } }, { key: "subtract", value: function (n) { return this.unit !== n.unit ? new t(NaN, "") : new t(this.num - n.num, this.unit) } }, { key: "multiply", value: function (n) { return this.unit !== "" && n.unit !== "" && this.unit !== n.unit ? new t(NaN, "") : new t(this.num * n.num, this.unit || n.unit) } }, { key: "divide", value: function (n) { return this.unit !== "" && n.unit !== "" && this.unit !== n.unit ? new t(NaN, "") : new t(this.num / n.num, this.unit || n.unit) } }, { key: "toString", value: function () { return "".concat(this.num).concat(this.unit) } }, { key: "isNaN", value: function () { return Number.isNaN(this.num) } }], [{ key: "parse", value: function (n) { var r, i = (r = TVe.exec(n)) !== null && r !== void 0 ? r : [], a = pN(i, 3), s = a[1], o = a[2]; return new t(parseFloat(s), o ?? "") } }]) })(); function fde(t) { if (t.includes(Hy)) return Hy; for (var e = t; e.includes("*") || e.includes("/");) { var n, r = (n = BX.exec(e)) !== null && n !== void 0 ? n : [], i = pN(r, 4), a = i[1], s = i[2], o = i[3], c = eT.parse(a ?? ""), u = eT.parse(o ?? ""), d = s === "*" ? c.multiply(u) : c.divide(u); if (d.isNaN()) return Hy; e = e.replace(BX, d.toString()) } for (; e.includes("+") || /.-\d+(?:\.\d+)?/.test(e);) { var f, h = (f = $X.exec(e)) !== null && f !== void 0 ? f : [], m = pN(h, 4), g = m[1], x = m[2], v = m[3], b = eT.parse(g ?? ""), E = eT.parse(v ?? ""), M = x === "+" ? b.add(E) : b.subtract(E); if (M.isNaN()) return Hy; e = e.replace($X, M.toString()) } return e } var zX = /\(([^()]*)\)/; function AVe(t) { for (var e = t; e.includes("(");) { var n = zX.exec(e), r = pN(n, 2), i = r[1]; e = e.replace(zX, fde(i)) } return e } function PVe(t) { var e = t.replace(/\s+/g, ""); return e = AVe(e), e = fde(e), e } function jVe(t) { try { return PVe(t) } catch { return Hy } } function AD(t) { var e = jVe(t.slice(5, -1)); return e === Hy ? "" : e } var RVe = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], kVe = ["dx", "dy", "angle", "className", "breakAll"]; function L4() { return L4 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, L4.apply(this, arguments) } function VX(t, e) { if (t == null) return {}; var n = IVe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function IVe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function HX(t, e) { return FVe(t) || LVe(t, e) || DVe(t, e) || OVe() } function OVe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function DVe(t, e) { if (t) { if (typeof t == "string") return WX(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return WX(t, e) } } function WX(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function LVe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e === 0) { if (Object(n) !== n) return; c = !1 } else for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function FVe(t) { if (Array.isArray(t)) return t } var hde = /[ \f\n\r\t\v\u2028\u2029]+/, pde = function (e) { var n = e.children, r = e.breakAll, i = e.style; try { var a = []; An(n) || (r ? a = n.toString().split("") : a = n.toString().split(hde)); var s = a.map(function (c) { return { word: c, width: n1(c, i).width } }), o = r ? 0 : n1("", i).width; return { wordsWithComputedWidth: s, spaceWidth: o } } catch { return null } }, UVe = function (e, n, r, i, a) { var s = e.maxLines, o = e.children, c = e.style, u = e.breakAll, d = It(s), f = o, h = function () { var q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; return q.reduce(function (Y, Z) { var $ = Z.word, V = Z.width, K = Y[Y.length - 1]; if (K && (i == null || a || K.width + V + r < Number(i))) K.words.push($), K.width += V + r; else { var X = { words: [$], width: V }; Y.push(X) } return Y }, []) }, m = h(n), g = function (q) { return q.reduce(function (Y, Z) { return Y.width > Z.width ? Y : Z }) }; if (!d) return m; for (var x = "", v = function (q) { var Y = f.slice(0, q), Z = pde({ breakAll: u, style: c, children: Y + x }).wordsWithComputedWidth, $ = h(Z), V = $.length > s || g($).width > Number(i); return [V, $] }, b = 0, E = f.length - 1, M = 0, C; b <= E && M <= f.length - 1;) { var N = Math.floor((b + E) / 2), A = N - 1, j = v(A), O = HX(j, 2), I = O[0], D = O[1], F = v(N), B = HX(F, 1), G = B[0]; if (!I && !G && (b = N + 1), I && G && (E = N - 1), !I && G) { C = D; break } M++ } return C || m }, GX = function (e) { var n = An(e) ? [] : e.toString().split(hde); return [{ words: n }] }, BVe = function (e) { var n = e.width, r = e.scaleToFit, i = e.children, a = e.style, s = e.breakAll, o = e.maxLines; if ((n || r) && !Cf.isSsr) { var c, u, d = pde({ breakAll: s, children: i, style: a }); if (d) { var f = d.wordsWithComputedWidth, h = d.spaceWidth; c = f, u = h } else return GX(i); return UVe({ breakAll: s, children: i, maxLines: o, style: a }, c, u, n, r) } return GX(i) }, qX = "#808080", Rg = function (e) { var n = e.x, r = n === void 0 ? 0 : n, i = e.y, a = i === void 0 ? 0 : i, s = e.lineHeight, o = s === void 0 ? "1em" : s, c = e.capHeight, u = c === void 0 ? "0.71em" : c, d = e.scaleToFit, f = d === void 0 ? !1 : d, h = e.textAnchor, m = h === void 0 ? "start" : h, g = e.verticalAnchor, x = g === void 0 ? "end" : g, v = e.fill, b = v === void 0 ? qX : v, E = VX(e, RVe), M = S.useMemo(function () { return BVe({ breakAll: E.breakAll, children: E.children, maxLines: E.maxLines, scaleToFit: f, style: E.style, width: E.width }) }, [E.breakAll, E.children, E.maxLines, f, E.style, E.width]), C = E.dx, N = E.dy, A = E.angle, j = E.className, O = E.breakAll, I = VX(E, kVe); if (!ka(r) || !ka(a)) return null; var D = r + (It(C) ? C : 0), F = a + (It(N) ? N : 0), B; switch (x) { case "start": B = AD("calc(".concat(u, ")")); break; case "middle": B = AD("calc(".concat((M.length - 1) / 2, " * -").concat(o, " + (").concat(u, " / 2))")); break; default: B = AD("calc(".concat(M.length - 1, " * -").concat(o, ")")); break }var G = []; if (f) { var z = M[0].width, q = E.width; G.push("scale(".concat((It(q) ? q / z : 1) / z, ")")) } return A && G.push("rotate(".concat(A, ", ").concat(D, ", ").concat(F, ")")), G.length && (I.transform = G.join(" ")), P.createElement("text", L4({}, vn(I, !0), { x: D, y: F, className: zn("recharts-text", j), textAnchor: m, fill: b.includes("url") ? qX : b }), M.map(function (Y, Z) { var $ = Y.words.join(O ? "" : " "); return P.createElement("tspan", { x: D, dy: Z === 0 ? B : o, key: "".concat($, "-").concat(Z) }, $) })) }; function qh(t, e) { return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN } function $Ve(t, e) { return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN } function $$(t) { let e, n, r; t.length !== 2 ? (e = qh, n = (o, c) => qh(t(o), c), r = (o, c) => t(o) - c) : (e = t === qh || t === $Ve ? t : zVe, n = t, r = t); function i(o, c, u = 0, d = o.length) { if (u < d) { if (e(c, c) !== 0) return d; do { const f = u + d >>> 1; n(o[f], c) < 0 ? u = f + 1 : d = f } while (u < d) } return u } function a(o, c, u = 0, d = o.length) { if (u < d) { if (e(c, c) !== 0) return d; do { const f = u + d >>> 1; n(o[f], c) <= 0 ? u = f + 1 : d = f } while (u < d) } return u } function s(o, c, u = 0, d = o.length) { const f = i(o, c, u, d - 1); return f > u && r(o[f - 1], c) > -r(o[f], c) ? f - 1 : f } return { left: i, center: s, right: a } } function zVe() { return 0 } function mde(t) { return t === null ? NaN : +t } function* VVe(t, e) { for (let n of t) n != null && (n = +n) >= n && (yield n) } const HVe = $$(qh), T_ = HVe.right; $$(mde).center; class XX extends Map { constructor(e, n = qVe) { if (super(), Object.defineProperties(this, { _intern: { value: new Map }, _key: { value: n } }), e != null) for (const [r, i] of e) this.set(r, i) } get(e) { return super.get(YX(this, e)) } has(e) { return super.has(YX(this, e)) } set(e, n) { return super.set(WVe(this, e), n) } delete(e) { return super.delete(GVe(this, e)) } } function YX({ _intern: t, _key: e }, n) { const r = e(n); return t.has(r) ? t.get(r) : n } function WVe({ _intern: t, _key: e }, n) { const r = e(n); return t.has(r) ? t.get(r) : (t.set(r, n), n) } function GVe({ _intern: t, _key: e }, n) { const r = e(n); return t.has(r) && (n = t.get(r), t.delete(r)), n } function qVe(t) { return t !== null && typeof t == "object" ? t.valueOf() : t } function XVe(t = qh) { if (t === qh) return gde; if (typeof t != "function") throw new TypeError("compare is not a function"); return (e, n) => { const r = t(e, n); return r || r === 0 ? r : (t(n, n) === 0) - (t(e, e) === 0) } } function gde(t, e) { return (t == null || !(t >= t)) - (e == null || !(e >= e)) || (t < e ? -1 : t > e ? 1 : 0) } const YVe = Math.sqrt(50), KVe = Math.sqrt(10), ZVe = Math.sqrt(2); function mN(t, e, n) { const r = (e - t) / Math.max(0, n), i = Math.floor(Math.log10(r)), a = r / Math.pow(10, i), s = a >= YVe ? 10 : a >= KVe ? 5 : a >= ZVe ? 2 : 1; let o, c, u; return i < 0 ? (u = Math.pow(10, -i) / s, o = Math.round(t * u), c = Math.round(e * u), o / u < t && ++o, c / u > e && --c, u = -u) : (u = Math.pow(10, i) * s, o = Math.round(t / u), c = Math.round(e / u), o * u < t && ++o, c * u > e && --c), c < o && .5 <= n && n < 2 ? mN(t, e, n * 2) : [o, c, u] } function F4(t, e, n) { if (e = +e, t = +t, n = +n, !(n > 0)) return []; if (t === e) return [t]; const r = e < t, [i, a, s] = r ? mN(e, t, n) : mN(t, e, n); if (!(a >= i)) return []; const o = a - i + 1, c = new Array(o); if (r) if (s < 0) for (let u = 0; u < o; ++u)c[u] = (a - u) / -s; else for (let u = 0; u < o; ++u)c[u] = (a - u) * s; else if (s < 0) for (let u = 0; u < o; ++u)c[u] = (i + u) / -s; else for (let u = 0; u < o; ++u)c[u] = (i + u) * s; return c } function U4(t, e, n) { return e = +e, t = +t, n = +n, mN(t, e, n)[2] } function B4(t, e, n) { e = +e, t = +t, n = +n; const r = e < t, i = r ? U4(e, t, n) : U4(t, e, n); return (r ? -1 : 1) * (i < 0 ? 1 / -i : i) } function KX(t, e) { let n; for (const r of t) r != null && (n < r || n === void 0 && r >= r) && (n = r); return n } function ZX(t, e) { let n; for (const r of t) r != null && (n > r || n === void 0 && r >= r) && (n = r); return n } function vde(t, e, n = 0, r = 1 / 0, i) { if (e = Math.floor(e), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(t.length - 1, r)), !(n <= e && e <= r)) return t; for (i = i === void 0 ? gde : XVe(i); r > n;) { if (r - n > 600) { const c = r - n + 1, u = e - n + 1, d = Math.log(c), f = .5 * Math.exp(2 * d / 3), h = .5 * Math.sqrt(d * f * (c - f) / c) * (u - c / 2 < 0 ? -1 : 1), m = Math.max(n, Math.floor(e - u * f / c + h)), g = Math.min(r, Math.floor(e + (c - u) * f / c + h)); vde(t, e, m, g, i) } const a = t[e]; let s = n, o = r; for (vw(t, n, e), i(t[r], a) > 0 && vw(t, n, r); s < o;) { for (vw(t, s, o), ++s, --o; i(t[s], a) < 0;)++s; for (; i(t[o], a) > 0;)--o } i(t[n], a) === 0 ? vw(t, n, o) : (++o, vw(t, o, r)), o <= e && (n = o + 1), e <= o && (r = o - 1) } return t } function vw(t, e, n) { const r = t[e]; t[e] = t[n], t[n] = r } function QVe(t, e, n) { if (t = Float64Array.from(VVe(t)), !(!(r = t.length) || isNaN(e = +e))) { if (e <= 0 || r < 2) return ZX(t); if (e >= 1) return KX(t); var r, i = (r - 1) * e, a = Math.floor(i), s = KX(vde(t, a).subarray(0, a + 1)), o = ZX(t.subarray(a + 1)); return s + (o - s) * (i - a) } } function JVe(t, e, n = mde) { if (!(!(r = t.length) || isNaN(e = +e))) { if (e <= 0 || r < 2) return +n(t[0], 0, t); if (e >= 1) return +n(t[r - 1], r - 1, t); var r, i = (r - 1) * e, a = Math.floor(i), s = +n(t[a], a, t), o = +n(t[a + 1], a + 1, t); return s + (o - s) * (i - a) } } function eHe(t, e, n) { t = +t, e = +e, n = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +n; for (var r = -1, i = Math.max(0, Math.ceil((e - t) / n)) | 0, a = new Array(i); ++r < i;)a[r] = t + r * n; return a } function Zl(t, e) { switch (arguments.length) { case 0: break; case 1: this.range(t); break; default: this.range(e).domain(t); break }return this } function Nf(t, e) { switch (arguments.length) { case 0: break; case 1: { typeof t == "function" ? this.interpolator(t) : this.range(t); break } default: { this.domain(t), typeof e == "function" ? this.interpolator(e) : this.range(e); break } }return this } const $4 = Symbol("implicit"); function z$() { var t = new XX, e = [], n = [], r = $4; function i(a) { let s = t.get(a); if (s === void 0) { if (r !== $4) return r; t.set(a, s = e.push(a) - 1) } return n[s % n.length] } return i.domain = function (a) { if (!arguments.length) return e.slice(); e = [], t = new XX; for (const s of a) t.has(s) || t.set(s, e.push(s) - 1); return i }, i.range = function (a) { return arguments.length ? (n = Array.from(a), i) : n.slice() }, i.unknown = function (a) { return arguments.length ? (r = a, i) : r }, i.copy = function () { return z$(e, n).unknown(r) }, Zl.apply(i, arguments), i } function tS() { var t = z$().unknown(void 0), e = t.domain, n = t.range, r = 0, i = 1, a, s, o = !1, c = 0, u = 0, d = .5; delete t.unknown; function f() { var h = e().length, m = i < r, g = m ? i : r, x = m ? r : i; a = (x - g) / Math.max(1, h - c + u * 2), o && (a = Math.floor(a)), g += (x - g - a * (h - c)) * d, s = a * (1 - c), o && (g = Math.round(g), s = Math.round(s)); var v = eHe(h).map(function (b) { return g + a * b }); return n(m ? v.reverse() : v) } return t.domain = function (h) { return arguments.length ? (e(h), f()) : e() }, t.range = function (h) { return arguments.length ? ([r, i] = h, r = +r, i = +i, f()) : [r, i] }, t.rangeRound = function (h) { return [r, i] = h, r = +r, i = +i, o = !0, f() }, t.bandwidth = function () { return s }, t.step = function () { return a }, t.round = function (h) { return arguments.length ? (o = !!h, f()) : o }, t.padding = function (h) { return arguments.length ? (c = Math.min(1, u = +h), f()) : c }, t.paddingInner = function (h) { return arguments.length ? (c = Math.min(1, h), f()) : c }, t.paddingOuter = function (h) { return arguments.length ? (u = +h, f()) : u }, t.align = function (h) { return arguments.length ? (d = Math.max(0, Math.min(1, h)), f()) : d }, t.copy = function () { return tS(e(), [r, i]).round(o).paddingInner(c).paddingOuter(u).align(d) }, Zl.apply(f(), arguments) } function yde(t) { var e = t.copy; return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function () { return yde(e()) }, t } function r1() { return yde(tS.apply(null, arguments).paddingInner(1)) } function V$(t, e, n) { t.prototype = e.prototype = n, n.constructor = t } function xde(t, e) { var n = Object.create(t.prototype); for (var r in e) n[r] = e[r]; return n } function C_() { } var nS = .7, gN = 1 / nS, nx = "\\s*([+-]?\\d+)\\s*", rS = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ku = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", tHe = /^#([0-9a-f]{3,8})$/, nHe = new RegExp(`^rgb\\(${nx},${nx},${nx}\\)$`), rHe = new RegExp(`^rgb\\(${ku},${ku},${ku}\\)$`), iHe = new RegExp(`^rgba\\(${nx},${nx},${nx},${rS}\\)$`), aHe = new RegExp(`^rgba\\(${ku},${ku},${ku},${rS}\\)$`), sHe = new RegExp(`^hsl\\(${rS},${ku},${ku}\\)$`), oHe = new RegExp(`^hsla\\(${rS},${ku},${ku},${rS}\\)$`), QX = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; V$(C_, iS, { copy(t) { return Object.assign(new this.constructor, this, t) }, displayable() { return this.rgb().displayable() }, hex: JX, formatHex: JX, formatHex8: lHe, formatHsl: cHe, formatRgb: eY, toString: eY }); function JX() { return this.rgb().formatHex() } function lHe() { return this.rgb().formatHex8() } function cHe() { return bde(this).formatHsl() } function eY() { return this.rgb().formatRgb() } function iS(t) { var e, n; return t = (t + "").trim().toLowerCase(), (e = tHe.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? tY(e) : n === 3 ? new Lo(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? tT(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? tT(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = nHe.exec(t)) ? new Lo(e[1], e[2], e[3], 1) : (e = rHe.exec(t)) ? new Lo(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = iHe.exec(t)) ? tT(e[1], e[2], e[3], e[4]) : (e = aHe.exec(t)) ? tT(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = sHe.exec(t)) ? iY(e[1], e[2] / 100, e[3] / 100, 1) : (e = oHe.exec(t)) ? iY(e[1], e[2] / 100, e[3] / 100, e[4]) : QX.hasOwnProperty(t) ? tY(QX[t]) : t === "transparent" ? new Lo(NaN, NaN, NaN, 0) : null } function tY(t) { return new Lo(t >> 16 & 255, t >> 8 & 255, t & 255, 1) } function tT(t, e, n, r) { return r <= 0 && (t = e = n = NaN), new Lo(t, e, n, r) } function uHe(t) { return t instanceof C_ || (t = iS(t)), t ? (t = t.rgb(), new Lo(t.r, t.g, t.b, t.opacity)) : new Lo } function z4(t, e, n, r) { return arguments.length === 1 ? uHe(t) : new Lo(t, e, n, r ?? 1) } function Lo(t, e, n, r) { this.r = +t, this.g = +e, this.b = +n, this.opacity = +r } V$(Lo, z4, xde(C_, { brighter(t) { return t = t == null ? gN : Math.pow(gN, t), new Lo(this.r * t, this.g * t, this.b * t, this.opacity) }, darker(t) { return t = t == null ? nS : Math.pow(nS, t), new Lo(this.r * t, this.g * t, this.b * t, this.opacity) }, rgb() { return this }, clamp() { return new Lo(mg(this.r), mg(this.g), mg(this.b), vN(this.opacity)) }, displayable() { return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1 }, hex: nY, formatHex: nY, formatHex8: dHe, formatRgb: rY, toString: rY })); function nY() { return `#${ng(this.r)}${ng(this.g)}${ng(this.b)}` } function dHe() { return `#${ng(this.r)}${ng(this.g)}${ng(this.b)}${ng((isNaN(this.opacity) ? 1 : this.opacity) * 255)}` } function rY() { const t = vN(this.opacity); return `${t === 1 ? "rgb(" : "rgba("}${mg(this.r)}, ${mg(this.g)}, ${mg(this.b)}${t === 1 ? ")" : `, ${t})`}` } function vN(t) { return isNaN(t) ? 1 : Math.max(0, Math.min(1, t)) } function mg(t) { return Math.max(0, Math.min(255, Math.round(t) || 0)) } function ng(t) { return t = mg(t), (t < 16 ? "0" : "") + t.toString(16) } function iY(t, e, n, r) { return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Dc(t, e, n, r) } function bde(t) { if (t instanceof Dc) return new Dc(t.h, t.s, t.l, t.opacity); if (t instanceof C_ || (t = iS(t)), !t) return new Dc; if (t instanceof Dc) return t; t = t.rgb(); var e = t.r / 255, n = t.g / 255, r = t.b / 255, i = Math.min(e, n, r), a = Math.max(e, n, r), s = NaN, o = a - i, c = (a + i) / 2; return o ? (e === a ? s = (n - r) / o + (n < r) * 6 : n === a ? s = (r - e) / o + 2 : s = (e - n) / o + 4, o /= c < .5 ? a + i : 2 - a - i, s *= 60) : o = c > 0 && c < 1 ? 0 : s, new Dc(s, o, c, t.opacity) } function fHe(t, e, n, r) { return arguments.length === 1 ? bde(t) : new Dc(t, e, n, r ?? 1) } function Dc(t, e, n, r) { this.h = +t, this.s = +e, this.l = +n, this.opacity = +r } V$(Dc, fHe, xde(C_, { brighter(t) { return t = t == null ? gN : Math.pow(gN, t), new Dc(this.h, this.s, this.l * t, this.opacity) }, darker(t) { return t = t == null ? nS : Math.pow(nS, t), new Dc(this.h, this.s, this.l * t, this.opacity) }, rgb() { var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < .5 ? n : 1 - n) * e, i = 2 * n - r; return new Lo(PD(t >= 240 ? t - 240 : t + 120, i, r), PD(t, i, r), PD(t < 120 ? t + 240 : t - 120, i, r), this.opacity) }, clamp() { return new Dc(aY(this.h), nT(this.s), nT(this.l), vN(this.opacity)) }, displayable() { return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1 }, formatHsl() { const t = vN(this.opacity); return `${t === 1 ? "hsl(" : "hsla("}${aY(this.h)}, ${nT(this.s) * 100}%, ${nT(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}` } })); function aY(t) { return t = (t || 0) % 360, t < 0 ? t + 360 : t } function nT(t) { return Math.max(0, Math.min(1, t || 0)) } function PD(t, e, n) { return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255 } const H$ = t => () => t; function hHe(t, e) { return function (n) { return t + n * e } } function pHe(t, e, n) { return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function (r) { return Math.pow(t + r * e, n) } } function mHe(t) { return (t = +t) == 1 ? wde : function (e, n) { return n - e ? pHe(e, n, t) : H$(isNaN(e) ? n : e) } } function wde(t, e) { var n = e - t; return n ? hHe(t, n) : H$(isNaN(t) ? e : t) } const sY = (function t(e) { var n = mHe(e); function r(i, a) { var s = n((i = z4(i)).r, (a = z4(a)).r), o = n(i.g, a.g), c = n(i.b, a.b), u = wde(i.opacity, a.opacity); return function (d) { return i.r = s(d), i.g = o(d), i.b = c(d), i.opacity = u(d), i + "" } } return r.gamma = t, r })(1); function gHe(t, e) { e || (e = []); var n = t ? Math.min(e.length, t.length) : 0, r = e.slice(), i; return function (a) { for (i = 0; i < n; ++i)r[i] = t[i] * (1 - a) + e[i] * a; return r } } function vHe(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) } function yHe(t, e) { var n = e ? e.length : 0, r = t ? Math.min(n, t.length) : 0, i = new Array(r), a = new Array(n), s; for (s = 0; s < r; ++s)i[s] = U0(t[s], e[s]); for (; s < n; ++s)a[s] = e[s]; return function (o) { for (s = 0; s < r; ++s)a[s] = i[s](o); return a } } function xHe(t, e) { var n = new Date; return t = +t, e = +e, function (r) { return n.setTime(t * (1 - r) + e * r), n } } function yN(t, e) { return t = +t, e = +e, function (n) { return t * (1 - n) + e * n } } function bHe(t, e) { var n = {}, r = {}, i; (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {}); for (i in e) i in t ? n[i] = U0(t[i], e[i]) : r[i] = e[i]; return function (a) { for (i in n) r[i] = n[i](a); return r } } var V4 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, jD = new RegExp(V4.source, "g"); function wHe(t) { return function () { return t } } function SHe(t) { return function (e) { return t(e) + "" } } function _He(t, e) { var n = V4.lastIndex = jD.lastIndex = 0, r, i, a, s = -1, o = [], c = []; for (t = t + "", e = e + ""; (r = V4.exec(t)) && (i = jD.exec(e));)(a = i.index) > n && (a = e.slice(n, a), o[s] ? o[s] += a : o[++s] = a), (r = r[0]) === (i = i[0]) ? o[s] ? o[s] += i : o[++s] = i : (o[++s] = null, c.push({ i: s, x: yN(r, i) })), n = jD.lastIndex; return n < e.length && (a = e.slice(n), o[s] ? o[s] += a : o[++s] = a), o.length < 2 ? c[0] ? SHe(c[0].x) : wHe(e) : (e = c.length, function (u) { for (var d = 0, f; d < e; ++d)o[(f = c[d]).i] = f.x(u); return o.join("") }) } function U0(t, e) { var n = typeof e, r; return e == null || n === "boolean" ? H$(e) : (n === "number" ? yN : n === "string" ? (r = iS(e)) ? (e = r, sY) : _He : e instanceof iS ? sY : e instanceof Date ? xHe : vHe(e) ? gHe : Array.isArray(e) ? yHe : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? bHe : yN)(t, e) } function W$(t, e) { return t = +t, e = +e, function (n) { return Math.round(t * (1 - n) + e * n) } } function EHe(t, e) { e === void 0 && (e = t, t = U0); for (var n = 0, r = e.length - 1, i = e[0], a = new Array(r < 0 ? 0 : r); n < r;)a[n] = t(i, i = e[++n]); return function (s) { var o = Math.max(0, Math.min(r - 1, Math.floor(s *= r))); return a[o](s - o) } } function MHe(t) { return function () { return t } } function xN(t) { return +t } var oY = [0, 1]; function to(t) { return t } function H4(t, e) { return (e -= t = +t) ? function (n) { return (n - t) / e } : MHe(isNaN(e) ? NaN : .5) } function THe(t, e) { var n; return t > e && (n = t, t = e, e = n), function (r) { return Math.max(t, Math.min(e, r)) } } function CHe(t, e, n) { var r = t[0], i = t[1], a = e[0], s = e[1]; return i < r ? (r = H4(i, r), a = n(s, a)) : (r = H4(r, i), a = n(a, s)), function (o) { return a(r(o)) } } function NHe(t, e, n) { var r = Math.min(t.length, e.length) - 1, i = new Array(r), a = new Array(r), s = -1; for (t[r] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < r;)i[s] = H4(t[s], t[s + 1]), a[s] = n(e[s], e[s + 1]); return function (o) { var c = T_(t, o, 1, r) - 1; return a[c](i[c](o)) } } function N_(t, e) { return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown()) } function W2() { var t = oY, e = oY, n = U0, r, i, a, s = to, o, c, u; function d() { var h = Math.min(t.length, e.length); return s !== to && (s = THe(t[0], t[h - 1])), o = h > 2 ? NHe : CHe, c = u = null, f } function f(h) { return h == null || isNaN(h = +h) ? a : (c || (c = o(t.map(r), e, n)))(r(s(h))) } return f.invert = function (h) { return s(i((u || (u = o(e, t.map(r), yN)))(h))) }, f.domain = function (h) { return arguments.length ? (t = Array.from(h, xN), d()) : t.slice() }, f.range = function (h) { return arguments.length ? (e = Array.from(h), d()) : e.slice() }, f.rangeRound = function (h) { return e = Array.from(h), n = W$, d() }, f.clamp = function (h) { return arguments.length ? (s = h ? !0 : to, d()) : s !== to }, f.interpolate = function (h) { return arguments.length ? (n = h, d()) : n }, f.unknown = function (h) { return arguments.length ? (a = h, f) : a }, function (h, m) { return r = h, i = m, d() } } function G$() { return W2()(to, to) } function AHe(t) { return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10) } function bN(t, e) { if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null; var n, r = t.slice(0, n); return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(n + 1)] } function Ux(t) { return t = bN(Math.abs(t)), t ? t[1] : NaN } function PHe(t, e) { return function (n, r) { for (var i = n.length, a = [], s = 0, o = t[0], c = 0; i > 0 && o > 0 && (c + o + 1 > r && (o = Math.max(1, r - c)), a.push(n.substring(i -= o, i + o)), !((c += o + 1) > r));)o = t[s = (s + 1) % t.length]; return a.reverse().join(e) } } function jHe(t) { return function (e) { return e.replace(/[0-9]/g, function (n) { return t[+n] }) } } var RHe = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i; function aS(t) { if (!(e = RHe.exec(t))) throw new Error("invalid format: " + t); var e; return new q$({ fill: e[1], align: e[2], sign: e[3], symbol: e[4], zero: e[5], width: e[6], comma: e[7], precision: e[8] && e[8].slice(1), trim: e[9], type: e[10] }) } aS.prototype = q$.prototype; function q$(t) { this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "" } q$.prototype.toString = function () { return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type }; function kHe(t) { e: for (var e = t.length, n = 1, r = -1, i; n < e; ++n)switch (t[n]) { case ".": r = i = n; break; case "0": r === 0 && (r = n), i = n; break; default: if (!+t[n]) break e; r > 0 && (r = 0); break }return r > 0 ? t.slice(0, r) + t.slice(i + 1) : t } var Sde; function IHe(t, e) { var n = bN(t, e); if (!n) return t + ""; var r = n[0], i = n[1], a = i - (Sde = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = r.length; return a === s ? r : a > s ? r + new Array(a - s + 1).join("0") : a > 0 ? r.slice(0, a) + "." + r.slice(a) : "0." + new Array(1 - a).join("0") + bN(t, Math.max(0, e + a - 1))[0] } function lY(t, e) { var n = bN(t, e); if (!n) return t + ""; var r = n[0], i = n[1]; return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0") } const cY = { "%": (t, e) => (t * 100).toFixed(e), b: t => Math.round(t).toString(2), c: t => t + "", d: AHe, e: (t, e) => t.toExponential(e), f: (t, e) => t.toFixed(e), g: (t, e) => t.toPrecision(e), o: t => Math.round(t).toString(8), p: (t, e) => lY(t * 100, e), r: lY, s: IHe, X: t => Math.round(t).toString(16).toUpperCase(), x: t => Math.round(t).toString(16) }; function uY(t) { return t } var dY = Array.prototype.map, fY = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"]; function OHe(t) { var e = t.grouping === void 0 || t.thousands === void 0 ? uY : PHe(dY.call(t.grouping, Number), t.thousands + ""), n = t.currency === void 0 ? "" : t.currency[0] + "", r = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", a = t.numerals === void 0 ? uY : jHe(dY.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", o = t.minus === void 0 ? "" : t.minus + "", c = t.nan === void 0 ? "NaN" : t.nan + ""; function u(f) { f = aS(f); var h = f.fill, m = f.align, g = f.sign, x = f.symbol, v = f.zero, b = f.width, E = f.comma, M = f.precision, C = f.trim, N = f.type; N === "n" ? (E = !0, N = "g") : cY[N] || (M === void 0 && (M = 12), C = !0, N = "g"), (v || h === "0" && m === "=") && (v = !0, h = "0", m = "="); var A = x === "$" ? n : x === "#" && /[boxX]/.test(N) ? "0" + N.toLowerCase() : "", j = x === "$" ? r : /[%p]/.test(N) ? s : "", O = cY[N], I = /[defgprs%]/.test(N); M = M === void 0 ? 6 : /[gprs]/.test(N) ? Math.max(1, Math.min(21, M)) : Math.max(0, Math.min(20, M)); function D(F) { var B = A, G = j, z, q, Y; if (N === "c") G = O(F) + G, F = ""; else { F = +F; var Z = F < 0 || 1 / F < 0; if (F = isNaN(F) ? c : O(Math.abs(F), M), C && (F = kHe(F)), Z && +F == 0 && g !== "+" && (Z = !1), B = (Z ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + B, G = (N === "s" ? fY[8 + Sde / 3] : "") + G + (Z && g === "(" ? ")" : ""), I) { for (z = -1, q = F.length; ++z < q;)if (Y = F.charCodeAt(z), 48 > Y || Y > 57) { G = (Y === 46 ? i + F.slice(z + 1) : F.slice(z)) + G, F = F.slice(0, z); break } } } E && !v && (F = e(F, 1 / 0)); var $ = B.length + F.length + G.length, V = $ < b ? new Array(b - $ + 1).join(h) : ""; switch (E && v && (F = e(V + F, V.length ? b - G.length : 1 / 0), V = ""), m) { case "<": F = B + F + G + V; break; case "=": F = B + V + F + G; break; case "^": F = V.slice(0, $ = V.length >> 1) + B + F + G + V.slice($); break; default: F = V + B + F + G; break }return a(F) } return D.toString = function () { return f + "" }, D } function d(f, h) { var m = u((f = aS(f), f.type = "f", f)), g = Math.max(-8, Math.min(8, Math.floor(Ux(h) / 3))) * 3, x = Math.pow(10, -g), v = fY[8 + g / 3]; return function (b) { return m(x * b) + v } } return { format: u, formatPrefix: d } } var rT, X$, _de; DHe({ thousands: ",", grouping: [3], currency: ["$", ""] }); function DHe(t) { return rT = OHe(t), X$ = rT.format, _de = rT.formatPrefix, rT } function LHe(t) { return Math.max(0, -Ux(Math.abs(t))) } function FHe(t, e) { return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ux(e) / 3))) * 3 - Ux(Math.abs(t))) } function UHe(t, e) { return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Ux(e) - Ux(t)) + 1 } function Ede(t, e, n, r) { var i = B4(t, e, n), a; switch (r = aS(r ?? ",f"), r.type) { case "s": { var s = Math.max(Math.abs(t), Math.abs(e)); return r.precision == null && !isNaN(a = FHe(i, s)) && (r.precision = a), _de(r, s) } case "": case "e": case "g": case "p": case "r": { r.precision == null && !isNaN(a = UHe(i, Math.max(Math.abs(t), Math.abs(e)))) && (r.precision = a - (r.type === "e")); break } case "f": case "%": { r.precision == null && !isNaN(a = LHe(i)) && (r.precision = a - (r.type === "%") * 2); break } }return X$(r) } function Tp(t) { var e = t.domain; return t.ticks = function (n) { var r = e(); return F4(r[0], r[r.length - 1], n ?? 10) }, t.tickFormat = function (n, r) { var i = e(); return Ede(i[0], i[i.length - 1], n ?? 10, r) }, t.nice = function (n) { n == null && (n = 10); var r = e(), i = 0, a = r.length - 1, s = r[i], o = r[a], c, u, d = 10; for (o < s && (u = s, s = o, o = u, u = i, i = a, a = u); d-- > 0;) { if (u = U4(s, o, n), u === c) return r[i] = s, r[a] = o, e(r); if (u > 0) s = Math.floor(s / u) * u, o = Math.ceil(o / u) * u; else if (u < 0) s = Math.ceil(s * u) / u, o = Math.floor(o * u) / u; else break; c = u } return t }, t } function wN() { var t = G$(); return t.copy = function () { return N_(t, wN()) }, Zl.apply(t, arguments), Tp(t) } function Mde(t) { var e; function n(r) { return r == null || isNaN(r = +r) ? e : r } return n.invert = n, n.domain = n.range = function (r) { return arguments.length ? (t = Array.from(r, xN), n) : t.slice() }, n.unknown = function (r) { return arguments.length ? (e = r, n) : e }, n.copy = function () { return Mde(t).unknown(e) }, t = arguments.length ? Array.from(t, xN) : [0, 1], Tp(n) } function Tde(t, e) { t = t.slice(); var n = 0, r = t.length - 1, i = t[n], a = t[r], s; return a < i && (s = n, n = r, r = s, s = i, i = a, a = s), t[n] = e.floor(i), t[r] = e.ceil(a), t } function hY(t) { return Math.log(t) } function pY(t) { return Math.exp(t) } function BHe(t) { return -Math.log(-t) } function $He(t) { return -Math.exp(-t) } function zHe(t) { return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t } function VHe(t) { return t === 10 ? zHe : t === Math.E ? Math.exp : e => Math.pow(t, e) } function HHe(t) { return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), e => Math.log(e) / t) } function mY(t) { return (e, n) => -t(-e, n) } function Y$(t) { const e = t(hY, pY), n = e.domain; let r = 10, i, a; function s() { return i = HHe(r), a = VHe(r), n()[0] < 0 ? (i = mY(i), a = mY(a), t(BHe, $He)) : t(hY, pY), e } return e.base = function (o) { return arguments.length ? (r = +o, s()) : r }, e.domain = function (o) { return arguments.length ? (n(o), s()) : n() }, e.ticks = o => { const c = n(); let u = c[0], d = c[c.length - 1]; const f = d < u; f && ([u, d] = [d, u]); let h = i(u), m = i(d), g, x; const v = o == null ? 10 : +o; let b = []; if (!(r % 1) && m - h < v) { if (h = Math.floor(h), m = Math.ceil(m), u > 0) { for (; h <= m; ++h)for (g = 1; g < r; ++g)if (x = h < 0 ? g / a(-h) : g * a(h), !(x < u)) { if (x > d) break; b.push(x) } } else for (; h <= m; ++h)for (g = r - 1; g >= 1; --g)if (x = h > 0 ? g / a(-h) : g * a(h), !(x < u)) { if (x > d) break; b.push(x) } b.length * 2 < v && (b = F4(u, d, v)) } else b = F4(h, m, Math.min(m - h, v)).map(a); return f ? b.reverse() : b }, e.tickFormat = (o, c) => { if (o == null && (o = 10), c == null && (c = r === 10 ? "s" : ","), typeof c != "function" && (!(r % 1) && (c = aS(c)).precision == null && (c.trim = !0), c = X$(c)), o === 1 / 0) return c; const u = Math.max(1, r * o / e.ticks().length); return d => { let f = d / a(Math.round(i(d))); return f * r < r - .5 && (f *= r), f <= u ? c(d) : "" } }, e.nice = () => n(Tde(n(), { floor: o => a(Math.floor(i(o))), ceil: o => a(Math.ceil(i(o))) })), e } function Cde() { const t = Y$(W2()).domain([1, 10]); return t.copy = () => N_(t, Cde()).base(t.base()), Zl.apply(t, arguments), t } function gY(t) { return function (e) { return Math.sign(e) * Math.log1p(Math.abs(e / t)) } } function vY(t) { return function (e) { return Math.sign(e) * Math.expm1(Math.abs(e)) * t } } function K$(t) { var e = 1, n = t(gY(e), vY(e)); return n.constant = function (r) { return arguments.length ? t(gY(e = +r), vY(e)) : e }, Tp(n) } function Nde() { var t = K$(W2()); return t.copy = function () { return N_(t, Nde()).constant(t.constant()) }, Zl.apply(t, arguments) } function yY(t) { return function (e) { return e < 0 ? -Math.pow(-e, t) : Math.pow(e, t) } } function WHe(t) { return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t) } function GHe(t) { return t < 0 ? -t * t : t * t } function Z$(t) { var e = t(to, to), n = 1; function r() { return n === 1 ? t(to, to) : n === .5 ? t(WHe, GHe) : t(yY(n), yY(1 / n)) } return e.exponent = function (i) { return arguments.length ? (n = +i, r()) : n }, Tp(e) } function Q$() { var t = Z$(W2()); return t.copy = function () { return N_(t, Q$()).exponent(t.exponent()) }, Zl.apply(t, arguments), t } function qHe() { return Q$.apply(null, arguments).exponent(.5) } function xY(t) { return Math.sign(t) * t * t } function XHe(t) { return Math.sign(t) * Math.sqrt(Math.abs(t)) } function Ade() { var t = G$(), e = [0, 1], n = !1, r; function i(a) { var s = XHe(t(a)); return isNaN(s) ? r : n ? Math.round(s) : s } return i.invert = function (a) { return t.invert(xY(a)) }, i.domain = function (a) { return arguments.length ? (t.domain(a), i) : t.domain() }, i.range = function (a) { return arguments.length ? (t.range((e = Array.from(a, xN)).map(xY)), i) : e.slice() }, i.rangeRound = function (a) { return i.range(a).round(!0) }, i.round = function (a) { return arguments.length ? (n = !!a, i) : n }, i.clamp = function (a) { return arguments.length ? (t.clamp(a), i) : t.clamp() }, i.unknown = function (a) { return arguments.length ? (r = a, i) : r }, i.copy = function () { return Ade(t.domain(), e).round(n).clamp(t.clamp()).unknown(r) }, Zl.apply(i, arguments), Tp(i) } function Pde() { var t = [], e = [], n = [], r; function i() { var s = 0, o = Math.max(1, e.length); for (n = new Array(o - 1); ++s < o;)n[s - 1] = JVe(t, s / o); return a } function a(s) { return s == null || isNaN(s = +s) ? r : e[T_(n, s)] } return a.invertExtent = function (s) { var o = e.indexOf(s); return o < 0 ? [NaN, NaN] : [o > 0 ? n[o - 1] : t[0], o < n.length ? n[o] : t[t.length - 1]] }, a.domain = function (s) { if (!arguments.length) return t.slice(); t = []; for (let o of s) o != null && !isNaN(o = +o) && t.push(o); return t.sort(qh), i() }, a.range = function (s) { return arguments.length ? (e = Array.from(s), i()) : e.slice() }, a.unknown = function (s) { return arguments.length ? (r = s, a) : r }, a.quantiles = function () { return n.slice() }, a.copy = function () { return Pde().domain(t).range(e).unknown(r) }, Zl.apply(a, arguments) } function jde() { var t = 0, e = 1, n = 1, r = [.5], i = [0, 1], a; function s(c) { return c != null && c <= c ? i[T_(r, c, 0, n)] : a } function o() { var c = -1; for (r = new Array(n); ++c < n;)r[c] = ((c + 1) * e - (c - n) * t) / (n + 1); return s } return s.domain = function (c) { return arguments.length ? ([t, e] = c, t = +t, e = +e, o()) : [t, e] }, s.range = function (c) { return arguments.length ? (n = (i = Array.from(c)).length - 1, o()) : i.slice() }, s.invertExtent = function (c) { var u = i.indexOf(c); return u < 0 ? [NaN, NaN] : u < 1 ? [t, r[0]] : u >= n ? [r[n - 1], e] : [r[u - 1], r[u]] }, s.unknown = function (c) { return arguments.length && (a = c), s }, s.thresholds = function () { return r.slice() }, s.copy = function () { return jde().domain([t, e]).range(i).unknown(a) }, Zl.apply(Tp(s), arguments) } function Rde() { var t = [.5], e = [0, 1], n, r = 1; function i(a) { return a != null && a <= a ? e[T_(t, a, 0, r)] : n } return i.domain = function (a) { return arguments.length ? (t = Array.from(a), r = Math.min(t.length, e.length - 1), i) : t.slice() }, i.range = function (a) { return arguments.length ? (e = Array.from(a), r = Math.min(t.length, e.length - 1), i) : e.slice() }, i.invertExtent = function (a) { var s = e.indexOf(a); return [t[s - 1], t[s]] }, i.unknown = function (a) { return arguments.length ? (n = a, i) : n }, i.copy = function () { return Rde().domain(t).range(e).unknown(n) }, Zl.apply(i, arguments) } const RD = new Date, kD = new Date; function Fa(t, e, n, r) { function i(a) { return t(a = arguments.length === 0 ? new Date : new Date(+a)), a } return i.floor = a => (t(a = new Date(+a)), a), i.ceil = a => (t(a = new Date(a - 1)), e(a, 1), t(a), a), i.round = a => { const s = i(a), o = i.ceil(a); return a - s < o - a ? s : o }, i.offset = (a, s) => (e(a = new Date(+a), s == null ? 1 : Math.floor(s)), a), i.range = (a, s, o) => { const c = []; if (a = i.ceil(a), o = o == null ? 1 : Math.floor(o), !(a < s) || !(o > 0)) return c; let u; do c.push(u = new Date(+a)), e(a, o), t(a); while (u < a && a < s); return c }, i.filter = a => Fa(s => { if (s >= s) for (; t(s), !a(s);)s.setTime(s - 1) }, (s, o) => { if (s >= s) if (o < 0) for (; ++o <= 0;)for (; e(s, -1), !a(s);); else for (; --o >= 0;)for (; e(s, 1), !a(s);); }), n && (i.count = (a, s) => (RD.setTime(+a), kD.setTime(+s), t(RD), t(kD), Math.floor(n(RD, kD))), i.every = a => (a = Math.floor(a), !isFinite(a) || !(a > 0) ? null : a > 1 ? i.filter(r ? s => r(s) % a === 0 : s => i.count(0, s) % a === 0) : i)), i } const SN = Fa(() => { }, (t, e) => { t.setTime(+t + e) }, (t, e) => e - t); SN.every = t => (t = Math.floor(t), !isFinite(t) || !(t > 0) ? null : t > 1 ? Fa(e => { e.setTime(Math.floor(e / t) * t) }, (e, n) => { e.setTime(+e + n * t) }, (e, n) => (n - e) / t) : SN); SN.range; const nf = 1e3, Bl = nf * 60, rf = Bl * 60, bf = rf * 24, J$ = bf * 7, bY = bf * 30, ID = bf * 365, rg = Fa(t => { t.setTime(t - t.getMilliseconds()) }, (t, e) => { t.setTime(+t + e * nf) }, (t, e) => (e - t) / nf, t => t.getUTCSeconds()); rg.range; const ez = Fa(t => { t.setTime(t - t.getMilliseconds() - t.getSeconds() * nf) }, (t, e) => { t.setTime(+t + e * Bl) }, (t, e) => (e - t) / Bl, t => t.getMinutes()); ez.range; const tz = Fa(t => { t.setUTCSeconds(0, 0) }, (t, e) => { t.setTime(+t + e * Bl) }, (t, e) => (e - t) / Bl, t => t.getUTCMinutes()); tz.range; const nz = Fa(t => { t.setTime(t - t.getMilliseconds() - t.getSeconds() * nf - t.getMinutes() * Bl) }, (t, e) => { t.setTime(+t + e * rf) }, (t, e) => (e - t) / rf, t => t.getHours()); nz.range; const rz = Fa(t => { t.setUTCMinutes(0, 0, 0) }, (t, e) => { t.setTime(+t + e * rf) }, (t, e) => (e - t) / rf, t => t.getUTCHours()); rz.range; const A_ = Fa(t => t.setHours(0, 0, 0, 0), (t, e) => t.setDate(t.getDate() + e), (t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * Bl) / bf, t => t.getDate() - 1); A_.range; const G2 = Fa(t => { t.setUTCHours(0, 0, 0, 0) }, (t, e) => { t.setUTCDate(t.getUTCDate() + e) }, (t, e) => (e - t) / bf, t => t.getUTCDate() - 1); G2.range; const kde = Fa(t => { t.setUTCHours(0, 0, 0, 0) }, (t, e) => { t.setUTCDate(t.getUTCDate() + e) }, (t, e) => (e - t) / bf, t => Math.floor(t / bf)); kde.range; function Yg(t) { return Fa(e => { e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0) }, (e, n) => { e.setDate(e.getDate() + n * 7) }, (e, n) => (n - e - (n.getTimezoneOffset() - e.getTimezoneOffset()) * Bl) / J$) } const q2 = Yg(0), _N = Yg(1), YHe = Yg(2), KHe = Yg(3), Bx = Yg(4), ZHe = Yg(5), QHe = Yg(6); q2.range; _N.range; YHe.range; KHe.range; Bx.range; ZHe.range; QHe.range; function Kg(t) { return Fa(e => { e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0) }, (e, n) => { e.setUTCDate(e.getUTCDate() + n * 7) }, (e, n) => (n - e) / J$) } const X2 = Kg(0), EN = Kg(1), JHe = Kg(2), eWe = Kg(3), $x = Kg(4), tWe = Kg(5), nWe = Kg(6); X2.range; EN.range; JHe.range; eWe.range; $x.range; tWe.range; nWe.range; const iz = Fa(t => { t.setDate(1), t.setHours(0, 0, 0, 0) }, (t, e) => { t.setMonth(t.getMonth() + e) }, (t, e) => e.getMonth() - t.getMonth() + (e.getFullYear() - t.getFullYear()) * 12, t => t.getMonth()); iz.range; const az = Fa(t => { t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0) }, (t, e) => { t.setUTCMonth(t.getUTCMonth() + e) }, (t, e) => e.getUTCMonth() - t.getUTCMonth() + (e.getUTCFullYear() - t.getUTCFullYear()) * 12, t => t.getUTCMonth()); az.range; const wf = Fa(t => { t.setMonth(0, 1), t.setHours(0, 0, 0, 0) }, (t, e) => { t.setFullYear(t.getFullYear() + e) }, (t, e) => e.getFullYear() - t.getFullYear(), t => t.getFullYear()); wf.every = t => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Fa(e => { e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0) }, (e, n) => { e.setFullYear(e.getFullYear() + n * t) }); wf.range; const Sf = Fa(t => { t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0) }, (t, e) => { t.setUTCFullYear(t.getUTCFullYear() + e) }, (t, e) => e.getUTCFullYear() - t.getUTCFullYear(), t => t.getUTCFullYear()); Sf.every = t => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Fa(e => { e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0) }, (e, n) => { e.setUTCFullYear(e.getUTCFullYear() + n * t) }); Sf.range; function Ide(t, e, n, r, i, a) { const s = [[rg, 1, nf], [rg, 5, 5 * nf], [rg, 15, 15 * nf], [rg, 30, 30 * nf], [a, 1, Bl], [a, 5, 5 * Bl], [a, 15, 15 * Bl], [a, 30, 30 * Bl], [i, 1, rf], [i, 3, 3 * rf], [i, 6, 6 * rf], [i, 12, 12 * rf], [r, 1, bf], [r, 2, 2 * bf], [n, 1, J$], [e, 1, bY], [e, 3, 3 * bY], [t, 1, ID]]; function o(u, d, f) { const h = d < u; h && ([u, d] = [d, u]); const m = f && typeof f.range == "function" ? f : c(u, d, f), g = m ? m.range(u, +d + 1) : []; return h ? g.reverse() : g } function c(u, d, f) { const h = Math.abs(d - u) / f, m = $$(([, , v]) => v).right(s, h); if (m === s.length) return t.every(B4(u / ID, d / ID, f)); if (m === 0) return SN.every(Math.max(B4(u, d, f), 1)); const [g, x] = s[h / s[m - 1][2] < s[m][2] / h ? m - 1 : m]; return g.every(x) } return [o, c] } const [rWe, iWe] = Ide(Sf, az, X2, kde, rz, tz), [aWe, sWe] = Ide(wf, iz, q2, A_, nz, ez); function OD(t) { if (0 <= t.y && t.y < 100) { var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L); return e.setFullYear(t.y), e } return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L) } function DD(t) { if (0 <= t.y && t.y < 100) { var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L)); return e.setUTCFullYear(t.y), e } return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L)) } function yw(t, e, n) { return { y: t, m: e, d: n, H: 0, M: 0, S: 0, L: 0 } } function oWe(t) { var e = t.dateTime, n = t.date, r = t.time, i = t.periods, a = t.days, s = t.shortDays, o = t.months, c = t.shortMonths, u = xw(i), d = bw(i), f = xw(a), h = bw(a), m = xw(s), g = bw(s), x = xw(o), v = bw(o), b = xw(c), E = bw(c), M = { a: Z, A: $, b: V, B: K, c: null, d: TY, e: TY, f: PWe, g: BWe, G: zWe, H: CWe, I: NWe, j: AWe, L: Ode, m: jWe, M: RWe, p: X, q: Q, Q: AY, s: PY, S: kWe, u: IWe, U: OWe, V: DWe, w: LWe, W: FWe, x: null, X: null, y: UWe, Y: $We, Z: VWe, "%": NY }, C = { a: re, A: ce, b: be, B: de, c: null, d: CY, e: CY, f: qWe, g: r7e, G: a7e, H: HWe, I: WWe, j: GWe, L: Lde, m: XWe, M: YWe, p: ae, q: se, Q: AY, s: PY, S: KWe, u: ZWe, U: QWe, V: JWe, w: e7e, W: t7e, x: null, X: null, y: n7e, Y: i7e, Z: s7e, "%": NY }, N = { a: D, A: F, b: B, B: G, c: z, d: EY, e: EY, f: _We, g: _Y, G: SY, H: MY, I: MY, j: xWe, L: SWe, m: yWe, M: bWe, p: I, q: vWe, Q: MWe, s: TWe, S: wWe, u: fWe, U: hWe, V: pWe, w: dWe, W: mWe, x: q, X: Y, y: _Y, Y: SY, Z: gWe, "%": EWe }; M.x = A(n, M), M.X = A(r, M), M.c = A(e, M), C.x = A(n, C), C.X = A(r, C), C.c = A(e, C); function A(he, Ae) { return function (Ce) { var fe = [], oe = -1, xe = 0, _e = he.length, je, ke, Ze; for (Ce instanceof Date || (Ce = new Date(+Ce)); ++oe < _e;)he.charCodeAt(oe) === 37 && (fe.push(he.slice(xe, oe)), (ke = wY[je = he.charAt(++oe)]) != null ? je = he.charAt(++oe) : ke = je === "e" ? " " : "0", (Ze = Ae[je]) && (je = Ze(Ce, ke)), fe.push(je), xe = oe + 1); return fe.push(he.slice(xe, oe)), fe.join("") } } function j(he, Ae) { return function (Ce) { var fe = yw(1900, void 0, 1), oe = O(fe, he, Ce += "", 0), xe, _e; if (oe != Ce.length) return null; if ("Q" in fe) return new Date(fe.Q); if ("s" in fe) return new Date(fe.s * 1e3 + ("L" in fe ? fe.L : 0)); if (Ae && !("Z" in fe) && (fe.Z = 0), "p" in fe && (fe.H = fe.H % 12 + fe.p * 12), fe.m === void 0 && (fe.m = "q" in fe ? fe.q : 0), "V" in fe) { if (fe.V < 1 || fe.V > 53) return null; "w" in fe || (fe.w = 1), "Z" in fe ? (xe = DD(yw(fe.y, 0, 1)), _e = xe.getUTCDay(), xe = _e > 4 || _e === 0 ? EN.ceil(xe) : EN(xe), xe = G2.offset(xe, (fe.V - 1) * 7), fe.y = xe.getUTCFullYear(), fe.m = xe.getUTCMonth(), fe.d = xe.getUTCDate() + (fe.w + 6) % 7) : (xe = OD(yw(fe.y, 0, 1)), _e = xe.getDay(), xe = _e > 4 || _e === 0 ? _N.ceil(xe) : _N(xe), xe = A_.offset(xe, (fe.V - 1) * 7), fe.y = xe.getFullYear(), fe.m = xe.getMonth(), fe.d = xe.getDate() + (fe.w + 6) % 7) } else ("W" in fe || "U" in fe) && ("w" in fe || (fe.w = "u" in fe ? fe.u % 7 : "W" in fe ? 1 : 0), _e = "Z" in fe ? DD(yw(fe.y, 0, 1)).getUTCDay() : OD(yw(fe.y, 0, 1)).getDay(), fe.m = 0, fe.d = "W" in fe ? (fe.w + 6) % 7 + fe.W * 7 - (_e + 5) % 7 : fe.w + fe.U * 7 - (_e + 6) % 7); return "Z" in fe ? (fe.H += fe.Z / 100 | 0, fe.M += fe.Z % 100, DD(fe)) : OD(fe) } } function O(he, Ae, Ce, fe) { for (var oe = 0, xe = Ae.length, _e = Ce.length, je, ke; oe < xe;) { if (fe >= _e) return -1; if (je = Ae.charCodeAt(oe++), je === 37) { if (je = Ae.charAt(oe++), ke = N[je in wY ? Ae.charAt(oe++) : je], !ke || (fe = ke(he, Ce, fe)) < 0) return -1 } else if (je != Ce.charCodeAt(fe++)) return -1 } return fe } function I(he, Ae, Ce) { var fe = u.exec(Ae.slice(Ce)); return fe ? (he.p = d.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1 } function D(he, Ae, Ce) { var fe = m.exec(Ae.slice(Ce)); return fe ? (he.w = g.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1 } function F(he, Ae, Ce) { var fe = f.exec(Ae.slice(Ce)); return fe ? (he.w = h.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1 } function B(he, Ae, Ce) { var fe = b.exec(Ae.slice(Ce)); return fe ? (he.m = E.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1 } function G(he, Ae, Ce) { var fe = x.exec(Ae.slice(Ce)); return fe ? (he.m = v.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1 } function z(he, Ae, Ce) { return O(he, e, Ae, Ce) } function q(he, Ae, Ce) { return O(he, n, Ae, Ce) } function Y(he, Ae, Ce) { return O(he, r, Ae, Ce) } function Z(he) { return s[he.getDay()] } function $(he) { return a[he.getDay()] } function V(he) { return c[he.getMonth()] } function K(he) { return o[he.getMonth()] } function X(he) { return i[+(he.getHours() >= 12)] } function Q(he) { return 1 + ~~(he.getMonth() / 3) } function re(he) { return s[he.getUTCDay()] } function ce(he) { return a[he.getUTCDay()] } function be(he) { return c[he.getUTCMonth()] } function de(he) { return o[he.getUTCMonth()] } function ae(he) { return i[+(he.getUTCHours() >= 12)] } function se(he) { return 1 + ~~(he.getUTCMonth() / 3) } return { format: function (he) { var Ae = A(he += "", M); return Ae.toString = function () { return he }, Ae }, parse: function (he) { var Ae = j(he += "", !1); return Ae.toString = function () { return he }, Ae }, utcFormat: function (he) { var Ae = A(he += "", C); return Ae.toString = function () { return he }, Ae }, utcParse: function (he) { var Ae = j(he += "", !0); return Ae.toString = function () { return he }, Ae } } } var wY = { "-": "", _: " ", 0: "0" }, Za = /^\s*\d+/, lWe = /^%/, cWe = /[\\^$*+?|[\]().{}]/g; function Or(t, e, n) { var r = t < 0 ? "-" : "", i = (r ? -t : t) + "", a = i.length; return r + (a < n ? new Array(n - a + 1).join(e) + i : i) } function uWe(t) { return t.replace(cWe, "\\$&") } function xw(t) { return new RegExp("^(?:" + t.map(uWe).join("|") + ")", "i") } function bw(t) { return new Map(t.map((e, n) => [e.toLowerCase(), n])) } function dWe(t, e, n) { var r = Za.exec(e.slice(n, n + 1)); return r ? (t.w = +r[0], n + r[0].length) : -1 } function fWe(t, e, n) { var r = Za.exec(e.slice(n, n + 1)); return r ? (t.u = +r[0], n + r[0].length) : -1 } function hWe(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.U = +r[0], n + r[0].length) : -1 } function pWe(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.V = +r[0], n + r[0].length) : -1 } function mWe(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.W = +r[0], n + r[0].length) : -1 } function SY(t, e, n) { var r = Za.exec(e.slice(n, n + 4)); return r ? (t.y = +r[0], n + r[0].length) : -1 } function _Y(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1 } function gWe(t, e, n) { var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(n, n + 6)); return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1 } function vWe(t, e, n) { var r = Za.exec(e.slice(n, n + 1)); return r ? (t.q = r[0] * 3 - 3, n + r[0].length) : -1 } function yWe(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.m = r[0] - 1, n + r[0].length) : -1 } function EY(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.d = +r[0], n + r[0].length) : -1 } function xWe(t, e, n) { var r = Za.exec(e.slice(n, n + 3)); return r ? (t.m = 0, t.d = +r[0], n + r[0].length) : -1 } function MY(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.H = +r[0], n + r[0].length) : -1 } function bWe(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.M = +r[0], n + r[0].length) : -1 } function wWe(t, e, n) { var r = Za.exec(e.slice(n, n + 2)); return r ? (t.S = +r[0], n + r[0].length) : -1 } function SWe(t, e, n) { var r = Za.exec(e.slice(n, n + 3)); return r ? (t.L = +r[0], n + r[0].length) : -1 } function _We(t, e, n) { var r = Za.exec(e.slice(n, n + 6)); return r ? (t.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1 } function EWe(t, e, n) { var r = lWe.exec(e.slice(n, n + 1)); return r ? n + r[0].length : -1 } function MWe(t, e, n) { var r = Za.exec(e.slice(n)); return r ? (t.Q = +r[0], n + r[0].length) : -1 } function TWe(t, e, n) { var r = Za.exec(e.slice(n)); return r ? (t.s = +r[0], n + r[0].length) : -1 } function TY(t, e) { return Or(t.getDate(), e, 2) } function CWe(t, e) { return Or(t.getHours(), e, 2) } function NWe(t, e) { return Or(t.getHours() % 12 || 12, e, 2) } function AWe(t, e) { return Or(1 + A_.count(wf(t), t), e, 3) } function Ode(t, e) { return Or(t.getMilliseconds(), e, 3) } function PWe(t, e) { return Ode(t, e) + "000" } function jWe(t, e) { return Or(t.getMonth() + 1, e, 2) } function RWe(t, e) { return Or(t.getMinutes(), e, 2) } function kWe(t, e) { return Or(t.getSeconds(), e, 2) } function IWe(t) { var e = t.getDay(); return e === 0 ? 7 : e } function OWe(t, e) { return Or(q2.count(wf(t) - 1, t), e, 2) } function Dde(t) { var e = t.getDay(); return e >= 4 || e === 0 ? Bx(t) : Bx.ceil(t) } function DWe(t, e) { return t = Dde(t), Or(Bx.count(wf(t), t) + (wf(t).getDay() === 4), e, 2) } function LWe(t) { return t.getDay() } function FWe(t, e) { return Or(_N.count(wf(t) - 1, t), e, 2) } function UWe(t, e) { return Or(t.getFullYear() % 100, e, 2) } function BWe(t, e) { return t = Dde(t), Or(t.getFullYear() % 100, e, 2) } function $We(t, e) { return Or(t.getFullYear() % 1e4, e, 4) } function zWe(t, e) { var n = t.getDay(); return t = n >= 4 || n === 0 ? Bx(t) : Bx.ceil(t), Or(t.getFullYear() % 1e4, e, 4) } function VWe(t) { var e = t.getTimezoneOffset(); return (e > 0 ? "-" : (e *= -1, "+")) + Or(e / 60 | 0, "0", 2) + Or(e % 60, "0", 2) } function CY(t, e) { return Or(t.getUTCDate(), e, 2) } function HWe(t, e) { return Or(t.getUTCHours(), e, 2) } function WWe(t, e) { return Or(t.getUTCHours() % 12 || 12, e, 2) } function GWe(t, e) { return Or(1 + G2.count(Sf(t), t), e, 3) } function Lde(t, e) { return Or(t.getUTCMilliseconds(), e, 3) } function qWe(t, e) { return Lde(t, e) + "000" } function XWe(t, e) { return Or(t.getUTCMonth() + 1, e, 2) } function YWe(t, e) { return Or(t.getUTCMinutes(), e, 2) } function KWe(t, e) { return Or(t.getUTCSeconds(), e, 2) } function ZWe(t) { var e = t.getUTCDay(); return e === 0 ? 7 : e } function QWe(t, e) { return Or(X2.count(Sf(t) - 1, t), e, 2) } function Fde(t) { var e = t.getUTCDay(); return e >= 4 || e === 0 ? $x(t) : $x.ceil(t) } function JWe(t, e) { return t = Fde(t), Or($x.count(Sf(t), t) + (Sf(t).getUTCDay() === 4), e, 2) } function e7e(t) { return t.getUTCDay() } function t7e(t, e) { return Or(EN.count(Sf(t) - 1, t), e, 2) } function n7e(t, e) { return Or(t.getUTCFullYear() % 100, e, 2) } function r7e(t, e) { return t = Fde(t), Or(t.getUTCFullYear() % 100, e, 2) } function i7e(t, e) { return Or(t.getUTCFullYear() % 1e4, e, 4) } function a7e(t, e) { var n = t.getUTCDay(); return t = n >= 4 || n === 0 ? $x(t) : $x.ceil(t), Or(t.getUTCFullYear() % 1e4, e, 4) } function s7e() { return "+0000" } function NY() { return "%" } function AY(t) { return +t } function PY(t) { return Math.floor(+t / 1e3) } var Ey, Ude, Bde; o7e({ dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] }); function o7e(t) { return Ey = oWe(t), Ude = Ey.format, Ey.parse, Bde = Ey.utcFormat, Ey.utcParse, Ey } function l7e(t) { return new Date(t) } function c7e(t) { return t instanceof Date ? +t : +new Date(+t) } function sz(t, e, n, r, i, a, s, o, c, u) { var d = G$(), f = d.invert, h = d.domain, m = u(".%L"), g = u(":%S"), x = u("%I:%M"), v = u("%I %p"), b = u("%a %d"), E = u("%b %d"), M = u("%B"), C = u("%Y"); function N(A) { return (c(A) < A ? m : o(A) < A ? g : s(A) < A ? x : a(A) < A ? v : r(A) < A ? i(A) < A ? b : E : n(A) < A ? M : C)(A) } return d.invert = function (A) { return new Date(f(A)) }, d.domain = function (A) { return arguments.length ? h(Array.from(A, c7e)) : h().map(l7e) }, d.ticks = function (A) { var j = h(); return t(j[0], j[j.length - 1], A ?? 10) }, d.tickFormat = function (A, j) { return j == null ? N : u(j) }, d.nice = function (A) { var j = h(); return (!A || typeof A.range != "function") && (A = e(j[0], j[j.length - 1], A ?? 10)), A ? h(Tde(j, A)) : d }, d.copy = function () { return N_(d, sz(t, e, n, r, i, a, s, o, c, u)) }, d } function u7e() { return Zl.apply(sz(aWe, sWe, wf, iz, q2, A_, nz, ez, rg, Ude).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments) } function d7e() { return Zl.apply(sz(rWe, iWe, Sf, az, X2, G2, rz, tz, rg, Bde).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments) } function Y2() { var t = 0, e = 1, n, r, i, a, s = to, o = !1, c; function u(f) { return f == null || isNaN(f = +f) ? c : s(i === 0 ? .5 : (f = (a(f) - n) * i, o ? Math.max(0, Math.min(1, f)) : f)) } u.domain = function (f) { return arguments.length ? ([t, e] = f, n = a(t = +t), r = a(e = +e), i = n === r ? 0 : 1 / (r - n), u) : [t, e] }, u.clamp = function (f) { return arguments.length ? (o = !!f, u) : o }, u.interpolator = function (f) { return arguments.length ? (s = f, u) : s }; function d(f) { return function (h) { var m, g; return arguments.length ? ([m, g] = h, s = f(m, g), u) : [s(0), s(1)] } } return u.range = d(U0), u.rangeRound = d(W$), u.unknown = function (f) { return arguments.length ? (c = f, u) : c }, function (f) { return a = f, n = f(t), r = f(e), i = n === r ? 0 : 1 / (r - n), u } } function Cp(t, e) { return e.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown()) } function $de() { var t = Tp(Y2()(to)); return t.copy = function () { return Cp(t, $de()) }, Nf.apply(t, arguments) } function zde() { var t = Y$(Y2()).domain([1, 10]); return t.copy = function () { return Cp(t, zde()).base(t.base()) }, Nf.apply(t, arguments) } function Vde() { var t = K$(Y2()); return t.copy = function () { return Cp(t, Vde()).constant(t.constant()) }, Nf.apply(t, arguments) } function oz() { var t = Z$(Y2()); return t.copy = function () { return Cp(t, oz()).exponent(t.exponent()) }, Nf.apply(t, arguments) } function f7e() { return oz.apply(null, arguments).exponent(.5) } function Hde() { var t = [], e = to; function n(r) { if (r != null && !isNaN(r = +r)) return e((T_(t, r, 1) - 1) / (t.length - 1)) } return n.domain = function (r) { if (!arguments.length) return t.slice(); t = []; for (let i of r) i != null && !isNaN(i = +i) && t.push(i); return t.sort(qh), n }, n.interpolator = function (r) { return arguments.length ? (e = r, n) : e }, n.range = function () { return t.map((r, i) => e(i / (t.length - 1))) }, n.quantiles = function (r) { return Array.from({ length: r + 1 }, (i, a) => QVe(t, a / r)) }, n.copy = function () { return Hde(e).domain(t) }, Nf.apply(n, arguments) } function K2() { var t = 0, e = .5, n = 1, r = 1, i, a, s, o, c, u = to, d, f = !1, h; function m(x) { return isNaN(x = +x) ? h : (x = .5 + ((x = +d(x)) - a) * (r * x < r * a ? o : c), u(f ? Math.max(0, Math.min(1, x)) : x)) } m.domain = function (x) { return arguments.length ? ([t, e, n] = x, i = d(t = +t), a = d(e = +e), s = d(n = +n), o = i === a ? 0 : .5 / (a - i), c = a === s ? 0 : .5 / (s - a), r = a < i ? -1 : 1, m) : [t, e, n] }, m.clamp = function (x) { return arguments.length ? (f = !!x, m) : f }, m.interpolator = function (x) { return arguments.length ? (u = x, m) : u }; function g(x) { return function (v) { var b, E, M; return arguments.length ? ([b, E, M] = v, u = EHe(x, [b, E, M]), m) : [u(0), u(.5), u(1)] } } return m.range = g(U0), m.rangeRound = g(W$), m.unknown = function (x) { return arguments.length ? (h = x, m) : h }, function (x) { return d = x, i = x(t), a = x(e), s = x(n), o = i === a ? 0 : .5 / (a - i), c = a === s ? 0 : .5 / (s - a), r = a < i ? -1 : 1, m } } function Wde() { var t = Tp(K2()(to)); return t.copy = function () { return Cp(t, Wde()) }, Nf.apply(t, arguments) } function Gde() { var t = Y$(K2()).domain([.1, 1, 10]); return t.copy = function () { return Cp(t, Gde()).base(t.base()) }, Nf.apply(t, arguments) } function qde() { var t = K$(K2()); return t.copy = function () { return Cp(t, qde()).constant(t.constant()) }, Nf.apply(t, arguments) } function lz() { var t = Z$(K2()); return t.copy = function () { return Cp(t, lz()).exponent(t.exponent()) }, Nf.apply(t, arguments) } function h7e() { return lz.apply(null, arguments).exponent(.5) } const jY = Object.freeze(Object.defineProperty({ __proto__: null, scaleBand: tS, scaleDiverging: Wde, scaleDivergingLog: Gde, scaleDivergingPow: lz, scaleDivergingSqrt: h7e, scaleDivergingSymlog: qde, scaleIdentity: Mde, scaleImplicit: $4, scaleLinear: wN, scaleLog: Cde, scaleOrdinal: z$, scalePoint: r1, scalePow: Q$, scaleQuantile: Pde, scaleQuantize: jde, scaleRadial: Ade, scaleSequential: $de, scaleSequentialLog: zde, scaleSequentialPow: oz, scaleSequentialQuantile: Hde, scaleSequentialSqrt: f7e, scaleSequentialSymlog: Vde, scaleSqrt: qHe, scaleSymlog: Nde, scaleThreshold: Rde, scaleTime: u7e, scaleUtc: d7e, tickFormat: Ede }, Symbol.toStringTag, { value: "Module" })); var LD, RY; function Z2() { if (RY) return LD; RY = 1; var t = O0(); function e(n, r, i) { for (var a = -1, s = n.length; ++a < s;) { var o = n[a], c = r(o); if (c != null && (u === void 0 ? c === c && !t(c) : i(c, u))) var u = c, d = o } return d } return LD = e, LD } var FD, kY; function Xde() { if (kY) return FD; kY = 1; function t(e, n) { return e > n } return FD = t, FD } var UD, IY; function p7e() { if (IY) return UD; IY = 1; var t = Z2(), e = Xde(), n = F0(); function r(i) { return i && i.length ? t(i, n, e) : void 0 } return UD = r, UD } var m7e = p7e(); const Lh = Fr(m7e); var BD, OY; function Yde() { if (OY) return BD; OY = 1; function t(e, n) { return e < n } return BD = t, BD } var $D, DY; function g7e() { if (DY) return $D; DY = 1; var t = Z2(), e = Yde(), n = F0(); function r(i) { return i && i.length ? t(i, n, e) : void 0 } return $D = r, $D } var v7e = g7e(); const Q2 = Fr(v7e); var zD, LY; function y7e() { if (LY) return zD; LY = 1; var t = M$(), e = td(), n = rde(), r = Vo(); function i(a, s) { var o = r(a) ? t : n; return o(a, e(s, 3)) } return zD = i, zD } var VD, FY; function x7e() { if (FY) return VD; FY = 1; var t = tde(), e = y7e(); function n(r, i) { return t(e(r, i), 1) } return VD = n, VD } var b7e = x7e(); const w7e = Fr(b7e); var HD, UY; function S7e() { if (UY) return HD; UY = 1; var t = L$(); function e(n, r) { return t(n, r) } return HD = e, HD } var _7e = S7e(); const sp = Fr(_7e); var B0 = 1e9, E7e = { precision: 20, rounding: 4, toExpNeg: -7, toExpPos: 21, LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286" }, uz, ki = !0, Gl = "[DecimalError] ", gg = Gl + "Invalid argument: ", cz = Gl + "Exponent out of range: ", $0 = Math.floor, Vm = Math.pow, M7e = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ll, Ga = 1e7, Mi = 7, Kde = 9007199254740991, MN = $0(Kde / Mi), cn = {}; cn.absoluteValue = cn.abs = function () { var t = new this.constructor(this); return t.s && (t.s = 1), t }; cn.comparedTo = cn.cmp = function (t) { var e, n, r, i, a = this; if (t = new a.constructor(t), a.s !== t.s) return a.s || -t.s; if (a.e !== t.e) return a.e > t.e ^ a.s < 0 ? 1 : -1; for (r = a.d.length, i = t.d.length, e = 0, n = r < i ? r : i; e < n; ++e)if (a.d[e] !== t.d[e]) return a.d[e] > t.d[e] ^ a.s < 0 ? 1 : -1; return r === i ? 0 : r > i ^ a.s < 0 ? 1 : -1 }; cn.decimalPlaces = cn.dp = function () { var t = this, e = t.d.length - 1, n = (e - t.e) * Mi; if (e = t.d[e], e) for (; e % 10 == 0; e /= 10)n--; return n < 0 ? 0 : n }; cn.dividedBy = cn.div = function (t) { return cf(this, new this.constructor(t)) }; cn.dividedToIntegerBy = cn.idiv = function (t) { var e = this, n = e.constructor; return ci(cf(e, new n(t), 0, 1), n.precision) }; cn.equals = cn.eq = function (t) { return !this.cmp(t) }; cn.exponent = function () { return ya(this) }; cn.greaterThan = cn.gt = function (t) { return this.cmp(t) > 0 }; cn.greaterThanOrEqualTo = cn.gte = function (t) { return this.cmp(t) >= 0 }; cn.isInteger = cn.isint = function () { return this.e > this.d.length - 2 }; cn.isNegative = cn.isneg = function () { return this.s < 0 }; cn.isPositive = cn.ispos = function () { return this.s > 0 }; cn.isZero = function () { return this.s === 0 }; cn.lessThan = cn.lt = function (t) { return this.cmp(t) < 0 }; cn.lessThanOrEqualTo = cn.lte = function (t) { return this.cmp(t) < 1 }; cn.logarithm = cn.log = function (t) { var e, n = this, r = n.constructor, i = r.precision, a = i + 5; if (t === void 0) t = new r(10); else if (t = new r(t), t.s < 1 || t.eq(ll)) throw Error(Gl + "NaN"); if (n.s < 1) throw Error(Gl + (n.s ? "NaN" : "-Infinity")); return n.eq(ll) ? new r(0) : (ki = !1, e = cf(sS(n, a), sS(t, a), a), ki = !0, ci(e, i)) }; cn.minus = cn.sub = function (t) { var e = this; return t = new e.constructor(t), e.s == t.s ? Jde(e, t) : Zde(e, (t.s = -t.s, t)) }; cn.modulo = cn.mod = function (t) { var e, n = this, r = n.constructor, i = r.precision; if (t = new r(t), !t.s) throw Error(Gl + "NaN"); return n.s ? (ki = !1, e = cf(n, t, 0, 1).times(t), ki = !0, n.minus(e)) : ci(new r(n), i) }; cn.naturalExponential = cn.exp = function () { return Qde(this) }; cn.naturalLogarithm = cn.ln = function () { return sS(this) }; cn.negated = cn.neg = function () { var t = new this.constructor(this); return t.s = -t.s || 0, t }; cn.plus = cn.add = function (t) { var e = this; return t = new e.constructor(t), e.s == t.s ? Zde(e, t) : Jde(e, (t.s = -t.s, t)) }; cn.precision = cn.sd = function (t) { var e, n, r, i = this; if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(gg + t); if (e = ya(i) + 1, r = i.d.length - 1, n = r * Mi + 1, r = i.d[r], r) { for (; r % 10 == 0; r /= 10)n--; for (r = i.d[0]; r >= 10; r /= 10)n++ } return t && e > n ? e : n }; cn.squareRoot = cn.sqrt = function () { var t, e, n, r, i, a, s, o = this, c = o.constructor; if (o.s < 1) { if (!o.s) return new c(0); throw Error(Gl + "NaN") } for (t = ya(o), ki = !1, i = Math.sqrt(+o), i == 0 || i == 1 / 0 ? (e = _u(o.d), (e.length + t) % 2 == 0 && (e += "0"), i = Math.sqrt(e), t = $0((t + 1) / 2) - (t < 0 || t % 2), i == 1 / 0 ? e = "5e" + t : (e = i.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + t), r = new c(e)) : r = new c(i.toString()), n = c.precision, i = s = n + 3; ;)if (a = r, r = a.plus(cf(o, a, s + 2)).times(.5), _u(a.d).slice(0, s) === (e = _u(r.d)).slice(0, s)) { if (e = e.slice(s - 3, s + 1), i == s && e == "4999") { if (ci(a, n + 1, 0), a.times(a).eq(o)) { r = a; break } } else if (e != "9999") break; s += 4 } return ki = !0, ci(r, n) }; cn.times = cn.mul = function (t) { var e, n, r, i, a, s, o, c, u, d = this, f = d.constructor, h = d.d, m = (t = new f(t)).d; if (!d.s || !t.s) return new f(0); for (t.s *= d.s, n = d.e + t.e, c = h.length, u = m.length, c < u && (a = h, h = m, m = a, s = c, c = u, u = s), a = [], s = c + u, r = s; r--;)a.push(0); for (r = u; --r >= 0;) { for (e = 0, i = c + r; i > r;)o = a[i] + m[r] * h[i - r - 1] + e, a[i--] = o % Ga | 0, e = o / Ga | 0; a[i] = (a[i] + e) % Ga | 0 } for (; !a[--s];)a.pop(); return e ? ++n : a.shift(), t.d = a, t.e = n, ki ? ci(t, f.precision) : t }; cn.toDecimalPlaces = cn.todp = function (t, e) { var n = this, r = n.constructor; return n = new r(n), t === void 0 ? n : (Wu(t, 0, B0), e === void 0 ? e = r.rounding : Wu(e, 0, 8), ci(n, t + ya(n) + 1, e)) }; cn.toExponential = function (t, e) { var n, r = this, i = r.constructor; return t === void 0 ? n = kg(r, !0) : (Wu(t, 0, B0), e === void 0 ? e = i.rounding : Wu(e, 0, 8), r = ci(new i(r), t + 1, e), n = kg(r, !0, t + 1)), n }; cn.toFixed = function (t, e) { var n, r, i = this, a = i.constructor; return t === void 0 ? kg(i) : (Wu(t, 0, B0), e === void 0 ? e = a.rounding : Wu(e, 0, 8), r = ci(new a(i), t + ya(i) + 1, e), n = kg(r.abs(), !1, t + ya(r) + 1), i.isneg() && !i.isZero() ? "-" + n : n) }; cn.toInteger = cn.toint = function () { var t = this, e = t.constructor; return ci(new e(t), ya(t) + 1, e.rounding) }; cn.toNumber = function () { return +this }; cn.toPower = cn.pow = function (t) { var e, n, r, i, a, s, o = this, c = o.constructor, u = 12, d = +(t = new c(t)); if (!t.s) return new c(ll); if (o = new c(o), !o.s) { if (t.s < 1) throw Error(Gl + "Infinity"); return o } if (o.eq(ll)) return o; if (r = c.precision, t.eq(ll)) return ci(o, r); if (e = t.e, n = t.d.length - 1, s = e >= n, a = o.s, s) { if ((n = d < 0 ? -d : d) <= Kde) { for (i = new c(ll), e = Math.ceil(r / Mi + 4), ki = !1; n % 2 && (i = i.times(o), $Y(i.d, e)), n = $0(n / 2), n !== 0;)o = o.times(o), $Y(o.d, e); return ki = !0, t.s < 0 ? new c(ll).div(i) : ci(i, r) } } else if (a < 0) throw Error(Gl + "NaN"); return a = a < 0 && t.d[Math.max(e, n)] & 1 ? -1 : 1, o.s = 1, ki = !1, i = t.times(sS(o, r + u)), ki = !0, i = Qde(i), i.s = a, i }; cn.toPrecision = function (t, e) { var n, r, i = this, a = i.constructor; return t === void 0 ? (n = ya(i), r = kg(i, n <= a.toExpNeg || n >= a.toExpPos)) : (Wu(t, 1, B0), e === void 0 ? e = a.rounding : Wu(e, 0, 8), i = ci(new a(i), t, e), n = ya(i), r = kg(i, t <= n || n <= a.toExpNeg, t)), r }; cn.toSignificantDigits = cn.tosd = function (t, e) { var n = this, r = n.constructor; return t === void 0 ? (t = r.precision, e = r.rounding) : (Wu(t, 1, B0), e === void 0 ? e = r.rounding : Wu(e, 0, 8)), ci(new r(n), t, e) }; cn.toString = cn.valueOf = cn.val = cn.toJSON = cn[Symbol.for("nodejs.util.inspect.custom")] = function () { var t = this, e = ya(t), n = t.constructor; return kg(t, e <= n.toExpNeg || e >= n.toExpPos) }; function Zde(t, e) { var n, r, i, a, s, o, c, u, d = t.constructor, f = d.precision; if (!t.s || !e.s) return e.s || (e = new d(t)), ki ? ci(e, f) : e; if (c = t.d, u = e.d, s = t.e, i = e.e, c = c.slice(), a = s - i, a) { for (a < 0 ? (r = c, a = -a, o = u.length) : (r = u, i = s, o = c.length), s = Math.ceil(f / Mi), o = s > o ? s + 1 : o + 1, a > o && (a = o, r.length = 1), r.reverse(); a--;)r.push(0); r.reverse() } for (o = c.length, a = u.length, o - a < 0 && (a = o, r = u, u = c, c = r), n = 0; a;)n = (c[--a] = c[a] + u[a] + n) / Ga | 0, c[a] %= Ga; for (n && (c.unshift(n), ++i), o = c.length; c[--o] == 0;)c.pop(); return e.d = c, e.e = i, ki ? ci(e, f) : e } function Wu(t, e, n) { if (t !== ~~t || t < e || t > n) throw Error(gg + t) } function _u(t) { var e, n, r, i = t.length - 1, a = "", s = t[0]; if (i > 0) { for (a += s, e = 1; e < i; e++)r = t[e] + "", n = Mi - r.length, n && (a += Ah(n)), a += r; s = t[e], r = s + "", n = Mi - r.length, n && (a += Ah(n)) } else if (s === 0) return "0"; for (; s % 10 === 0;)s /= 10; return a + s } var cf = (function () { function t(r, i) { var a, s = 0, o = r.length; for (r = r.slice(); o--;)a = r[o] * i + s, r[o] = a % Ga | 0, s = a / Ga | 0; return s && r.unshift(s), r } function e(r, i, a, s) { var o, c; if (a != s) c = a > s ? 1 : -1; else for (o = c = 0; o < a; o++)if (r[o] != i[o]) { c = r[o] > i[o] ? 1 : -1; break } return c } function n(r, i, a) { for (var s = 0; a--;)r[a] -= s, s = r[a] < i[a] ? 1 : 0, r[a] = s * Ga + r[a] - i[a]; for (; !r[0] && r.length > 1;)r.shift() } return function (r, i, a, s) { var o, c, u, d, f, h, m, g, x, v, b, E, M, C, N, A, j, O, I = r.constructor, D = r.s == i.s ? 1 : -1, F = r.d, B = i.d; if (!r.s) return new I(r); if (!i.s) throw Error(Gl + "Division by zero"); for (c = r.e - i.e, j = B.length, N = F.length, m = new I(D), g = m.d = [], u = 0; B[u] == (F[u] || 0);)++u; if (B[u] > (F[u] || 0) && --c, a == null ? E = a = I.precision : s ? E = a + (ya(r) - ya(i)) + 1 : E = a, E < 0) return new I(0); if (E = E / Mi + 2 | 0, u = 0, j == 1) for (d = 0, B = B[0], E++; (u < N || d) && E--; u++)M = d * Ga + (F[u] || 0), g[u] = M / B | 0, d = M % B | 0; else { for (d = Ga / (B[0] + 1) | 0, d > 1 && (B = t(B, d), F = t(F, d), j = B.length, N = F.length), C = j, x = F.slice(0, j), v = x.length; v < j;)x[v++] = 0; O = B.slice(), O.unshift(0), A = B[0], B[1] >= Ga / 2 && ++A; do d = 0, o = e(B, x, j, v), o < 0 ? (b = x[0], j != v && (b = b * Ga + (x[1] || 0)), d = b / A | 0, d > 1 ? (d >= Ga && (d = Ga - 1), f = t(B, d), h = f.length, v = x.length, o = e(f, x, h, v), o == 1 && (d--, n(f, j < h ? O : B, h))) : (d == 0 && (o = d = 1), f = B.slice()), h = f.length, h < v && f.unshift(0), n(x, f, v), o == -1 && (v = x.length, o = e(B, x, j, v), o < 1 && (d++, n(x, j < v ? O : B, v))), v = x.length) : o === 0 && (d++, x = [0]), g[u++] = d, o && x[0] ? x[v++] = F[C] || 0 : (x = [F[C]], v = 1); while ((C++ < N || x[0] !== void 0) && E--) } return g[0] || g.shift(), m.e = c, ci(m, s ? a + ya(m) + 1 : a) } })(); function Qde(t, e) { var n, r, i, a, s, o, c = 0, u = 0, d = t.constructor, f = d.precision; if (ya(t) > 16) throw Error(cz + ya(t)); if (!t.s) return new d(ll); for (ki = !1, o = f, s = new d(.03125); t.abs().gte(.1);)t = t.times(s), u += 5; for (r = Math.log(Vm(2, u)) / Math.LN10 * 2 + 5 | 0, o += r, n = i = a = new d(ll), d.precision = o; ;) { if (i = ci(i.times(t), o), n = n.times(++c), s = a.plus(cf(i, n, o)), _u(s.d).slice(0, o) === _u(a.d).slice(0, o)) { for (; u--;)a = ci(a.times(a), o); return d.precision = f, e == null ? (ki = !0, ci(a, f)) : a } a = s } } function ya(t) { for (var e = t.e * Mi, n = t.d[0]; n >= 10; n /= 10)e++; return e } function WD(t, e, n) { if (e > t.LN10.sd()) throw ki = !0, n && (t.precision = n), Error(Gl + "LN10 precision limit exceeded"); return ci(new t(t.LN10), e) } function Ah(t) { for (var e = ""; t--;)e += "0"; return e } function sS(t, e) { var n, r, i, a, s, o, c, u, d, f = 1, h = 10, m = t, g = m.d, x = m.constructor, v = x.precision; if (m.s < 1) throw Error(Gl + (m.s ? "NaN" : "-Infinity")); if (m.eq(ll)) return new x(0); if (e == null ? (ki = !1, u = v) : u = e, m.eq(10)) return e == null && (ki = !0), WD(x, u); if (u += h, x.precision = u, n = _u(g), r = n.charAt(0), a = ya(m), Math.abs(a) < 15e14) { for (; r < 7 && r != 1 || r == 1 && n.charAt(1) > 3;)m = m.times(t), n = _u(m.d), r = n.charAt(0), f++; a = ya(m), r > 1 ? (m = new x("0." + n), a++) : m = new x(r + "." + n.slice(1)) } else return c = WD(x, u + 2, v).times(a + ""), m = sS(new x(r + "." + n.slice(1)), u - h).plus(c), x.precision = v, e == null ? (ki = !0, ci(m, v)) : m; for (o = s = m = cf(m.minus(ll), m.plus(ll), u), d = ci(m.times(m), u), i = 3; ;) { if (s = ci(s.times(d), u), c = o.plus(cf(s, new x(i), u)), _u(c.d).slice(0, u) === _u(o.d).slice(0, u)) return o = o.times(2), a !== 0 && (o = o.plus(WD(x, u + 2, v).times(a + ""))), o = cf(o, new x(f), u), x.precision = v, e == null ? (ki = !0, ci(o, v)) : o; o = c, i += 2 } } function BY(t, e) { var n, r, i; for ((n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (r = e.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +e.slice(r + 1), e = e.substring(0, r)) : n < 0 && (n = e.length), r = 0; e.charCodeAt(r) === 48;)++r; for (i = e.length; e.charCodeAt(i - 1) === 48;)--i; if (e = e.slice(r, i), e) { if (i -= r, n = n - r - 1, t.e = $0(n / Mi), t.d = [], r = (n + 1) % Mi, n < 0 && (r += Mi), r < i) { for (r && t.d.push(+e.slice(0, r)), i -= Mi; r < i;)t.d.push(+e.slice(r, r += Mi)); e = e.slice(r), r = Mi - e.length } else r -= i; for (; r--;)e += "0"; if (t.d.push(+e), ki && (t.e > MN || t.e < -MN)) throw Error(cz + n) } else t.s = 0, t.e = 0, t.d = [0]; return t } function ci(t, e, n) { var r, i, a, s, o, c, u, d, f = t.d; for (s = 1, a = f[0]; a >= 10; a /= 10)s++; if (r = e - s, r < 0) r += Mi, i = e, u = f[d = 0]; else { if (d = Math.ceil((r + 1) / Mi), a = f.length, d >= a) return t; for (u = a = f[d], s = 1; a >= 10; a /= 10)s++; r %= Mi, i = r - Mi + s } if (n !== void 0 && (a = Vm(10, s - i - 1), o = u / a % 10 | 0, c = e < 0 || f[d + 1] !== void 0 || u % a, c = n < 4 ? (o || c) && (n == 0 || n == (t.s < 0 ? 3 : 2)) : o > 5 || o == 5 && (n == 4 || c || n == 6 && (r > 0 ? i > 0 ? u / Vm(10, s - i) : 0 : f[d - 1]) % 10 & 1 || n == (t.s < 0 ? 8 : 7))), e < 1 || !f[0]) return c ? (a = ya(t), f.length = 1, e = e - a - 1, f[0] = Vm(10, (Mi - e % Mi) % Mi), t.e = $0(-e / Mi) || 0) : (f.length = 1, f[0] = t.e = t.s = 0), t; if (r == 0 ? (f.length = d, a = 1, d--) : (f.length = d + 1, a = Vm(10, Mi - r), f[d] = i > 0 ? (u / Vm(10, s - i) % Vm(10, i) | 0) * a : 0), c) for (; ;)if (d == 0) { (f[0] += a) == Ga && (f[0] = 1, ++t.e); break } else { if (f[d] += a, f[d] != Ga) break; f[d--] = 0, a = 1 } for (r = f.length; f[--r] === 0;)f.pop(); if (ki && (t.e > MN || t.e < -MN)) throw Error(cz + ya(t)); return t } function Jde(t, e) { var n, r, i, a, s, o, c, u, d, f, h = t.constructor, m = h.precision; if (!t.s || !e.s) return e.s ? e.s = -e.s : e = new h(t), ki ? ci(e, m) : e; if (c = t.d, f = e.d, r = e.e, u = t.e, c = c.slice(), s = u - r, s) { for (d = s < 0, d ? (n = c, s = -s, o = f.length) : (n = f, r = u, o = c.length), i = Math.max(Math.ceil(m / Mi), o) + 2, s > i && (s = i, n.length = 1), n.reverse(), i = s; i--;)n.push(0); n.reverse() } else { for (i = c.length, o = f.length, d = i < o, d && (o = i), i = 0; i < o; i++)if (c[i] != f[i]) { d = c[i] < f[i]; break } s = 0 } for (d && (n = c, c = f, f = n, e.s = -e.s), o = c.length, i = f.length - o; i > 0; --i)c[o++] = 0; for (i = f.length; i > s;) { if (c[--i] < f[i]) { for (a = i; a && c[--a] === 0;)c[a] = Ga - 1; --c[a], c[i] += Ga } c[i] -= f[i] } for (; c[--o] === 0;)c.pop(); for (; c[0] === 0; c.shift())--r; return c[0] ? (e.d = c, e.e = r, ki ? ci(e, m) : e) : new h(0) } function kg(t, e, n) { var r, i = ya(t), a = _u(t.d), s = a.length; return e ? (n && (r = n - s) > 0 ? a = a.charAt(0) + "." + a.slice(1) + Ah(r) : s > 1 && (a = a.charAt(0) + "." + a.slice(1)), a = a + (i < 0 ? "e" : "e+") + i) : i < 0 ? (a = "0." + Ah(-i - 1) + a, n && (r = n - s) > 0 && (a += Ah(r))) : i >= s ? (a += Ah(i + 1 - s), n && (r = n - i - 1) > 0 && (a = a + "." + Ah(r))) : ((r = i + 1) < s && (a = a.slice(0, r) + "." + a.slice(r)), n && (r = n - s) > 0 && (i + 1 === s && (a += "."), a += Ah(r))), t.s < 0 ? "-" + a : a } function $Y(t, e) { if (t.length > e) return t.length = e, !0 } function efe(t) { var e, n, r; function i(a) { var s = this; if (!(s instanceof i)) return new i(a); if (s.constructor = i, a instanceof i) { s.s = a.s, s.e = a.e, s.d = (a = a.d) ? a.slice() : a; return } if (typeof a == "number") { if (a * 0 !== 0) throw Error(gg + a); if (a > 0) s.s = 1; else if (a < 0) a = -a, s.s = -1; else { s.s = 0, s.e = 0, s.d = [0]; return } if (a === ~~a && a < 1e7) { s.e = 0, s.d = [a]; return } return BY(s, a.toString()) } else if (typeof a != "string") throw Error(gg + a); if (a.charCodeAt(0) === 45 ? (a = a.slice(1), s.s = -1) : s.s = 1, M7e.test(a)) BY(s, a); else throw Error(gg + a) } if (i.prototype = cn, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = efe, i.config = i.set = T7e, t === void 0 && (t = {}), t) for (r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], e = 0; e < r.length;)t.hasOwnProperty(n = r[e++]) || (t[n] = this[n]); return i.config(t), i } function T7e(t) { if (!t || typeof t != "object") throw Error(Gl + "Object expected"); var e, n, r, i = ["precision", 1, B0, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0]; for (e = 0; e < i.length; e += 3)if ((r = t[n = i[e]]) !== void 0) if ($0(r) === r && r >= i[e + 1] && r <= i[e + 2]) this[n] = r; else throw Error(gg + n + ": " + r); if ((r = t[n = "LN10"]) !== void 0) if (r == Math.LN10) this[n] = new this(r); else throw Error(gg + n + ": " + r); return this } var uz = efe(E7e); ll = new uz(1); const Jr = uz; function C7e(t) { return j7e(t) || P7e(t) || A7e(t) || N7e() } function N7e() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function A7e(t, e) { if (t) { if (typeof t == "string") return W4(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return W4(t, e) } } function P7e(t) { if (typeof Symbol < "u" && Symbol.iterator in Object(t)) return Array.from(t) } function j7e(t) { if (Array.isArray(t)) return W4(t) } function W4(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var R7e = function (e) { return e }, tfe = {}, nfe = function (e) { return e === tfe }, zY = function (e) { return function n() { return arguments.length === 0 || arguments.length === 1 && nfe(arguments.length <= 0 ? void 0 : arguments[0]) ? n : e.apply(void 0, arguments) } }, k7e = function t(e, n) { return e === 1 ? n : zY(function () { for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; var s = i.filter(function (o) { return o !== tfe }).length; return s >= e ? n.apply(void 0, i) : t(e - s, zY(function () { for (var o = arguments.length, c = new Array(o), u = 0; u < o; u++)c[u] = arguments[u]; var d = i.map(function (f) { return nfe(f) ? c.shift() : f }); return n.apply(void 0, C7e(d).concat(c)) })) }) }, J2 = function (e) { return k7e(e.length, e) }, G4 = function (e, n) { for (var r = [], i = e; i < n; ++i)r[i - e] = i; return r }, I7e = J2(function (t, e) { return Array.isArray(e) ? e.map(t) : Object.keys(e).map(function (n) { return e[n] }).map(t) }), O7e = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; if (!n.length) return R7e; var i = n.reverse(), a = i[0], s = i.slice(1); return function () { return s.reduce(function (o, c) { return c(o) }, a.apply(void 0, arguments)) } }, q4 = function (e) { return Array.isArray(e) ? e.reverse() : e.split("").reverse.join("") }, rfe = function (e) { var n = null, r = null; return function () { for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)a[s] = arguments[s]; return n && a.every(function (o, c) { return o === n[c] }) || (n = a, r = e.apply(void 0, a)), r } }; function D7e(t) { var e; return t === 0 ? e = 1 : e = Math.floor(new Jr(t).abs().log(10).toNumber()) + 1, e } function L7e(t, e, n) { for (var r = new Jr(t), i = 0, a = []; r.lt(e) && i < 1e5;)a.push(r.toNumber()), r = r.add(n), i++; return a } var F7e = J2(function (t, e, n) { var r = +t, i = +e; return r + n * (i - r) }), U7e = J2(function (t, e, n) { var r = e - +t; return r = r || 1 / 0, (n - t) / r }), B7e = J2(function (t, e, n) { var r = e - +t; return r = r || 1 / 0, Math.max(0, Math.min(1, (n - t) / r)) }); const eP = { rangeStep: L7e, getDigitCount: D7e, interpolateNumber: F7e, uninterpolateNumber: U7e, uninterpolateTruncation: B7e }; function X4(t) { return V7e(t) || z7e(t) || ife(t) || $7e() } function $7e() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function z7e(t) { if (typeof Symbol < "u" && Symbol.iterator in Object(t)) return Array.from(t) } function V7e(t) { if (Array.isArray(t)) return Y4(t) } function oS(t, e) { return G7e(t) || W7e(t, e) || ife(t, e) || H7e() } function H7e() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function ife(t, e) { if (t) { if (typeof t == "string") return Y4(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Y4(t, e) } } function Y4(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function W7e(t, e) { if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(t)))) { var n = [], r = !0, i = !1, a = void 0; try { for (var s = t[Symbol.iterator](), o; !(r = (o = s.next()).done) && (n.push(o.value), !(e && n.length === e)); r = !0); } catch (c) { i = !0, a = c } finally { try { !r && s.return != null && s.return() } finally { if (i) throw a } } return n } } function G7e(t) { if (Array.isArray(t)) return t } function afe(t) { var e = oS(t, 2), n = e[0], r = e[1], i = n, a = r; return n > r && (i = r, a = n), [i, a] } function sfe(t, e, n) { if (t.lte(0)) return new Jr(0); var r = eP.getDigitCount(t.toNumber()), i = new Jr(10).pow(r), a = t.div(i), s = r !== 1 ? .05 : .1, o = new Jr(Math.ceil(a.div(s).toNumber())).add(n).mul(s), c = o.mul(i); return e ? c : new Jr(Math.ceil(c)) } function q7e(t, e, n) { var r = 1, i = new Jr(t); if (!i.isint() && n) { var a = Math.abs(t); a < 1 ? (r = new Jr(10).pow(eP.getDigitCount(t) - 1), i = new Jr(Math.floor(i.div(r).toNumber())).mul(r)) : a > 1 && (i = new Jr(Math.floor(t))) } else t === 0 ? i = new Jr(Math.floor((e - 1) / 2)) : n || (i = new Jr(Math.floor(t))); var s = Math.floor((e - 1) / 2), o = O7e(I7e(function (c) { return i.add(new Jr(c - s).mul(r)).toNumber() }), G4); return o(0, e) } function ofe(t, e, n, r) { var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0; if (!Number.isFinite((e - t) / (n - 1))) return { step: new Jr(0), tickMin: new Jr(0), tickMax: new Jr(0) }; var a = sfe(new Jr(e).sub(t).div(n - 1), r, i), s; t <= 0 && e >= 0 ? s = new Jr(0) : (s = new Jr(t).add(e).div(2), s = s.sub(new Jr(s).mod(a))); var o = Math.ceil(s.sub(t).div(a).toNumber()), c = Math.ceil(new Jr(e).sub(s).div(a).toNumber()), u = o + c + 1; return u > n ? ofe(t, e, n, r, i + 1) : (u < n && (c = e > 0 ? c + (n - u) : c, o = e > 0 ? o : o + (n - u)), { step: a, tickMin: s.sub(new Jr(o).mul(a)), tickMax: s.add(new Jr(c).mul(a)) }) } function X7e(t) { var e = oS(t, 2), n = e[0], r = e[1], i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = Math.max(i, 2), o = afe([n, r]), c = oS(o, 2), u = c[0], d = c[1]; if (u === -1 / 0 || d === 1 / 0) { var f = d === 1 / 0 ? [u].concat(X4(G4(0, i - 1).map(function () { return 1 / 0 }))) : [].concat(X4(G4(0, i - 1).map(function () { return -1 / 0 })), [d]); return n > r ? q4(f) : f } if (u === d) return q7e(u, i, a); var h = ofe(u, d, s, a), m = h.step, g = h.tickMin, x = h.tickMax, v = eP.rangeStep(g, x.add(new Jr(.1).mul(m)), m); return n > r ? q4(v) : v } function Y7e(t, e) { var n = oS(t, 2), r = n[0], i = n[1], a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = afe([r, i]), o = oS(s, 2), c = o[0], u = o[1]; if (c === -1 / 0 || u === 1 / 0) return [r, i]; if (c === u) return [c]; var d = Math.max(e, 2), f = sfe(new Jr(u).sub(c).div(d - 1), a, 0), h = [].concat(X4(eP.rangeStep(new Jr(c), new Jr(u).sub(new Jr(.99).mul(f)), f)), [u]); return r > i ? q4(h) : h } var K7e = rfe(X7e), Z7e = rfe(Y7e), Q7e = "Invariant failed"; function Ig(t, e) { throw new Error(Q7e) } var J7e = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"]; function zx(t) { "@babel/helpers - typeof"; return zx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, zx(t) } function TN() { return TN = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, TN.apply(this, arguments) } function e9e(t, e) { return i9e(t) || r9e(t, e) || n9e(t, e) || t9e() } function t9e() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function n9e(t, e) { if (t) { if (typeof t == "string") return VY(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return VY(t, e) } } function VY(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function r9e(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function i9e(t) { if (Array.isArray(t)) return t } function a9e(t, e) { if (t == null) return {}; var n = s9e(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function s9e(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function o9e(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function l9e(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, ufe(r.key), r) } } function c9e(t, e, n) { return e && l9e(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function u9e(t, e, n) { return e = CN(e), d9e(t, lfe() ? Reflect.construct(e, n || [], CN(t).constructor) : e.apply(t, n)) } function d9e(t, e) { if (e && (zx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return f9e(t) } function f9e(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function lfe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (lfe = function () { return !!t })() } function CN(t) { return CN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, CN(t) } function h9e(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && K4(t, e) } function K4(t, e) { return K4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, K4(t, e) } function cfe(t, e, n) { return e = ufe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ufe(t) { var e = p9e(t, "string"); return zx(e) == "symbol" ? e : e + "" } function p9e(t, e) { if (zx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (zx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var z0 = (function (t) { function e() { return o9e(this, e), u9e(this, e, arguments) } return h9e(e, t), c9e(e, [{ key: "render", value: function () { var r = this.props, i = r.offset, a = r.layout, s = r.width, o = r.dataKey, c = r.data, u = r.dataPointFormatter, d = r.xAxis, f = r.yAxis, h = a9e(r, J7e), m = vn(h, !1); this.props.direction === "x" && d.type !== "number" && Ig(); var g = c.map(function (x) { var v = u(x, o), b = v.x, E = v.y, M = v.value, C = v.errorVal; if (!C) return null; var N = [], A, j; if (Array.isArray(C)) { var O = e9e(C, 2); A = O[0], j = O[1] } else A = j = C; if (a === "vertical") { var I = d.scale, D = E + i, F = D + s, B = D - s, G = I(M - A), z = I(M + j); N.push({ x1: z, y1: F, x2: z, y2: B }), N.push({ x1: G, y1: D, x2: z, y2: D }), N.push({ x1: G, y1: F, x2: G, y2: B }) } else if (a === "horizontal") { var q = f.scale, Y = b + i, Z = Y - s, $ = Y + s, V = q(M - A), K = q(M + j); N.push({ x1: Z, y1: K, x2: $, y2: K }), N.push({ x1: Y, y1: V, x2: Y, y2: K }), N.push({ x1: Z, y1: V, x2: $, y2: V }) } return P.createElement(ar, TN({ className: "recharts-errorBar", key: "bar-".concat(N.map(function (X) { return "".concat(X.x1, "-").concat(X.x2, "-").concat(X.y1, "-").concat(X.y2) })) }, m), N.map(function (X) { return P.createElement("line", TN({}, X, { key: "line-".concat(X.x1, "-").concat(X.x2, "-").concat(X.y1, "-").concat(X.y2) })) })) }); return P.createElement(ar, { className: "recharts-errorBars" }, g) } }]) })(P.Component); cfe(z0, "defaultProps", { stroke: "black", strokeWidth: 1.5, width: 5, offset: 0, layout: "horizontal" }); cfe(z0, "displayName", "ErrorBar"); function lS(t) { "@babel/helpers - typeof"; return lS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, lS(t) } function HY(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Rm(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? HY(Object(n), !0).forEach(function (r) { m9e(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : HY(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function m9e(t, e, n) { return e = g9e(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function g9e(t) { var e = v9e(t, "string"); return lS(e) == "symbol" ? e : e + "" } function v9e(t, e) { if (lS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (lS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var dfe = function (e) { var n = e.children, r = e.formattedGraphicalItems, i = e.legendWidth, a = e.legendContent, s = al(n, Ru); if (!s) return null; var o = Ru.defaultProps, c = o !== void 0 ? Rm(Rm({}, o), s.props) : {}, u; return s.props && s.props.payload ? u = s.props && s.props.payload : a === "children" ? u = (r || []).reduce(function (d, f) { var h = f.item, m = f.props, g = m.sectors || m.data || []; return d.concat(g.map(function (x) { return { type: s.props.iconType || h.props.legendType, value: x.name, color: x.fill, payload: x } })) }, []) : u = (r || []).map(function (d) { var f = d.item, h = f.type.defaultProps, m = h !== void 0 ? Rm(Rm({}, h), f.props) : {}, g = m.dataKey, x = m.name, v = m.legendType, b = m.hide; return { inactive: b, dataKey: g, type: c.iconType || v || "square", color: dz(f), value: x || g, payload: m } }), Rm(Rm(Rm({}, c), Ru.getWithHeight(s, i)), {}, { payload: u, item: s }) }; function cS(t) { "@babel/helpers - typeof"; return cS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, cS(t) } function WY(t) { return w9e(t) || b9e(t) || x9e(t) || y9e() } function y9e() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function x9e(t, e) { if (t) { if (typeof t == "string") return Z4(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Z4(t, e) } } function b9e(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function w9e(t) { if (Array.isArray(t)) return Z4(t) } function Z4(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function GY(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Xi(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? GY(Object(n), !0).forEach(function (r) { rx(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : GY(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function rx(t, e, n) { return e = S9e(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function S9e(t) { var e = _9e(t, "string"); return cS(e) == "symbol" ? e : e + "" } function _9e(t, e) { if (cS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (cS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function Ci(t, e, n) { return An(t) || An(e) ? n : ka(e) ? pl(t, e, n) : Rn(e) ? e(t) : n } function i1(t, e, n, r) { var i = w7e(t, function (o) { return Ci(o, e) }); if (n === "number") { var a = i.filter(function (o) { return It(o) || parseFloat(o) }); return a.length ? [Q2(a), Lh(a)] : [1 / 0, -1 / 0] } var s = r ? i.filter(function (o) { return !An(o) }) : i; return s.map(function (o) { return ka(o) || o instanceof Date ? o : "" }) } var E9e = function (e) { var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 ? arguments[2] : void 0, a = arguments.length > 3 ? arguments[3] : void 0, s = -1, o = (n = r?.length) !== null && n !== void 0 ? n : 0; if (o <= 1) return 0; if (a && a.axisType === "angleAxis" && Math.abs(Math.abs(a.range[1] - a.range[0]) - 360) <= 1e-6) for (var c = a.range, u = 0; u < o; u++) { var d = u > 0 ? i[u - 1].coordinate : i[o - 1].coordinate, f = i[u].coordinate, h = u >= o - 1 ? i[0].coordinate : i[u + 1].coordinate, m = void 0; if (Js(f - d) !== Js(h - f)) { var g = []; if (Js(h - f) === Js(c[1] - c[0])) { m = h; var x = f + c[1] - c[0]; g[0] = Math.min(x, (x + d) / 2), g[1] = Math.max(x, (x + d) / 2) } else { m = d; var v = h + c[1] - c[0]; g[0] = Math.min(f, (v + f) / 2), g[1] = Math.max(f, (v + f) / 2) } var b = [Math.min(f, (m + f) / 2), Math.max(f, (m + f) / 2)]; if (e > b[0] && e <= b[1] || e >= g[0] && e <= g[1]) { s = i[u].index; break } } else { var E = Math.min(d, h), M = Math.max(d, h); if (e > (E + f) / 2 && e <= (M + f) / 2) { s = i[u].index; break } } } else for (var C = 0; C < o; C++)if (C === 0 && e <= (r[C].coordinate + r[C + 1].coordinate) / 2 || C > 0 && C < o - 1 && e > (r[C].coordinate + r[C - 1].coordinate) / 2 && e <= (r[C].coordinate + r[C + 1].coordinate) / 2 || C === o - 1 && e > (r[C].coordinate + r[C - 1].coordinate) / 2) { s = r[C].index; break } return s }, dz = function (e) { var n, r = e, i = r.type.displayName, a = (n = e.type) !== null && n !== void 0 && n.defaultProps ? Xi(Xi({}, e.type.defaultProps), e.props) : e.props, s = a.stroke, o = a.fill, c; switch (i) { case "Line": c = s; break; case "Area": case "Radar": c = s && s !== "none" ? s : o; break; default: c = o; break }return c }, M9e = function (e) { var n = e.barSize, r = e.totalSize, i = e.stackGroups, a = i === void 0 ? {} : i; if (!a) return {}; for (var s = {}, o = Object.keys(a), c = 0, u = o.length; c < u; c++)for (var d = a[o[c]].stackGroups, f = Object.keys(d), h = 0, m = f.length; h < m; h++) { var g = d[f[h]], x = g.items, v = g.cateAxisId, b = x.filter(function (j) { return lf(j.type).indexOf("Bar") >= 0 }); if (b && b.length) { var E = b[0].type.defaultProps, M = E !== void 0 ? Xi(Xi({}, E), b[0].props) : b[0].props, C = M.barSize, N = M[v]; s[N] || (s[N] = []); var A = An(C) ? n : C; s[N].push({ item: b[0], stackList: b.slice(1), barSize: An(A) ? void 0 : eo(A, r, 0) }) } } return s }, T9e = function (e) { var n = e.barGap, r = e.barCategoryGap, i = e.bandSize, a = e.sizeList, s = a === void 0 ? [] : a, o = e.maxBarSize, c = s.length; if (c < 1) return null; var u = eo(n, i, 0, !0), d, f = []; if (s[0].barSize === +s[0].barSize) { var h = !1, m = i / c, g = s.reduce(function (C, N) { return C + N.barSize || 0 }, 0); g += (c - 1) * u, g >= i && (g -= (c - 1) * u, u = 0), g >= i && m > 0 && (h = !0, m *= .9, g = c * m); var x = (i - g) / 2 >> 0, v = { offset: x - u, size: 0 }; d = s.reduce(function (C, N) { var A = { item: N.item, position: { offset: v.offset + v.size + u, size: h ? m : N.barSize } }, j = [].concat(WY(C), [A]); return v = j[j.length - 1].position, N.stackList && N.stackList.length && N.stackList.forEach(function (O) { j.push({ item: O, position: v }) }), j }, f) } else { var b = eo(r, i, 0, !0); i - 2 * b - (c - 1) * u <= 0 && (u = 0); var E = (i - 2 * b - (c - 1) * u) / c; E > 1 && (E >>= 0); var M = o === +o ? Math.min(E, o) : E; d = s.reduce(function (C, N, A) { var j = [].concat(WY(C), [{ item: N.item, position: { offset: b + (E + u) * A + (E - M) / 2, size: M } }]); return N.stackList && N.stackList.length && N.stackList.forEach(function (O) { j.push({ item: O, position: j[j.length - 1].position }) }), j }, f) } return d }, C9e = function (e, n, r, i) { var a = r.children, s = r.width, o = r.margin, c = s - (o.left || 0) - (o.right || 0), u = dfe({ children: a, legendWidth: c }); if (u) { var d = i || {}, f = d.width, h = d.height, m = u.align, g = u.verticalAlign, x = u.layout; if ((x === "vertical" || x === "horizontal" && g === "middle") && m !== "center" && It(e[m])) return Xi(Xi({}, e), {}, rx({}, m, e[m] + (f || 0))); if ((x === "horizontal" || x === "vertical" && m === "center") && g !== "middle" && It(e[g])) return Xi(Xi({}, e), {}, rx({}, g, e[g] + (h || 0))) } return e }, N9e = function (e, n, r) { return An(n) ? !0 : e === "horizontal" ? n === "yAxis" : e === "vertical" || r === "x" ? n === "xAxis" : r === "y" ? n === "yAxis" : !0 }, ffe = function (e, n, r, i, a) { var s = n.props.children, o = so(s, z0).filter(function (u) { return N9e(i, a, u.props.direction) }); if (o && o.length) { var c = o.map(function (u) { return u.props.dataKey }); return e.reduce(function (u, d) { var f = Ci(d, r); if (An(f)) return u; var h = Array.isArray(f) ? [Q2(f), Lh(f)] : [f, f], m = c.reduce(function (g, x) { var v = Ci(d, x, 0), b = h[0] - Math.abs(Array.isArray(v) ? v[0] : v), E = h[1] + Math.abs(Array.isArray(v) ? v[1] : v); return [Math.min(b, g[0]), Math.max(E, g[1])] }, [1 / 0, -1 / 0]); return [Math.min(m[0], u[0]), Math.max(m[1], u[1])] }, [1 / 0, -1 / 0]) } return null }, A9e = function (e, n, r, i, a) { var s = n.map(function (o) { return ffe(e, o, r, a, i) }).filter(function (o) { return !An(o) }); return s && s.length ? s.reduce(function (o, c) { return [Math.min(o[0], c[0]), Math.max(o[1], c[1])] }, [1 / 0, -1 / 0]) : null }, hfe = function (e, n, r, i, a) { var s = n.map(function (c) { var u = c.props.dataKey; return r === "number" && u && ffe(e, c, u, i) || i1(e, u, r, a) }); if (r === "number") return s.reduce(function (c, u) { return [Math.min(c[0], u[0]), Math.max(c[1], u[1])] }, [1 / 0, -1 / 0]); var o = {}; return s.reduce(function (c, u) { for (var d = 0, f = u.length; d < f; d++)o[u[d]] || (o[u[d]] = !0, c.push(u[d])); return c }, []) }, pfe = function (e, n) { return e === "horizontal" && n === "xAxis" || e === "vertical" && n === "yAxis" || e === "centric" && n === "angleAxis" || e === "radial" && n === "radiusAxis" }, mfe = function (e, n, r, i) { if (i) return e.map(function (c) { return c.coordinate }); var a, s, o = e.map(function (c) { return c.coordinate === n && (a = !0), c.coordinate === r && (s = !0), c.coordinate }); return a || o.push(n), s || o.push(r), o }, af = function (e, n, r) { if (!e) return null; var i = e.scale, a = e.duplicateDomain, s = e.type, o = e.range, c = e.realScaleType === "scaleBand" ? i.bandwidth() / 2 : 2, u = (n || r) && s === "category" && i.bandwidth ? i.bandwidth() / c : 0; if (u = e.axisType === "angleAxis" && o?.length >= 2 ? Js(o[0] - o[1]) * 2 * u : u, n && (e.ticks || e.niceTicks)) { var d = (e.ticks || e.niceTicks).map(function (f) { var h = a ? a.indexOf(f) : f; return { coordinate: i(h) + u, value: f, offset: u } }); return d.filter(function (f) { return !L0(f.coordinate) }) } return e.isCategorical && e.categoricalDomain ? e.categoricalDomain.map(function (f, h) { return { coordinate: i(f) + u, value: f, index: h, offset: u } }) : i.ticks && !r ? i.ticks(e.tickCount).map(function (f) { return { coordinate: i(f) + u, value: f, offset: u } }) : i.domain().map(function (f, h) { return { coordinate: i(f) + u, value: a ? a[f] : f, index: h, offset: u } }) }, GD = new WeakMap, iT = function (e, n) { if (typeof n != "function") return e; GD.has(e) || GD.set(e, new WeakMap); var r = GD.get(e); if (r.has(n)) return r.get(n); var i = function () { e.apply(void 0, arguments), n.apply(void 0, arguments) }; return r.set(n, i), i }, gfe = function (e, n, r) { var i = e.scale, a = e.type, s = e.layout, o = e.axisType; if (i === "auto") return s === "radial" && o === "radiusAxis" ? { scale: tS(), realScaleType: "band" } : s === "radial" && o === "angleAxis" ? { scale: wN(), realScaleType: "linear" } : a === "category" && n && (n.indexOf("LineChart") >= 0 || n.indexOf("AreaChart") >= 0 || n.indexOf("ComposedChart") >= 0 && !r) ? { scale: r1(), realScaleType: "point" } : a === "category" ? { scale: tS(), realScaleType: "band" } : { scale: wN(), realScaleType: "linear" }; if (jg(i)) { var c = "scale".concat(D2(i)); return { scale: (jY[c] || r1)(), realScaleType: jY[c] ? c : "point" } } return Rn(i) ? { scale: i } : { scale: r1(), realScaleType: "point" } }, qY = 1e-4, vfe = function (e) { var n = e.domain(); if (!(!n || n.length <= 2)) { var r = n.length, i = e.range(), a = Math.min(i[0], i[1]) - qY, s = Math.max(i[0], i[1]) + qY, o = e(n[0]), c = e(n[r - 1]); (o < a || o > s || c < a || c > s) && e.domain([n[0], n[r - 1]]) } }, P9e = function (e, n) { if (!e) return null; for (var r = 0, i = e.length; r < i; r++)if (e[r].item === n) return e[r].position; return null }, j9e = function (e, n) { if (!n || n.length !== 2 || !It(n[0]) || !It(n[1])) return e; var r = Math.min(n[0], n[1]), i = Math.max(n[0], n[1]), a = [e[0], e[1]]; return (!It(e[0]) || e[0] < r) && (a[0] = r), (!It(e[1]) || e[1] > i) && (a[1] = i), a[0] > i && (a[0] = i), a[1] < r && (a[1] = r), a }, R9e = function (e) { var n = e.length; if (!(n <= 0)) for (var r = 0, i = e[0].length; r < i; ++r)for (var a = 0, s = 0, o = 0; o < n; ++o) { var c = L0(e[o][r][1]) ? e[o][r][0] : e[o][r][1]; c >= 0 ? (e[o][r][0] = a, e[o][r][1] = a + c, a = e[o][r][1]) : (e[o][r][0] = s, e[o][r][1] = s + c, s = e[o][r][1]) } }, k9e = function (e) { var n = e.length; if (!(n <= 0)) for (var r = 0, i = e[0].length; r < i; ++r)for (var a = 0, s = 0; s < n; ++s) { var o = L0(e[s][r][1]) ? e[s][r][0] : e[s][r][1]; o >= 0 ? (e[s][r][0] = a, e[s][r][1] = a + o, a = e[s][r][1]) : (e[s][r][0] = 0, e[s][r][1] = 0) } }, I9e = { sign: R9e, expand: wze, none: Ix, silhouette: Sze, wiggle: _ze, positive: k9e }, O9e = function (e, n, r) { var i = n.map(function (o) { return o.props.dataKey }), a = I9e[r], s = bze().keys(i).value(function (o, c) { return +Ci(o, c, 0) }).order(C4).offset(a); return s(e) }, D9e = function (e, n, r, i, a, s) { if (!e) return null; var o = s ? n.reverse() : n, c = {}, u = o.reduce(function (f, h) { var m, g = (m = h.type) !== null && m !== void 0 && m.defaultProps ? Xi(Xi({}, h.type.defaultProps), h.props) : h.props, x = g.stackId, v = g.hide; if (v) return f; var b = g[r], E = f[b] || { hasStack: !1, stackGroups: {} }; if (ka(x)) { var M = E.stackGroups[x] || { numericAxisId: r, cateAxisId: i, items: [] }; M.items.push(h), E.hasStack = !0, E.stackGroups[x] = M } else E.stackGroups[Ep("_stackId_")] = { numericAxisId: r, cateAxisId: i, items: [h] }; return Xi(Xi({}, f), {}, rx({}, b, E)) }, c), d = {}; return Object.keys(u).reduce(function (f, h) { var m = u[h]; if (m.hasStack) { var g = {}; m.stackGroups = Object.keys(m.stackGroups).reduce(function (x, v) { var b = m.stackGroups[v]; return Xi(Xi({}, x), {}, rx({}, v, { numericAxisId: r, cateAxisId: i, items: b.items, stackedData: O9e(e, b.items, a) })) }, g) } return Xi(Xi({}, f), {}, rx({}, h, m)) }, d) }, yfe = function (e, n) { var r = n.realScaleType, i = n.type, a = n.tickCount, s = n.originalDomain, o = n.allowDecimals, c = r || n.scale; if (c !== "auto" && c !== "linear") return null; if (a && i === "number" && s && (s[0] === "auto" || s[1] === "auto")) { var u = e.domain(); if (!u.length) return null; var d = K7e(u, a, o); return e.domain([Q2(d), Lh(d)]), { niceTicks: d } } if (a && i === "number") { var f = e.domain(), h = Z7e(f, a, o); return { niceTicks: h } } return null }; function Vx(t) { var e = t.axis, n = t.ticks, r = t.bandSize, i = t.entry, a = t.index, s = t.dataKey; if (e.type === "category") { if (!e.allowDuplicatedCategory && e.dataKey && !An(i[e.dataKey])) { var o = rN(n, "value", i[e.dataKey]); if (o) return o.coordinate + r / 2 } return n[a] ? n[a].coordinate + r / 2 : null } var c = Ci(i, An(s) ? e.dataKey : s); return An(c) ? null : e.scale(c) } var XY = function (e) { var n = e.axis, r = e.ticks, i = e.offset, a = e.bandSize, s = e.entry, o = e.index; if (n.type === "category") return r[o] ? r[o].coordinate + i : null; var c = Ci(s, n.dataKey, n.domain[o]); return An(c) ? null : n.scale(c) - a / 2 + i }, L9e = function (e) { var n = e.numericAxis, r = n.scale.domain(); if (n.type === "number") { var i = Math.min(r[0], r[1]), a = Math.max(r[0], r[1]); return i <= 0 && a >= 0 ? 0 : a < 0 ? a : i } return r[0] }, F9e = function (e, n) { var r, i = (r = e.type) !== null && r !== void 0 && r.defaultProps ? Xi(Xi({}, e.type.defaultProps), e.props) : e.props, a = i.stackId; if (ka(a)) { var s = n[a]; if (s) { var o = s.items.indexOf(e); return o >= 0 ? s.stackedData[o] : null } } return null }, U9e = function (e) { return e.reduce(function (n, r) { return [Q2(r.concat([n[0]]).filter(It)), Lh(r.concat([n[1]]).filter(It))] }, [1 / 0, -1 / 0]) }, xfe = function (e, n, r) { return Object.keys(e).reduce(function (i, a) { var s = e[a], o = s.stackedData, c = o.reduce(function (u, d) { var f = U9e(d.slice(n, r + 1)); return [Math.min(u[0], f[0]), Math.max(u[1], f[1])] }, [1 / 0, -1 / 0]); return [Math.min(c[0], i[0]), Math.max(c[1], i[1])] }, [1 / 0, -1 / 0]).map(function (i) { return i === 1 / 0 || i === -1 / 0 ? 0 : i }) }, YY = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, KY = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, Q4 = function (e, n, r) { if (Rn(e)) return e(n, r); if (!Array.isArray(e)) return n; var i = []; if (It(e[0])) i[0] = r ? e[0] : Math.min(e[0], n[0]); else if (YY.test(e[0])) { var a = +YY.exec(e[0])[1]; i[0] = n[0] - a } else Rn(e[0]) ? i[0] = e[0](n[0]) : i[0] = n[0]; if (It(e[1])) i[1] = r ? e[1] : Math.max(e[1], n[1]); else if (KY.test(e[1])) { var s = +KY.exec(e[1])[1]; i[1] = n[1] + s } else Rn(e[1]) ? i[1] = e[1](n[1]) : i[1] = n[1]; return i }, NN = function (e, n, r) { if (e && e.scale && e.scale.bandwidth) { var i = e.scale.bandwidth(); if (!r || i > 0) return i } if (e && n && n.length >= 2) { for (var a = U$(n, function (f) { return f.coordinate }), s = 1 / 0, o = 1, c = a.length; o < c; o++) { var u = a[o], d = a[o - 1]; s = Math.min((u.coordinate || 0) - (d.coordinate || 0), s) } return s === 1 / 0 ? 0 : s } return r ? void 0 : 0 }, ZY = function (e, n, r) { return !e || !e.length || sp(e, pl(r, "type.defaultProps.domain")) ? n : e }, bfe = function (e, n) { var r = e.type.defaultProps ? Xi(Xi({}, e.type.defaultProps), e.props) : e.props, i = r.dataKey, a = r.name, s = r.unit, o = r.formatter, c = r.tooltipType, u = r.chartType, d = r.hide; return Xi(Xi({}, vn(e, !1)), {}, { dataKey: i, unit: s, formatter: o, name: a || i, color: dz(e), value: Ci(n, i), type: c, payload: n, chartType: u, hide: d }) }; function uS(t) { "@babel/helpers - typeof"; return uS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, uS(t) } function QY(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Xd(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? QY(Object(n), !0).forEach(function (r) { wfe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : QY(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function wfe(t, e, n) { return e = B9e(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function B9e(t) { var e = $9e(t, "string"); return uS(e) == "symbol" ? e : e + "" } function $9e(t, e) { if (uS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (uS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function z9e(t, e) { return G9e(t) || W9e(t, e) || H9e(t, e) || V9e() } function V9e() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function H9e(t, e) { if (t) { if (typeof t == "string") return JY(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return JY(t, e) } } function JY(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function W9e(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function G9e(t) { if (Array.isArray(t)) return t } var AN = Math.PI / 180, q9e = function (e) { return e * 180 / Math.PI }, bi = function (e, n, r, i) { return { x: e + Math.cos(-AN * i) * r, y: n + Math.sin(-AN * i) * r } }, Sfe = function (e, n) { var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { top: 0, right: 0, bottom: 0, left: 0 }; return Math.min(Math.abs(e - (r.left || 0) - (r.right || 0)), Math.abs(n - (r.top || 0) - (r.bottom || 0))) / 2 }, X9e = function (e, n, r, i, a) { var s = e.width, o = e.height, c = e.startAngle, u = e.endAngle, d = eo(e.cx, s, s / 2), f = eo(e.cy, o, o / 2), h = Sfe(s, o, r), m = eo(e.innerRadius, h, 0), g = eo(e.outerRadius, h, h * .8), x = Object.keys(n); return x.reduce(function (v, b) { var E = n[b], M = E.domain, C = E.reversed, N; if (An(E.range)) i === "angleAxis" ? N = [c, u] : i === "radiusAxis" && (N = [m, g]), C && (N = [N[1], N[0]]); else { N = E.range; var A = N, j = z9e(A, 2); c = j[0], u = j[1] } var O = gfe(E, a), I = O.realScaleType, D = O.scale; D.domain(M).range(N), vfe(D); var F = yfe(D, Xd(Xd({}, E), {}, { realScaleType: I })), B = Xd(Xd(Xd({}, E), F), {}, { range: N, radius: g, realScaleType: I, scale: D, cx: d, cy: f, innerRadius: m, outerRadius: g, startAngle: c, endAngle: u }); return Xd(Xd({}, v), {}, wfe({}, b, B)) }, {}) }, Y9e = function (e, n) { var r = e.x, i = e.y, a = n.x, s = n.y; return Math.sqrt(Math.pow(r - a, 2) + Math.pow(i - s, 2)) }, K9e = function (e, n) { var r = e.x, i = e.y, a = n.cx, s = n.cy, o = Y9e({ x: r, y: i }, { x: a, y: s }); if (o <= 0) return { radius: o }; var c = (r - a) / o, u = Math.acos(c); return i > s && (u = 2 * Math.PI - u), { radius: o, angle: q9e(u), angleInRadian: u } }, Z9e = function (e) { var n = e.startAngle, r = e.endAngle, i = Math.floor(n / 360), a = Math.floor(r / 360), s = Math.min(i, a); return { startAngle: n - s * 360, endAngle: r - s * 360 } }, Q9e = function (e, n) { var r = n.startAngle, i = n.endAngle, a = Math.floor(r / 360), s = Math.floor(i / 360), o = Math.min(a, s); return e + o * 360 }, eK = function (e, n) { var r = e.x, i = e.y, a = K9e({ x: r, y: i }, n), s = a.radius, o = a.angle, c = n.innerRadius, u = n.outerRadius; if (s < c || s > u) return !1; if (s === 0) return !0; var d = Z9e(n), f = d.startAngle, h = d.endAngle, m = o, g; if (f <= h) { for (; m > h;)m -= 360; for (; m < f;)m += 360; g = m >= f && m <= h } else { for (; m > f;)m -= 360; for (; m < h;)m += 360; g = m >= h && m <= f } return g ? Xd(Xd({}, n), {}, { radius: s, angle: Q9e(m, n) }) : null }, _fe = function (e) { return !S.isValidElement(e) && !Rn(e) && typeof e != "boolean" ? e.className : "" }; function dS(t) { "@babel/helpers - typeof"; return dS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, dS(t) } var J9e = ["offset"]; function eGe(t) { return iGe(t) || rGe(t) || nGe(t) || tGe() } function tGe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function nGe(t, e) { if (t) { if (typeof t == "string") return J4(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return J4(t, e) } } function rGe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function iGe(t) { if (Array.isArray(t)) return J4(t) } function J4(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function aGe(t, e) { if (t == null) return {}; var n = sGe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function sGe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function tK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ca(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? tK(Object(n), !0).forEach(function (r) { oGe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : tK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function oGe(t, e, n) { return e = lGe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function lGe(t) { var e = cGe(t, "string"); return dS(e) == "symbol" ? e : e + "" } function cGe(t, e) { if (dS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (dS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function fS() { return fS = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, fS.apply(this, arguments) } var uGe = function (e) { var n = e.value, r = e.formatter, i = An(e.children) ? n : e.children; return Rn(r) ? r(i) : i }, dGe = function (e, n) { var r = Js(n - e), i = Math.min(Math.abs(n - e), 360); return r * i }, fGe = function (e, n, r) {
	var i = e.position, a = e.viewBox, s = e.offset, o = e.className, c = a, u = c.cx, d = c.cy, f = c.innerRadius, h = c.outerRadius, m = c.startAngle, g = c.endAngle, x = c.clockWise, v = (f + h) / 2, b = dGe(m, g), E = b >= 0 ? 1 : -1, M, C; i === "insideStart" ? (M = m + E * s, C = x) : i === "insideEnd" ? (M = g - E * s, C = !x) : i === "end" && (M = g + E * s, C = x), C = b <= 0 ? C : !C; var N = bi(u, d, v, M), A = bi(u, d, v, M + (C ? 1 : -1) * 359), j = "M".concat(N.x, ",").concat(N.y, `
    A`).concat(v, ",").concat(v, ",0,1,").concat(C ? 0 : 1, `,
    `).concat(A.x, ",").concat(A.y), O = An(e.id) ? Ep("recharts-radial-line-") : e.id; return P.createElement("text", fS({}, r, { dominantBaseline: "central", className: zn("recharts-radial-bar-label", o) }), P.createElement("defs", null, P.createElement("path", { id: O, d: j })), P.createElement("textPath", { xlinkHref: "#".concat(O) }, n))
}, hGe = function (e) { var n = e.viewBox, r = e.offset, i = e.position, a = n, s = a.cx, o = a.cy, c = a.innerRadius, u = a.outerRadius, d = a.startAngle, f = a.endAngle, h = (d + f) / 2; if (i === "outside") { var m = bi(s, o, u + r, h), g = m.x, x = m.y; return { x: g, y: x, textAnchor: g >= s ? "start" : "end", verticalAnchor: "middle" } } if (i === "center") return { x: s, y: o, textAnchor: "middle", verticalAnchor: "middle" }; if (i === "centerTop") return { x: s, y: o, textAnchor: "middle", verticalAnchor: "start" }; if (i === "centerBottom") return { x: s, y: o, textAnchor: "middle", verticalAnchor: "end" }; var v = (c + u) / 2, b = bi(s, o, v, h), E = b.x, M = b.y; return { x: E, y: M, textAnchor: "middle", verticalAnchor: "middle" } }, pGe = function (e) { var n = e.viewBox, r = e.parentViewBox, i = e.offset, a = e.position, s = n, o = s.x, c = s.y, u = s.width, d = s.height, f = d >= 0 ? 1 : -1, h = f * i, m = f > 0 ? "end" : "start", g = f > 0 ? "start" : "end", x = u >= 0 ? 1 : -1, v = x * i, b = x > 0 ? "end" : "start", E = x > 0 ? "start" : "end"; if (a === "top") { var M = { x: o + u / 2, y: c - f * i, textAnchor: "middle", verticalAnchor: m }; return Ca(Ca({}, M), r ? { height: Math.max(c - r.y, 0), width: u } : {}) } if (a === "bottom") { var C = { x: o + u / 2, y: c + d + h, textAnchor: "middle", verticalAnchor: g }; return Ca(Ca({}, C), r ? { height: Math.max(r.y + r.height - (c + d), 0), width: u } : {}) } if (a === "left") { var N = { x: o - v, y: c + d / 2, textAnchor: b, verticalAnchor: "middle" }; return Ca(Ca({}, N), r ? { width: Math.max(N.x - r.x, 0), height: d } : {}) } if (a === "right") { var A = { x: o + u + v, y: c + d / 2, textAnchor: E, verticalAnchor: "middle" }; return Ca(Ca({}, A), r ? { width: Math.max(r.x + r.width - A.x, 0), height: d } : {}) } var j = r ? { width: u, height: d } : {}; return a === "insideLeft" ? Ca({ x: o + v, y: c + d / 2, textAnchor: E, verticalAnchor: "middle" }, j) : a === "insideRight" ? Ca({ x: o + u - v, y: c + d / 2, textAnchor: b, verticalAnchor: "middle" }, j) : a === "insideTop" ? Ca({ x: o + u / 2, y: c + h, textAnchor: "middle", verticalAnchor: g }, j) : a === "insideBottom" ? Ca({ x: o + u / 2, y: c + d - h, textAnchor: "middle", verticalAnchor: m }, j) : a === "insideTopLeft" ? Ca({ x: o + v, y: c + h, textAnchor: E, verticalAnchor: g }, j) : a === "insideTopRight" ? Ca({ x: o + u - v, y: c + h, textAnchor: b, verticalAnchor: g }, j) : a === "insideBottomLeft" ? Ca({ x: o + v, y: c + d - h, textAnchor: E, verticalAnchor: m }, j) : a === "insideBottomRight" ? Ca({ x: o + u - v, y: c + d - h, textAnchor: b, verticalAnchor: m }, j) : D0(a) && (It(a.x) || tg(a.x)) && (It(a.y) || tg(a.y)) ? Ca({ x: o + eo(a.x, u), y: c + eo(a.y, d), textAnchor: "end", verticalAnchor: "end" }, j) : Ca({ x: o + u / 2, y: c + d / 2, textAnchor: "middle", verticalAnchor: "middle" }, j) }, mGe = function (e) { return "cx" in e && It(e.cx) }; function ei(t) { var e = t.offset, n = e === void 0 ? 5 : e, r = aGe(t, J9e), i = Ca({ offset: n }, r), a = i.viewBox, s = i.position, o = i.value, c = i.children, u = i.content, d = i.className, f = d === void 0 ? "" : d, h = i.textBreakAll; if (!a || An(o) && An(c) && !S.isValidElement(u) && !Rn(u)) return null; if (S.isValidElement(u)) return S.cloneElement(u, i); var m; if (Rn(u)) { if (m = S.createElement(u, i), S.isValidElement(m)) return m } else m = uGe(i); var g = mGe(a), x = vn(i, !0); if (g && (s === "insideStart" || s === "insideEnd" || s === "end")) return fGe(i, m, x); var v = g ? hGe(i) : pGe(i); return P.createElement(Rg, fS({ className: zn("recharts-label", f) }, x, v, { breakAll: h }), m) } ei.displayName = "Label"; var Efe = function (e) { var n = e.cx, r = e.cy, i = e.angle, a = e.startAngle, s = e.endAngle, o = e.r, c = e.radius, u = e.innerRadius, d = e.outerRadius, f = e.x, h = e.y, m = e.top, g = e.left, x = e.width, v = e.height, b = e.clockWise, E = e.labelViewBox; if (E) return E; if (It(x) && It(v)) { if (It(f) && It(h)) return { x: f, y: h, width: x, height: v }; if (It(m) && It(g)) return { x: m, y: g, width: x, height: v } } return It(f) && It(h) ? { x: f, y: h, width: 0, height: 0 } : It(n) && It(r) ? { cx: n, cy: r, startAngle: a || i || 0, endAngle: s || i || 0, innerRadius: u || 0, outerRadius: d || c || o || 0, clockWise: b } : e.viewBox ? e.viewBox : {} }, gGe = function (e, n) { return e ? e === !0 ? P.createElement(ei, { key: "label-implicit", viewBox: n }) : ka(e) ? P.createElement(ei, { key: "label-implicit", viewBox: n, value: e }) : S.isValidElement(e) ? e.type === ei ? S.cloneElement(e, { key: "label-implicit", viewBox: n }) : P.createElement(ei, { key: "label-implicit", content: e, viewBox: n }) : Rn(e) ? P.createElement(ei, { key: "label-implicit", content: e, viewBox: n }) : D0(e) ? P.createElement(ei, fS({ viewBox: n }, e, { key: "label-implicit" })) : null : null }, vGe = function (e, n) { var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; if (!e || !e.children && r && !e.label) return null; var i = e.children, a = Efe(e), s = so(i, ei).map(function (c, u) { return S.cloneElement(c, { viewBox: n || a, key: "label-".concat(u) }) }); if (!r) return s; var o = gGe(e.label, n || a); return [o].concat(eGe(s)) }; ei.parseViewBox = Efe; ei.renderCallByParent = vGe; var qD, nK; function yGe() { if (nK) return qD; nK = 1; function t(e) { var n = e == null ? 0 : e.length; return n ? e[n - 1] : void 0 } return qD = t, qD } var xGe = yGe(); const bGe = Fr(xGe); function hS(t) { "@babel/helpers - typeof"; return hS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, hS(t) } var wGe = ["valueAccessor"], SGe = ["data", "dataKey", "clockWise", "id", "textBreakAll"]; function _Ge(t) { return CGe(t) || TGe(t) || MGe(t) || EGe() } function EGe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function MGe(t, e) { if (t) { if (typeof t == "string") return eF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return eF(t, e) } } function TGe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function CGe(t) { if (Array.isArray(t)) return eF(t) } function eF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function PN() { return PN = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, PN.apply(this, arguments) } function rK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function iK(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? rK(Object(n), !0).forEach(function (r) { NGe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : rK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function NGe(t, e, n) { return e = AGe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function AGe(t) { var e = PGe(t, "string"); return hS(e) == "symbol" ? e : e + "" } function PGe(t, e) { if (hS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (hS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function aK(t, e) { if (t == null) return {}; var n = jGe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function jGe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } var RGe = function (e) { return Array.isArray(e.value) ? bGe(e.value) : e.value }; function $c(t) { var e = t.valueAccessor, n = e === void 0 ? RGe : e, r = aK(t, wGe), i = r.data, a = r.dataKey, s = r.clockWise, o = r.id, c = r.textBreakAll, u = aK(r, SGe); return !i || !i.length ? null : P.createElement(ar, { className: "recharts-label-list" }, i.map(function (d, f) { var h = An(a) ? n(d, f) : Ci(d && d.payload, a), m = An(o) ? {} : { id: "".concat(o, "-").concat(f) }; return P.createElement(ei, PN({}, vn(d, !0), u, m, { parentViewBox: d.parentViewBox, value: h, textBreakAll: c, viewBox: ei.parseViewBox(An(s) ? d : iK(iK({}, d), {}, { clockWise: s })), key: "label-".concat(f), index: f })) })) } $c.displayName = "LabelList"; function kGe(t, e) { return t ? t === !0 ? P.createElement($c, { key: "labelList-implicit", data: e }) : P.isValidElement(t) || Rn(t) ? P.createElement($c, { key: "labelList-implicit", data: e, content: t }) : D0(t) ? P.createElement($c, PN({ data: e }, t, { key: "labelList-implicit" })) : null : null } function IGe(t, e) { var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; if (!t || !t.children && n && !t.label) return null; var r = t.children, i = so(r, $c).map(function (s, o) { return S.cloneElement(s, { data: e, key: "labelList-".concat(o) }) }); if (!n) return i; var a = kGe(t.label, e); return [a].concat(_Ge(i)) } $c.renderCallByParent = IGe; function pS(t) { "@babel/helpers - typeof"; return pS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, pS(t) } function tF() { return tF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, tF.apply(this, arguments) } function sK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function oK(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? sK(Object(n), !0).forEach(function (r) { OGe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function OGe(t, e, n) { return e = DGe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function DGe(t) { var e = LGe(t, "string"); return pS(e) == "symbol" ? e : e + "" } function LGe(t, e) { if (pS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (pS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var FGe = function (e, n) { var r = Js(n - e), i = Math.min(Math.abs(n - e), 359.999); return r * i }, aT = function (e) { var n = e.cx, r = e.cy, i = e.radius, a = e.angle, s = e.sign, o = e.isExternal, c = e.cornerRadius, u = e.cornerIsExternal, d = c * (o ? 1 : -1) + i, f = Math.asin(c / d) / AN, h = u ? a : a + s * f, m = bi(n, r, d, h), g = bi(n, r, i, h), x = u ? a - s * f : a, v = bi(n, r, d * Math.cos(f * AN), x); return { center: m, circleTangency: g, lineTangency: v, theta: f } }, Mfe = function (e) {
	var n = e.cx, r = e.cy, i = e.innerRadius, a = e.outerRadius, s = e.startAngle, o = e.endAngle, c = FGe(s, o), u = s + c, d = bi(n, r, a, s), f = bi(n, r, a, u), h = "M ".concat(d.x, ",").concat(d.y, `
    A `).concat(a, ",").concat(a, `,0,
    `).concat(+(Math.abs(c) > 180), ",").concat(+(s > u), `,
    `).concat(f.x, ",").concat(f.y, `
  `); if (i > 0) {
		var m = bi(n, r, i, s), g = bi(n, r, i, u); h += "L ".concat(g.x, ",").concat(g.y, `
            A `).concat(i, ",").concat(i, `,0,
            `).concat(+(Math.abs(c) > 180), ",").concat(+(s <= u), `,
            `).concat(m.x, ",").concat(m.y, " Z")
	} else h += "L ".concat(n, ",").concat(r, " Z"); return h
}, UGe = function (e) {
	var n = e.cx, r = e.cy, i = e.innerRadius, a = e.outerRadius, s = e.cornerRadius, o = e.forceCornerRadius, c = e.cornerIsExternal, u = e.startAngle, d = e.endAngle, f = Js(d - u), h = aT({ cx: n, cy: r, radius: a, angle: u, sign: f, cornerRadius: s, cornerIsExternal: c }), m = h.circleTangency, g = h.lineTangency, x = h.theta, v = aT({ cx: n, cy: r, radius: a, angle: d, sign: -f, cornerRadius: s, cornerIsExternal: c }), b = v.circleTangency, E = v.lineTangency, M = v.theta, C = c ? Math.abs(u - d) : Math.abs(u - d) - x - M; if (C < 0) return o ? "M ".concat(g.x, ",").concat(g.y, `
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(s * 2, `,0
        a`).concat(s, ",").concat(s, ",0,0,1,").concat(-s * 2, `,0
      `) : Mfe({ cx: n, cy: r, innerRadius: i, outerRadius: a, startAngle: u, endAngle: d }); var N = "M ".concat(g.x, ",").concat(g.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(f < 0), ",").concat(m.x, ",").concat(m.y, `
    A`).concat(a, ",").concat(a, ",0,").concat(+(C > 180), ",").concat(+(f < 0), ",").concat(b.x, ",").concat(b.y, `
    A`).concat(s, ",").concat(s, ",0,0,").concat(+(f < 0), ",").concat(E.x, ",").concat(E.y, `
  `); if (i > 0) {
		var A = aT({ cx: n, cy: r, radius: i, angle: u, sign: f, isExternal: !0, cornerRadius: s, cornerIsExternal: c }), j = A.circleTangency, O = A.lineTangency, I = A.theta, D = aT({ cx: n, cy: r, radius: i, angle: d, sign: -f, isExternal: !0, cornerRadius: s, cornerIsExternal: c }), F = D.circleTangency, B = D.lineTangency, G = D.theta, z = c ? Math.abs(u - d) : Math.abs(u - d) - I - G; if (z < 0 && s === 0) return "".concat(N, "L").concat(n, ",").concat(r, "Z"); N += "L".concat(B.x, ",").concat(B.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(f < 0), ",").concat(F.x, ",").concat(F.y, `
      A`).concat(i, ",").concat(i, ",0,").concat(+(z > 180), ",").concat(+(f > 0), ",").concat(j.x, ",").concat(j.y, `
      A`).concat(s, ",").concat(s, ",0,0,").concat(+(f < 0), ",").concat(O.x, ",").concat(O.y, "Z")
	} else N += "L".concat(n, ",").concat(r, "Z"); return N
}, BGe = { cx: 0, cy: 0, innerRadius: 0, outerRadius: 0, startAngle: 0, endAngle: 0, cornerRadius: 0, forceCornerRadius: !1, cornerIsExternal: !1 }, fz = function (e) { var n = oK(oK({}, BGe), e), r = n.cx, i = n.cy, a = n.innerRadius, s = n.outerRadius, o = n.cornerRadius, c = n.forceCornerRadius, u = n.cornerIsExternal, d = n.startAngle, f = n.endAngle, h = n.className; if (s < a || d === f) return null; var m = zn("recharts-sector", h), g = s - a, x = eo(o, g, 0, !0), v; return x > 0 && Math.abs(d - f) < 360 ? v = UGe({ cx: r, cy: i, innerRadius: a, outerRadius: s, cornerRadius: Math.min(x, g / 2), forceCornerRadius: c, cornerIsExternal: u, startAngle: d, endAngle: f }) : v = Mfe({ cx: r, cy: i, innerRadius: a, outerRadius: s, startAngle: d, endAngle: f }), P.createElement("path", tF({}, vn(n, !0), { className: m, d: v, role: "img" })) }; function mS(t) { "@babel/helpers - typeof"; return mS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, mS(t) } function nF() { return nF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, nF.apply(this, arguments) } function lK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function cK(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? lK(Object(n), !0).forEach(function (r) { $Ge(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : lK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function $Ge(t, e, n) { return e = zGe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function zGe(t) { var e = VGe(t, "string"); return mS(e) == "symbol" ? e : e + "" } function VGe(t, e) { if (mS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (mS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var uK = { curveBasisClosed: cze, curveBasisOpen: uze, curveBasis: lze, curveBumpX: X$e, curveBumpY: Y$e, curveLinearClosed: dze, curveLinear: F2, curveMonotoneX: fze, curveMonotoneY: hze, curveNatural: pze, curveStep: mze, curveStepAfter: vze, curveStepBefore: gze }, sT = function (e) { return e.x === +e.x && e.y === +e.y }, ww = function (e) { return e.x }, Sw = function (e) { return e.y }, HGe = function (e, n) { if (Rn(e)) return e; var r = "curve".concat(D2(e)); return (r === "curveMonotone" || r === "curveBump") && n ? uK["".concat(r).concat(n === "vertical" ? "Y" : "X")] : uK[r] || F2 }, WGe = function (e) { var n = e.type, r = n === void 0 ? "linear" : n, i = e.points, a = i === void 0 ? [] : i, s = e.baseLine, o = e.layout, c = e.connectNulls, u = c === void 0 ? !1 : c, d = HGe(r, o), f = u ? a.filter(function (x) { return sT(x) }) : a, h; if (Array.isArray(s)) { var m = u ? s.filter(function (x) { return sT(x) }) : s, g = f.map(function (x, v) { return cK(cK({}, x), {}, { base: m[v] }) }); return o === "vertical" ? h = ZM().y(Sw).x1(ww).x0(function (x) { return x.base.x }) : h = ZM().x(ww).y1(Sw).y0(function (x) { return x.base.y }), h.defined(sT).curve(d), h(g) } return o === "vertical" && It(s) ? h = ZM().y(Sw).x1(ww).x0(s) : It(s) ? h = ZM().x(ww).y1(Sw).y0(s) : h = Eue().x(ww).y(Sw), h.defined(sT).curve(d), h(f) }, Xh = function (e) { var n = e.className, r = e.points, i = e.path, a = e.pathRef; if ((!r || !r.length) && !i) return null; var s = r && r.length ? WGe(e) : i; return S.createElement("path", nF({}, vn(e, !1), iN(e), { className: zn("recharts-curve", n), d: s, ref: a })) }, GGe = Object.getOwnPropertyNames, qGe = Object.getOwnPropertySymbols, XGe = Object.prototype.hasOwnProperty; function dK(t, e) { return function (r, i, a) { return t(r, i, a) && e(r, i, a) } } function oT(t) { return function (n, r, i) { if (!n || !r || typeof n != "object" || typeof r != "object") return t(n, r, i); var a = i.cache, s = a.get(n), o = a.get(r); if (s && o) return s === r && o === n; a.set(n, r), a.set(r, n); var c = t(n, r, i); return a.delete(n), a.delete(r), c } } function fK(t) { return GGe(t).concat(qGe(t)) } var YGe = Object.hasOwn || (function (t, e) { return XGe.call(t, e) }); function Zg(t, e) { return t === e || !t && !e && t !== t && e !== e } var KGe = "__v", ZGe = "__o", QGe = "_owner", hK = Object.getOwnPropertyDescriptor, pK = Object.keys; function JGe(t, e, n) { var r = t.length; if (e.length !== r) return !1; for (; r-- > 0;)if (!n.equals(t[r], e[r], r, r, t, e, n)) return !1; return !0 } function eqe(t, e) { return Zg(t.getTime(), e.getTime()) } function tqe(t, e) { return t.name === e.name && t.message === e.message && t.cause === e.cause && t.stack === e.stack } function nqe(t, e) { return t === e } function mK(t, e, n) { var r = t.size; if (r !== e.size) return !1; if (!r) return !0; for (var i = new Array(r), a = t.entries(), s, o, c = 0; (s = a.next()) && !s.done;) { for (var u = e.entries(), d = !1, f = 0; (o = u.next()) && !o.done;) { if (i[f]) { f++; continue } var h = s.value, m = o.value; if (n.equals(h[0], m[0], c, f, t, e, n) && n.equals(h[1], m[1], h[0], m[0], t, e, n)) { d = i[f] = !0; break } f++ } if (!d) return !1; c++ } return !0 } var rqe = Zg; function iqe(t, e, n) { var r = pK(t), i = r.length; if (pK(e).length !== i) return !1; for (; i-- > 0;)if (!Tfe(t, e, n, r[i])) return !1; return !0 } function _w(t, e, n) { var r = fK(t), i = r.length; if (fK(e).length !== i) return !1; for (var a, s, o; i-- > 0;)if (a = r[i], !Tfe(t, e, n, a) || (s = hK(t, a), o = hK(e, a), (s || o) && (!s || !o || s.configurable !== o.configurable || s.enumerable !== o.enumerable || s.writable !== o.writable))) return !1; return !0 } function aqe(t, e) { return Zg(t.valueOf(), e.valueOf()) } function sqe(t, e) { return t.source === e.source && t.flags === e.flags } function gK(t, e, n) { var r = t.size; if (r !== e.size) return !1; if (!r) return !0; for (var i = new Array(r), a = t.values(), s, o; (s = a.next()) && !s.done;) { for (var c = e.values(), u = !1, d = 0; (o = c.next()) && !o.done;) { if (!i[d] && n.equals(s.value, o.value, s.value, o.value, t, e, n)) { u = i[d] = !0; break } d++ } if (!u) return !1 } return !0 } function oqe(t, e) { var n = t.length; if (e.length !== n) return !1; for (; n-- > 0;)if (t[n] !== e[n]) return !1; return !0 } function lqe(t, e) { return t.hostname === e.hostname && t.pathname === e.pathname && t.protocol === e.protocol && t.port === e.port && t.hash === e.hash && t.username === e.username && t.password === e.password } function Tfe(t, e, n, r) { return (r === QGe || r === ZGe || r === KGe) && (t.$$typeof || e.$$typeof) ? !0 : YGe(e, r) && n.equals(t[r], e[r], r, r, t, e, n) } var cqe = "[object Arguments]", uqe = "[object Boolean]", dqe = "[object Date]", fqe = "[object Error]", hqe = "[object Map]", pqe = "[object Number]", mqe = "[object Object]", gqe = "[object RegExp]", vqe = "[object Set]", yqe = "[object String]", xqe = "[object URL]", bqe = Array.isArray, vK = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, yK = Object.assign, wqe = Object.prototype.toString.call.bind(Object.prototype.toString); function Sqe(t) { var e = t.areArraysEqual, n = t.areDatesEqual, r = t.areErrorsEqual, i = t.areFunctionsEqual, a = t.areMapsEqual, s = t.areNumbersEqual, o = t.areObjectsEqual, c = t.arePrimitiveWrappersEqual, u = t.areRegExpsEqual, d = t.areSetsEqual, f = t.areTypedArraysEqual, h = t.areUrlsEqual; return function (g, x, v) { if (g === x) return !0; if (g == null || x == null) return !1; var b = typeof g; if (b !== typeof x) return !1; if (b !== "object") return b === "number" ? s(g, x, v) : b === "function" ? i(g, x, v) : !1; var E = g.constructor; if (E !== x.constructor) return !1; if (E === Object) return o(g, x, v); if (bqe(g)) return e(g, x, v); if (vK != null && vK(g)) return f(g, x, v); if (E === Date) return n(g, x, v); if (E === RegExp) return u(g, x, v); if (E === Map) return a(g, x, v); if (E === Set) return d(g, x, v); var M = wqe(g); return M === dqe ? n(g, x, v) : M === gqe ? u(g, x, v) : M === hqe ? a(g, x, v) : M === vqe ? d(g, x, v) : M === mqe ? typeof g.then != "function" && typeof x.then != "function" && o(g, x, v) : M === xqe ? h(g, x, v) : M === fqe ? r(g, x, v) : M === cqe ? o(g, x, v) : M === uqe || M === pqe || M === yqe ? c(g, x, v) : !1 } } function _qe(t) { var e = t.circular, n = t.createCustomConfig, r = t.strict, i = { areArraysEqual: r ? _w : JGe, areDatesEqual: eqe, areErrorsEqual: tqe, areFunctionsEqual: nqe, areMapsEqual: r ? dK(mK, _w) : mK, areNumbersEqual: rqe, areObjectsEqual: r ? _w : iqe, arePrimitiveWrappersEqual: aqe, areRegExpsEqual: sqe, areSetsEqual: r ? dK(gK, _w) : gK, areTypedArraysEqual: r ? _w : oqe, areUrlsEqual: lqe }; if (n && (i = yK({}, i, n(i))), e) { var a = oT(i.areArraysEqual), s = oT(i.areMapsEqual), o = oT(i.areObjectsEqual), c = oT(i.areSetsEqual); i = yK({}, i, { areArraysEqual: a, areMapsEqual: s, areObjectsEqual: o, areSetsEqual: c }) } return i } function Eqe(t) { return function (e, n, r, i, a, s, o) { return t(e, n, o) } } function Mqe(t) { var e = t.circular, n = t.comparator, r = t.createState, i = t.equals, a = t.strict; if (r) return function (c, u) { var d = r(), f = d.cache, h = f === void 0 ? e ? new WeakMap : void 0 : f, m = d.meta; return n(c, u, { cache: h, equals: i, meta: m, strict: a }) }; if (e) return function (c, u) { return n(c, u, { cache: new WeakMap, equals: i, meta: void 0, strict: a }) }; var s = { cache: void 0, equals: i, meta: void 0, strict: a }; return function (c, u) { return n(c, u, s) } } var Tqe = Np(); Np({ strict: !0 }); Np({ circular: !0 }); Np({ circular: !0, strict: !0 }); Np({ createInternalComparator: function () { return Zg } }); Np({ strict: !0, createInternalComparator: function () { return Zg } }); Np({ circular: !0, createInternalComparator: function () { return Zg } }); Np({ circular: !0, createInternalComparator: function () { return Zg }, strict: !0 }); function Np(t) { t === void 0 && (t = {}); var e = t.circular, n = e === void 0 ? !1 : e, r = t.createInternalComparator, i = t.createState, a = t.strict, s = a === void 0 ? !1 : a, o = _qe(t), c = Sqe(o), u = r ? r(c) : Eqe(c); return Mqe({ circular: n, comparator: c, createState: i, equals: u, strict: s }) } function Cqe(t) { typeof requestAnimationFrame < "u" && requestAnimationFrame(t) } function xK(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = -1, r = function i(a) { n < 0 && (n = a), a - n > e ? (t(a), n = -1) : Cqe(i) }; requestAnimationFrame(r) } function rF(t) { "@babel/helpers - typeof"; return rF = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, rF(t) } function Nqe(t) { return Rqe(t) || jqe(t) || Pqe(t) || Aqe() } function Aqe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function Pqe(t, e) { if (t) { if (typeof t == "string") return bK(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bK(t, e) } } function bK(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function jqe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function Rqe(t) { if (Array.isArray(t)) return t } function kqe() { var t = {}, e = function () { return null }, n = !1, r = function i(a) { if (!n) { if (Array.isArray(a)) { if (!a.length) return; var s = a, o = Nqe(s), c = o[0], u = o.slice(1); if (typeof c == "number") { xK(i.bind(null, u), c); return } i(c), xK(i.bind(null, u)); return } rF(a) === "object" && (t = a, e(t)), typeof a == "function" && a() } }; return { stop: function () { n = !0 }, start: function (a) { n = !1, r(a) }, subscribe: function (a) { return e = a, function () { e = function () { return null } } } } } function gS(t) { "@babel/helpers - typeof"; return gS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, gS(t) } function wK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function SK(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? wK(Object(n), !0).forEach(function (r) { Cfe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : wK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Cfe(t, e, n) { return e = Iqe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Iqe(t) { var e = Oqe(t, "string"); return gS(e) === "symbol" ? e : String(e) } function Oqe(t, e) { if (gS(t) !== "object" || t === null) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (gS(r) !== "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var Dqe = function (e, n) { return [Object.keys(e), Object.keys(n)].reduce(function (r, i) { return r.filter(function (a) { return i.includes(a) }) }) }, Lqe = function (e) { return e }, Fqe = function (e) { return e.replace(/([A-Z])/g, function (n) { return "-".concat(n.toLowerCase()) }) }, a1 = function (e, n) { return Object.keys(n).reduce(function (r, i) { return SK(SK({}, r), {}, Cfe({}, i, e(i, n[i]))) }, {}) }, _K = function (e, n, r) { return e.map(function (i) { return "".concat(Fqe(i), " ").concat(n, "ms ").concat(r) }).join(",") }; function Uqe(t, e) { return zqe(t) || $qe(t, e) || Nfe(t, e) || Bqe() } function Bqe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function $qe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function zqe(t) { if (Array.isArray(t)) return t } function Vqe(t) { return Gqe(t) || Wqe(t) || Nfe(t) || Hqe() } function Hqe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function Nfe(t, e) { if (t) { if (typeof t == "string") return iF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return iF(t, e) } } function Wqe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function Gqe(t) { if (Array.isArray(t)) return iF(t) } function iF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var jN = 1e-4, Afe = function (e, n) { return [0, 3 * e, 3 * n - 6 * e, 3 * e - 3 * n + 1] }, Pfe = function (e, n) { return e.map(function (r, i) { return r * Math.pow(n, i) }).reduce(function (r, i) { return r + i }) }, EK = function (e, n) { return function (r) { var i = Afe(e, n); return Pfe(i, r) } }, qqe = function (e, n) { return function (r) { var i = Afe(e, n), a = [].concat(Vqe(i.map(function (s, o) { return s * o }).slice(1)), [0]); return Pfe(a, r) } }, MK = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; var i = n[0], a = n[1], s = n[2], o = n[3]; if (n.length === 1) switch (n[0]) { case "linear": i = 0, a = 0, s = 1, o = 1; break; case "ease": i = .25, a = .1, s = .25, o = 1; break; case "ease-in": i = .42, a = 0, s = 1, o = 1; break; case "ease-out": i = .42, a = 0, s = .58, o = 1; break; case "ease-in-out": i = 0, a = 0, s = .58, o = 1; break; default: { var c = n[0].split("("); if (c[0] === "cubic-bezier" && c[1].split(")")[0].split(",").length === 4) { var u = c[1].split(")")[0].split(",").map(function (v) { return parseFloat(v) }), d = Uqe(u, 4); i = d[0], a = d[1], s = d[2], o = d[3] } } }var f = EK(i, s), h = EK(a, o), m = qqe(i, s), g = function (b) { return b > 1 ? 1 : b < 0 ? 0 : b }, x = function (b) { for (var E = b > 1 ? 1 : b, M = E, C = 0; C < 8; ++C) { var N = f(M) - E, A = m(M); if (Math.abs(N - E) < jN || A < jN) return h(M); M = g(M - N / A) } return h(M) }; return x.isStepper = !1, x }, Xqe = function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = e.stiff, r = n === void 0 ? 100 : n, i = e.damping, a = i === void 0 ? 8 : i, s = e.dt, o = s === void 0 ? 17 : s, c = function (d, f, h) { var m = -(d - f) * r, g = h * a, x = h + (m - g) * o / 1e3, v = h * o / 1e3 + d; return Math.abs(v - f) < jN && Math.abs(x) < jN ? [f, 0] : [v, x] }; return c.isStepper = !0, c.dt = o, c }, Yqe = function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; var i = n[0]; if (typeof i == "string") switch (i) { case "ease": case "ease-in-out": case "ease-out": case "ease-in": case "linear": return MK(i); case "spring": return Xqe(); default: if (i.split("(")[0] === "cubic-bezier") return MK(i) }return typeof i == "function" ? i : null }; function vS(t) { "@babel/helpers - typeof"; return vS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, vS(t) } function TK(t) { return Qqe(t) || Zqe(t) || jfe(t) || Kqe() } function Kqe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function Zqe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function Qqe(t) { if (Array.isArray(t)) return sF(t) } function CK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function os(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? CK(Object(n), !0).forEach(function (r) { aF(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : CK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function aF(t, e, n) { return e = Jqe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Jqe(t) { var e = eXe(t, "string"); return vS(e) === "symbol" ? e : String(e) } function eXe(t, e) { if (vS(t) !== "object" || t === null) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (vS(r) !== "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function tXe(t, e) { return iXe(t) || rXe(t, e) || jfe(t, e) || nXe() } function nXe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function jfe(t, e) { if (t) { if (typeof t == "string") return sF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sF(t, e) } } function sF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function rXe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function iXe(t) { if (Array.isArray(t)) return t } var RN = function (e, n, r) { return e + (n - e) * r }, oF = function (e) { var n = e.from, r = e.to; return n !== r }, aXe = function t(e, n, r) { var i = a1(function (a, s) { if (oF(s)) { var o = e(s.from, s.to, s.velocity), c = tXe(o, 2), u = c[0], d = c[1]; return os(os({}, s), {}, { from: u, velocity: d }) } return s }, n); return r < 1 ? a1(function (a, s) { return oF(s) ? os(os({}, s), {}, { velocity: RN(s.velocity, i[a].velocity, r), from: RN(s.from, i[a].from, r) }) : s }, n) : t(e, i, r - 1) }; const sXe = (function (t, e, n, r, i) { var a = Dqe(t, e), s = a.reduce(function (v, b) { return os(os({}, v), {}, aF({}, b, [t[b], e[b]])) }, {}), o = a.reduce(function (v, b) { return os(os({}, v), {}, aF({}, b, { from: t[b], velocity: 0, to: e[b] })) }, {}), c = -1, u, d, f = function () { return null }, h = function () { return a1(function (b, E) { return E.from }, o) }, m = function () { return !Object.values(o).filter(oF).length }, g = function (b) { u || (u = b); var E = b - u, M = E / n.dt; o = aXe(n, o, M), i(os(os(os({}, t), e), h())), u = b, m() || (c = requestAnimationFrame(f)) }, x = function (b) { d || (d = b); var E = (b - d) / r, M = a1(function (N, A) { return RN.apply(void 0, TK(A).concat([n(E)])) }, s); if (i(os(os(os({}, t), e), M)), E < 1) c = requestAnimationFrame(f); else { var C = a1(function (N, A) { return RN.apply(void 0, TK(A).concat([n(1)])) }, s); i(os(os(os({}, t), e), C)) } }; return f = n.isStepper ? g : x, function () { return requestAnimationFrame(f), function () { cancelAnimationFrame(c) } } }); function Hx(t) { "@babel/helpers - typeof"; return Hx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Hx(t) } var oXe = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"]; function lXe(t, e) { if (t == null) return {}; var n = cXe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function cXe(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, a; for (a = 0; a < r.length; a++)i = r[a], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } function XD(t) { return hXe(t) || fXe(t) || dXe(t) || uXe() } function uXe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function dXe(t, e) { if (t) { if (typeof t == "string") return lF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return lF(t, e) } } function fXe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function hXe(t) { if (Array.isArray(t)) return lF(t) } function lF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function NK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Cc(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? NK(Object(n), !0).forEach(function (r) { Fw(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : NK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Fw(t, e, n) { return e = Rfe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function pXe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function mXe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Rfe(r.key), r) } } function gXe(t, e, n) { return e && mXe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function Rfe(t) { var e = vXe(t, "string"); return Hx(e) === "symbol" ? e : String(e) } function vXe(t, e) { if (Hx(t) !== "object" || t === null) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Hx(r) !== "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function yXe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && cF(t, e) } function cF(t, e) { return cF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, cF(t, e) } function xXe(t) { var e = bXe(); return function () { var r = kN(t), i; if (e) { var a = kN(this).constructor; i = Reflect.construct(r, arguments, a) } else i = r.apply(this, arguments); return uF(this, i) } } function uF(t, e) { if (e && (Hx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return dF(t) } function dF(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function bXe() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function kN(t) { return kN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, kN(t) } var ql = (function (t) { yXe(n, t); var e = xXe(n); function n(r, i) { var a; pXe(this, n), a = e.call(this, r, i); var s = a.props, o = s.isActive, c = s.attributeName, u = s.from, d = s.to, f = s.steps, h = s.children, m = s.duration; if (a.handleStyleChange = a.handleStyleChange.bind(dF(a)), a.changeStyle = a.changeStyle.bind(dF(a)), !o || m <= 0) return a.state = { style: {} }, typeof h == "function" && (a.state = { style: d }), uF(a); if (f && f.length) a.state = { style: f[0].style }; else if (u) { if (typeof h == "function") return a.state = { style: u }, uF(a); a.state = { style: c ? Fw({}, c, u) : u } } else a.state = { style: {} }; return a } return gXe(n, [{ key: "componentDidMount", value: function () { var i = this.props, a = i.isActive, s = i.canBegin; this.mounted = !0, !(!a || !s) && this.runAnimation(this.props) } }, { key: "componentDidUpdate", value: function (i) { var a = this.props, s = a.isActive, o = a.canBegin, c = a.attributeName, u = a.shouldReAnimate, d = a.to, f = a.from, h = this.state.style; if (o) { if (!s) { var m = { style: c ? Fw({}, c, d) : d }; this.state && h && (c && h[c] !== d || !c && h !== d) && this.setState(m); return } if (!(Tqe(i.to, d) && i.canBegin && i.isActive)) { var g = !i.canBegin || !i.isActive; this.manager && this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation(); var x = g || u ? f : i.to; if (this.state && h) { var v = { style: c ? Fw({}, c, x) : x }; (c && h[c] !== x || !c && h !== x) && this.setState(v) } this.runAnimation(Cc(Cc({}, this.props), {}, { from: x, begin: 0 })) } } } }, { key: "componentWillUnmount", value: function () { this.mounted = !1; var i = this.props.onAnimationEnd; this.unSubscribe && this.unSubscribe(), this.manager && (this.manager.stop(), this.manager = null), this.stopJSAnimation && this.stopJSAnimation(), i && i() } }, { key: "handleStyleChange", value: function (i) { this.changeStyle(i) } }, { key: "changeStyle", value: function (i) { this.mounted && this.setState({ style: i }) } }, { key: "runJSAnimation", value: function (i) { var a = this, s = i.from, o = i.to, c = i.duration, u = i.easing, d = i.begin, f = i.onAnimationEnd, h = i.onAnimationStart, m = sXe(s, o, Yqe(u), c, this.changeStyle), g = function () { a.stopJSAnimation = m() }; this.manager.start([h, d, g, c, f]) } }, { key: "runStepAnimation", value: function (i) { var a = this, s = i.steps, o = i.begin, c = i.onAnimationStart, u = s[0], d = u.style, f = u.duration, h = f === void 0 ? 0 : f, m = function (x, v, b) { if (b === 0) return x; var E = v.duration, M = v.easing, C = M === void 0 ? "ease" : M, N = v.style, A = v.properties, j = v.onAnimationEnd, O = b > 0 ? s[b - 1] : v, I = A || Object.keys(N); if (typeof C == "function" || C === "spring") return [].concat(XD(x), [a.runJSAnimation.bind(a, { from: O.style, to: N, duration: E, easing: C }), E]); var D = _K(I, E, C), F = Cc(Cc(Cc({}, O.style), N), {}, { transition: D }); return [].concat(XD(x), [F, E, j]).filter(Lqe) }; return this.manager.start([c].concat(XD(s.reduce(m, [d, Math.max(h, o)])), [i.onAnimationEnd])) } }, { key: "runAnimation", value: function (i) { this.manager || (this.manager = kqe()); var a = i.begin, s = i.duration, o = i.attributeName, c = i.to, u = i.easing, d = i.onAnimationStart, f = i.onAnimationEnd, h = i.steps, m = i.children, g = this.manager; if (this.unSubscribe = g.subscribe(this.handleStyleChange), typeof u == "function" || typeof m == "function" || u === "spring") { this.runJSAnimation(i); return } if (h.length > 1) { this.runStepAnimation(i); return } var x = o ? Fw({}, o, c) : c, v = _K(Object.keys(x), s, u); g.start([d, a, Cc(Cc({}, x), {}, { transition: v }), s, f]) } }, { key: "render", value: function () { var i = this.props, a = i.children; i.begin; var s = i.duration; i.attributeName, i.easing; var o = i.isActive; i.steps, i.from, i.to, i.canBegin, i.onAnimationEnd, i.shouldReAnimate, i.onAnimationReStart; var c = lXe(i, oXe), u = S.Children.count(a), d = this.state.style; if (typeof a == "function") return a(d); if (!o || u === 0 || s <= 0) return a; var f = function (m) { var g = m.props, x = g.style, v = x === void 0 ? {} : x, b = g.className, E = S.cloneElement(m, Cc(Cc({}, c), {}, { style: Cc(Cc({}, v), d), className: b })); return E }; return u === 1 ? f(S.Children.only(a)) : P.createElement("div", null, S.Children.map(a, function (h) { return f(h) })) } }]), n })(S.PureComponent); ql.displayName = "Animate"; ql.defaultProps = { begin: 0, duration: 1e3, from: "", to: "", attributeName: "", easing: "ease", isActive: !0, canBegin: !0, steps: [], onAnimationEnd: function () { }, onAnimationStart: function () { } }; ql.propTypes = { from: $r.oneOfType([$r.object, $r.string]), to: $r.oneOfType([$r.object, $r.string]), attributeName: $r.string, duration: $r.number, begin: $r.number, easing: $r.oneOfType([$r.string, $r.func]), steps: $r.arrayOf($r.shape({ duration: $r.number.isRequired, style: $r.object.isRequired, easing: $r.oneOfType([$r.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), $r.func]), properties: $r.arrayOf("string"), onAnimationEnd: $r.func })), children: $r.oneOfType([$r.node, $r.func]), isActive: $r.bool, canBegin: $r.bool, onAnimationEnd: $r.func, shouldReAnimate: $r.bool, onAnimationStart: $r.func, onAnimationReStart: $r.func }; function yS(t) { "@babel/helpers - typeof"; return yS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, yS(t) } function IN() { return IN = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, IN.apply(this, arguments) } function wXe(t, e) { return MXe(t) || EXe(t, e) || _Xe(t, e) || SXe() } function SXe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function _Xe(t, e) { if (t) { if (typeof t == "string") return AK(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AK(t, e) } } function AK(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function EXe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function MXe(t) { if (Array.isArray(t)) return t } function PK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function jK(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? PK(Object(n), !0).forEach(function (r) { TXe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : PK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function TXe(t, e, n) { return e = CXe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function CXe(t) { var e = NXe(t, "string"); return yS(e) == "symbol" ? e : e + "" } function NXe(t, e) { if (yS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (yS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var RK = function (e, n, r, i, a) {
	var s = Math.min(Math.abs(r) / 2, Math.abs(i) / 2), o = i >= 0 ? 1 : -1, c = r >= 0 ? 1 : -1, u = i >= 0 && r >= 0 || i < 0 && r < 0 ? 1 : 0, d; if (s > 0 && a instanceof Array) {
		for (var f = [0, 0, 0, 0], h = 0, m = 4; h < m; h++)f[h] = a[h] > s ? s : a[h]; d = "M".concat(e, ",").concat(n + o * f[0]), f[0] > 0 && (d += "A ".concat(f[0], ",").concat(f[0], ",0,0,").concat(u, ",").concat(e + c * f[0], ",").concat(n)), d += "L ".concat(e + r - c * f[1], ",").concat(n), f[1] > 0 && (d += "A ".concat(f[1], ",").concat(f[1], ",0,0,").concat(u, `,
        `).concat(e + r, ",").concat(n + o * f[1])), d += "L ".concat(e + r, ",").concat(n + i - o * f[2]), f[2] > 0 && (d += "A ".concat(f[2], ",").concat(f[2], ",0,0,").concat(u, `,
        `).concat(e + r - c * f[2], ",").concat(n + i)), d += "L ".concat(e + c * f[3], ",").concat(n + i), f[3] > 0 && (d += "A ".concat(f[3], ",").concat(f[3], ",0,0,").concat(u, `,
        `).concat(e, ",").concat(n + i - o * f[3])), d += "Z"
	} else if (s > 0 && a === +a && a > 0) {
		var g = Math.min(s, a); d = "M ".concat(e, ",").concat(n + o * g, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(e + c * g, ",").concat(n, `
            L `).concat(e + r - c * g, ",").concat(n, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(e + r, ",").concat(n + o * g, `
            L `).concat(e + r, ",").concat(n + i - o * g, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(e + r - c * g, ",").concat(n + i, `
            L `).concat(e + c * g, ",").concat(n + i, `
            A `).concat(g, ",").concat(g, ",0,0,").concat(u, ",").concat(e, ",").concat(n + i - o * g, " Z")
	} else d = "M ".concat(e, ",").concat(n, " h ").concat(r, " v ").concat(i, " h ").concat(-r, " Z"); return d
}, AXe = function (e, n) { if (!e || !n) return !1; var r = e.x, i = e.y, a = n.x, s = n.y, o = n.width, c = n.height; if (Math.abs(o) > 0 && Math.abs(c) > 0) { var u = Math.min(a, a + o), d = Math.max(a, a + o), f = Math.min(s, s + c), h = Math.max(s, s + c); return r >= u && r <= d && i >= f && i <= h } return !1 }, PXe = { x: 0, y: 0, width: 0, height: 0, radius: 0, isAnimationActive: !1, isUpdateAnimationActive: !1, animationBegin: 0, animationDuration: 1500, animationEasing: "ease" }, hz = function (e) { var n = jK(jK({}, PXe), e), r = S.useRef(), i = S.useState(-1), a = wXe(i, 2), s = a[0], o = a[1]; S.useEffect(function () { if (r.current && r.current.getTotalLength) try { var C = r.current.getTotalLength(); C && o(C) } catch { } }, []); var c = n.x, u = n.y, d = n.width, f = n.height, h = n.radius, m = n.className, g = n.animationEasing, x = n.animationDuration, v = n.animationBegin, b = n.isAnimationActive, E = n.isUpdateAnimationActive; if (c !== +c || u !== +u || d !== +d || f !== +f || d === 0 || f === 0) return null; var M = zn("recharts-rectangle", m); return E ? P.createElement(ql, { canBegin: s > 0, from: { width: d, height: f, x: c, y: u }, to: { width: d, height: f, x: c, y: u }, duration: x, animationEasing: g, isActive: E }, function (C) { var N = C.width, A = C.height, j = C.x, O = C.y; return P.createElement(ql, { canBegin: s > 0, from: "0px ".concat(s === -1 ? 1 : s, "px"), to: "".concat(s, "px 0px"), attributeName: "strokeDasharray", begin: v, duration: x, isActive: b, easing: g }, P.createElement("path", IN({}, vn(n, !0), { className: M, d: RK(j, O, N, A, h), ref: r }))) }) : P.createElement("path", IN({}, vn(n, !0), { className: M, d: RK(c, u, d, f, h) })) }, jXe = ["points", "className", "baseLinePoints", "connectNulls"]; function Wy() { return Wy = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Wy.apply(this, arguments) } function RXe(t, e) { if (t == null) return {}; var n = kXe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function kXe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function kK(t) { return LXe(t) || DXe(t) || OXe(t) || IXe() } function IXe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function OXe(t, e) { if (t) { if (typeof t == "string") return fF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return fF(t, e) } } function DXe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function LXe(t) { if (Array.isArray(t)) return fF(t) } function fF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var IK = function (e) { return e && e.x === +e.x && e.y === +e.y }, FXe = function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = [[]]; return e.forEach(function (r) { IK(r) ? n[n.length - 1].push(r) : n[n.length - 1].length > 0 && n.push([]) }), IK(e[0]) && n[n.length - 1].push(e[0]), n[n.length - 1].length <= 0 && (n = n.slice(0, -1)), n }, s1 = function (e, n) { var r = FXe(e); n && (r = [r.reduce(function (a, s) { return [].concat(kK(a), kK(s)) }, [])]); var i = r.map(function (a) { return a.reduce(function (s, o, c) { return "".concat(s).concat(c === 0 ? "M" : "L").concat(o.x, ",").concat(o.y) }, "") }).join(""); return r.length === 1 ? "".concat(i, "Z") : i }, UXe = function (e, n, r) { var i = s1(e, r); return "".concat(i.slice(-1) === "Z" ? i.slice(0, -1) : i, "L").concat(s1(n.reverse(), r).slice(1)) }, BXe = function (e) { var n = e.points, r = e.className, i = e.baseLinePoints, a = e.connectNulls, s = RXe(e, jXe); if (!n || !n.length) return null; var o = zn("recharts-polygon", r); if (i && i.length) { var c = s.stroke && s.stroke !== "none", u = UXe(n, i, a); return P.createElement("g", { className: o }, P.createElement("path", Wy({}, vn(s, !0), { fill: u.slice(-1) === "Z" ? s.fill : "none", stroke: "none", d: u })), c ? P.createElement("path", Wy({}, vn(s, !0), { fill: "none", d: s1(n, a) })) : null, c ? P.createElement("path", Wy({}, vn(s, !0), { fill: "none", d: s1(i, a) })) : null) } var d = s1(n, a); return P.createElement("path", Wy({}, vn(s, !0), { fill: d.slice(-1) === "Z" ? s.fill : "none", className: o, d })) }; function hF() { return hF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, hF.apply(this, arguments) } var Gu = function (e) { var n = e.cx, r = e.cy, i = e.r, a = e.className, s = zn("recharts-dot", a); return n === +n && r === +r && i === +i ? S.createElement("circle", hF({}, vn(e, !1), iN(e), { className: s, cx: n, cy: r, r: i })) : null }; function xS(t) { "@babel/helpers - typeof"; return xS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, xS(t) } var $Xe = ["x", "y", "top", "left", "width", "height", "className"]; function pF() { return pF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, pF.apply(this, arguments) } function OK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function zXe(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? OK(Object(n), !0).forEach(function (r) { VXe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : OK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function VXe(t, e, n) { return e = HXe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function HXe(t) { var e = WXe(t, "string"); return xS(e) == "symbol" ? e : e + "" } function WXe(t, e) { if (xS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (xS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function GXe(t, e) { if (t == null) return {}; var n = qXe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function qXe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } var XXe = function (e, n, r, i, a, s) { return "M".concat(e, ",").concat(a, "v").concat(i, "M").concat(s, ",").concat(n, "h").concat(r) }, YXe = function (e) { var n = e.x, r = n === void 0 ? 0 : n, i = e.y, a = i === void 0 ? 0 : i, s = e.top, o = s === void 0 ? 0 : s, c = e.left, u = c === void 0 ? 0 : c, d = e.width, f = d === void 0 ? 0 : d, h = e.height, m = h === void 0 ? 0 : h, g = e.className, x = GXe(e, $Xe), v = zXe({ x: r, y: a, top: o, left: u, width: f, height: m }, x); return !It(r) || !It(a) || !It(f) || !It(m) || !It(o) || !It(u) ? null : P.createElement("path", pF({}, vn(v, !0), { className: zn("recharts-cross", g), d: XXe(r, a, f, m, o, u) })) }, YD, DK; function KXe() { if (DK) return YD; DK = 1; var t = Z2(), e = Xde(), n = td(); function r(i, a) { return i && i.length ? t(i, n(a, 2), e) : void 0 } return YD = r, YD } var ZXe = KXe(); const QXe = Fr(ZXe); var KD, LK; function JXe() { if (LK) return KD; LK = 1; var t = Z2(), e = td(), n = Yde(); function r(i, a) { return i && i.length ? t(i, e(a, 2), n) : void 0 } return KD = r, KD } var eYe = JXe(); const tYe = Fr(eYe); var nYe = ["cx", "cy", "angle", "ticks", "axisLine"], rYe = ["ticks", "tick", "angle", "tickFormatter", "stroke"]; function Wx(t) { "@babel/helpers - typeof"; return Wx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Wx(t) } function o1() { return o1 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, o1.apply(this, arguments) } function FK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function km(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? FK(Object(n), !0).forEach(function (r) { tP(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : FK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function UK(t, e) { if (t == null) return {}; var n = iYe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function iYe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function aYe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function BK(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Ife(r.key), r) } } function sYe(t, e, n) { return e && BK(t.prototype, e), n && BK(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function oYe(t, e, n) { return e = ON(e), lYe(t, kfe() ? Reflect.construct(e, n || [], ON(t).constructor) : e.apply(t, n)) } function lYe(t, e) { if (e && (Wx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return cYe(t) } function cYe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function kfe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (kfe = function () { return !!t })() } function ON(t) { return ON = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, ON(t) } function uYe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && mF(t, e) } function mF(t, e) { return mF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, mF(t, e) } function tP(t, e, n) { return e = Ife(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Ife(t) { var e = dYe(t, "string"); return Wx(e) == "symbol" ? e : e + "" } function dYe(t, e) { if (Wx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Wx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var nP = (function (t) { function e() { return aYe(this, e), oYe(this, e, arguments) } return uYe(e, t), sYe(e, [{ key: "getTickValueCoord", value: function (r) { var i = r.coordinate, a = this.props, s = a.angle, o = a.cx, c = a.cy; return bi(o, c, i, s) } }, { key: "getTickTextAnchor", value: function () { var r = this.props.orientation, i; switch (r) { case "left": i = "end"; break; case "right": i = "start"; break; default: i = "middle"; break }return i } }, { key: "getViewBox", value: function () { var r = this.props, i = r.cx, a = r.cy, s = r.angle, o = r.ticks, c = QXe(o, function (d) { return d.coordinate || 0 }), u = tYe(o, function (d) { return d.coordinate || 0 }); return { cx: i, cy: a, startAngle: s, endAngle: s, innerRadius: u.coordinate || 0, outerRadius: c.coordinate || 0 } } }, { key: "renderAxisLine", value: function () { var r = this.props, i = r.cx, a = r.cy, s = r.angle, o = r.ticks, c = r.axisLine, u = UK(r, nYe), d = o.reduce(function (g, x) { return [Math.min(g[0], x.coordinate), Math.max(g[1], x.coordinate)] }, [1 / 0, -1 / 0]), f = bi(i, a, d[0], s), h = bi(i, a, d[1], s), m = km(km(km({}, vn(u, !1)), {}, { fill: "none" }, vn(c, !1)), {}, { x1: f.x, y1: f.y, x2: h.x, y2: h.y }); return P.createElement("line", o1({ className: "recharts-polar-radius-axis-line" }, m)) } }, { key: "renderTicks", value: function () { var r = this, i = this.props, a = i.ticks, s = i.tick, o = i.angle, c = i.tickFormatter, u = i.stroke, d = UK(i, rYe), f = this.getTickTextAnchor(), h = vn(d, !1), m = vn(s, !1), g = a.map(function (x, v) { var b = r.getTickValueCoord(x), E = km(km(km(km({ textAnchor: f, transform: "rotate(".concat(90 - o, ", ").concat(b.x, ", ").concat(b.y, ")") }, h), {}, { stroke: "none", fill: u }, m), {}, { index: v }, b), {}, { payload: x }); return P.createElement(ar, o1({ className: zn("recharts-polar-radius-axis-tick", _fe(s)), key: "tick-".concat(x.coordinate) }, ap(r.props, x, v)), e.renderTickItem(s, E, c ? c(x.value, v) : x.value)) }); return P.createElement(ar, { className: "recharts-polar-radius-axis-ticks" }, g) } }, { key: "render", value: function () { var r = this.props, i = r.ticks, a = r.axisLine, s = r.tick; return !i || !i.length ? null : P.createElement(ar, { className: zn("recharts-polar-radius-axis", this.props.className) }, a && this.renderAxisLine(), s && this.renderTicks(), ei.renderCallByParent(this.props, this.getViewBox())) } }], [{ key: "renderTickItem", value: function (r, i, a) { var s; return P.isValidElement(r) ? s = P.cloneElement(r, i) : Rn(r) ? s = r(i) : s = P.createElement(Rg, o1({}, i, { className: "recharts-polar-radius-axis-tick-value" }), a), s } }]) })(S.PureComponent); tP(nP, "displayName", "PolarRadiusAxis"); tP(nP, "axisType", "radiusAxis"); tP(nP, "defaultProps", { type: "number", radiusAxisId: 0, cx: 0, cy: 0, angle: 0, orientation: "right", stroke: "#ccc", axisLine: !0, tick: !0, tickCount: 5, allowDataOverflow: !1, scale: "auto", allowDuplicatedCategory: !0 }); function Gx(t) { "@babel/helpers - typeof"; return Gx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Gx(t) } function Wm() { return Wm = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Wm.apply(this, arguments) } function $K(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Im(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? $K(Object(n), !0).forEach(function (r) { rP(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $K(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function fYe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function zK(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Dfe(r.key), r) } } function hYe(t, e, n) { return e && zK(t.prototype, e), n && zK(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function pYe(t, e, n) { return e = DN(e), mYe(t, Ofe() ? Reflect.construct(e, n || [], DN(t).constructor) : e.apply(t, n)) } function mYe(t, e) { if (e && (Gx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return gYe(t) } function gYe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Ofe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Ofe = function () { return !!t })() } function DN(t) { return DN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, DN(t) } function vYe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && gF(t, e) } function gF(t, e) { return gF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, gF(t, e) } function rP(t, e, n) { return e = Dfe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Dfe(t) { var e = yYe(t, "string"); return Gx(e) == "symbol" ? e : e + "" } function yYe(t, e) { if (Gx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Gx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var xYe = Math.PI / 180, VK = 1e-5, iP = (function (t) { function e() { return fYe(this, e), pYe(this, e, arguments) } return vYe(e, t), hYe(e, [{ key: "getTickLineCoord", value: function (r) { var i = this.props, a = i.cx, s = i.cy, o = i.radius, c = i.orientation, u = i.tickSize, d = u || 8, f = bi(a, s, o, r.coordinate), h = bi(a, s, o + (c === "inner" ? -1 : 1) * d, r.coordinate); return { x1: f.x, y1: f.y, x2: h.x, y2: h.y } } }, { key: "getTickTextAnchor", value: function (r) { var i = this.props.orientation, a = Math.cos(-r.coordinate * xYe), s; return a > VK ? s = i === "outer" ? "start" : "end" : a < -VK ? s = i === "outer" ? "end" : "start" : s = "middle", s } }, { key: "renderAxisLine", value: function () { var r = this.props, i = r.cx, a = r.cy, s = r.radius, o = r.axisLine, c = r.axisLineType, u = Im(Im({}, vn(this.props, !1)), {}, { fill: "none" }, vn(o, !1)); if (c === "circle") return P.createElement(Gu, Wm({ className: "recharts-polar-angle-axis-line" }, u, { cx: i, cy: a, r: s })); var d = this.props.ticks, f = d.map(function (h) { return bi(i, a, s, h.coordinate) }); return P.createElement(BXe, Wm({ className: "recharts-polar-angle-axis-line" }, u, { points: f })) } }, { key: "renderTicks", value: function () { var r = this, i = this.props, a = i.ticks, s = i.tick, o = i.tickLine, c = i.tickFormatter, u = i.stroke, d = vn(this.props, !1), f = vn(s, !1), h = Im(Im({}, d), {}, { fill: "none" }, vn(o, !1)), m = a.map(function (g, x) { var v = r.getTickLineCoord(g), b = r.getTickTextAnchor(g), E = Im(Im(Im({ textAnchor: b }, d), {}, { stroke: "none", fill: u }, f), {}, { index: x, payload: g, x: v.x2, y: v.y2 }); return P.createElement(ar, Wm({ className: zn("recharts-polar-angle-axis-tick", _fe(s)), key: "tick-".concat(g.coordinate) }, ap(r.props, g, x)), o && P.createElement("line", Wm({ className: "recharts-polar-angle-axis-tick-line" }, h, v)), s && e.renderTickItem(s, E, c ? c(g.value, x) : g.value)) }); return P.createElement(ar, { className: "recharts-polar-angle-axis-ticks" }, m) } }, { key: "render", value: function () { var r = this.props, i = r.ticks, a = r.radius, s = r.axisLine; return a <= 0 || !i || !i.length ? null : P.createElement(ar, { className: zn("recharts-polar-angle-axis", this.props.className) }, s && this.renderAxisLine(), this.renderTicks()) } }], [{ key: "renderTickItem", value: function (r, i, a) { var s; return P.isValidElement(r) ? s = P.cloneElement(r, i) : Rn(r) ? s = r(i) : s = P.createElement(Rg, Wm({}, i, { className: "recharts-polar-angle-axis-tick-value" }), a), s } }]) })(S.PureComponent); rP(iP, "displayName", "PolarAngleAxis"); rP(iP, "axisType", "angleAxis"); rP(iP, "defaultProps", { type: "category", angleAxisId: 0, scale: "auto", cx: 0, cy: 0, orientation: "outer", axisLine: !0, tickLine: !0, tickSize: 8, tick: !0, hide: !1, allowDuplicatedCategory: !0 }); var ZD, HK; function bYe() { if (HK) return ZD; HK = 1; var t = que(), e = t(Object.getPrototypeOf, Object); return ZD = e, ZD } var QD, WK; function wYe() { if (WK) return QD; WK = 1; var t = Mf(), e = bYe(), n = Tf(), r = "[object Object]", i = Function.prototype, a = Object.prototype, s = i.toString, o = a.hasOwnProperty, c = s.call(Object); function u(d) { if (!n(d) || t(d) != r) return !1; var f = e(d); if (f === null) return !0; var h = o.call(f, "constructor") && f.constructor; return typeof h == "function" && h instanceof h && s.call(h) == c } return QD = u, QD } var SYe = wYe(); const _Ye = Fr(SYe); var JD, GK; function EYe() { if (GK) return JD; GK = 1; var t = Mf(), e = Tf(), n = "[object Boolean]"; function r(i) { return i === !0 || i === !1 || e(i) && t(i) == n } return JD = r, JD } var MYe = EYe(); const TYe = Fr(MYe); function bS(t) { "@babel/helpers - typeof"; return bS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, bS(t) } function LN() { return LN = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, LN.apply(this, arguments) } function CYe(t, e) { return jYe(t) || PYe(t, e) || AYe(t, e) || NYe() } function NYe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function AYe(t, e) { if (t) { if (typeof t == "string") return qK(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return qK(t, e) } } function qK(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function PYe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function jYe(t) { if (Array.isArray(t)) return t } function XK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function YK(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? XK(Object(n), !0).forEach(function (r) { RYe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : XK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function RYe(t, e, n) { return e = kYe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function kYe(t) { var e = IYe(t, "string"); return bS(e) == "symbol" ? e : e + "" } function IYe(t, e) { if (bS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (bS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var KK = function (e, n, r, i, a) { var s = r - i, o; return o = "M ".concat(e, ",").concat(n), o += "L ".concat(e + r, ",").concat(n), o += "L ".concat(e + r - s / 2, ",").concat(n + a), o += "L ".concat(e + r - s / 2 - i, ",").concat(n + a), o += "L ".concat(e, ",").concat(n, " Z"), o }, OYe = { x: 0, y: 0, upperWidth: 0, lowerWidth: 0, height: 0, isUpdateAnimationActive: !1, animationBegin: 0, animationDuration: 1500, animationEasing: "ease" }, DYe = function (e) { var n = YK(YK({}, OYe), e), r = S.useRef(), i = S.useState(-1), a = CYe(i, 2), s = a[0], o = a[1]; S.useEffect(function () { if (r.current && r.current.getTotalLength) try { var M = r.current.getTotalLength(); M && o(M) } catch { } }, []); var c = n.x, u = n.y, d = n.upperWidth, f = n.lowerWidth, h = n.height, m = n.className, g = n.animationEasing, x = n.animationDuration, v = n.animationBegin, b = n.isUpdateAnimationActive; if (c !== +c || u !== +u || d !== +d || f !== +f || h !== +h || d === 0 && f === 0 || h === 0) return null; var E = zn("recharts-trapezoid", m); return b ? P.createElement(ql, { canBegin: s > 0, from: { upperWidth: 0, lowerWidth: 0, height: h, x: c, y: u }, to: { upperWidth: d, lowerWidth: f, height: h, x: c, y: u }, duration: x, animationEasing: g, isActive: b }, function (M) { var C = M.upperWidth, N = M.lowerWidth, A = M.height, j = M.x, O = M.y; return P.createElement(ql, { canBegin: s > 0, from: "0px ".concat(s === -1 ? 1 : s, "px"), to: "".concat(s, "px 0px"), attributeName: "strokeDasharray", begin: v, duration: x, easing: g }, P.createElement("path", LN({}, vn(n, !0), { className: E, d: KK(j, O, C, N, A), ref: r }))) }) : P.createElement("g", null, P.createElement("path", LN({}, vn(n, !0), { className: E, d: KK(c, u, d, f, h) }))) }, LYe = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"]; function wS(t) { "@babel/helpers - typeof"; return wS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, wS(t) } function FYe(t, e) { if (t == null) return {}; var n = UYe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function UYe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function ZK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function FN(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? ZK(Object(n), !0).forEach(function (r) { BYe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ZK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function BYe(t, e, n) { return e = $Ye(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function $Ye(t) { var e = zYe(t, "string"); return wS(e) == "symbol" ? e : e + "" } function zYe(t, e) { if (wS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (wS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function VYe(t, e) { return FN(FN({}, e), t) } function HYe(t, e) { return t === "symbols" } function QK(t) { var e = t.shapeType, n = t.elementProps; switch (e) { case "rectangle": return P.createElement(hz, n); case "trapezoid": return P.createElement(DYe, n); case "sector": return P.createElement(fz, n); case "symbols": if (HYe(e)) return P.createElement(B2, n); break; default: return null } } function WYe(t) { return S.isValidElement(t) ? t.props : t } function UN(t) { var e = t.option, n = t.shapeType, r = t.propTransformer, i = r === void 0 ? VYe : r, a = t.activeClassName, s = a === void 0 ? "recharts-active-shape" : a, o = t.isActive, c = FYe(t, LYe), u; if (S.isValidElement(e)) u = S.cloneElement(e, FN(FN({}, c), WYe(e))); else if (Rn(e)) u = e(c); else if (_Ye(e) && !TYe(e)) { var d = i(e, c); u = P.createElement(QK, { shapeType: n, elementProps: d }) } else { var f = c; u = P.createElement(QK, { shapeType: n, elementProps: f }) } return o ? P.createElement(ar, { className: s }, u) : u } function aP(t, e) { return e != null && "trapezoids" in t.props } function sP(t, e) { return e != null && "sectors" in t.props } function SS(t, e) { return e != null && "points" in t.props } function GYe(t, e) { var n, r, i = t.x === (e == null || (n = e.labelViewBox) === null || n === void 0 ? void 0 : n.x) || t.x === e.x, a = t.y === (e == null || (r = e.labelViewBox) === null || r === void 0 ? void 0 : r.y) || t.y === e.y; return i && a } function qYe(t, e) { var n = t.endAngle === e.endAngle, r = t.startAngle === e.startAngle; return n && r } function XYe(t, e) { var n = t.x === e.x, r = t.y === e.y, i = t.z === e.z; return n && r && i } function YYe(t, e) { var n; return aP(t, e) ? n = GYe : sP(t, e) ? n = qYe : SS(t, e) && (n = XYe), n } function KYe(t, e) { var n; return aP(t, e) ? n = "trapezoids" : sP(t, e) ? n = "sectors" : SS(t, e) && (n = "points"), n } function ZYe(t, e) { if (aP(t, e)) { var n; return (n = e.tooltipPayload) === null || n === void 0 || (n = n[0]) === null || n === void 0 || (n = n.payload) === null || n === void 0 ? void 0 : n.payload } if (sP(t, e)) { var r; return (r = e.tooltipPayload) === null || r === void 0 || (r = r[0]) === null || r === void 0 || (r = r.payload) === null || r === void 0 ? void 0 : r.payload } return SS(t, e) ? e.payload : {} } function QYe(t) { var e = t.activeTooltipItem, n = t.graphicalItem, r = t.itemData, i = KYe(n, e), a = ZYe(n, e), s = r.filter(function (c, u) { var d = sp(a, c), f = n.props[i].filter(function (g) { var x = YYe(n, e); return x(g, e) }), h = n.props[i].indexOf(f[f.length - 1]), m = u === h; return d && m }), o = r.indexOf(s[s.length - 1]); return o } var FT; function qx(t) { "@babel/helpers - typeof"; return qx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, qx(t) } function Gy() { return Gy = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Gy.apply(this, arguments) } function JK(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function pi(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? JK(Object(n), !0).forEach(function (r) { Fl(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : JK(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function JYe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function eZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Ffe(r.key), r) } } function eKe(t, e, n) { return e && eZ(t.prototype, e), n && eZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function tKe(t, e, n) { return e = BN(e), nKe(t, Lfe() ? Reflect.construct(e, n || [], BN(t).constructor) : e.apply(t, n)) } function nKe(t, e) { if (e && (qx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return rKe(t) } function rKe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Lfe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Lfe = function () { return !!t })() } function BN(t) { return BN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, BN(t) } function iKe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && vF(t, e) } function vF(t, e) { return vF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, vF(t, e) } function Fl(t, e, n) { return e = Ffe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Ffe(t) { var e = aKe(t, "string"); return qx(e) == "symbol" ? e : e + "" } function aKe(t, e) { if (qx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (qx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var Af = (function (t) { function e(n) { var r; return JYe(this, e), r = tKe(this, e, [n]), Fl(r, "pieRef", null), Fl(r, "sectorRefs", []), Fl(r, "id", Ep("recharts-pie-")), Fl(r, "handleAnimationEnd", function () { var i = r.props.onAnimationEnd; r.setState({ isAnimationFinished: !0 }), Rn(i) && i() }), Fl(r, "handleAnimationStart", function () { var i = r.props.onAnimationStart; r.setState({ isAnimationFinished: !1 }), Rn(i) && i() }), r.state = { isAnimationFinished: !n.isAnimationActive, prevIsAnimationActive: n.isAnimationActive, prevAnimationId: n.animationId, sectorToFocus: 0 }, r } return iKe(e, t), eKe(e, [{ key: "isActiveIndex", value: function (r) { var i = this.props.activeIndex; return Array.isArray(i) ? i.indexOf(r) !== -1 : r === i } }, { key: "hasActiveIndex", value: function () { var r = this.props.activeIndex; return Array.isArray(r) ? r.length !== 0 : r || r === 0 } }, { key: "renderLabels", value: function (r) { var i = this.props.isAnimationActive; if (i && !this.state.isAnimationFinished) return null; var a = this.props, s = a.label, o = a.labelLine, c = a.dataKey, u = a.valueKey, d = vn(this.props, !1), f = vn(s, !1), h = vn(o, !1), m = s && s.offsetRadius || 20, g = r.map(function (x, v) { var b = (x.startAngle + x.endAngle) / 2, E = bi(x.cx, x.cy, x.outerRadius + m, b), M = pi(pi(pi(pi({}, d), x), {}, { stroke: "none" }, f), {}, { index: v, textAnchor: e.getTextAnchor(E.x, x.cx) }, E), C = pi(pi(pi(pi({}, d), x), {}, { fill: "none", stroke: x.fill }, h), {}, { index: v, points: [bi(x.cx, x.cy, x.outerRadius, b), E] }), N = c; return An(c) && An(u) ? N = "value" : An(c) && (N = u), P.createElement(ar, { key: "label-".concat(x.startAngle, "-").concat(x.endAngle, "-").concat(x.midAngle, "-").concat(v) }, o && e.renderLabelLineItem(o, C, "line"), e.renderLabelItem(s, M, Ci(x, N))) }); return P.createElement(ar, { className: "recharts-pie-labels" }, g) } }, { key: "renderSectorsStatically", value: function (r) { var i = this, a = this.props, s = a.activeShape, o = a.blendStroke, c = a.inactiveShape; return r.map(function (u, d) { if (u?.startAngle === 0 && u?.endAngle === 0 && r.length !== 1) return null; var f = i.isActiveIndex(d), h = c && i.hasActiveIndex() ? c : null, m = f ? s : h, g = pi(pi({}, u), {}, { stroke: o ? u.fill : u.stroke, tabIndex: -1 }); return P.createElement(ar, Gy({ ref: function (v) { v && !i.sectorRefs.includes(v) && i.sectorRefs.push(v) }, tabIndex: -1, className: "recharts-pie-sector" }, ap(i.props, u, d), { key: "sector-".concat(u?.startAngle, "-").concat(u?.endAngle, "-").concat(u.midAngle, "-").concat(d) }), P.createElement(UN, Gy({ option: m, isActive: f, shapeType: "sector" }, g))) }) } }, { key: "renderSectorsWithAnimation", value: function () { var r = this, i = this.props, a = i.sectors, s = i.isAnimationActive, o = i.animationBegin, c = i.animationDuration, u = i.animationEasing, d = i.animationId, f = this.state, h = f.prevSectors, m = f.prevIsAnimationActive; return P.createElement(ql, { begin: o, duration: c, isActive: s, easing: u, from: { t: 0 }, to: { t: 1 }, key: "pie-".concat(d, "-").concat(m), onAnimationStart: this.handleAnimationStart, onAnimationEnd: this.handleAnimationEnd }, function (g) { var x = g.t, v = [], b = a && a[0], E = b.startAngle; return a.forEach(function (M, C) { var N = h && h[C], A = C > 0 ? pl(M, "paddingAngle", 0) : 0; if (N) { var j = Di(N.endAngle - N.startAngle, M.endAngle - M.startAngle), O = pi(pi({}, M), {}, { startAngle: E + A, endAngle: E + j(x) + A }); v.push(O), E = O.endAngle } else { var I = M.endAngle, D = M.startAngle, F = Di(0, I - D), B = F(x), G = pi(pi({}, M), {}, { startAngle: E + A, endAngle: E + B + A }); v.push(G), E = G.endAngle } }), P.createElement(ar, null, r.renderSectorsStatically(v)) }) } }, { key: "attachKeyboardHandlers", value: function (r) { var i = this; r.onkeydown = function (a) { if (!a.altKey) switch (a.key) { case "ArrowLeft": { var s = ++i.state.sectorToFocus % i.sectorRefs.length; i.sectorRefs[s].focus(), i.setState({ sectorToFocus: s }); break } case "ArrowRight": { var o = --i.state.sectorToFocus < 0 ? i.sectorRefs.length - 1 : i.state.sectorToFocus % i.sectorRefs.length; i.sectorRefs[o].focus(), i.setState({ sectorToFocus: o }); break } case "Escape": { i.sectorRefs[i.state.sectorToFocus].blur(), i.setState({ sectorToFocus: 0 }); break } } } } }, { key: "renderSectors", value: function () { var r = this.props, i = r.sectors, a = r.isAnimationActive, s = this.state.prevSectors; return a && i && i.length && (!s || !sp(s, i)) ? this.renderSectorsWithAnimation() : this.renderSectorsStatically(i) } }, { key: "componentDidMount", value: function () { this.pieRef && this.attachKeyboardHandlers(this.pieRef) } }, { key: "render", value: function () { var r = this, i = this.props, a = i.hide, s = i.sectors, o = i.className, c = i.label, u = i.cx, d = i.cy, f = i.innerRadius, h = i.outerRadius, m = i.isAnimationActive, g = this.state.isAnimationFinished; if (a || !s || !s.length || !It(u) || !It(d) || !It(f) || !It(h)) return null; var x = zn("recharts-pie", o); return P.createElement(ar, { tabIndex: this.props.rootTabIndex, className: x, ref: function (b) { r.pieRef = b } }, this.renderSectors(), c && this.renderLabels(s), ei.renderCallByParent(this.props, null, !1), (!m || g) && $c.renderCallByParent(this.props, s, !1)) } }], [{ key: "getDerivedStateFromProps", value: function (r, i) { return i.prevIsAnimationActive !== r.isAnimationActive ? { prevIsAnimationActive: r.isAnimationActive, prevAnimationId: r.animationId, curSectors: r.sectors, prevSectors: [], isAnimationFinished: !0 } : r.isAnimationActive && r.animationId !== i.prevAnimationId ? { prevAnimationId: r.animationId, curSectors: r.sectors, prevSectors: i.curSectors, isAnimationFinished: !0 } : r.sectors !== i.curSectors ? { curSectors: r.sectors, isAnimationFinished: !0 } : null } }, { key: "getTextAnchor", value: function (r, i) { return r > i ? "start" : r < i ? "end" : "middle" } }, { key: "renderLabelLineItem", value: function (r, i, a) { if (P.isValidElement(r)) return P.cloneElement(r, i); if (Rn(r)) return r(i); var s = zn("recharts-pie-label-line", typeof r != "boolean" ? r.className : ""); return P.createElement(Xh, Gy({}, i, { key: a, type: "linear", className: s })) } }, { key: "renderLabelItem", value: function (r, i, a) { if (P.isValidElement(r)) return P.cloneElement(r, i); var s = a; if (Rn(r) && (s = r(i), P.isValidElement(s))) return s; var o = zn("recharts-pie-label-text", typeof r != "boolean" && !Rn(r) ? r.className : ""); return P.createElement(Rg, Gy({}, i, { alignmentBaseline: "middle", className: o }), s) } }]) })(S.PureComponent); FT = Af; Fl(Af, "displayName", "Pie"); Fl(Af, "defaultProps", { stroke: "#fff", fill: "#808080", legendType: "rect", cx: "50%", cy: "50%", startAngle: 0, endAngle: 360, innerRadius: 0, outerRadius: "80%", paddingAngle: 0, labelLine: !0, hide: !1, minAngle: 0, isAnimationActive: !Cf.isSsr, animationBegin: 400, animationDuration: 1500, animationEasing: "ease", nameKey: "name", blendStroke: !1, rootTabIndex: 0 }); Fl(Af, "parseDeltaAngle", function (t, e) { var n = Js(e - t), r = Math.min(Math.abs(e - t), 360); return n * r }); Fl(Af, "getRealPieData", function (t) { var e = t.data, n = t.children, r = vn(t, !1), i = so(n, H2); return e && e.length ? e.map(function (a, s) { return pi(pi(pi({ payload: a }, r), a), i && i[s] && i[s].props) }) : i && i.length ? i.map(function (a) { return pi(pi({}, r), a.props) }) : [] }); Fl(Af, "parseCoordinateOfPie", function (t, e) { var n = e.top, r = e.left, i = e.width, a = e.height, s = Sfe(i, a), o = r + eo(t.cx, i, i / 2), c = n + eo(t.cy, a, a / 2), u = eo(t.innerRadius, s, 0), d = eo(t.outerRadius, s, s * .8), f = t.maxRadius || Math.sqrt(i * i + a * a) / 2; return { cx: o, cy: c, innerRadius: u, outerRadius: d, maxRadius: f } }); Fl(Af, "getComposedData", function (t) {
	var e = t.item, n = t.offset, r = e.type.defaultProps !== void 0 ? pi(pi({}, e.type.defaultProps), e.props) : e.props, i = FT.getRealPieData(r); if (!i || !i.length) return null; var a = r.cornerRadius, s = r.startAngle, o = r.endAngle, c = r.paddingAngle, u = r.dataKey, d = r.nameKey, f = r.valueKey, h = r.tooltipType, m = Math.abs(r.minAngle), g = FT.parseCoordinateOfPie(r, n), x = FT.parseDeltaAngle(s, o), v = Math.abs(x), b = u; An(u) && An(f) ? (Bc(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), b = "value") : An(u) && (Bc(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), b = f); var E = i.filter(function (O) { return Ci(O, b, 0) !== 0 }).length, M = (v >= 360 ? E : E - 1) * c, C = v - E * m - M, N = i.reduce(function (O, I) { var D = Ci(I, b, 0); return O + (It(D) ? D : 0) }, 0), A; if (N > 0) { var j; A = i.map(function (O, I) { var D = Ci(O, b, 0), F = Ci(O, d, I), B = (It(D) ? D : 0) / N, G; I ? G = j.endAngle + Js(x) * c * (D !== 0 ? 1 : 0) : G = s; var z = G + Js(x) * ((D !== 0 ? m : 0) + B * C), q = (G + z) / 2, Y = (g.innerRadius + g.outerRadius) / 2, Z = [{ name: F, value: D, payload: O, dataKey: b, type: h }], $ = bi(g.cx, g.cy, Y, q); return j = pi(pi(pi({ percent: B, cornerRadius: a, name: F, tooltipPayload: Z, midAngle: q, middleRadius: Y, tooltipPosition: $ }, O), g), {}, { value: Ci(O, b), startAngle: G, endAngle: z, payload: O, paddingAngle: Js(x) * c }), j }) } return pi(pi({}, g), {}, { sectors: A, data: i })
}); var e3, tZ; function sKe() { if (tZ) return e3; tZ = 1; var t = Math.ceil, e = Math.max; function n(r, i, a, s) { for (var o = -1, c = e(t((i - r) / (a || 1)), 0), u = Array(c); c--;)u[s ? c : ++o] = r, r += a; return u } return e3 = n, e3 } var t3, nZ; function Ufe() { if (nZ) return t3; nZ = 1; var t = cde(), e = 1 / 0, n = 17976931348623157e292; function r(i) { if (!i) return i === 0 ? i : 0; if (i = t(i), i === e || i === -e) { var a = i < 0 ? -1 : 1; return a * n } return i === i ? i : 0 } return t3 = r, t3 } var n3, rZ; function oKe() { if (rZ) return n3; rZ = 1; var t = sKe(), e = V2(), n = Ufe(); function r(i) { return function (a, s, o) { return o && typeof o != "number" && e(a, s, o) && (s = o = void 0), a = n(a), s === void 0 ? (s = a, a = 0) : s = n(s), o = o === void 0 ? a < s ? 1 : -1 : n(o), t(a, s, o, i) } } return n3 = r, n3 } var r3, iZ; function lKe() { if (iZ) return r3; iZ = 1; var t = oKe(), e = t(); return r3 = e, r3 } var cKe = lKe(); const $N = Fr(cKe); function _S(t) { "@babel/helpers - typeof"; return _S = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, _S(t) } function aZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function sZ(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? aZ(Object(n), !0).forEach(function (r) { Bfe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : aZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Bfe(t, e, n) { return e = uKe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function uKe(t) { var e = dKe(t, "string"); return _S(e) == "symbol" ? e : e + "" } function dKe(t, e) { if (_S(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (_S(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var fKe = ["Webkit", "Moz", "O", "ms"], hKe = function (e, n) { var r = e.replace(/(\w)/, function (a) { return a.toUpperCase() }), i = fKe.reduce(function (a, s) { return sZ(sZ({}, a), {}, Bfe({}, s + r, n)) }, {}); return i[e] = n, i }; function Xx(t) { "@babel/helpers - typeof"; return Xx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Xx(t) } function zN() { return zN = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, zN.apply(this, arguments) } function oZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function i3(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? oZ(Object(n), !0).forEach(function (r) { rl(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : oZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function pKe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function lZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, zfe(r.key), r) } } function mKe(t, e, n) { return e && lZ(t.prototype, e), n && lZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function gKe(t, e, n) { return e = VN(e), vKe(t, $fe() ? Reflect.construct(e, n || [], VN(t).constructor) : e.apply(t, n)) } function vKe(t, e) { if (e && (Xx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return yKe(t) } function yKe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function $fe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return ($fe = function () { return !!t })() } function VN(t) { return VN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, VN(t) } function xKe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && yF(t, e) } function yF(t, e) { return yF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, yF(t, e) } function rl(t, e, n) { return e = zfe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function zfe(t) { var e = bKe(t, "string"); return Xx(e) == "symbol" ? e : e + "" } function bKe(t, e) { if (Xx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Xx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var wKe = function (e) { var n = e.data, r = e.startIndex, i = e.endIndex, a = e.x, s = e.width, o = e.travellerWidth; if (!n || !n.length) return {}; var c = n.length, u = r1().domain($N(0, c)).range([a, a + s - o]), d = u.domain().map(function (f) { return u(f) }); return { isTextActive: !1, isSlideMoving: !1, isTravellerMoving: !1, isTravellerFocused: !1, startX: u(r), endX: u(i), scale: u, scaleValues: d } }, cZ = function (e) { return e.changedTouches && !!e.changedTouches.length }, Yx = (function (t) { function e(n) { var r; return pKe(this, e), r = gKe(this, e, [n]), rl(r, "handleDrag", function (i) { r.leaveTimer && (clearTimeout(r.leaveTimer), r.leaveTimer = null), r.state.isTravellerMoving ? r.handleTravellerMove(i) : r.state.isSlideMoving && r.handleSlideDrag(i) }), rl(r, "handleTouchMove", function (i) { i.changedTouches != null && i.changedTouches.length > 0 && r.handleDrag(i.changedTouches[0]) }), rl(r, "handleDragEnd", function () { r.setState({ isTravellerMoving: !1, isSlideMoving: !1 }, function () { var i = r.props, a = i.endIndex, s = i.onDragEnd, o = i.startIndex; s?.({ endIndex: a, startIndex: o }) }), r.detachDragEndListener() }), rl(r, "handleLeaveWrapper", function () { (r.state.isTravellerMoving || r.state.isSlideMoving) && (r.leaveTimer = window.setTimeout(r.handleDragEnd, r.props.leaveTimeOut)) }), rl(r, "handleEnterSlideOrTraveller", function () { r.setState({ isTextActive: !0 }) }), rl(r, "handleLeaveSlideOrTraveller", function () { r.setState({ isTextActive: !1 }) }), rl(r, "handleSlideDragStart", function (i) { var a = cZ(i) ? i.changedTouches[0] : i; r.setState({ isTravellerMoving: !1, isSlideMoving: !0, slideMoveStartX: a.pageX }), r.attachDragEndListener() }), r.travellerDragStartHandlers = { startX: r.handleTravellerDragStart.bind(r, "startX"), endX: r.handleTravellerDragStart.bind(r, "endX") }, r.state = {}, r } return xKe(e, t), mKe(e, [{ key: "componentWillUnmount", value: function () { this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener() } }, { key: "getIndex", value: function (r) { var i = r.startX, a = r.endX, s = this.state.scaleValues, o = this.props, c = o.gap, u = o.data, d = u.length - 1, f = Math.min(i, a), h = Math.max(i, a), m = e.getIndexInRange(s, f), g = e.getIndexInRange(s, h); return { startIndex: m - m % c, endIndex: g === d ? d : g - g % c } } }, { key: "getTextOfTick", value: function (r) { var i = this.props, a = i.data, s = i.tickFormatter, o = i.dataKey, c = Ci(a[r], o, r); return Rn(s) ? s(c, r) : c } }, { key: "attachDragEndListener", value: function () { window.addEventListener("mouseup", this.handleDragEnd, !0), window.addEventListener("touchend", this.handleDragEnd, !0), window.addEventListener("mousemove", this.handleDrag, !0) } }, { key: "detachDragEndListener", value: function () { window.removeEventListener("mouseup", this.handleDragEnd, !0), window.removeEventListener("touchend", this.handleDragEnd, !0), window.removeEventListener("mousemove", this.handleDrag, !0) } }, { key: "handleSlideDrag", value: function (r) { var i = this.state, a = i.slideMoveStartX, s = i.startX, o = i.endX, c = this.props, u = c.x, d = c.width, f = c.travellerWidth, h = c.startIndex, m = c.endIndex, g = c.onChange, x = r.pageX - a; x > 0 ? x = Math.min(x, u + d - f - o, u + d - f - s) : x < 0 && (x = Math.max(x, u - s, u - o)); var v = this.getIndex({ startX: s + x, endX: o + x }); (v.startIndex !== h || v.endIndex !== m) && g && g(v), this.setState({ startX: s + x, endX: o + x, slideMoveStartX: r.pageX }) } }, { key: "handleTravellerDragStart", value: function (r, i) { var a = cZ(i) ? i.changedTouches[0] : i; this.setState({ isSlideMoving: !1, isTravellerMoving: !0, movingTravellerId: r, brushMoveStartX: a.pageX }), this.attachDragEndListener() } }, { key: "handleTravellerMove", value: function (r) { var i = this.state, a = i.brushMoveStartX, s = i.movingTravellerId, o = i.endX, c = i.startX, u = this.state[s], d = this.props, f = d.x, h = d.width, m = d.travellerWidth, g = d.onChange, x = d.gap, v = d.data, b = { startX: this.state.startX, endX: this.state.endX }, E = r.pageX - a; E > 0 ? E = Math.min(E, f + h - m - u) : E < 0 && (E = Math.max(E, f - u)), b[s] = u + E; var M = this.getIndex(b), C = M.startIndex, N = M.endIndex, A = function () { var O = v.length - 1; return s === "startX" && (o > c ? C % x === 0 : N % x === 0) || o < c && N === O || s === "endX" && (o > c ? N % x === 0 : C % x === 0) || o > c && N === O }; this.setState(rl(rl({}, s, u + E), "brushMoveStartX", r.pageX), function () { g && A() && g(M) }) } }, { key: "handleTravellerMoveKeyboard", value: function (r, i) { var a = this, s = this.state, o = s.scaleValues, c = s.startX, u = s.endX, d = this.state[i], f = o.indexOf(d); if (f !== -1) { var h = f + r; if (!(h === -1 || h >= o.length)) { var m = o[h]; i === "startX" && m >= u || i === "endX" && m <= c || this.setState(rl({}, i, m), function () { a.props.onChange(a.getIndex({ startX: a.state.startX, endX: a.state.endX })) }) } } } }, { key: "renderBackground", value: function () { var r = this.props, i = r.x, a = r.y, s = r.width, o = r.height, c = r.fill, u = r.stroke; return P.createElement("rect", { stroke: u, fill: c, x: i, y: a, width: s, height: o }) } }, { key: "renderPanorama", value: function () { var r = this.props, i = r.x, a = r.y, s = r.width, o = r.height, c = r.data, u = r.children, d = r.padding, f = S.Children.only(u); return f ? P.cloneElement(f, { x: i, y: a, width: s, height: o, margin: d, compact: !0, data: c }) : null } }, { key: "renderTravellerLayer", value: function (r, i) { var a, s, o = this, c = this.props, u = c.y, d = c.travellerWidth, f = c.height, h = c.traveller, m = c.ariaLabel, g = c.data, x = c.startIndex, v = c.endIndex, b = Math.max(r, this.props.x), E = i3(i3({}, vn(this.props, !1)), {}, { x: b, y: u, width: d, height: f }), M = m || "Min value: ".concat((a = g[x]) === null || a === void 0 ? void 0 : a.name, ", Max value: ").concat((s = g[v]) === null || s === void 0 ? void 0 : s.name); return P.createElement(ar, { tabIndex: 0, role: "slider", "aria-label": M, "aria-valuenow": r, className: "recharts-brush-traveller", onMouseEnter: this.handleEnterSlideOrTraveller, onMouseLeave: this.handleLeaveSlideOrTraveller, onMouseDown: this.travellerDragStartHandlers[i], onTouchStart: this.travellerDragStartHandlers[i], onKeyDown: function (N) { ["ArrowLeft", "ArrowRight"].includes(N.key) && (N.preventDefault(), N.stopPropagation(), o.handleTravellerMoveKeyboard(N.key === "ArrowRight" ? 1 : -1, i)) }, onFocus: function () { o.setState({ isTravellerFocused: !0 }) }, onBlur: function () { o.setState({ isTravellerFocused: !1 }) }, style: { cursor: "col-resize" } }, e.renderTraveller(h, E)) } }, { key: "renderSlide", value: function (r, i) { var a = this.props, s = a.y, o = a.height, c = a.stroke, u = a.travellerWidth, d = Math.min(r, i) + u, f = Math.max(Math.abs(i - r) - u, 0); return P.createElement("rect", { className: "recharts-brush-slide", onMouseEnter: this.handleEnterSlideOrTraveller, onMouseLeave: this.handleLeaveSlideOrTraveller, onMouseDown: this.handleSlideDragStart, onTouchStart: this.handleSlideDragStart, style: { cursor: "move" }, stroke: "none", fill: c, fillOpacity: .2, x: d, y: s, width: f, height: o }) } }, { key: "renderText", value: function () { var r = this.props, i = r.startIndex, a = r.endIndex, s = r.y, o = r.height, c = r.travellerWidth, u = r.stroke, d = this.state, f = d.startX, h = d.endX, m = 5, g = { pointerEvents: "none", fill: u }; return P.createElement(ar, { className: "recharts-brush-texts" }, P.createElement(Rg, zN({ textAnchor: "end", verticalAnchor: "middle", x: Math.min(f, h) - m, y: s + o / 2 }, g), this.getTextOfTick(i)), P.createElement(Rg, zN({ textAnchor: "start", verticalAnchor: "middle", x: Math.max(f, h) + c + m, y: s + o / 2 }, g), this.getTextOfTick(a))) } }, { key: "render", value: function () { var r = this.props, i = r.data, a = r.className, s = r.children, o = r.x, c = r.y, u = r.width, d = r.height, f = r.alwaysShowText, h = this.state, m = h.startX, g = h.endX, x = h.isTextActive, v = h.isSlideMoving, b = h.isTravellerMoving, E = h.isTravellerFocused; if (!i || !i.length || !It(o) || !It(c) || !It(u) || !It(d) || u <= 0 || d <= 0) return null; var M = zn("recharts-brush", a), C = P.Children.count(s) === 1, N = hKe("userSelect", "none"); return P.createElement(ar, { className: M, onMouseLeave: this.handleLeaveWrapper, onTouchMove: this.handleTouchMove, style: N }, this.renderBackground(), C && this.renderPanorama(), this.renderSlide(m, g), this.renderTravellerLayer(m, "startX"), this.renderTravellerLayer(g, "endX"), (x || v || b || E || f) && this.renderText()) } }], [{ key: "renderDefaultTraveller", value: function (r) { var i = r.x, a = r.y, s = r.width, o = r.height, c = r.stroke, u = Math.floor(a + o / 2) - 1; return P.createElement(P.Fragment, null, P.createElement("rect", { x: i, y: a, width: s, height: o, fill: c, stroke: "none" }), P.createElement("line", { x1: i + 1, y1: u, x2: i + s - 1, y2: u, fill: "none", stroke: "#fff" }), P.createElement("line", { x1: i + 1, y1: u + 2, x2: i + s - 1, y2: u + 2, fill: "none", stroke: "#fff" })) } }, { key: "renderTraveller", value: function (r, i) { var a; return P.isValidElement(r) ? a = P.cloneElement(r, i) : Rn(r) ? a = r(i) : a = e.renderDefaultTraveller(i), a } }, { key: "getDerivedStateFromProps", value: function (r, i) { var a = r.data, s = r.width, o = r.x, c = r.travellerWidth, u = r.updateId, d = r.startIndex, f = r.endIndex; if (a !== i.prevData || u !== i.prevUpdateId) return i3({ prevData: a, prevTravellerWidth: c, prevUpdateId: u, prevX: o, prevWidth: s }, a && a.length ? wKe({ data: a, width: s, x: o, travellerWidth: c, startIndex: d, endIndex: f }) : { scale: null, scaleValues: null }); if (i.scale && (s !== i.prevWidth || o !== i.prevX || c !== i.prevTravellerWidth)) { i.scale.range([o, o + s - c]); var h = i.scale.domain().map(function (m) { return i.scale(m) }); return { prevData: a, prevTravellerWidth: c, prevUpdateId: u, prevX: o, prevWidth: s, startX: i.scale(r.startIndex), endX: i.scale(r.endIndex), scaleValues: h } } return null } }, { key: "getIndexInRange", value: function (r, i) { for (var a = r.length, s = 0, o = a - 1; o - s > 1;) { var c = Math.floor((s + o) / 2); r[c] > i ? o = c : s = c } return i >= r[o] ? o : s } }]) })(S.PureComponent); rl(Yx, "displayName", "Brush"); rl(Yx, "defaultProps", { height: 40, travellerWidth: 5, gap: 1, fill: "#fff", stroke: "#666", padding: { top: 1, right: 1, bottom: 1, left: 1 }, leaveTimeOut: 1e3, alwaysShowText: !1 }); var a3, uZ; function SKe() { if (uZ) return a3; uZ = 1; var t = F$(); function e(n, r) { var i; return t(n, function (a, s, o) { return i = r(a, s, o), !i }), !!i } return a3 = e, a3 } var s3, dZ; function _Ke() { if (dZ) return s3; dZ = 1; var t = Bue(), e = td(), n = SKe(), r = Vo(), i = V2(); function a(s, o, c) { var u = r(s) ? t : n; return c && i(s, o, c) && (o = void 0), u(s, e(o, 3)) } return s3 = a, s3 } var EKe = _Ke(); const MKe = Fr(EKe); var Iu = function (e, n) { var r = e.alwaysShow, i = e.ifOverflow; return r && (i = "extendDomain"), i === n }, o3, fZ; function TKe() { if (fZ) return o3; fZ = 1; var t = ide(); function e(n, r, i) { r == "__proto__" && t ? t(n, r, { configurable: !0, enumerable: !0, value: i, writable: !0 }) : n[r] = i } return o3 = e, o3 } var l3, hZ; function CKe() { if (hZ) return l3; hZ = 1; var t = TKe(), e = nde(), n = td(); function r(i, a) { var s = {}; return a = n(a, 3), e(i, function (o, c, u) { t(s, c, a(o, c, u)) }), s } return l3 = r, l3 } var NKe = CKe(); const AKe = Fr(NKe); var c3, pZ; function PKe() { if (pZ) return c3; pZ = 1; function t(e, n) { for (var r = -1, i = e == null ? 0 : e.length; ++r < i;)if (!n(e[r], r, e)) return !1; return !0 } return c3 = t, c3 } var u3, mZ; function jKe() { if (mZ) return u3; mZ = 1; var t = F$(); function e(n, r) { var i = !0; return t(n, function (a, s, o) { return i = !!r(a, s, o), i }), i } return u3 = e, u3 } var d3, gZ; function RKe() { if (gZ) return d3; gZ = 1; var t = PKe(), e = jKe(), n = td(), r = Vo(), i = V2(); function a(s, o, c) { var u = r(s) ? t : e; return c && i(s, o, c) && (o = void 0), u(s, n(o, 3)) } return d3 = a, d3 } var kKe = RKe(); const Vfe = Fr(kKe); var IKe = ["x", "y"]; function ES(t) { "@babel/helpers - typeof"; return ES = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, ES(t) } function xF() { return xF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, xF.apply(this, arguments) } function vZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ew(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? vZ(Object(n), !0).forEach(function (r) { OKe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : vZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function OKe(t, e, n) { return e = DKe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function DKe(t) { var e = LKe(t, "string"); return ES(e) == "symbol" ? e : e + "" } function LKe(t, e) { if (ES(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (ES(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function FKe(t, e) { if (t == null) return {}; var n = UKe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function UKe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function BKe(t, e) { var n = t.x, r = t.y, i = FKe(t, IKe), a = "".concat(n), s = parseInt(a, 10), o = "".concat(r), c = parseInt(o, 10), u = "".concat(e.height || i.height), d = parseInt(u, 10), f = "".concat(e.width || i.width), h = parseInt(f, 10); return Ew(Ew(Ew(Ew(Ew({}, e), i), s ? { x: s } : {}), c ? { y: c } : {}), {}, { height: d, width: h, name: e.name, radius: e.radius }) } function yZ(t) { return P.createElement(UN, xF({ shapeType: "rectangle", propTransformer: BKe, activeClassName: "recharts-active-bar" }, t)) } var $Ke = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; return function (r, i) { if (typeof e == "number") return e; var a = It(r) || m$e(r); return a ? e(r, i) : (a || Ig(), n) } }, zKe = ["value", "background"], Hfe; function Kx(t) { "@babel/helpers - typeof"; return Kx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Kx(t) } function VKe(t, e) { if (t == null) return {}; var n = HKe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function HKe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function HN() { return HN = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, HN.apply(this, arguments) } function xZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function ma(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? xZ(Object(n), !0).forEach(function (r) { Fh(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : xZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function WKe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function bZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Gfe(r.key), r) } } function GKe(t, e, n) { return e && bZ(t.prototype, e), n && bZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function qKe(t, e, n) { return e = WN(e), XKe(t, Wfe() ? Reflect.construct(e, n || [], WN(t).constructor) : e.apply(t, n)) } function XKe(t, e) { if (e && (Kx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return YKe(t) } function YKe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Wfe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Wfe = function () { return !!t })() } function WN(t) { return WN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, WN(t) } function KKe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && bF(t, e) } function bF(t, e) { return bF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, bF(t, e) } function Fh(t, e, n) { return e = Gfe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Gfe(t) { var e = ZKe(t, "string"); return Kx(e) == "symbol" ? e : e + "" } function ZKe(t, e) { if (Kx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Kx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var Ap = (function (t) { function e() { var n; WKe(this, e); for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; return n = qKe(this, e, [].concat(i)), Fh(n, "state", { isAnimationFinished: !1 }), Fh(n, "id", Ep("recharts-bar-")), Fh(n, "handleAnimationEnd", function () { var s = n.props.onAnimationEnd; n.setState({ isAnimationFinished: !0 }), s && s() }), Fh(n, "handleAnimationStart", function () { var s = n.props.onAnimationStart; n.setState({ isAnimationFinished: !1 }), s && s() }), n } return KKe(e, t), GKe(e, [{ key: "renderRectanglesStatically", value: function (r) { var i = this, a = this.props, s = a.shape, o = a.dataKey, c = a.activeIndex, u = a.activeBar, d = vn(this.props, !1); return r && r.map(function (f, h) { var m = h === c, g = m ? u : s, x = ma(ma(ma({}, d), f), {}, { isActive: m, option: g, index: h, dataKey: o, onAnimationStart: i.handleAnimationStart, onAnimationEnd: i.handleAnimationEnd }); return P.createElement(ar, HN({ className: "recharts-bar-rectangle" }, ap(i.props, f, h), { key: "rectangle-".concat(f?.x, "-").concat(f?.y, "-").concat(f?.value, "-").concat(h) }), P.createElement(yZ, x)) }) } }, { key: "renderRectanglesWithAnimation", value: function () { var r = this, i = this.props, a = i.data, s = i.layout, o = i.isAnimationActive, c = i.animationBegin, u = i.animationDuration, d = i.animationEasing, f = i.animationId, h = this.state.prevData; return P.createElement(ql, { begin: c, duration: u, isActive: o, easing: d, from: { t: 0 }, to: { t: 1 }, key: "bar-".concat(f), onAnimationEnd: this.handleAnimationEnd, onAnimationStart: this.handleAnimationStart }, function (m) { var g = m.t, x = a.map(function (v, b) { var E = h && h[b]; if (E) { var M = Di(E.x, v.x), C = Di(E.y, v.y), N = Di(E.width, v.width), A = Di(E.height, v.height); return ma(ma({}, v), {}, { x: M(g), y: C(g), width: N(g), height: A(g) }) } if (s === "horizontal") { var j = Di(0, v.height), O = j(g); return ma(ma({}, v), {}, { y: v.y + v.height - O, height: O }) } var I = Di(0, v.width), D = I(g); return ma(ma({}, v), {}, { width: D }) }); return P.createElement(ar, null, r.renderRectanglesStatically(x)) }) } }, { key: "renderRectangles", value: function () { var r = this.props, i = r.data, a = r.isAnimationActive, s = this.state.prevData; return a && i && i.length && (!s || !sp(s, i)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(i) } }, { key: "renderBackground", value: function () { var r = this, i = this.props, a = i.data, s = i.dataKey, o = i.activeIndex, c = vn(this.props.background, !1); return a.map(function (u, d) { u.value; var f = u.background, h = VKe(u, zKe); if (!f) return null; var m = ma(ma(ma(ma(ma({}, h), {}, { fill: "#eee" }, f), c), ap(r.props, u, d)), {}, { onAnimationStart: r.handleAnimationStart, onAnimationEnd: r.handleAnimationEnd, dataKey: s, index: d, className: "recharts-bar-background-rectangle" }); return P.createElement(yZ, HN({ key: "background-bar-".concat(d), option: r.props.background, isActive: d === o }, m)) }) } }, { key: "renderErrorBar", value: function (r, i) { if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null; var a = this.props, s = a.data, o = a.xAxis, c = a.yAxis, u = a.layout, d = a.children, f = so(d, z0); if (!f) return null; var h = u === "vertical" ? s[0].height / 2 : s[0].width / 2, m = function (v, b) { var E = Array.isArray(v.value) ? v.value[1] : v.value; return { x: v.x, y: v.y, value: E, errorVal: Ci(v, b) } }, g = { clipPath: r ? "url(#clipPath-".concat(i, ")") : null }; return P.createElement(ar, g, f.map(function (x) { return P.cloneElement(x, { key: "error-bar-".concat(i, "-").concat(x.props.dataKey), data: s, xAxis: o, yAxis: c, layout: u, offset: h, dataPointFormatter: m }) })) } }, { key: "render", value: function () { var r = this.props, i = r.hide, a = r.data, s = r.className, o = r.xAxis, c = r.yAxis, u = r.left, d = r.top, f = r.width, h = r.height, m = r.isAnimationActive, g = r.background, x = r.id; if (i || !a || !a.length) return null; var v = this.state.isAnimationFinished, b = zn("recharts-bar", s), E = o && o.allowDataOverflow, M = c && c.allowDataOverflow, C = E || M, N = An(x) ? this.id : x; return P.createElement(ar, { className: b }, E || M ? P.createElement("defs", null, P.createElement("clipPath", { id: "clipPath-".concat(N) }, P.createElement("rect", { x: E ? u : u - f / 2, y: M ? d : d - h / 2, width: E ? f : f * 2, height: M ? h : h * 2 }))) : null, P.createElement(ar, { className: "recharts-bar-rectangles", clipPath: C ? "url(#clipPath-".concat(N, ")") : null }, g ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(C, N), (!m || v) && $c.renderCallByParent(this.props, a)) } }], [{ key: "getDerivedStateFromProps", value: function (r, i) { return r.animationId !== i.prevAnimationId ? { prevAnimationId: r.animationId, curData: r.data, prevData: i.curData } : r.data !== i.curData ? { curData: r.data } : null } }]) })(S.PureComponent); Hfe = Ap; Fh(Ap, "displayName", "Bar"); Fh(Ap, "defaultProps", { xAxisId: 0, yAxisId: 0, legendType: "rect", minPointSize: 0, hide: !1, data: [], layout: "vertical", activeBar: !1, isAnimationActive: !Cf.isSsr, animationBegin: 0, animationDuration: 400, animationEasing: "ease" }); Fh(Ap, "getComposedData", function (t) { var e = t.props, n = t.item, r = t.barPosition, i = t.bandSize, a = t.xAxis, s = t.yAxis, o = t.xAxisTicks, c = t.yAxisTicks, u = t.stackedData, d = t.dataStartIndex, f = t.displayedData, h = t.offset, m = P9e(r, n); if (!m) return null; var g = e.layout, x = n.type.defaultProps, v = x !== void 0 ? ma(ma({}, x), n.props) : n.props, b = v.dataKey, E = v.children, M = v.minPointSize, C = g === "horizontal" ? s : a, N = u ? C.scale.domain() : null, A = L9e({ numericAxis: C }), j = so(E, H2), O = f.map(function (I, D) { var F, B, G, z, q, Y; u ? F = j9e(u[d + D], N) : (F = Ci(I, b), Array.isArray(F) || (F = [A, F])); var Z = $Ke(M, Hfe.defaultProps.minPointSize)(F[1], D); if (g === "horizontal") { var $, V = [s.scale(F[0]), s.scale(F[1])], K = V[0], X = V[1]; B = XY({ axis: a, ticks: o, bandSize: i, offset: m.offset, entry: I, index: D }), G = ($ = X ?? K) !== null && $ !== void 0 ? $ : void 0, z = m.size; var Q = K - X; if (q = Number.isNaN(Q) ? 0 : Q, Y = { x: B, y: s.y, width: z, height: s.height }, Math.abs(Z) > 0 && Math.abs(q) < Math.abs(Z)) { var re = Js(q || Z) * (Math.abs(Z) - Math.abs(q)); G -= re, q += re } } else { var ce = [a.scale(F[0]), a.scale(F[1])], be = ce[0], de = ce[1]; if (B = be, G = XY({ axis: s, ticks: c, bandSize: i, offset: m.offset, entry: I, index: D }), z = de - be, q = m.size, Y = { x: a.x, y: G, width: a.width, height: q }, Math.abs(Z) > 0 && Math.abs(z) < Math.abs(Z)) { var ae = Js(z || Z) * (Math.abs(Z) - Math.abs(z)); z += ae } } return ma(ma(ma({}, I), {}, { x: B, y: G, width: z, height: q, value: u ? F : F[1], payload: I, background: Y }, j && j[D] && j[D].props), {}, { tooltipPayload: [bfe(n, I)], tooltipPosition: { x: B + z / 2, y: G + q / 2 } }) }); return ma({ data: O, layout: g }, h) }); function MS(t) { "@babel/helpers - typeof"; return MS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, MS(t) } function QKe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function wZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, qfe(r.key), r) } } function JKe(t, e, n) { return e && wZ(t.prototype, e), n && wZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function SZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function jc(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? SZ(Object(n), !0).forEach(function (r) { oP(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : SZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function oP(t, e, n) { return e = qfe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function qfe(t) { var e = eZe(t, "string"); return MS(e) == "symbol" ? e : e + "" } function eZe(t, e) { if (MS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (MS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var lP = function (e, n, r, i, a) { var s = e.width, o = e.height, c = e.layout, u = e.children, d = Object.keys(n), f = { left: r.left, leftMirror: r.left, right: s - r.right, rightMirror: s - r.right, top: r.top, topMirror: r.top, bottom: o - r.bottom, bottomMirror: o - r.bottom }, h = !!al(u, Ap); return d.reduce(function (m, g) { var x = n[g], v = x.orientation, b = x.domain, E = x.padding, M = E === void 0 ? {} : E, C = x.mirror, N = x.reversed, A = "".concat(v).concat(C ? "Mirror" : ""), j, O, I, D, F; if (x.type === "number" && (x.padding === "gap" || x.padding === "no-gap")) { var B = b[1] - b[0], G = 1 / 0, z = x.categoricalDomain.sort(x$e); if (z.forEach(function (ce, be) { be > 0 && (G = Math.min((ce || 0) - (z[be - 1] || 0), G)) }), Number.isFinite(G)) { var q = G / B, Y = x.layout === "vertical" ? r.height : r.width; if (x.padding === "gap" && (j = q * Y / 2), x.padding === "no-gap") { var Z = eo(e.barCategoryGap, q * Y), $ = q * Y / 2; j = $ - Z - ($ - Z) / Y * Z } } } i === "xAxis" ? O = [r.left + (M.left || 0) + (j || 0), r.left + r.width - (M.right || 0) - (j || 0)] : i === "yAxis" ? O = c === "horizontal" ? [r.top + r.height - (M.bottom || 0), r.top + (M.top || 0)] : [r.top + (M.top || 0) + (j || 0), r.top + r.height - (M.bottom || 0) - (j || 0)] : O = x.range, N && (O = [O[1], O[0]]); var V = gfe(x, a, h), K = V.scale, X = V.realScaleType; K.domain(b).range(O), vfe(K); var Q = yfe(K, jc(jc({}, x), {}, { realScaleType: X })); i === "xAxis" ? (F = v === "top" && !C || v === "bottom" && C, I = r.left, D = f[A] - F * x.height) : i === "yAxis" && (F = v === "left" && !C || v === "right" && C, I = f[A] - F * x.width, D = r.top); var re = jc(jc(jc({}, x), Q), {}, { realScaleType: X, x: I, y: D, scale: K, width: i === "xAxis" ? r.width : x.width, height: i === "yAxis" ? r.height : x.height }); return re.bandSize = NN(re, Q), !x.hide && i === "xAxis" ? f[A] += (F ? -1 : 1) * re.height : x.hide || (f[A] += (F ? -1 : 1) * re.width), jc(jc({}, m), {}, oP({}, g, re)) }, {}) }, Xfe = function (e, n) { var r = e.x, i = e.y, a = n.x, s = n.y; return { x: Math.min(r, a), y: Math.min(i, s), width: Math.abs(a - r), height: Math.abs(s - i) } }, tZe = function (e) { var n = e.x1, r = e.y1, i = e.x2, a = e.y2; return Xfe({ x: n, y: r }, { x: i, y: a }) }, Yfe = (function () { function t(e) { QKe(this, t), this.scale = e } return JKe(t, [{ key: "domain", get: function () { return this.scale.domain } }, { key: "range", get: function () { return this.scale.range } }, { key: "rangeMin", get: function () { return this.range()[0] } }, { key: "rangeMax", get: function () { return this.range()[1] } }, { key: "bandwidth", get: function () { return this.scale.bandwidth } }, { key: "apply", value: function (n) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.bandAware, a = r.position; if (n !== void 0) { if (a) switch (a) { case "start": return this.scale(n); case "middle": { var s = this.bandwidth ? this.bandwidth() / 2 : 0; return this.scale(n) + s } case "end": { var o = this.bandwidth ? this.bandwidth() : 0; return this.scale(n) + o } default: return this.scale(n) }if (i) { var c = this.bandwidth ? this.bandwidth() / 2 : 0; return this.scale(n) + c } return this.scale(n) } } }, { key: "isInRange", value: function (n) { var r = this.range(), i = r[0], a = r[r.length - 1]; return i <= a ? n >= i && n <= a : n >= a && n <= i } }], [{ key: "create", value: function (n) { return new t(n) } }]) })(); oP(Yfe, "EPS", 1e-4); var pz = function (e) { var n = Object.keys(e).reduce(function (r, i) { return jc(jc({}, r), {}, oP({}, i, Yfe.create(e[i]))) }, {}); return jc(jc({}, n), {}, { apply: function (i) { var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = a.bandAware, o = a.position; return AKe(i, function (c, u) { return n[u].apply(c, { bandAware: s, position: o }) }) }, isInRange: function (i) { return Vfe(i, function (a, s) { return n[s].isInRange(a) }) } }) }; function nZe(t) { return (t % 180 + 180) % 180 } var rZe = function (e) { var n = e.width, r = e.height, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, a = nZe(i), s = a * Math.PI / 180, o = Math.atan(r / n), c = s > o && s < Math.PI - o ? r / Math.sin(s) : n / Math.cos(s); return Math.abs(c) }, f3, _Z; function iZe() { if (_Z) return f3; _Z = 1; var t = td(), e = M_(), n = $2(); function r(i) { return function (a, s, o) { var c = Object(a); if (!e(a)) { var u = t(s, 3); a = n(a), s = function (f) { return u(c[f], f, c) } } var d = i(a, s, o); return d > -1 ? c[u ? a[d] : d] : void 0 } } return f3 = r, f3 } var h3, EZ; function aZe() { if (EZ) return h3; EZ = 1; var t = Ufe(); function e(n) { var r = t(n), i = r % 1; return r === r ? i ? r - i : r : 0 } return h3 = e, h3 } var p3, MZ; function sZe() { if (MZ) return p3; MZ = 1; var t = Zue(), e = td(), n = aZe(), r = Math.max; function i(a, s, o) { var c = a == null ? 0 : a.length; if (!c) return -1; var u = o == null ? 0 : n(o); return u < 0 && (u = r(c + u, 0)), t(a, e(s, 3), u) } return p3 = i, p3 } var m3, TZ; function oZe() { if (TZ) return m3; TZ = 1; var t = iZe(), e = sZe(), n = t(e); return m3 = n, m3 } var lZe = oZe(); const cZe = Fr(lZe); var uZe = fue(); const dZe = Fr(uZe); var fZe = dZe(function (t) { return { x: t.left, y: t.top, width: t.width, height: t.height } }, function (t) { return ["l", t.left, "t", t.top, "w", t.width, "h", t.height].join("") }), mz = S.createContext(void 0), gz = S.createContext(void 0), Kfe = S.createContext(void 0), Zfe = S.createContext({}), Qfe = S.createContext(void 0), Jfe = S.createContext(0), ehe = S.createContext(0), CZ = function (e) { var n = e.state, r = n.xAxisMap, i = n.yAxisMap, a = n.offset, s = e.clipPathId, o = e.children, c = e.width, u = e.height, d = fZe(a); return P.createElement(mz.Provider, { value: r }, P.createElement(gz.Provider, { value: i }, P.createElement(Zfe.Provider, { value: a }, P.createElement(Kfe.Provider, { value: d }, P.createElement(Qfe.Provider, { value: s }, P.createElement(Jfe.Provider, { value: u }, P.createElement(ehe.Provider, { value: c }, o))))))) }, hZe = function () { return S.useContext(Qfe) }, the = function (e) { var n = S.useContext(mz); n == null && Ig(); var r = n[e]; return r == null && Ig(), r }, pZe = function () { var e = S.useContext(mz); return kh(e) }, mZe = function () { var e = S.useContext(gz), n = cZe(e, function (r) { return Vfe(r.domain, Number.isFinite) }); return n || kh(e) }, nhe = function (e) { var n = S.useContext(gz); n == null && Ig(); var r = n[e]; return r == null && Ig(), r }, gZe = function () { var e = S.useContext(Kfe); return e }, vZe = function () { return S.useContext(Zfe) }, vz = function () { return S.useContext(ehe) }, yz = function () { return S.useContext(Jfe) }; function Zx(t) { "@babel/helpers - typeof"; return Zx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Zx(t) } function yZe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function xZe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, ihe(r.key), r) } } function bZe(t, e, n) { return e && xZe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function wZe(t, e, n) { return e = GN(e), SZe(t, rhe() ? Reflect.construct(e, n || [], GN(t).constructor) : e.apply(t, n)) } function SZe(t, e) { if (e && (Zx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return _Ze(t) } function _Ze(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function rhe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (rhe = function () { return !!t })() } function GN(t) { return GN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, GN(t) } function EZe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && wF(t, e) } function wF(t, e) { return wF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, wF(t, e) } function NZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function AZ(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? NZ(Object(n), !0).forEach(function (r) { xz(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : NZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function xz(t, e, n) { return e = ihe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function ihe(t) { var e = MZe(t, "string"); return Zx(e) == "symbol" ? e : e + "" } function MZe(t, e) { if (Zx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Zx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } function TZe(t, e) { return PZe(t) || AZe(t, e) || NZe(t, e) || CZe() } function CZe() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function NZe(t, e) { if (t) { if (typeof t == "string") return PZ(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PZ(t, e) } } function PZ(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function AZe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function PZe(t) { if (Array.isArray(t)) return t } function SF() { return SF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, SF.apply(this, arguments) } var jZe = function (e, n) { var r; return P.isValidElement(e) ? r = P.cloneElement(e, n) : Rn(e) ? r = e(n) : r = P.createElement("line", SF({}, n, { className: "recharts-reference-line-line" })), r }, RZe = function (e, n, r, i, a, s, o, c, u) { var d = a.x, f = a.y, h = a.width, m = a.height; if (r) { var g = u.y, x = e.y.apply(g, { position: s }); if (Iu(u, "discard") && !e.y.isInRange(x)) return null; var v = [{ x: d + h, y: x }, { x: d, y: x }]; return c === "left" ? v.reverse() : v } if (n) { var b = u.x, E = e.x.apply(b, { position: s }); if (Iu(u, "discard") && !e.x.isInRange(E)) return null; var M = [{ x: E, y: f + m }, { x: E, y: f }]; return o === "top" ? M.reverse() : M } if (i) { var C = u.segment, N = C.map(function (A) { return e.apply(A, { position: s }) }); return Iu(u, "discard") && MKe(N, function (A) { return !e.isInRange(A) }) ? null : N } return null }; function kZe(t) { var e = t.x, n = t.y, r = t.segment, i = t.xAxisId, a = t.yAxisId, s = t.shape, o = t.className, c = t.alwaysShow, u = hZe(), d = the(i), f = nhe(a), h = gZe(); if (!u || !h) return null; Bc(c === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'); var m = pz({ x: d.scale, y: f.scale }), g = ka(e), x = ka(n), v = r && r.length === 2, b = RZe(m, g, x, v, h, t.position, d.orientation, f.orientation, t); if (!b) return null; var E = TZe(b, 2), M = E[0], C = M.x, N = M.y, A = E[1], j = A.x, O = A.y, I = Iu(t, "hidden") ? "url(#".concat(u, ")") : void 0, D = AZ(AZ({ clipPath: I }, vn(t, !0)), {}, { x1: C, y1: N, x2: j, y2: O }); return P.createElement(ar, { className: zn("recharts-reference-line", o) }, jZe(s, D), ei.renderCallByParent(t, tZe({ x1: C, y1: N, x2: j, y2: O }))) } var bz = (function (t) { function e() { return yZe(this, e), wZe(this, e, arguments) } return EZe(e, t), bZe(e, [{ key: "render", value: function () { return P.createElement(kZe, this.props) } }]) })(P.Component); xz(bz, "displayName", "ReferenceLine"); xz(bz, "defaultProps", { isFront: !1, ifOverflow: "discard", xAxisId: 0, yAxisId: 0, fill: "none", stroke: "#ccc", fillOpacity: 1, strokeWidth: 1, position: "middle" }); function _F() { return _F = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, _F.apply(this, arguments) } function Qx(t) { "@babel/helpers - typeof"; return Qx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Qx(t) } function jZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function RZ(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? jZ(Object(n), !0).forEach(function (r) { cP(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : jZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function IZe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function OZe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, she(r.key), r) } } function DZe(t, e, n) { return e && OZe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function LZe(t, e, n) { return e = qN(e), FZe(t, ahe() ? Reflect.construct(e, n || [], qN(t).constructor) : e.apply(t, n)) } function FZe(t, e) { if (e && (Qx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return UZe(t) } function UZe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function ahe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (ahe = function () { return !!t })() } function qN(t) { return qN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, qN(t) } function BZe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && EF(t, e) } function EF(t, e) { return EF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, EF(t, e) } function cP(t, e, n) { return e = she(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function she(t) { var e = $Ze(t, "string"); return Qx(e) == "symbol" ? e : e + "" } function $Ze(t, e) { if (Qx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Qx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var zZe = function (e) { var n = e.x, r = e.y, i = e.xAxis, a = e.yAxis, s = pz({ x: i.scale, y: a.scale }), o = s.apply({ x: n, y: r }, { bandAware: !0 }); return Iu(e, "discard") && !s.isInRange(o) ? null : o }, uP = (function (t) { function e() { return IZe(this, e), LZe(this, e, arguments) } return BZe(e, t), DZe(e, [{ key: "render", value: function () { var r = this.props, i = r.x, a = r.y, s = r.r, o = r.alwaysShow, c = r.clipPathId, u = ka(i), d = ka(a); if (Bc(o === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'), !u || !d) return null; var f = zZe(this.props); if (!f) return null; var h = f.x, m = f.y, g = this.props, x = g.shape, v = g.className, b = Iu(this.props, "hidden") ? "url(#".concat(c, ")") : void 0, E = RZ(RZ({ clipPath: b }, vn(this.props, !0)), {}, { cx: h, cy: m }); return P.createElement(ar, { className: zn("recharts-reference-dot", v) }, e.renderDot(x, E), ei.renderCallByParent(this.props, { x: h - s, y: m - s, width: 2 * s, height: 2 * s })) } }]) })(P.Component); cP(uP, "displayName", "ReferenceDot"); cP(uP, "defaultProps", { isFront: !1, ifOverflow: "discard", xAxisId: 0, yAxisId: 0, r: 10, fill: "#fff", stroke: "#ccc", fillOpacity: 1, strokeWidth: 1 }); cP(uP, "renderDot", function (t, e) { var n; return P.isValidElement(t) ? n = P.cloneElement(t, e) : Rn(t) ? n = t(e) : n = P.createElement(Gu, _F({}, e, { cx: e.cx, cy: e.cy, className: "recharts-reference-dot-dot" })), n }); function MF() { return MF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, MF.apply(this, arguments) } function Jx(t) { "@babel/helpers - typeof"; return Jx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Jx(t) } function kZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function IZ(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? kZ(Object(n), !0).forEach(function (r) { dP(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : kZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function VZe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function HZe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, lhe(r.key), r) } } function WZe(t, e, n) { return e && HZe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function GZe(t, e, n) { return e = XN(e), qZe(t, ohe() ? Reflect.construct(e, n || [], XN(t).constructor) : e.apply(t, n)) } function qZe(t, e) { if (e && (Jx(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return XZe(t) } function XZe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function ohe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (ohe = function () { return !!t })() } function XN(t) { return XN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, XN(t) } function YZe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && TF(t, e) } function TF(t, e) { return TF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, TF(t, e) } function dP(t, e, n) { return e = lhe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function lhe(t) { var e = KZe(t, "string"); return Jx(e) == "symbol" ? e : e + "" } function KZe(t, e) { if (Jx(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Jx(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var ZZe = function (e, n, r, i, a) { var s = a.x1, o = a.x2, c = a.y1, u = a.y2, d = a.xAxis, f = a.yAxis; if (!d || !f) return null; var h = pz({ x: d.scale, y: f.scale }), m = { x: e ? h.x.apply(s, { position: "start" }) : h.x.rangeMin, y: r ? h.y.apply(c, { position: "start" }) : h.y.rangeMin }, g = { x: n ? h.x.apply(o, { position: "end" }) : h.x.rangeMax, y: i ? h.y.apply(u, { position: "end" }) : h.y.rangeMax }; return Iu(a, "discard") && (!h.isInRange(m) || !h.isInRange(g)) ? null : Xfe(m, g) }, fP = (function (t) { function e() { return VZe(this, e), GZe(this, e, arguments) } return YZe(e, t), WZe(e, [{ key: "render", value: function () { var r = this.props, i = r.x1, a = r.x2, s = r.y1, o = r.y2, c = r.className, u = r.alwaysShow, d = r.clipPathId; Bc(u === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'); var f = ka(i), h = ka(a), m = ka(s), g = ka(o), x = this.props.shape; if (!f && !h && !m && !g && !x) return null; var v = ZZe(f, h, m, g, this.props); if (!v && !x) return null; var b = Iu(this.props, "hidden") ? "url(#".concat(d, ")") : void 0; return P.createElement(ar, { className: zn("recharts-reference-area", c) }, e.renderRect(x, IZ(IZ({ clipPath: b }, vn(this.props, !0)), v)), ei.renderCallByParent(this.props, v)) } }]) })(P.Component); dP(fP, "displayName", "ReferenceArea"); dP(fP, "defaultProps", { isFront: !1, ifOverflow: "discard", xAxisId: 0, yAxisId: 0, r: 10, fill: "#ccc", fillOpacity: .5, stroke: "none", strokeWidth: 1 }); dP(fP, "renderRect", function (t, e) { var n; return P.isValidElement(t) ? n = P.cloneElement(t, e) : Rn(t) ? n = t(e) : n = P.createElement(hz, MF({}, e, { className: "recharts-reference-area-rect" })), n }); function che(t, e, n) { if (e < 1) return []; if (e === 1 && n === void 0) return t; for (var r = [], i = 0; i < t.length; i += e)r.push(t[i]); return r } function QZe(t, e, n) { var r = { width: t.width + e.width, height: t.height + e.height }; return rZe(r, n) } function JZe(t, e, n) { var r = n === "width", i = t.x, a = t.y, s = t.width, o = t.height; return e === 1 ? { start: r ? i : a, end: r ? i + s : a + o } : { start: r ? i + s : a + o, end: r ? i : a } } function YN(t, e, n, r, i) { if (t * e < t * r || t * e > t * i) return !1; var a = n(); return t * (e - t * a / 2 - r) >= 0 && t * (e + t * a / 2 - i) <= 0 } function eQe(t, e) { return che(t, e + 1) } function tQe(t, e, n, r, i) { for (var a = (r || []).slice(), s = e.start, o = e.end, c = 0, u = 1, d = s, f = function () { var g = r?.[c]; if (g === void 0) return { v: che(r, u) }; var x = c, v, b = function () { return v === void 0 && (v = n(g, x)), v }, E = g.coordinate, M = c === 0 || YN(t, E, b, d, o); M || (c = 0, d = s, u += 1), M && (d = E + t * (b() / 2 + i), c += u) }, h; u <= a.length;)if (h = f(), h) return h.v; return [] } function TS(t) { "@babel/helpers - typeof"; return TS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, TS(t) } function OZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function _s(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? OZ(Object(n), !0).forEach(function (r) { nQe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : OZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function nQe(t, e, n) { return e = rQe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function rQe(t) { var e = iQe(t, "string"); return TS(e) == "symbol" ? e : e + "" } function iQe(t, e) { if (TS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (TS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function aQe(t, e, n, r, i) { for (var a = (r || []).slice(), s = a.length, o = e.start, c = e.end, u = function (h) { var m = a[h], g, x = function () { return g === void 0 && (g = n(m, h)), g }; if (h === s - 1) { var v = t * (m.coordinate + t * x() / 2 - c); a[h] = m = _s(_s({}, m), {}, { tickCoord: v > 0 ? m.coordinate - v * t : m.coordinate }) } else a[h] = m = _s(_s({}, m), {}, { tickCoord: m.coordinate }); var b = YN(t, m.tickCoord, x, o, c); b && (c = m.tickCoord - t * (x() / 2 + i), a[h] = _s(_s({}, m), {}, { isShow: !0 })) }, d = s - 1; d >= 0; d--)u(d); return a } function sQe(t, e, n, r, i, a) { var s = (r || []).slice(), o = s.length, c = e.start, u = e.end; if (a) { var d = r[o - 1], f = n(d, o - 1), h = t * (d.coordinate + t * f / 2 - u); s[o - 1] = d = _s(_s({}, d), {}, { tickCoord: h > 0 ? d.coordinate - h * t : d.coordinate }); var m = YN(t, d.tickCoord, function () { return f }, c, u); m && (u = d.tickCoord - t * (f / 2 + i), s[o - 1] = _s(_s({}, d), {}, { isShow: !0 })) } for (var g = a ? o - 1 : o, x = function (E) { var M = s[E], C, N = function () { return C === void 0 && (C = n(M, E)), C }; if (E === 0) { var A = t * (M.coordinate - t * N() / 2 - c); s[E] = M = _s(_s({}, M), {}, { tickCoord: A < 0 ? M.coordinate - A * t : M.coordinate }) } else s[E] = M = _s(_s({}, M), {}, { tickCoord: M.coordinate }); var j = YN(t, M.tickCoord, N, c, u); j && (c = M.tickCoord + t * (N() / 2 + i), s[E] = _s(_s({}, M), {}, { isShow: !0 })) }, v = 0; v < g; v++)x(v); return s } function wz(t, e, n) { var r = t.tick, i = t.ticks, a = t.viewBox, s = t.minTickGap, o = t.orientation, c = t.interval, u = t.tickFormatter, d = t.unit, f = t.angle; if (!i || !i.length || !r) return []; if (It(c) || Cf.isSsr) return eQe(i, typeof c == "number" && It(c) ? c : 0); var h = [], m = o === "top" || o === "bottom" ? "width" : "height", g = d && m === "width" ? n1(d, { fontSize: e, letterSpacing: n }) : { width: 0, height: 0 }, x = function (M, C) { var N = Rn(u) ? u(M.value, C) : M.value; return m === "width" ? QZe(n1(N, { fontSize: e, letterSpacing: n }), g, f) : n1(N, { fontSize: e, letterSpacing: n })[m] }, v = i.length >= 2 ? Js(i[1].coordinate - i[0].coordinate) : 1, b = JZe(a, v, m); return c === "equidistantPreserveStart" ? tQe(v, b, x, i, s) : (c === "preserveStart" || c === "preserveStartEnd" ? h = sQe(v, b, x, i, s, c === "preserveStartEnd") : h = aQe(v, b, x, i, s), h.filter(function (E) { return E.isShow })) } var oQe = ["viewBox"], lQe = ["viewBox"], cQe = ["ticks"]; function e0(t) { "@babel/helpers - typeof"; return e0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, e0(t) } function qy() { return qy = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, qy.apply(this, arguments) } function DZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ta(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? DZ(Object(n), !0).forEach(function (r) { Sz(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : DZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function g3(t, e) { if (t == null) return {}; var n = uQe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function uQe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function dQe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function LZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, dhe(r.key), r) } } function fQe(t, e, n) { return e && LZ(t.prototype, e), n && LZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function hQe(t, e, n) { return e = KN(e), pQe(t, uhe() ? Reflect.construct(e, n || [], KN(t).constructor) : e.apply(t, n)) } function pQe(t, e) { if (e && (e0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return mQe(t) } function mQe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function uhe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (uhe = function () { return !!t })() } function KN(t) { return KN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, KN(t) } function gQe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && CF(t, e) } function CF(t, e) { return CF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, CF(t, e) } function Sz(t, e, n) { return e = dhe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function dhe(t) { var e = vQe(t, "string"); return e0(e) == "symbol" ? e : e + "" } function vQe(t, e) { if (e0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (e0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var V0 = (function (t) { function e(n) { var r; return dQe(this, e), r = hQe(this, e, [n]), r.state = { fontSize: "", letterSpacing: "" }, r } return gQe(e, t), fQe(e, [{ key: "shouldComponentUpdate", value: function (r, i) { var a = r.viewBox, s = g3(r, oQe), o = this.props, c = o.viewBox, u = g3(o, lQe); return !tx(a, c) || !tx(s, u) || !tx(i, this.state) } }, { key: "componentDidMount", value: function () { var r = this.layerReference; if (r) { var i = r.getElementsByClassName("recharts-cartesian-axis-tick-value")[0]; i && this.setState({ fontSize: window.getComputedStyle(i).fontSize, letterSpacing: window.getComputedStyle(i).letterSpacing }) } } }, { key: "getTickLineCoord", value: function (r) { var i = this.props, a = i.x, s = i.y, o = i.width, c = i.height, u = i.orientation, d = i.tickSize, f = i.mirror, h = i.tickMargin, m, g, x, v, b, E, M = f ? -1 : 1, C = r.tickSize || d, N = It(r.tickCoord) ? r.tickCoord : r.coordinate; switch (u) { case "top": m = g = r.coordinate, v = s + +!f * c, x = v - M * C, E = x - M * h, b = N; break; case "left": x = v = r.coordinate, g = a + +!f * o, m = g - M * C, b = m - M * h, E = N; break; case "right": x = v = r.coordinate, g = a + +f * o, m = g + M * C, b = m + M * h, E = N; break; default: m = g = r.coordinate, v = s + +f * c, x = v + M * C, E = x + M * h, b = N; break }return { line: { x1: m, y1: x, x2: g, y2: v }, tick: { x: b, y: E } } } }, { key: "getTickTextAnchor", value: function () { var r = this.props, i = r.orientation, a = r.mirror, s; switch (i) { case "left": s = a ? "start" : "end"; break; case "right": s = a ? "end" : "start"; break; default: s = "middle"; break }return s } }, { key: "getTickVerticalAnchor", value: function () { var r = this.props, i = r.orientation, a = r.mirror, s = "end"; switch (i) { case "left": case "right": s = "middle"; break; case "top": s = a ? "start" : "end"; break; default: s = a ? "end" : "start"; break }return s } }, { key: "renderAxisLine", value: function () { var r = this.props, i = r.x, a = r.y, s = r.width, o = r.height, c = r.orientation, u = r.mirror, d = r.axisLine, f = Ta(Ta(Ta({}, vn(this.props, !1)), vn(d, !1)), {}, { fill: "none" }); if (c === "top" || c === "bottom") { var h = +(c === "top" && !u || c === "bottom" && u); f = Ta(Ta({}, f), {}, { x1: i, y1: a + h * o, x2: i + s, y2: a + h * o }) } else { var m = +(c === "left" && !u || c === "right" && u); f = Ta(Ta({}, f), {}, { x1: i + m * s, y1: a, x2: i + m * s, y2: a + o }) } return P.createElement("line", qy({}, f, { className: zn("recharts-cartesian-axis-line", pl(d, "className")) })) } }, { key: "renderTicks", value: function (r, i, a) { var s = this, o = this.props, c = o.tickLine, u = o.stroke, d = o.tick, f = o.tickFormatter, h = o.unit, m = wz(Ta(Ta({}, this.props), {}, { ticks: r }), i, a), g = this.getTickTextAnchor(), x = this.getTickVerticalAnchor(), v = vn(this.props, !1), b = vn(d, !1), E = Ta(Ta({}, v), {}, { fill: "none" }, vn(c, !1)), M = m.map(function (C, N) { var A = s.getTickLineCoord(C), j = A.line, O = A.tick, I = Ta(Ta(Ta(Ta({ textAnchor: g, verticalAnchor: x }, v), {}, { stroke: "none", fill: u }, b), O), {}, { index: N, payload: C, visibleTicksCount: m.length, tickFormatter: f }); return P.createElement(ar, qy({ className: "recharts-cartesian-axis-tick", key: "tick-".concat(C.value, "-").concat(C.coordinate, "-").concat(C.tickCoord) }, ap(s.props, C, N)), c && P.createElement("line", qy({}, E, j, { className: zn("recharts-cartesian-axis-tick-line", pl(c, "className")) })), d && e.renderTickItem(d, I, "".concat(Rn(f) ? f(C.value, N) : C.value).concat(h || ""))) }); return P.createElement("g", { className: "recharts-cartesian-axis-ticks" }, M) } }, { key: "render", value: function () { var r = this, i = this.props, a = i.axisLine, s = i.width, o = i.height, c = i.ticksGenerator, u = i.className, d = i.hide; if (d) return null; var f = this.props, h = f.ticks, m = g3(f, cQe), g = h; return Rn(c) && (g = h && h.length > 0 ? c(this.props) : c(m)), s <= 0 || o <= 0 || !g || !g.length ? null : P.createElement(ar, { className: zn("recharts-cartesian-axis", u), ref: function (v) { r.layerReference = v } }, a && this.renderAxisLine(), this.renderTicks(g, this.state.fontSize, this.state.letterSpacing), ei.renderCallByParent(this.props)) } }], [{ key: "renderTickItem", value: function (r, i, a) { var s, o = zn(i.className, "recharts-cartesian-axis-tick-value"); return P.isValidElement(r) ? s = P.cloneElement(r, Ta(Ta({}, i), {}, { className: o })) : Rn(r) ? s = r(Ta(Ta({}, i), {}, { className: o })) : s = P.createElement(Rg, qy({}, i, { className: "recharts-cartesian-axis-tick-value" }), a), s } }]) })(S.Component); Sz(V0, "displayName", "CartesianAxis"); Sz(V0, "defaultProps", { x: 0, y: 0, width: 0, height: 0, viewBox: { x: 0, y: 0, width: 0, height: 0 }, orientation: "bottom", ticks: [], stroke: "#666", tickLine: !0, axisLine: !0, tick: !0, mirror: !1, minTickGap: 5, tickSize: 6, tickMargin: 2, interval: "preserveEnd" }); var yQe = ["x1", "y1", "x2", "y2", "key"], xQe = ["offset"]; function Og(t) { "@babel/helpers - typeof"; return Og = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Og(t) } function FZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ts(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? FZ(Object(n), !0).forEach(function (r) { bQe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : FZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function bQe(t, e, n) { return e = wQe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function wQe(t) { var e = SQe(t, "string"); return Og(e) == "symbol" ? e : e + "" } function SQe(t, e) { if (Og(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (Og(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function ig() { return ig = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, ig.apply(this, arguments) } function UZ(t, e) { if (t == null) return {}; var n = _Qe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function _Qe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } var EQe = function (e) { var n = e.fill; if (!n || n === "none") return null; var r = e.fillOpacity, i = e.x, a = e.y, s = e.width, o = e.height, c = e.ry; return P.createElement("rect", { x: i, y: a, ry: c, width: s, height: o, stroke: "none", fill: n, fillOpacity: r, className: "recharts-cartesian-grid-bg" }) }; function fhe(t, e) { var n; if (P.isValidElement(t)) n = P.cloneElement(t, e); else if (Rn(t)) n = t(e); else { var r = e.x1, i = e.y1, a = e.x2, s = e.y2, o = e.key, c = UZ(e, yQe), u = vn(c, !1); u.offset; var d = UZ(u, xQe); n = P.createElement("line", ig({}, d, { x1: r, y1: i, x2: a, y2: s, fill: "none", key: o })) } return n } function MQe(t) { var e = t.x, n = t.width, r = t.horizontal, i = r === void 0 ? !0 : r, a = t.horizontalPoints; if (!i || !a || !a.length) return null; var s = a.map(function (o, c) { var u = Ts(Ts({}, t), {}, { x1: e, y1: o, x2: e + n, y2: o, key: "line-".concat(c), index: c }); return fhe(i, u) }); return P.createElement("g", { className: "recharts-cartesian-grid-horizontal" }, s) } function TQe(t) { var e = t.y, n = t.height, r = t.vertical, i = r === void 0 ? !0 : r, a = t.verticalPoints; if (!i || !a || !a.length) return null; var s = a.map(function (o, c) { var u = Ts(Ts({}, t), {}, { x1: o, y1: e, x2: o, y2: e + n, key: "line-".concat(c), index: c }); return fhe(i, u) }); return P.createElement("g", { className: "recharts-cartesian-grid-vertical" }, s) } function CQe(t) { var e = t.horizontalFill, n = t.fillOpacity, r = t.x, i = t.y, a = t.width, s = t.height, o = t.horizontalPoints, c = t.horizontal, u = c === void 0 ? !0 : c; if (!u || !e || !e.length) return null; var d = o.map(function (h) { return Math.round(h + i - i) }).sort(function (h, m) { return h - m }); i !== d[0] && d.unshift(0); var f = d.map(function (h, m) { var g = !d[m + 1], x = g ? i + s - h : d[m + 1] - h; if (x <= 0) return null; var v = m % e.length; return P.createElement("rect", { key: "react-".concat(m), y: h, x: r, height: x, width: a, stroke: "none", fill: e[v], fillOpacity: n, className: "recharts-cartesian-grid-bg" }) }); return P.createElement("g", { className: "recharts-cartesian-gridstripes-horizontal" }, f) } function NQe(t) { var e = t.vertical, n = e === void 0 ? !0 : e, r = t.verticalFill, i = t.fillOpacity, a = t.x, s = t.y, o = t.width, c = t.height, u = t.verticalPoints; if (!n || !r || !r.length) return null; var d = u.map(function (h) { return Math.round(h + a - a) }).sort(function (h, m) { return h - m }); a !== d[0] && d.unshift(0); var f = d.map(function (h, m) { var g = !d[m + 1], x = g ? a + o - h : d[m + 1] - h; if (x <= 0) return null; var v = m % r.length; return P.createElement("rect", { key: "react-".concat(m), x: h, y: s, width: x, height: c, stroke: "none", fill: r[v], fillOpacity: i, className: "recharts-cartesian-grid-bg" }) }); return P.createElement("g", { className: "recharts-cartesian-gridstripes-vertical" }, f) } var AQe = function (e, n) { var r = e.xAxis, i = e.width, a = e.height, s = e.offset; return mfe(wz(Ts(Ts(Ts({}, V0.defaultProps), r), {}, { ticks: af(r, !0), viewBox: { x: 0, y: 0, width: i, height: a } })), s.left, s.left + s.width, n) }, PQe = function (e, n) { var r = e.yAxis, i = e.width, a = e.height, s = e.offset; return mfe(wz(Ts(Ts(Ts({}, V0.defaultProps), r), {}, { ticks: af(r, !0), viewBox: { x: 0, y: 0, width: i, height: a } })), s.top, s.top + s.height, n) }, My = { horizontal: !0, vertical: !0, stroke: "#ccc", fill: "none", verticalFill: [], horizontalFill: [] }; function P_(t) { var e, n, r, i, a, s, o = vz(), c = yz(), u = vZe(), d = Ts(Ts({}, t), {}, { stroke: (e = t.stroke) !== null && e !== void 0 ? e : My.stroke, fill: (n = t.fill) !== null && n !== void 0 ? n : My.fill, horizontal: (r = t.horizontal) !== null && r !== void 0 ? r : My.horizontal, horizontalFill: (i = t.horizontalFill) !== null && i !== void 0 ? i : My.horizontalFill, vertical: (a = t.vertical) !== null && a !== void 0 ? a : My.vertical, verticalFill: (s = t.verticalFill) !== null && s !== void 0 ? s : My.verticalFill, x: It(t.x) ? t.x : u.left, y: It(t.y) ? t.y : u.top, width: It(t.width) ? t.width : u.width, height: It(t.height) ? t.height : u.height }), f = d.x, h = d.y, m = d.width, g = d.height, x = d.syncWithTicks, v = d.horizontalValues, b = d.verticalValues, E = pZe(), M = mZe(); if (!It(m) || m <= 0 || !It(g) || g <= 0 || !It(f) || f !== +f || !It(h) || h !== +h) return null; var C = d.verticalCoordinatesGenerator || AQe, N = d.horizontalCoordinatesGenerator || PQe, A = d.horizontalPoints, j = d.verticalPoints; if ((!A || !A.length) && Rn(N)) { var O = v && v.length, I = N({ yAxis: M ? Ts(Ts({}, M), {}, { ticks: O ? v : M.ticks }) : void 0, width: o, height: c, offset: u }, O ? !0 : x); Bc(Array.isArray(I), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(Og(I), "]")), Array.isArray(I) && (A = I) } if ((!j || !j.length) && Rn(C)) { var D = b && b.length, F = C({ xAxis: E ? Ts(Ts({}, E), {}, { ticks: D ? b : E.ticks }) : void 0, width: o, height: c, offset: u }, D ? !0 : x); Bc(Array.isArray(F), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(Og(F), "]")), Array.isArray(F) && (j = F) } return P.createElement("g", { className: "recharts-cartesian-grid" }, P.createElement(EQe, { fill: d.fill, fillOpacity: d.fillOpacity, x: d.x, y: d.y, width: d.width, height: d.height, ry: d.ry }), P.createElement(MQe, ig({}, d, { offset: u, horizontalPoints: A, xAxis: E, yAxis: M })), P.createElement(TQe, ig({}, d, { offset: u, verticalPoints: j, xAxis: E, yAxis: M })), P.createElement(CQe, ig({}, d, { horizontalPoints: A })), P.createElement(NQe, ig({}, d, { verticalPoints: j }))) } P_.displayName = "CartesianGrid"; var jQe = ["type", "layout", "connectNulls", "ref"], RQe = ["key"]; function t0(t) { "@babel/helpers - typeof"; return t0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, t0(t) } function BZ(t, e) { if (t == null) return {}; var n = kQe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function kQe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function l1() { return l1 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, l1.apply(this, arguments) } function $Z(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function nl(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? $Z(Object(n), !0).forEach(function (r) { Rc(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $Z(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Ty(t) { return LQe(t) || DQe(t) || OQe(t) || IQe() } function IQe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function OQe(t, e) { if (t) { if (typeof t == "string") return NF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return NF(t, e) } } function DQe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function LQe(t) { if (Array.isArray(t)) return NF(t) } function NF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function FQe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function zZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, phe(r.key), r) } } function UQe(t, e, n) { return e && zZ(t.prototype, e), n && zZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function BQe(t, e, n) { return e = ZN(e), $Qe(t, hhe() ? Reflect.construct(e, n || [], ZN(t).constructor) : e.apply(t, n)) } function $Qe(t, e) { if (e && (t0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return zQe(t) } function zQe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function hhe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (hhe = function () { return !!t })() } function ZN(t) { return ZN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, ZN(t) } function VQe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && AF(t, e) } function AF(t, e) { return AF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, AF(t, e) } function Rc(t, e, n) { return e = phe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function phe(t) { var e = HQe(t, "string"); return t0(e) == "symbol" ? e : e + "" } function HQe(t, e) { if (t0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (t0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var op = (function (t) { function e() { var n; FQe(this, e); for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; return n = BQe(this, e, [].concat(i)), Rc(n, "state", { isAnimationFinished: !0, totalLength: 0 }), Rc(n, "generateSimpleStrokeDasharray", function (s, o) { return "".concat(o, "px ").concat(s - o, "px") }), Rc(n, "getStrokeDasharray", function (s, o, c) { var u = c.reduce(function (b, E) { return b + E }); if (!u) return n.generateSimpleStrokeDasharray(o, s); for (var d = Math.floor(s / u), f = s % u, h = o - s, m = [], g = 0, x = 0; g < c.length; x += c[g], ++g)if (x + c[g] > f) { m = [].concat(Ty(c.slice(0, g)), [f - x]); break } var v = m.length % 2 === 0 ? [0, h] : [h]; return [].concat(Ty(e.repeat(c, d)), Ty(m), v).map(function (b) { return "".concat(b, "px") }).join(", ") }), Rc(n, "id", Ep("recharts-line-")), Rc(n, "pathRef", function (s) { n.mainCurve = s }), Rc(n, "handleAnimationEnd", function () { n.setState({ isAnimationFinished: !0 }), n.props.onAnimationEnd && n.props.onAnimationEnd() }), Rc(n, "handleAnimationStart", function () { n.setState({ isAnimationFinished: !1 }), n.props.onAnimationStart && n.props.onAnimationStart() }), n } return VQe(e, t), UQe(e, [{ key: "componentDidMount", value: function () { if (this.props.isAnimationActive) { var r = this.getTotalLength(); this.setState({ totalLength: r }) } } }, { key: "componentDidUpdate", value: function () { if (this.props.isAnimationActive) { var r = this.getTotalLength(); r !== this.state.totalLength && this.setState({ totalLength: r }) } } }, { key: "getTotalLength", value: function () { var r = this.mainCurve; try { return r && r.getTotalLength && r.getTotalLength() || 0 } catch { return 0 } } }, { key: "renderErrorBar", value: function (r, i) { if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null; var a = this.props, s = a.points, o = a.xAxis, c = a.yAxis, u = a.layout, d = a.children, f = so(d, z0); if (!f) return null; var h = function (x, v) { return { x: x.x, y: x.y, value: x.value, errorVal: Ci(x.payload, v) } }, m = { clipPath: r ? "url(#clipPath-".concat(i, ")") : null }; return P.createElement(ar, m, f.map(function (g) { return P.cloneElement(g, { key: "bar-".concat(g.props.dataKey), data: s, xAxis: o, yAxis: c, layout: u, dataPointFormatter: h }) })) } }, { key: "renderDots", value: function (r, i, a) { var s = this.props.isAnimationActive; if (s && !this.state.isAnimationFinished) return null; var o = this.props, c = o.dot, u = o.points, d = o.dataKey, f = vn(this.props, !1), h = vn(c, !0), m = u.map(function (x, v) { var b = nl(nl(nl({ key: "dot-".concat(v), r: 3 }, f), h), {}, { index: v, cx: x.x, cy: x.y, value: x.value, dataKey: d, payload: x.payload, points: u }); return e.renderDotItem(c, b) }), g = { clipPath: r ? "url(#clipPath-".concat(i ? "" : "dots-").concat(a, ")") : null }; return P.createElement(ar, l1({ className: "recharts-line-dots", key: "dots" }, g), m) } }, { key: "renderCurveStatically", value: function (r, i, a, s) { var o = this.props, c = o.type, u = o.layout, d = o.connectNulls; o.ref; var f = BZ(o, jQe), h = nl(nl(nl({}, vn(f, !0)), {}, { fill: "none", className: "recharts-line-curve", clipPath: i ? "url(#clipPath-".concat(a, ")") : null, points: r }, s), {}, { type: c, layout: u, connectNulls: d }); return P.createElement(Xh, l1({}, h, { pathRef: this.pathRef })) } }, { key: "renderCurveWithAnimation", value: function (r, i) { var a = this, s = this.props, o = s.points, c = s.strokeDasharray, u = s.isAnimationActive, d = s.animationBegin, f = s.animationDuration, h = s.animationEasing, m = s.animationId, g = s.animateNewValues, x = s.width, v = s.height, b = this.state, E = b.prevPoints, M = b.totalLength; return P.createElement(ql, { begin: d, duration: f, isActive: u, easing: h, from: { t: 0 }, to: { t: 1 }, key: "line-".concat(m), onAnimationEnd: this.handleAnimationEnd, onAnimationStart: this.handleAnimationStart }, function (C) { var N = C.t; if (E) { var A = E.length / o.length, j = o.map(function (B, G) { var z = Math.floor(G * A); if (E[z]) { var q = E[z], Y = Di(q.x, B.x), Z = Di(q.y, B.y); return nl(nl({}, B), {}, { x: Y(N), y: Z(N) }) } if (g) { var $ = Di(x * 2, B.x), V = Di(v / 2, B.y); return nl(nl({}, B), {}, { x: $(N), y: V(N) }) } return nl(nl({}, B), {}, { x: B.x, y: B.y }) }); return a.renderCurveStatically(j, r, i) } var O = Di(0, M), I = O(N), D; if (c) { var F = "".concat(c).split(/[,\s]+/gim).map(function (B) { return parseFloat(B) }); D = a.getStrokeDasharray(I, M, F) } else D = a.generateSimpleStrokeDasharray(M, I); return a.renderCurveStatically(o, r, i, { strokeDasharray: D }) }) } }, { key: "renderCurve", value: function (r, i) { var a = this.props, s = a.points, o = a.isAnimationActive, c = this.state, u = c.prevPoints, d = c.totalLength; return o && s && s.length && (!u && d > 0 || !sp(u, s)) ? this.renderCurveWithAnimation(r, i) : this.renderCurveStatically(s, r, i) } }, { key: "render", value: function () { var r, i = this.props, a = i.hide, s = i.dot, o = i.points, c = i.className, u = i.xAxis, d = i.yAxis, f = i.top, h = i.left, m = i.width, g = i.height, x = i.isAnimationActive, v = i.id; if (a || !o || !o.length) return null; var b = this.state.isAnimationFinished, E = o.length === 1, M = zn("recharts-line", c), C = u && u.allowDataOverflow, N = d && d.allowDataOverflow, A = C || N, j = An(v) ? this.id : v, O = (r = vn(s, !1)) !== null && r !== void 0 ? r : { r: 3, strokeWidth: 2 }, I = O.r, D = I === void 0 ? 3 : I, F = O.strokeWidth, B = F === void 0 ? 2 : F, G = vue(s) ? s : {}, z = G.clipDot, q = z === void 0 ? !0 : z, Y = D * 2 + B; return P.createElement(ar, { className: M }, C || N ? P.createElement("defs", null, P.createElement("clipPath", { id: "clipPath-".concat(j) }, P.createElement("rect", { x: C ? h : h - m / 2, y: N ? f : f - g / 2, width: C ? m : m * 2, height: N ? g : g * 2 })), !q && P.createElement("clipPath", { id: "clipPath-dots-".concat(j) }, P.createElement("rect", { x: h - Y / 2, y: f - Y / 2, width: m + Y, height: g + Y }))) : null, !E && this.renderCurve(A, j), this.renderErrorBar(A, j), (E || s) && this.renderDots(A, q, j), (!x || b) && $c.renderCallByParent(this.props, o)) } }], [{ key: "getDerivedStateFromProps", value: function (r, i) { return r.animationId !== i.prevAnimationId ? { prevAnimationId: r.animationId, curPoints: r.points, prevPoints: i.curPoints } : r.points !== i.curPoints ? { curPoints: r.points } : null } }, { key: "repeat", value: function (r, i) { for (var a = r.length % 2 !== 0 ? [].concat(Ty(r), [0]) : r, s = [], o = 0; o < i; ++o)s = [].concat(Ty(s), Ty(a)); return s } }, { key: "renderDotItem", value: function (r, i) { var a; if (P.isValidElement(r)) a = P.cloneElement(r, i); else if (Rn(r)) a = r(i); else { var s = i.key, o = BZ(i, RQe), c = zn("recharts-line-dot", typeof r != "boolean" ? r.className : ""); a = P.createElement(Gu, l1({ key: s }, o, { className: c })) } return a } }]) })(S.PureComponent); Rc(op, "displayName", "Line"); Rc(op, "defaultProps", { xAxisId: 0, yAxisId: 0, connectNulls: !1, activeDot: !0, dot: !0, legendType: "line", stroke: "#3182bd", strokeWidth: 1, fill: "#fff", points: [], isAnimationActive: !Cf.isSsr, animateNewValues: !0, animationBegin: 0, animationDuration: 1500, animationEasing: "ease", hide: !1, label: !1 }); Rc(op, "getComposedData", function (t) { var e = t.props, n = t.xAxis, r = t.yAxis, i = t.xAxisTicks, a = t.yAxisTicks, s = t.dataKey, o = t.bandSize, c = t.displayedData, u = t.offset, d = e.layout, f = c.map(function (h, m) { var g = Ci(h, s); return d === "horizontal" ? { x: Vx({ axis: n, ticks: i, bandSize: o, entry: h, index: m }), y: An(g) ? null : r.scale(g), value: g, payload: h } : { x: An(g) ? null : n.scale(g), y: Vx({ axis: r, ticks: a, bandSize: o, entry: h, index: m }), value: g, payload: h } }); return nl({ points: f, layout: d }, u) }); var WQe = ["layout", "type", "stroke", "connectNulls", "isRange", "ref"], GQe = ["key"], mhe; function n0(t) { "@babel/helpers - typeof"; return n0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n0(t) } function ghe(t, e) { if (t == null) return {}; var n = qQe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function qQe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function ag() { return ag = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, ag.apply(this, arguments) } function VZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ch(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? VZ(Object(n), !0).forEach(function (r) { Eu(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : VZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function XQe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function HZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, yhe(r.key), r) } } function YQe(t, e, n) { return e && HZ(t.prototype, e), n && HZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function KQe(t, e, n) { return e = QN(e), ZQe(t, vhe() ? Reflect.construct(e, n || [], QN(t).constructor) : e.apply(t, n)) } function ZQe(t, e) { if (e && (n0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return QQe(t) } function QQe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function vhe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (vhe = function () { return !!t })() } function QN(t) { return QN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, QN(t) } function JQe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && PF(t, e) } function PF(t, e) { return PF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, PF(t, e) } function Eu(t, e, n) { return e = yhe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function yhe(t) { var e = eJe(t, "string"); return n0(e) == "symbol" ? e : e + "" } function eJe(t, e) { if (n0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (n0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var Pf = (function (t) { function e() { var n; XQe(this, e); for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; return n = KQe(this, e, [].concat(i)), Eu(n, "state", { isAnimationFinished: !0 }), Eu(n, "id", Ep("recharts-area-")), Eu(n, "handleAnimationEnd", function () { var s = n.props.onAnimationEnd; n.setState({ isAnimationFinished: !0 }), Rn(s) && s() }), Eu(n, "handleAnimationStart", function () { var s = n.props.onAnimationStart; n.setState({ isAnimationFinished: !1 }), Rn(s) && s() }), n } return JQe(e, t), YQe(e, [{ key: "renderDots", value: function (r, i, a) { var s = this.props.isAnimationActive, o = this.state.isAnimationFinished; if (s && !o) return null; var c = this.props, u = c.dot, d = c.points, f = c.dataKey, h = vn(this.props, !1), m = vn(u, !0), g = d.map(function (v, b) { var E = Ch(Ch(Ch({ key: "dot-".concat(b), r: 3 }, h), m), {}, { index: b, cx: v.x, cy: v.y, dataKey: f, value: v.value, payload: v.payload, points: d }); return e.renderDotItem(u, E) }), x = { clipPath: r ? "url(#clipPath-".concat(i ? "" : "dots-").concat(a, ")") : null }; return P.createElement(ar, ag({ className: "recharts-area-dots" }, x), g) } }, { key: "renderHorizontalRect", value: function (r) { var i = this.props, a = i.baseLine, s = i.points, o = i.strokeWidth, c = s[0].x, u = s[s.length - 1].x, d = r * Math.abs(c - u), f = Lh(s.map(function (h) { return h.y || 0 })); return It(a) && typeof a == "number" ? f = Math.max(a, f) : a && Array.isArray(a) && a.length && (f = Math.max(Lh(a.map(function (h) { return h.y || 0 })), f)), It(f) ? P.createElement("rect", { x: c < u ? c : c - d, y: 0, width: d, height: Math.floor(f + (o ? parseInt("".concat(o), 10) : 1)) }) : null } }, { key: "renderVerticalRect", value: function (r) { var i = this.props, a = i.baseLine, s = i.points, o = i.strokeWidth, c = s[0].y, u = s[s.length - 1].y, d = r * Math.abs(c - u), f = Lh(s.map(function (h) { return h.x || 0 })); return It(a) && typeof a == "number" ? f = Math.max(a, f) : a && Array.isArray(a) && a.length && (f = Math.max(Lh(a.map(function (h) { return h.x || 0 })), f)), It(f) ? P.createElement("rect", { x: 0, y: c < u ? c : c - d, width: f + (o ? parseInt("".concat(o), 10) : 1), height: Math.floor(d) }) : null } }, { key: "renderClipRect", value: function (r) { var i = this.props.layout; return i === "vertical" ? this.renderVerticalRect(r) : this.renderHorizontalRect(r) } }, { key: "renderAreaStatically", value: function (r, i, a, s) { var o = this.props, c = o.layout, u = o.type, d = o.stroke, f = o.connectNulls, h = o.isRange; o.ref; var m = ghe(o, WQe); return P.createElement(ar, { clipPath: a ? "url(#clipPath-".concat(s, ")") : null }, P.createElement(Xh, ag({}, vn(m, !0), { points: r, connectNulls: f, type: u, baseLine: i, layout: c, stroke: "none", className: "recharts-area-area" })), d !== "none" && P.createElement(Xh, ag({}, vn(this.props, !1), { className: "recharts-area-curve", layout: c, type: u, connectNulls: f, fill: "none", points: r })), d !== "none" && h && P.createElement(Xh, ag({}, vn(this.props, !1), { className: "recharts-area-curve", layout: c, type: u, connectNulls: f, fill: "none", points: i }))) } }, { key: "renderAreaWithAnimation", value: function (r, i) { var a = this, s = this.props, o = s.points, c = s.baseLine, u = s.isAnimationActive, d = s.animationBegin, f = s.animationDuration, h = s.animationEasing, m = s.animationId, g = this.state, x = g.prevPoints, v = g.prevBaseLine; return P.createElement(ql, { begin: d, duration: f, isActive: u, easing: h, from: { t: 0 }, to: { t: 1 }, key: "area-".concat(m), onAnimationEnd: this.handleAnimationEnd, onAnimationStart: this.handleAnimationStart }, function (b) { var E = b.t; if (x) { var M = x.length / o.length, C = o.map(function (O, I) { var D = Math.floor(I * M); if (x[D]) { var F = x[D], B = Di(F.x, O.x), G = Di(F.y, O.y); return Ch(Ch({}, O), {}, { x: B(E), y: G(E) }) } return O }), N; if (It(c) && typeof c == "number") { var A = Di(v, c); N = A(E) } else if (An(c) || L0(c)) { var j = Di(v, 0); N = j(E) } else N = c.map(function (O, I) { var D = Math.floor(I * M); if (v[D]) { var F = v[D], B = Di(F.x, O.x), G = Di(F.y, O.y); return Ch(Ch({}, O), {}, { x: B(E), y: G(E) }) } return O }); return a.renderAreaStatically(C, N, r, i) } return P.createElement(ar, null, P.createElement("defs", null, P.createElement("clipPath", { id: "animationClipPath-".concat(i) }, a.renderClipRect(E))), P.createElement(ar, { clipPath: "url(#animationClipPath-".concat(i, ")") }, a.renderAreaStatically(o, c, r, i))) }) } }, { key: "renderArea", value: function (r, i) { var a = this.props, s = a.points, o = a.baseLine, c = a.isAnimationActive, u = this.state, d = u.prevPoints, f = u.prevBaseLine, h = u.totalLength; return c && s && s.length && (!d && h > 0 || !sp(d, s) || !sp(f, o)) ? this.renderAreaWithAnimation(r, i) : this.renderAreaStatically(s, o, r, i) } }, { key: "render", value: function () { var r, i = this.props, a = i.hide, s = i.dot, o = i.points, c = i.className, u = i.top, d = i.left, f = i.xAxis, h = i.yAxis, m = i.width, g = i.height, x = i.isAnimationActive, v = i.id; if (a || !o || !o.length) return null; var b = this.state.isAnimationFinished, E = o.length === 1, M = zn("recharts-area", c), C = f && f.allowDataOverflow, N = h && h.allowDataOverflow, A = C || N, j = An(v) ? this.id : v, O = (r = vn(s, !1)) !== null && r !== void 0 ? r : { r: 3, strokeWidth: 2 }, I = O.r, D = I === void 0 ? 3 : I, F = O.strokeWidth, B = F === void 0 ? 2 : F, G = vue(s) ? s : {}, z = G.clipDot, q = z === void 0 ? !0 : z, Y = D * 2 + B; return P.createElement(ar, { className: M }, C || N ? P.createElement("defs", null, P.createElement("clipPath", { id: "clipPath-".concat(j) }, P.createElement("rect", { x: C ? d : d - m / 2, y: N ? u : u - g / 2, width: C ? m : m * 2, height: N ? g : g * 2 })), !q && P.createElement("clipPath", { id: "clipPath-dots-".concat(j) }, P.createElement("rect", { x: d - Y / 2, y: u - Y / 2, width: m + Y, height: g + Y }))) : null, E ? null : this.renderArea(A, j), (s || E) && this.renderDots(A, q, j), (!x || b) && $c.renderCallByParent(this.props, o)) } }], [{ key: "getDerivedStateFromProps", value: function (r, i) { return r.animationId !== i.prevAnimationId ? { prevAnimationId: r.animationId, curPoints: r.points, curBaseLine: r.baseLine, prevPoints: i.curPoints, prevBaseLine: i.curBaseLine } : r.points !== i.curPoints || r.baseLine !== i.curBaseLine ? { curPoints: r.points, curBaseLine: r.baseLine } : null } }]) })(S.PureComponent); mhe = Pf; Eu(Pf, "displayName", "Area"); Eu(Pf, "defaultProps", { stroke: "#3182bd", fill: "#3182bd", fillOpacity: .6, xAxisId: 0, yAxisId: 0, legendType: "line", connectNulls: !1, points: [], dot: !1, activeDot: !0, hide: !1, isAnimationActive: !Cf.isSsr, animationBegin: 0, animationDuration: 1500, animationEasing: "ease" }); Eu(Pf, "getBaseValue", function (t, e, n, r) { var i = t.layout, a = t.baseValue, s = e.props.baseValue, o = s ?? a; if (It(o) && typeof o == "number") return o; var c = i === "horizontal" ? r : n, u = c.scale.domain(); if (c.type === "number") { var d = Math.max(u[0], u[1]), f = Math.min(u[0], u[1]); return o === "dataMin" ? f : o === "dataMax" || d < 0 ? d : Math.max(Math.min(u[0], u[1]), 0) } return o === "dataMin" ? u[0] : o === "dataMax" ? u[1] : u[0] }); Eu(Pf, "getComposedData", function (t) { var e = t.props, n = t.item, r = t.xAxis, i = t.yAxis, a = t.xAxisTicks, s = t.yAxisTicks, o = t.bandSize, c = t.dataKey, u = t.stackedData, d = t.dataStartIndex, f = t.displayedData, h = t.offset, m = e.layout, g = u && u.length, x = mhe.getBaseValue(e, n, r, i), v = m === "horizontal", b = !1, E = f.map(function (C, N) { var A; g ? A = u[d + N] : (A = Ci(C, c), Array.isArray(A) ? b = !0 : A = [x, A]); var j = A[1] == null || g && Ci(C, c) == null; return v ? { x: Vx({ axis: r, ticks: a, bandSize: o, entry: C, index: N }), y: j ? null : i.scale(A[1]), value: A, payload: C } : { x: j ? null : r.scale(A[1]), y: Vx({ axis: i, ticks: s, bandSize: o, entry: C, index: N }), value: A, payload: C } }), M; return g || b ? M = E.map(function (C) { var N = Array.isArray(C.value) ? C.value[0] : null; return v ? { x: C.x, y: N != null && C.y != null ? i.scale(N) : null } : { x: N != null ? r.scale(N) : null, y: C.y } }) : M = v ? i.scale(x) : r.scale(x), Ch({ points: E, baseLine: M, layout: m, isRange: b }, h) }); Eu(Pf, "renderDotItem", function (t, e) { var n; if (P.isValidElement(t)) n = P.cloneElement(t, e); else if (Rn(t)) n = t(e); else { var r = zn("recharts-area-dot", typeof t != "boolean" ? t.className : ""), i = e.key, a = ghe(e, GQe); n = P.createElement(Gu, ag({}, a, { key: i, className: r })) } return n }); function r0(t) { "@babel/helpers - typeof"; return r0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, r0(t) } function tJe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function nJe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, whe(r.key), r) } } function rJe(t, e, n) { return e && nJe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function iJe(t, e, n) { return e = JN(e), aJe(t, xhe() ? Reflect.construct(e, n || [], JN(t).constructor) : e.apply(t, n)) } function aJe(t, e) { if (e && (r0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return sJe(t) } function sJe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function xhe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (xhe = function () { return !!t })() } function JN(t) { return JN = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, JN(t) } function oJe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && jF(t, e) } function jF(t, e) { return jF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, jF(t, e) } function bhe(t, e, n) { return e = whe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function whe(t) { var e = lJe(t, "string"); return r0(e) == "symbol" ? e : e + "" } function lJe(t, e) { if (r0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (r0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var j_ = (function (t) { function e() { return tJe(this, e), iJe(this, e, arguments) } return oJe(e, t), rJe(e, [{ key: "render", value: function () { return null } }]) })(S.Component); bhe(j_, "displayName", "ZAxis"); bhe(j_, "defaultProps", { zAxisId: 0, range: [64, 64], scale: "auto", type: "number" }); var cJe = ["option", "isActive"]; function c1() { return c1 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, c1.apply(this, arguments) } function uJe(t, e) { if (t == null) return {}; var n = dJe(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function dJe(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function fJe(t) { var e = t.option, n = t.isActive, r = uJe(t, cJe); return typeof e == "string" ? S.createElement(UN, c1({ option: S.createElement(B2, c1({ type: e }, r)), isActive: n, shapeType: "symbols" }, r)) : S.createElement(UN, c1({ option: e, isActive: n, shapeType: "symbols" }, r)) } function i0(t) { "@babel/helpers - typeof"; return i0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, i0(t) } function u1() { return u1 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, u1.apply(this, arguments) } function WZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Ol(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? WZ(Object(n), !0).forEach(function (r) { Uh(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : WZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function hJe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function GZ(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, _he(r.key), r) } } function pJe(t, e, n) { return e && GZ(t.prototype, e), n && GZ(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function mJe(t, e, n) { return e = eA(e), gJe(t, She() ? Reflect.construct(e, n || [], eA(t).constructor) : e.apply(t, n)) } function gJe(t, e) { if (e && (i0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return vJe(t) } function vJe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function She() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (She = function () { return !!t })() } function eA(t) { return eA = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, eA(t) } function yJe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && RF(t, e) } function RF(t, e) { return RF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, RF(t, e) } function Uh(t, e, n) { return e = _he(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function _he(t) { var e = xJe(t, "string"); return i0(e) == "symbol" ? e : e + "" } function xJe(t, e) { if (i0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (i0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var R_ = (function (t) { function e() { var n; hJe(this, e); for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; return n = mJe(this, e, [].concat(i)), Uh(n, "state", { isAnimationFinished: !1 }), Uh(n, "handleAnimationEnd", function () { n.setState({ isAnimationFinished: !0 }) }), Uh(n, "handleAnimationStart", function () { n.setState({ isAnimationFinished: !1 }) }), Uh(n, "id", Ep("recharts-scatter-")), n } return yJe(e, t), pJe(e, [{ key: "renderSymbolsStatically", value: function (r) { var i = this, a = this.props, s = a.shape, o = a.activeShape, c = a.activeIndex, u = vn(this.props, !1); return r.map(function (d, f) { var h = c === f, m = h ? o : s, g = Ol(Ol({}, u), d); return P.createElement(ar, u1({ className: "recharts-scatter-symbol", key: "symbol-".concat(d?.cx, "-").concat(d?.cy, "-").concat(d?.size, "-").concat(f) }, ap(i.props, d, f), { role: "img" }), P.createElement(fJe, u1({ option: m, isActive: h, key: "symbol-".concat(f) }, g))) }) } }, { key: "renderSymbolsWithAnimation", value: function () { var r = this, i = this.props, a = i.points, s = i.isAnimationActive, o = i.animationBegin, c = i.animationDuration, u = i.animationEasing, d = i.animationId, f = this.state.prevPoints; return P.createElement(ql, { begin: o, duration: c, isActive: s, easing: u, from: { t: 0 }, to: { t: 1 }, key: "pie-".concat(d), onAnimationEnd: this.handleAnimationEnd, onAnimationStart: this.handleAnimationStart }, function (h) { var m = h.t, g = a.map(function (x, v) { var b = f && f[v]; if (b) { var E = Di(b.cx, x.cx), M = Di(b.cy, x.cy), C = Di(b.size, x.size); return Ol(Ol({}, x), {}, { cx: E(m), cy: M(m), size: C(m) }) } var N = Di(0, x.size); return Ol(Ol({}, x), {}, { size: N(m) }) }); return P.createElement(ar, null, r.renderSymbolsStatically(g)) }) } }, { key: "renderSymbols", value: function () { var r = this.props, i = r.points, a = r.isAnimationActive, s = this.state.prevPoints; return a && i && i.length && (!s || !sp(s, i)) ? this.renderSymbolsWithAnimation() : this.renderSymbolsStatically(i) } }, { key: "renderErrorBar", value: function () { var r = this.props.isAnimationActive; if (r && !this.state.isAnimationFinished) return null; var i = this.props, a = i.points, s = i.xAxis, o = i.yAxis, c = i.children, u = so(c, z0); return u ? u.map(function (d, f) { var h = d.props, m = h.direction, g = h.dataKey; return P.cloneElement(d, { key: "".concat(m, "-").concat(g, "-").concat(a[f]), data: a, xAxis: s, yAxis: o, layout: m === "x" ? "vertical" : "horizontal", dataPointFormatter: function (v, b) { return { x: v.cx, y: v.cy, value: m === "x" ? +v.node.x : +v.node.y, errorVal: Ci(v, b) } } }) }) : null } }, { key: "renderLine", value: function () { var r = this.props, i = r.points, a = r.line, s = r.lineType, o = r.lineJointType, c = vn(this.props, !1), u = vn(a, !1), d, f; if (s === "joint") d = i.map(function (M) { return { x: M.cx, y: M.cy } }); else if (s === "fitting") { var h = y$e(i), m = h.xmin, g = h.xmax, x = h.a, v = h.b, b = function (C) { return x * C + v }; d = [{ x: m, y: b(m) }, { x: g, y: b(g) }] } var E = Ol(Ol(Ol({}, c), {}, { fill: "none", stroke: c && c.fill }, u), {}, { points: d }); return P.isValidElement(a) ? f = P.cloneElement(a, E) : Rn(a) ? f = a(E) : f = P.createElement(Xh, u1({}, E, { type: o })), P.createElement(ar, { className: "recharts-scatter-line", key: "recharts-scatter-line" }, f) } }, { key: "render", value: function () { var r = this.props, i = r.hide, a = r.points, s = r.line, o = r.className, c = r.xAxis, u = r.yAxis, d = r.left, f = r.top, h = r.width, m = r.height, g = r.id, x = r.isAnimationActive; if (i || !a || !a.length) return null; var v = this.state.isAnimationFinished, b = zn("recharts-scatter", o), E = c && c.allowDataOverflow, M = u && u.allowDataOverflow, C = E || M, N = An(g) ? this.id : g; return P.createElement(ar, { className: b, clipPath: C ? "url(#clipPath-".concat(N, ")") : null }, E || M ? P.createElement("defs", null, P.createElement("clipPath", { id: "clipPath-".concat(N) }, P.createElement("rect", { x: E ? d : d - h / 2, y: M ? f : f - m / 2, width: E ? h : h * 2, height: M ? m : m * 2 }))) : null, s && this.renderLine(), this.renderErrorBar(), P.createElement(ar, { key: "recharts-scatter-symbols" }, this.renderSymbols()), (!x || v) && $c.renderCallByParent(this.props, a)) } }], [{ key: "getDerivedStateFromProps", value: function (r, i) { return r.animationId !== i.prevAnimationId ? { prevAnimationId: r.animationId, curPoints: r.points, prevPoints: i.curPoints } : r.points !== i.curPoints ? { curPoints: r.points } : null } }]) })(S.PureComponent); Uh(R_, "displayName", "Scatter"); Uh(R_, "defaultProps", { xAxisId: 0, yAxisId: 0, zAxisId: 0, legendType: "circle", lineType: "joint", lineJointType: "linear", data: [], shape: "circle", hide: !1, isAnimationActive: !Cf.isSsr, animationBegin: 0, animationDuration: 400, animationEasing: "linear" }); Uh(R_, "getComposedData", function (t) { var e = t.xAxis, n = t.yAxis, r = t.zAxis, i = t.item, a = t.displayedData, s = t.xAxisTicks, o = t.yAxisTicks, c = t.offset, u = i.props.tooltipType, d = so(i.props.children, H2), f = An(e.dataKey) ? i.props.dataKey : e.dataKey, h = An(n.dataKey) ? i.props.dataKey : n.dataKey, m = r && r.dataKey, g = r ? r.range : j_.defaultProps.range, x = g && g[0], v = e.scale.bandwidth ? e.scale.bandwidth() : 0, b = n.scale.bandwidth ? n.scale.bandwidth() : 0, E = a.map(function (M, C) { var N = Ci(M, f), A = Ci(M, h), j = !An(m) && Ci(M, m) || "-", O = [{ name: An(e.dataKey) ? i.props.name : e.name || e.dataKey, unit: e.unit || "", value: N, payload: M, dataKey: f, type: u }, { name: An(n.dataKey) ? i.props.name : n.name || n.dataKey, unit: n.unit || "", value: A, payload: M, dataKey: h, type: u }]; j !== "-" && O.push({ name: r.name || r.dataKey, unit: r.unit || "", value: j, payload: M, dataKey: m, type: u }); var I = Vx({ axis: e, ticks: s, bandSize: v, entry: M, index: C, dataKey: f }), D = Vx({ axis: n, ticks: o, bandSize: b, entry: M, index: C, dataKey: h }), F = j !== "-" ? r.scale(j) : x, B = Math.sqrt(Math.max(F, 0) / Math.PI); return Ol(Ol({}, M), {}, { cx: I, cy: D, x: I - B, y: D - B, xAxis: e, yAxis: n, zAxis: r, width: 2 * B, height: 2 * B, size: F, node: { x: N, y: A, z: j }, tooltipPayload: O, tooltipPosition: { x: I, y: D }, payload: M }, d && d[C] && d[C].props) }); return Ol({ points: E }, c) }); function a0(t) { "@babel/helpers - typeof"; return a0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, a0(t) } function bJe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function wJe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, The(r.key), r) } } function SJe(t, e, n) { return e && wJe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function _Je(t, e, n) { return e = tA(e), EJe(t, Ehe() ? Reflect.construct(e, n || [], tA(t).constructor) : e.apply(t, n)) } function EJe(t, e) { if (e && (a0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return MJe(t) } function MJe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Ehe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Ehe = function () { return !!t })() } function tA(t) { return tA = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, tA(t) } function TJe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && kF(t, e) } function kF(t, e) { return kF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, kF(t, e) } function Mhe(t, e, n) { return e = The(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function The(t) { var e = CJe(t, "string"); return a0(e) == "symbol" ? e : e + "" } function CJe(t, e) { if (a0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (a0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } function IF() { return IF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, IF.apply(this, arguments) } function NJe(t) { var e = t.xAxisId, n = vz(), r = yz(), i = the(e); return i == null ? null : S.createElement(V0, IF({}, i, { className: zn("recharts-".concat(i.axisType, " ").concat(i.axisType), i.className), viewBox: { x: 0, y: 0, width: n, height: r }, ticksGenerator: function (s) { return af(s, !0) } })) } var $o = (function (t) { function e() { return bJe(this, e), _Je(this, e, arguments) } return TJe(e, t), SJe(e, [{ key: "render", value: function () { return S.createElement(NJe, this.props) } }]) })(S.Component); Mhe($o, "displayName", "XAxis"); Mhe($o, "defaultProps", { allowDecimals: !0, hide: !1, orientation: "bottom", width: 0, height: 30, mirror: !1, xAxisId: 0, tickCount: 5, type: "category", padding: { left: 0, right: 0 }, allowDataOverflow: !1, scale: "auto", reversed: !1, allowDuplicatedCategory: !0 }); function s0(t) { "@babel/helpers - typeof"; return s0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, s0(t) } function AJe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function PJe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Ahe(r.key), r) } } function jJe(t, e, n) { return e && PJe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function RJe(t, e, n) { return e = nA(e), kJe(t, Che() ? Reflect.construct(e, n || [], nA(t).constructor) : e.apply(t, n)) } function kJe(t, e) { if (e && (s0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return IJe(t) } function IJe(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Che() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Che = function () { return !!t })() } function nA(t) { return nA = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, nA(t) } function OJe(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && OF(t, e) } function OF(t, e) { return OF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, OF(t, e) } function Nhe(t, e, n) { return e = Ahe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Ahe(t) { var e = DJe(t, "string"); return s0(e) == "symbol" ? e : e + "" } function DJe(t, e) { if (s0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (s0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } function DF() { return DF = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, DF.apply(this, arguments) } var LJe = function (e) { var n = e.yAxisId, r = vz(), i = yz(), a = nhe(n); return a == null ? null : S.createElement(V0, DF({}, a, { className: zn("recharts-".concat(a.axisType, " ").concat(a.axisType), a.className), viewBox: { x: 0, y: 0, width: r, height: i }, ticksGenerator: function (o) { return af(o, !0) } })) }, zo = (function (t) { function e() { return AJe(this, e), RJe(this, e, arguments) } return OJe(e, t), jJe(e, [{ key: "render", value: function () { return S.createElement(LJe, this.props) } }]) })(S.Component); Nhe(zo, "displayName", "YAxis"); Nhe(zo, "defaultProps", { allowDuplicatedCategory: !0, allowDecimals: !0, hide: !1, orientation: "left", width: 60, height: 0, mirror: !1, yAxisId: 0, tickCount: 5, type: "number", padding: { top: 0, bottom: 0 }, allowDataOverflow: !1, scale: "auto", reversed: !1 }); function qZ(t) { return $Je(t) || BJe(t) || UJe(t) || FJe() } function FJe() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function UJe(t, e) { if (t) { if (typeof t == "string") return LF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LF(t, e) } } function BJe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function $Je(t) { if (Array.isArray(t)) return LF(t) } function LF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var FF = function (e, n, r, i, a) { var s = so(e, bz), o = so(e, uP), c = [].concat(qZ(s), qZ(o)), u = so(e, fP), d = "".concat(i, "Id"), f = i[0], h = n; if (c.length && (h = c.reduce(function (x, v) { if (v.props[d] === r && Iu(v.props, "extendDomain") && It(v.props[f])) { var b = v.props[f]; return [Math.min(x[0], b), Math.max(x[1], b)] } return x }, h)), u.length) { var m = "".concat(f, "1"), g = "".concat(f, "2"); h = u.reduce(function (x, v) { if (v.props[d] === r && Iu(v.props, "extendDomain") && It(v.props[m]) && It(v.props[g])) { var b = v.props[m], E = v.props[g]; return [Math.min(x[0], b, E), Math.max(x[1], b, E)] } return x }, h) } return a && a.length && (h = a.reduce(function (x, v) { return It(v) ? [Math.min(x[0], v), Math.max(x[1], v)] : x }, h)), h }, v3 = { exports: {} }, XZ; function zJe() { return XZ || (XZ = 1, (function (t) { var e = Object.prototype.hasOwnProperty, n = "~"; function r() { } Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1)); function i(c, u, d) { this.fn = c, this.context = u, this.once = d || !1 } function a(c, u, d, f, h) { if (typeof d != "function") throw new TypeError("The listener must be a function"); var m = new i(d, f || c, h), g = n ? n + u : u; return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], m] : c._events[g].push(m) : (c._events[g] = m, c._eventsCount++), c } function s(c, u) { --c._eventsCount === 0 ? c._events = new r : delete c._events[u] } function o() { this._events = new r, this._eventsCount = 0 } o.prototype.eventNames = function () { var u = [], d, f; if (this._eventsCount === 0) return u; for (f in d = this._events) e.call(d, f) && u.push(n ? f.slice(1) : f); return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(d)) : u }, o.prototype.listeners = function (u) { var d = n ? n + u : u, f = this._events[d]; if (!f) return []; if (f.fn) return [f.fn]; for (var h = 0, m = f.length, g = new Array(m); h < m; h++)g[h] = f[h].fn; return g }, o.prototype.listenerCount = function (u) { var d = n ? n + u : u, f = this._events[d]; return f ? f.fn ? 1 : f.length : 0 }, o.prototype.emit = function (u, d, f, h, m, g) { var x = n ? n + u : u; if (!this._events[x]) return !1; var v = this._events[x], b = arguments.length, E, M; if (v.fn) { switch (v.once && this.removeListener(u, v.fn, void 0, !0), b) { case 1: return v.fn.call(v.context), !0; case 2: return v.fn.call(v.context, d), !0; case 3: return v.fn.call(v.context, d, f), !0; case 4: return v.fn.call(v.context, d, f, h), !0; case 5: return v.fn.call(v.context, d, f, h, m), !0; case 6: return v.fn.call(v.context, d, f, h, m, g), !0 }for (M = 1, E = new Array(b - 1); M < b; M++)E[M - 1] = arguments[M]; v.fn.apply(v.context, E) } else { var C = v.length, N; for (M = 0; M < C; M++)switch (v[M].once && this.removeListener(u, v[M].fn, void 0, !0), b) { case 1: v[M].fn.call(v[M].context); break; case 2: v[M].fn.call(v[M].context, d); break; case 3: v[M].fn.call(v[M].context, d, f); break; case 4: v[M].fn.call(v[M].context, d, f, h); break; default: if (!E) for (N = 1, E = new Array(b - 1); N < b; N++)E[N - 1] = arguments[N]; v[M].fn.apply(v[M].context, E) } } return !0 }, o.prototype.on = function (u, d, f) { return a(this, u, d, f, !1) }, o.prototype.once = function (u, d, f) { return a(this, u, d, f, !0) }, o.prototype.removeListener = function (u, d, f, h) { var m = n ? n + u : u; if (!this._events[m]) return this; if (!d) return s(this, m), this; var g = this._events[m]; if (g.fn) g.fn === d && (!h || g.once) && (!f || g.context === f) && s(this, m); else { for (var x = 0, v = [], b = g.length; x < b; x++)(g[x].fn !== d || h && !g[x].once || f && g[x].context !== f) && v.push(g[x]); v.length ? this._events[m] = v.length === 1 ? v[0] : v : s(this, m) } return this }, o.prototype.removeAllListeners = function (u) { var d; return u ? (d = n ? n + u : u, this._events[d] && s(this, d)) : (this._events = new r, this._eventsCount = 0), this }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, t.exports = o })(v3)), v3.exports } var VJe = zJe(); const HJe = Fr(VJe); var y3 = new HJe, x3 = "recharts.syncMouseEvents"; function CS(t) { "@babel/helpers - typeof"; return CS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, CS(t) } function WJe(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function GJe(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Phe(r.key), r) } } function qJe(t, e, n) { return e && GJe(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function b3(t, e, n) { return e = Phe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Phe(t) { var e = XJe(t, "string"); return CS(e) == "symbol" ? e : e + "" } function XJe(t, e) { if (CS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (CS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } var YJe = (function () { function t() { WJe(this, t), b3(this, "activeIndex", 0), b3(this, "coordinateList", []), b3(this, "layout", "horizontal") } return qJe(t, [{ key: "setDetails", value: function (n) { var r, i = n.coordinateList, a = i === void 0 ? null : i, s = n.container, o = s === void 0 ? null : s, c = n.layout, u = c === void 0 ? null : c, d = n.offset, f = d === void 0 ? null : d, h = n.mouseHandlerCallback, m = h === void 0 ? null : h; this.coordinateList = (r = a ?? this.coordinateList) !== null && r !== void 0 ? r : [], this.container = o ?? this.container, this.layout = u ?? this.layout, this.offset = f ?? this.offset, this.mouseHandlerCallback = m ?? this.mouseHandlerCallback, this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1) } }, { key: "focus", value: function () { this.spoofMouse() } }, { key: "keyboardEvent", value: function (n) { if (this.coordinateList.length !== 0) switch (n.key) { case "ArrowRight": { if (this.layout !== "horizontal") return; this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1), this.spoofMouse(); break } case "ArrowLeft": { if (this.layout !== "horizontal") return; this.activeIndex = Math.max(this.activeIndex - 1, 0), this.spoofMouse(); break } } } }, { key: "setIndex", value: function (n) { this.activeIndex = n } }, { key: "spoofMouse", value: function () { var n, r; if (this.layout === "horizontal" && this.coordinateList.length !== 0) { var i = this.container.getBoundingClientRect(), a = i.x, s = i.y, o = i.height, c = this.coordinateList[this.activeIndex].coordinate, u = ((n = window) === null || n === void 0 ? void 0 : n.scrollX) || 0, d = ((r = window) === null || r === void 0 ? void 0 : r.scrollY) || 0, f = a + c + u, h = s + this.offset.top + o / 2 + d; this.mouseHandlerCallback({ pageX: f, pageY: h }) } } }]) })(); function KJe(t, e, n) { if (n === "number" && e === !0 && Array.isArray(t)) { var r = t?.[0], i = t?.[1]; if (r && i && It(r) && It(i)) return !0 } return !1 } function ZJe(t, e, n, r) { var i = r / 2; return { stroke: "none", fill: "#ccc", x: t === "horizontal" ? e.x - i : n.left + .5, y: t === "horizontal" ? n.top + .5 : e.y - i, width: t === "horizontal" ? r : n.width - 1, height: t === "horizontal" ? n.height - 1 : r } } function jhe(t) { var e = t.cx, n = t.cy, r = t.radius, i = t.startAngle, a = t.endAngle, s = bi(e, n, r, i), o = bi(e, n, r, a); return { points: [s, o], cx: e, cy: n, radius: r, startAngle: i, endAngle: a } } function QJe(t, e, n) { var r, i, a, s; if (t === "horizontal") r = e.x, a = r, i = n.top, s = n.top + n.height; else if (t === "vertical") i = e.y, s = i, r = n.left, a = n.left + n.width; else if (e.cx != null && e.cy != null) if (t === "centric") { var o = e.cx, c = e.cy, u = e.innerRadius, d = e.outerRadius, f = e.angle, h = bi(o, c, u, f), m = bi(o, c, d, f); r = h.x, i = h.y, a = m.x, s = m.y } else return jhe(e); return [{ x: r, y: i }, { x: a, y: s }] } function NS(t) { "@babel/helpers - typeof"; return NS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, NS(t) } function YZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function lT(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? YZ(Object(n), !0).forEach(function (r) { JJe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : YZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function JJe(t, e, n) { return e = eet(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function eet(t) { var e = tet(t, "string"); return NS(e) == "symbol" ? e : e + "" } function tet(t, e) { if (NS(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (NS(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function net(t) { var e, n, r = t.element, i = t.tooltipEventType, a = t.isActive, s = t.activeCoordinate, o = t.activePayload, c = t.offset, u = t.activeTooltipIndex, d = t.tooltipAxisBandSize, f = t.layout, h = t.chartName, m = (e = r.props.cursor) !== null && e !== void 0 ? e : (n = r.type.defaultProps) === null || n === void 0 ? void 0 : n.cursor; if (!r || !m || !a || !s || h !== "ScatterChart" && i !== "axis") return null; var g, x = Xh; if (h === "ScatterChart") g = s, x = YXe; else if (h === "BarChart") g = ZJe(f, s, c, d), x = hz; else if (f === "radial") { var v = jhe(s), b = v.cx, E = v.cy, M = v.radius, C = v.startAngle, N = v.endAngle; g = { cx: b, cy: E, startAngle: C, endAngle: N, innerRadius: M, outerRadius: M }, x = fz } else g = { points: QJe(f, s, c) }, x = Xh; var A = lT(lT(lT(lT({ stroke: "#ccc", pointerEvents: "none" }, c), g), vn(m, !1)), {}, { payload: o, payloadIndex: u, className: zn("recharts-tooltip-cursor", m.className) }); return S.isValidElement(m) ? S.cloneElement(m, A) : S.createElement(x, A) } var ret = ["item"], iet = ["children", "className", "width", "height", "style", "compact", "title", "desc"]; function o0(t) { "@babel/helpers - typeof"; return o0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, o0(t) } function Xy() { return Xy = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Xy.apply(this, arguments) } function KZ(t, e) { return oet(t) || set(t, e) || khe(t, e) || aet() } function aet() {
	throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function set(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, a, s, o = [], c = !0, u = !1; try { if (a = (n = n.call(t)).next, e !== 0) for (; !(c = (r = a.call(n)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (d) { u = !0, i = d } finally { try { if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return } finally { if (u) throw i } } return o } } function oet(t) { if (Array.isArray(t)) return t } function ZZ(t, e) { if (t == null) return {}; var n = cet(t, e), r, i; if (Object.getOwnPropertySymbols) { var a = Object.getOwnPropertySymbols(t); for (i = 0; i < a.length; i++)r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function cet(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function uet(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function det(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Ihe(r.key), r) } } function fet(t, e, n) { return e && det(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t } function het(t, e, n) { return e = rA(e), pet(t, Rhe() ? Reflect.construct(e, n || [], rA(t).constructor) : e.apply(t, n)) } function pet(t, e) { if (e && (o0(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return met(t) } function met(t) { if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function Rhe() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })) } catch { } return (Rhe = function () { return !!t })() } function rA(t) { return rA = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, rA(t) } function get(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && UF(t, e) } function UF(t, e) { return UF = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) { return r.__proto__ = i, r }, UF(t, e) } function l0(t) { return xet(t) || yet(t) || khe(t) || vet() } function vet() {
	throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function khe(t, e) { if (t) { if (typeof t == "string") return BF(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return BF(t, e) } } function yet(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function xet(t) { if (Array.isArray(t)) return BF(t) } function BF(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function QZ(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function rt(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? QZ(Object(n), !0).forEach(function (r) { kn(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : QZ(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function kn(t, e, n) { return e = Ihe(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Ihe(t) { var e = bet(t, "string"); return o0(e) == "symbol" ? e : e + "" } function bet(t, e) { if (o0(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (o0(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } var wet = { xAxis: ["bottom", "top"], yAxis: ["left", "right"] }, _et = { width: "100%", height: "100%" }, Ohe = { x: 0, y: 0 }; function cT(t) { return t } var Eet = function (e, n) { return n === "horizontal" ? e.x : n === "vertical" ? e.y : n === "centric" ? e.angle : e.radius }, Met = function (e, n, r, i) { var a = n.find(function (d) { return d && d.index === r }); if (a) { if (e === "horizontal") return { x: a.coordinate, y: i.y }; if (e === "vertical") return { x: i.x, y: a.coordinate }; if (e === "centric") { var s = a.coordinate, o = i.radius; return rt(rt(rt({}, i), bi(i.cx, i.cy, o, s)), {}, { angle: s, radius: o }) } var c = a.coordinate, u = i.angle; return rt(rt(rt({}, i), bi(i.cx, i.cy, c, u)), {}, { angle: u, radius: c }) } return Ohe }, hP = function (e, n) { var r = n.graphicalItems, i = n.dataStartIndex, a = n.dataEndIndex, s = (r ?? []).reduce(function (o, c) { var u = c.props.data; return u && u.length ? [].concat(l0(o), l0(u)) : o }, []); return s.length > 0 ? s : e && e.length && It(i) && It(a) ? e.slice(i, a + 1) : [] }; function Dhe(t) { return t === "number" ? [0, "auto"] : void 0 } var $F = function (e, n, r, i) { var a = e.graphicalItems, s = e.tooltipAxis, o = hP(n, e); return r < 0 || !a || !a.length || r >= o.length ? null : a.reduce(function (c, u) { var d, f = (d = u.props.data) !== null && d !== void 0 ? d : n; f && e.dataStartIndex + e.dataEndIndex !== 0 && e.dataEndIndex - e.dataStartIndex >= r && (f = f.slice(e.dataStartIndex, e.dataEndIndex + 1)); var h; if (s.dataKey && !s.allowDuplicatedCategory) { var m = f === void 0 ? o : f; h = rN(m, s.dataKey, i) } else h = f && f[r] || o[r]; return h ? [].concat(l0(c), [bfe(u, h)]) : c }, []) }, JZ = function (e, n, r, i) { var a = i || { x: e.chartX, y: e.chartY }, s = Eet(a, r), o = e.orderedTooltipTicks, c = e.tooltipAxis, u = e.tooltipTicks, d = E9e(s, o, u, c); if (d >= 0 && u) { var f = u[d] && u[d].value, h = $F(e, n, d, f), m = Met(r, o, d, a); return { activeTooltipIndex: d, activeLabel: f, activePayload: h, activeCoordinate: m } } return null }, Tet = function (e, n) { var r = n.axes, i = n.graphicalItems, a = n.axisType, s = n.axisIdKey, o = n.stackGroups, c = n.dataStartIndex, u = n.dataEndIndex, d = e.layout, f = e.children, h = e.stackOffset, m = pfe(d, a); return r.reduce(function (g, x) { var v, b = x.type.defaultProps !== void 0 ? rt(rt({}, x.type.defaultProps), x.props) : x.props, E = b.type, M = b.dataKey, C = b.allowDataOverflow, N = b.allowDuplicatedCategory, A = b.scale, j = b.ticks, O = b.includeHidden, I = b[s]; if (g[I]) return g; var D = hP(e.data, { graphicalItems: i.filter(function (Q) { var re, ce = s in Q.props ? Q.props[s] : (re = Q.type.defaultProps) === null || re === void 0 ? void 0 : re[s]; return ce === I }), dataStartIndex: c, dataEndIndex: u }), F = D.length, B, G, z; KJe(b.domain, C, E) && (B = Q4(b.domain, null, C), m && (E === "number" || A !== "auto") && (z = i1(D, M, "category"))); var q = Dhe(E); if (!B || B.length === 0) { var Y, Z = (Y = b.domain) !== null && Y !== void 0 ? Y : q; if (M) { if (B = i1(D, M, E), E === "category" && m) { var $ = v$e(B); N && $ ? (G = B, B = $N(0, F)) : N || (B = ZY(Z, B, x).reduce(function (Q, re) { return Q.indexOf(re) >= 0 ? Q : [].concat(l0(Q), [re]) }, [])) } else if (E === "category") N ? B = B.filter(function (Q) { return Q !== "" && !An(Q) }) : B = ZY(Z, B, x).reduce(function (Q, re) { return Q.indexOf(re) >= 0 || re === "" || An(re) ? Q : [].concat(l0(Q), [re]) }, []); else if (E === "number") { var V = A9e(D, i.filter(function (Q) { var re, ce, be = s in Q.props ? Q.props[s] : (re = Q.type.defaultProps) === null || re === void 0 ? void 0 : re[s], de = "hide" in Q.props ? Q.props.hide : (ce = Q.type.defaultProps) === null || ce === void 0 ? void 0 : ce.hide; return be === I && (O || !de) }), M, a, d); V && (B = V) } m && (E === "number" || A !== "auto") && (z = i1(D, M, "category")) } else m ? B = $N(0, F) : o && o[I] && o[I].hasStack && E === "number" ? B = h === "expand" ? [0, 1] : xfe(o[I].stackGroups, c, u) : B = hfe(D, i.filter(function (Q) { var re = s in Q.props ? Q.props[s] : Q.type.defaultProps[s], ce = "hide" in Q.props ? Q.props.hide : Q.type.defaultProps.hide; return re === I && (O || !ce) }), E, d, !0); if (E === "number") B = FF(f, B, I, a, j), Z && (B = Q4(Z, B, C)); else if (E === "category" && Z) { var K = Z, X = B.every(function (Q) { return K.indexOf(Q) >= 0 }); X && (B = K) } } return rt(rt({}, g), {}, kn({}, I, rt(rt({}, b), {}, { axisType: a, domain: B, categoricalDomain: z, duplicateDomain: G, originalDomain: (v = b.domain) !== null && v !== void 0 ? v : q, isCategorical: m, layout: d }))) }, {}) }, Cet = function (e, n) { var r = n.graphicalItems, i = n.Axis, a = n.axisType, s = n.axisIdKey, o = n.stackGroups, c = n.dataStartIndex, u = n.dataEndIndex, d = e.layout, f = e.children, h = hP(e.data, { graphicalItems: r, dataStartIndex: c, dataEndIndex: u }), m = h.length, g = pfe(d, a), x = -1; return r.reduce(function (v, b) { var E = b.type.defaultProps !== void 0 ? rt(rt({}, b.type.defaultProps), b.props) : b.props, M = E[s], C = Dhe("number"); if (!v[M]) { x++; var N; return g ? N = $N(0, m) : o && o[M] && o[M].hasStack ? (N = xfe(o[M].stackGroups, c, u), N = FF(f, N, M, a)) : (N = Q4(C, hfe(h, r.filter(function (A) { var j, O, I = s in A.props ? A.props[s] : (j = A.type.defaultProps) === null || j === void 0 ? void 0 : j[s], D = "hide" in A.props ? A.props.hide : (O = A.type.defaultProps) === null || O === void 0 ? void 0 : O.hide; return I === M && !D }), "number", d), i.defaultProps.allowDataOverflow), N = FF(f, N, M, a)), rt(rt({}, v), {}, kn({}, M, rt(rt({ axisType: a }, i.defaultProps), {}, { hide: !0, orientation: pl(wet, "".concat(a, ".").concat(x % 2), null), domain: N, originalDomain: C, isCategorical: g, layout: d }))) } return v }, {}) }, Net = function (e, n) { var r = n.axisType, i = r === void 0 ? "xAxis" : r, a = n.AxisComp, s = n.graphicalItems, o = n.stackGroups, c = n.dataStartIndex, u = n.dataEndIndex, d = e.children, f = "".concat(i, "Id"), h = so(d, a), m = {}; return h && h.length ? m = Tet(e, { axes: h, graphicalItems: s, axisType: i, axisIdKey: f, stackGroups: o, dataStartIndex: c, dataEndIndex: u }) : s && s.length && (m = Cet(e, { Axis: a, graphicalItems: s, axisType: i, axisIdKey: f, stackGroups: o, dataStartIndex: c, dataEndIndex: u })), m }, Aet = function (e) { var n = kh(e), r = af(n, !1, !0); return { tooltipTicks: r, orderedTooltipTicks: U$(r, function (i) { return i.coordinate }), tooltipAxis: n, tooltipAxisBandSize: NN(n, r) } }, eQ = function (e) { var n = e.children, r = e.defaultShowTooltip, i = al(n, Yx), a = 0, s = 0; return e.data && e.data.length !== 0 && (s = e.data.length - 1), i && i.props && (i.props.startIndex >= 0 && (a = i.props.startIndex), i.props.endIndex >= 0 && (s = i.props.endIndex)), { chartX: 0, chartY: 0, dataStartIndex: a, dataEndIndex: s, activeTooltipIndex: -1, isTooltipActive: !!r } }, Pet = function (e) { return !e || !e.length ? !1 : e.some(function (n) { var r = lf(n && n.type); return r && r.indexOf("Bar") >= 0 }) }, tQ = function (e) { return e === "horizontal" ? { numericAxisName: "yAxis", cateAxisName: "xAxis" } : e === "vertical" ? { numericAxisName: "xAxis", cateAxisName: "yAxis" } : e === "centric" ? { numericAxisName: "radiusAxis", cateAxisName: "angleAxis" } : { numericAxisName: "angleAxis", cateAxisName: "radiusAxis" } }, jet = function (e, n) { var r = e.props, i = e.graphicalItems, a = e.xAxisMap, s = a === void 0 ? {} : a, o = e.yAxisMap, c = o === void 0 ? {} : o, u = r.width, d = r.height, f = r.children, h = r.margin || {}, m = al(f, Yx), g = al(f, Ru), x = Object.keys(c).reduce(function (N, A) { var j = c[A], O = j.orientation; return !j.mirror && !j.hide ? rt(rt({}, N), {}, kn({}, O, N[O] + j.width)) : N }, { left: h.left || 0, right: h.right || 0 }), v = Object.keys(s).reduce(function (N, A) { var j = s[A], O = j.orientation; return !j.mirror && !j.hide ? rt(rt({}, N), {}, kn({}, O, pl(N, "".concat(O)) + j.height)) : N }, { top: h.top || 0, bottom: h.bottom || 0 }), b = rt(rt({}, v), x), E = b.bottom; m && (b.bottom += m.props.height || Yx.defaultProps.height), g && n && (b = C9e(b, i, r, n)); var M = u - b.left - b.right, C = d - b.top - b.bottom; return rt(rt({ brushBottom: E }, b), {}, { width: Math.max(M, 0), height: Math.max(C, 0) }) }, Ret = function (e, n) { if (n === "xAxis") return e[n].width; if (n === "yAxis") return e[n].height }, k_ = function (e) { var n = e.chartName, r = e.GraphicalChild, i = e.defaultTooltipEventType, a = i === void 0 ? "axis" : i, s = e.validateTooltipEventTypes, o = s === void 0 ? ["axis"] : s, c = e.axisComponents, u = e.legendContent, d = e.formatAxisMap, f = e.defaultProps, h = function (b, E) { var M = E.graphicalItems, C = E.stackGroups, N = E.offset, A = E.updateId, j = E.dataStartIndex, O = E.dataEndIndex, I = b.barSize, D = b.layout, F = b.barGap, B = b.barCategoryGap, G = b.maxBarSize, z = tQ(D), q = z.numericAxisName, Y = z.cateAxisName, Z = Pet(M), $ = []; return M.forEach(function (V, K) { var X = hP(b.data, { graphicalItems: [V], dataStartIndex: j, dataEndIndex: O }), Q = V.type.defaultProps !== void 0 ? rt(rt({}, V.type.defaultProps), V.props) : V.props, re = Q.dataKey, ce = Q.maxBarSize, be = Q["".concat(q, "Id")], de = Q["".concat(Y, "Id")], ae = {}, se = c.reduce(function (Tt, St) { var ee = E["".concat(St.axisType, "Map")], ne = Q["".concat(St.axisType, "Id")]; ee && ee[ne] || St.axisType === "zAxis" || Ig(); var Re = ee[ne]; return rt(rt({}, Tt), {}, kn(kn({}, St.axisType, Re), "".concat(St.axisType, "Ticks"), af(Re))) }, ae), he = se[Y], Ae = se["".concat(Y, "Ticks")], Ce = C && C[be] && C[be].hasStack && F9e(V, C[be].stackGroups), fe = lf(V.type).indexOf("Bar") >= 0, oe = NN(he, Ae), xe = [], _e = Z && M9e({ barSize: I, stackGroups: C, totalSize: Ret(se, Y) }); if (fe) { var je, ke, Ze = An(ce) ? G : ce, Xe = (je = (ke = NN(he, Ae, !0)) !== null && ke !== void 0 ? ke : Ze) !== null && je !== void 0 ? je : 0; xe = T9e({ barGap: F, barCategoryGap: B, bandSize: Xe !== oe ? Xe : oe, sizeList: _e[de], maxBarSize: Ze }), Xe !== oe && (xe = xe.map(function (Tt) { return rt(rt({}, Tt), {}, { position: rt(rt({}, Tt.position), {}, { offset: Tt.position.offset - Xe / 2 }) }) })) } var nt = V && V.type && V.type.getComposedData; nt && $.push({ props: rt(rt({}, nt(rt(rt({}, se), {}, { displayedData: X, props: b, dataKey: re, item: V, bandSize: oe, barPosition: xe, offset: N, stackedData: Ce, layout: D, dataStartIndex: j, dataEndIndex: O }))), {}, kn(kn(kn({ key: V.key || "item-".concat(K) }, q, se[q]), Y, se[Y]), "animationId", A)), childIndex: P$e(V, b.children), item: V }) }), $ }, m = function (b, E) { var M = b.props, C = b.dataStartIndex, N = b.dataEndIndex, A = b.updateId; if (!fG({ props: M })) return null; var j = M.children, O = M.layout, I = M.stackOffset, D = M.data, F = M.reverseStackOrder, B = tQ(O), G = B.numericAxisName, z = B.cateAxisName, q = so(j, r), Y = D9e(D, q, "".concat(G, "Id"), "".concat(z, "Id"), I, F), Z = c.reduce(function (Q, re) { var ce = "".concat(re.axisType, "Map"); return rt(rt({}, Q), {}, kn({}, ce, Net(M, rt(rt({}, re), {}, { graphicalItems: q, stackGroups: re.axisType === G && Y, dataStartIndex: C, dataEndIndex: N })))) }, {}), $ = jet(rt(rt({}, Z), {}, { props: M, graphicalItems: q }), E?.legendBBox); Object.keys(Z).forEach(function (Q) { Z[Q] = d(M, Z[Q], $, Q.replace("Map", ""), n) }); var V = Z["".concat(z, "Map")], K = Aet(V), X = h(M, rt(rt({}, Z), {}, { dataStartIndex: C, dataEndIndex: N, updateId: A, graphicalItems: q, stackGroups: Y, offset: $ })); return rt(rt({ formattedGraphicalItems: X, graphicalItems: q, offset: $, stackGroups: Y }, K), Z) }, g = (function (v) { function b(E) { var M, C, N; return uet(this, b), N = het(this, b, [E]), kn(N, "eventEmitterSymbol", Symbol("rechartsEventEmitter")), kn(N, "accessibilityManager", new YJe), kn(N, "handleLegendBBoxUpdate", function (A) { if (A) { var j = N.state, O = j.dataStartIndex, I = j.dataEndIndex, D = j.updateId; N.setState(rt({ legendBBox: A }, m({ props: N.props, dataStartIndex: O, dataEndIndex: I, updateId: D }, rt(rt({}, N.state), {}, { legendBBox: A })))) } }), kn(N, "handleReceiveSyncEvent", function (A, j, O) { if (N.props.syncId === A) { if (O === N.eventEmitterSymbol && typeof N.props.syncMethod != "function") return; N.applySyncEvent(j) } }), kn(N, "handleBrushChange", function (A) { var j = A.startIndex, O = A.endIndex; if (j !== N.state.dataStartIndex || O !== N.state.dataEndIndex) { var I = N.state.updateId; N.setState(function () { return rt({ dataStartIndex: j, dataEndIndex: O }, m({ props: N.props, dataStartIndex: j, dataEndIndex: O, updateId: I }, N.state)) }), N.triggerSyncEvent({ dataStartIndex: j, dataEndIndex: O }) } }), kn(N, "handleMouseEnter", function (A) { var j = N.getMouseInfo(A); if (j) { var O = rt(rt({}, j), {}, { isTooltipActive: !0 }); N.setState(O), N.triggerSyncEvent(O); var I = N.props.onMouseEnter; Rn(I) && I(O, A) } }), kn(N, "triggeredAfterMouseMove", function (A) { var j = N.getMouseInfo(A), O = j ? rt(rt({}, j), {}, { isTooltipActive: !0 }) : { isTooltipActive: !1 }; N.setState(O), N.triggerSyncEvent(O); var I = N.props.onMouseMove; Rn(I) && I(O, A) }), kn(N, "handleItemMouseEnter", function (A) { N.setState(function () { return { isTooltipActive: !0, activeItem: A, activePayload: A.tooltipPayload, activeCoordinate: A.tooltipPosition || { x: A.cx, y: A.cy } } }) }), kn(N, "handleItemMouseLeave", function () { N.setState(function () { return { isTooltipActive: !1 } }) }), kn(N, "handleMouseMove", function (A) { A.persist(), N.throttleTriggeredAfterMouseMove(A) }), kn(N, "handleMouseLeave", function (A) { N.throttleTriggeredAfterMouseMove.cancel(); var j = { isTooltipActive: !1 }; N.setState(j), N.triggerSyncEvent(j); var O = N.props.onMouseLeave; Rn(O) && O(j, A) }), kn(N, "handleOuterEvent", function (A) { var j = A$e(A), O = pl(N.props, "".concat(j)); if (j && Rn(O)) { var I, D; /.*touch.*/i.test(j) ? D = N.getMouseInfo(A.changedTouches[0]) : D = N.getMouseInfo(A), O((I = D) !== null && I !== void 0 ? I : {}, A) } }), kn(N, "handleClick", function (A) { var j = N.getMouseInfo(A); if (j) { var O = rt(rt({}, j), {}, { isTooltipActive: !0 }); N.setState(O), N.triggerSyncEvent(O); var I = N.props.onClick; Rn(I) && I(O, A) } }), kn(N, "handleMouseDown", function (A) { var j = N.props.onMouseDown; if (Rn(j)) { var O = N.getMouseInfo(A); j(O, A) } }), kn(N, "handleMouseUp", function (A) { var j = N.props.onMouseUp; if (Rn(j)) { var O = N.getMouseInfo(A); j(O, A) } }), kn(N, "handleTouchMove", function (A) { A.changedTouches != null && A.changedTouches.length > 0 && N.throttleTriggeredAfterMouseMove(A.changedTouches[0]) }), kn(N, "handleTouchStart", function (A) { A.changedTouches != null && A.changedTouches.length > 0 && N.handleMouseDown(A.changedTouches[0]) }), kn(N, "handleTouchEnd", function (A) { A.changedTouches != null && A.changedTouches.length > 0 && N.handleMouseUp(A.changedTouches[0]) }), kn(N, "handleDoubleClick", function (A) { var j = N.props.onDoubleClick; if (Rn(j)) { var O = N.getMouseInfo(A); j(O, A) } }), kn(N, "handleContextMenu", function (A) { var j = N.props.onContextMenu; if (Rn(j)) { var O = N.getMouseInfo(A); j(O, A) } }), kn(N, "triggerSyncEvent", function (A) { N.props.syncId !== void 0 && y3.emit(x3, N.props.syncId, A, N.eventEmitterSymbol) }), kn(N, "applySyncEvent", function (A) { var j = N.props, O = j.layout, I = j.syncMethod, D = N.state.updateId, F = A.dataStartIndex, B = A.dataEndIndex; if (A.dataStartIndex !== void 0 || A.dataEndIndex !== void 0) N.setState(rt({ dataStartIndex: F, dataEndIndex: B }, m({ props: N.props, dataStartIndex: F, dataEndIndex: B, updateId: D }, N.state))); else if (A.activeTooltipIndex !== void 0) { var G = A.chartX, z = A.chartY, q = A.activeTooltipIndex, Y = N.state, Z = Y.offset, $ = Y.tooltipTicks; if (!Z) return; if (typeof I == "function") q = I($, A); else if (I === "value") { q = -1; for (var V = 0; V < $.length; V++)if ($[V].value === A.activeLabel) { q = V; break } } var K = rt(rt({}, Z), {}, { x: Z.left, y: Z.top }), X = Math.min(G, K.x + K.width), Q = Math.min(z, K.y + K.height), re = $[q] && $[q].value, ce = $F(N.state, N.props.data, q), be = $[q] ? { x: O === "horizontal" ? $[q].coordinate : X, y: O === "horizontal" ? Q : $[q].coordinate } : Ohe; N.setState(rt(rt({}, A), {}, { activeLabel: re, activeCoordinate: be, activePayload: ce, activeTooltipIndex: q })) } else N.setState(A) }), kn(N, "renderCursor", function (A) { var j, O = N.state, I = O.isTooltipActive, D = O.activeCoordinate, F = O.activePayload, B = O.offset, G = O.activeTooltipIndex, z = O.tooltipAxisBandSize, q = N.getTooltipEventType(), Y = (j = A.props.active) !== null && j !== void 0 ? j : I, Z = N.props.layout, $ = A.key || "_recharts-cursor"; return P.createElement(net, { key: $, activeCoordinate: D, activePayload: F, activeTooltipIndex: G, chartName: n, element: A, isActive: Y, layout: Z, offset: B, tooltipAxisBandSize: z, tooltipEventType: q }) }), kn(N, "renderPolarAxis", function (A, j, O) { var I = pl(A, "type.axisType"), D = pl(N.state, "".concat(I, "Map")), F = A.type.defaultProps, B = F !== void 0 ? rt(rt({}, F), A.props) : A.props, G = D && D[B["".concat(I, "Id")]]; return S.cloneElement(A, rt(rt({}, G), {}, { className: zn(I, G.className), key: A.key || "".concat(j, "-").concat(O), ticks: af(G, !0) })) }), kn(N, "renderPolarGrid", function (A) { var j = A.props, O = j.radialLines, I = j.polarAngles, D = j.polarRadius, F = N.state, B = F.radiusAxisMap, G = F.angleAxisMap, z = kh(B), q = kh(G), Y = q.cx, Z = q.cy, $ = q.innerRadius, V = q.outerRadius; return S.cloneElement(A, { polarAngles: Array.isArray(I) ? I : af(q, !0).map(function (K) { return K.coordinate }), polarRadius: Array.isArray(D) ? D : af(z, !0).map(function (K) { return K.coordinate }), cx: Y, cy: Z, innerRadius: $, outerRadius: V, key: A.key || "polar-grid", radialLines: O }) }), kn(N, "renderLegend", function () { var A = N.state.formattedGraphicalItems, j = N.props, O = j.children, I = j.width, D = j.height, F = N.props.margin || {}, B = I - (F.left || 0) - (F.right || 0), G = dfe({ children: O, formattedGraphicalItems: A, legendWidth: B, legendContent: u }); if (!G) return null; var z = G.item, q = ZZ(G, ret); return S.cloneElement(z, rt(rt({}, q), {}, { chartWidth: I, chartHeight: D, margin: F, onBBoxUpdate: N.handleLegendBBoxUpdate })) }), kn(N, "renderTooltip", function () { var A, j = N.props, O = j.children, I = j.accessibilityLayer, D = al(O, Po); if (!D) return null; var F = N.state, B = F.isTooltipActive, G = F.activeCoordinate, z = F.activePayload, q = F.activeLabel, Y = F.offset, Z = (A = D.props.active) !== null && A !== void 0 ? A : B; return S.cloneElement(D, { viewBox: rt(rt({}, Y), {}, { x: Y.left, y: Y.top }), active: Z, label: q, payload: Z ? z : [], coordinate: G, accessibilityLayer: I }) }), kn(N, "renderBrush", function (A) { var j = N.props, O = j.margin, I = j.data, D = N.state, F = D.offset, B = D.dataStartIndex, G = D.dataEndIndex, z = D.updateId; return S.cloneElement(A, { key: A.key || "_recharts-brush", onChange: iT(N.handleBrushChange, A.props.onChange), data: I, x: It(A.props.x) ? A.props.x : F.left, y: It(A.props.y) ? A.props.y : F.top + F.height + F.brushBottom - (O.bottom || 0), width: It(A.props.width) ? A.props.width : F.width, startIndex: B, endIndex: G, updateId: "brush-".concat(z) }) }), kn(N, "renderReferenceElement", function (A, j, O) { if (!A) return null; var I = N, D = I.clipPathId, F = N.state, B = F.xAxisMap, G = F.yAxisMap, z = F.offset, q = A.type.defaultProps || {}, Y = A.props, Z = Y.xAxisId, $ = Z === void 0 ? q.xAxisId : Z, V = Y.yAxisId, K = V === void 0 ? q.yAxisId : V; return S.cloneElement(A, { key: A.key || "".concat(j, "-").concat(O), xAxis: B[$], yAxis: G[K], viewBox: { x: z.left, y: z.top, width: z.width, height: z.height }, clipPathId: D }) }), kn(N, "renderActivePoints", function (A) { var j = A.item, O = A.activePoint, I = A.basePoint, D = A.childIndex, F = A.isRange, B = [], G = j.props.key, z = j.item.type.defaultProps !== void 0 ? rt(rt({}, j.item.type.defaultProps), j.item.props) : j.item.props, q = z.activeDot, Y = z.dataKey, Z = rt(rt({ index: D, dataKey: Y, cx: O.x, cy: O.y, r: 4, fill: dz(j.item), strokeWidth: 2, stroke: "#fff", payload: O.payload, value: O.value }, vn(q, !1)), iN(q)); return B.push(b.renderActiveDot(q, Z, "".concat(G, "-activePoint-").concat(D))), I ? B.push(b.renderActiveDot(q, rt(rt({}, Z), {}, { cx: I.x, cy: I.y }), "".concat(G, "-basePoint-").concat(D))) : F && B.push(null), B }), kn(N, "renderGraphicChild", function (A, j, O) { var I = N.filterFormatItem(A, j, O); if (!I) return null; var D = N.getTooltipEventType(), F = N.state, B = F.isTooltipActive, G = F.tooltipAxis, z = F.activeTooltipIndex, q = F.activeLabel, Y = N.props.children, Z = al(Y, Po), $ = I.props, V = $.points, K = $.isRange, X = $.baseLine, Q = I.item.type.defaultProps !== void 0 ? rt(rt({}, I.item.type.defaultProps), I.item.props) : I.item.props, re = Q.activeDot, ce = Q.hide, be = Q.activeBar, de = Q.activeShape, ae = !!(!ce && B && Z && (re || be || de)), se = {}; D !== "axis" && Z && Z.props.trigger === "click" ? se = { onClick: iT(N.handleItemMouseEnter, A.props.onClick) } : D !== "axis" && (se = { onMouseLeave: iT(N.handleItemMouseLeave, A.props.onMouseLeave), onMouseEnter: iT(N.handleItemMouseEnter, A.props.onMouseEnter) }); var he = S.cloneElement(A, rt(rt({}, I.props), se)); function Ae(St) { return typeof G.dataKey == "function" ? G.dataKey(St.payload) : null } if (ae) if (z >= 0) { var Ce, fe; if (G.dataKey && !G.allowDuplicatedCategory) { var oe = typeof G.dataKey == "function" ? Ae : "payload.".concat(G.dataKey.toString()); Ce = rN(V, oe, q), fe = K && X && rN(X, oe, q) } else Ce = V?.[z], fe = K && X && X[z]; if (de || be) { var xe = A.props.activeIndex !== void 0 ? A.props.activeIndex : z; return [S.cloneElement(A, rt(rt(rt({}, I.props), se), {}, { activeIndex: xe })), null, null] } if (!An(Ce)) return [he].concat(l0(N.renderActivePoints({ item: I, activePoint: Ce, basePoint: fe, childIndex: z, isRange: K }))) } else { var _e, je = (_e = N.getItemByXY(N.state.activeCoordinate)) !== null && _e !== void 0 ? _e : { graphicalItem: he }, ke = je.graphicalItem, Ze = ke.item, Xe = Ze === void 0 ? A : Ze, nt = ke.childIndex, Tt = rt(rt(rt({}, I.props), se), {}, { activeIndex: nt }); return [S.cloneElement(Xe, Tt), null, null] } return K ? [he, null, null] : [he, null] }), kn(N, "renderCustomized", function (A, j, O) { return S.cloneElement(A, rt(rt({ key: "recharts-customized-".concat(O) }, N.props), N.state)) }), kn(N, "renderMap", { CartesianGrid: { handler: cT, once: !0 }, ReferenceArea: { handler: N.renderReferenceElement }, ReferenceLine: { handler: cT }, ReferenceDot: { handler: N.renderReferenceElement }, XAxis: { handler: cT }, YAxis: { handler: cT }, Brush: { handler: N.renderBrush, once: !0 }, Bar: { handler: N.renderGraphicChild }, Line: { handler: N.renderGraphicChild }, Area: { handler: N.renderGraphicChild }, Radar: { handler: N.renderGraphicChild }, RadialBar: { handler: N.renderGraphicChild }, Scatter: { handler: N.renderGraphicChild }, Pie: { handler: N.renderGraphicChild }, Funnel: { handler: N.renderGraphicChild }, Tooltip: { handler: N.renderCursor, once: !0 }, PolarGrid: { handler: N.renderPolarGrid, once: !0 }, PolarAngleAxis: { handler: N.renderPolarAxis }, PolarRadiusAxis: { handler: N.renderPolarAxis }, Customized: { handler: N.renderCustomized } }), N.clipPathId = "".concat((M = E.id) !== null && M !== void 0 ? M : Ep("recharts"), "-clip"), N.throttleTriggeredAfterMouseMove = ude(N.triggeredAfterMouseMove, (C = E.throttleDelay) !== null && C !== void 0 ? C : 1e3 / 60), N.state = {}, N } return get(b, v), fet(b, [{ key: "componentDidMount", value: function () { var M, C; this.addListener(), this.accessibilityManager.setDetails({ container: this.container, offset: { left: (M = this.props.margin.left) !== null && M !== void 0 ? M : 0, top: (C = this.props.margin.top) !== null && C !== void 0 ? C : 0 }, coordinateList: this.state.tooltipTicks, mouseHandlerCallback: this.triggeredAfterMouseMove, layout: this.props.layout }), this.displayDefaultTooltip() } }, { key: "displayDefaultTooltip", value: function () { var M = this.props, C = M.children, N = M.data, A = M.height, j = M.layout, O = al(C, Po); if (O) { var I = O.props.defaultIndex; if (!(typeof I != "number" || I < 0 || I > this.state.tooltipTicks.length - 1)) { var D = this.state.tooltipTicks[I] && this.state.tooltipTicks[I].value, F = $F(this.state, N, I, D), B = this.state.tooltipTicks[I].coordinate, G = (this.state.offset.top + A) / 2, z = j === "horizontal", q = z ? { x: B, y: G } : { y: B, x: G }, Y = this.state.formattedGraphicalItems.find(function ($) { var V = $.item; return V.type.name === "Scatter" }); Y && (q = rt(rt({}, q), Y.props.points[I].tooltipPosition), F = Y.props.points[I].tooltipPayload); var Z = { activeTooltipIndex: I, isTooltipActive: !0, activeLabel: D, activePayload: F, activeCoordinate: q }; this.setState(Z), this.renderCursor(O), this.accessibilityManager.setIndex(I) } } } }, { key: "getSnapshotBeforeUpdate", value: function (M, C) { if (!this.props.accessibilityLayer) return null; if (this.state.tooltipTicks !== C.tooltipTicks && this.accessibilityManager.setDetails({ coordinateList: this.state.tooltipTicks }), this.props.layout !== M.layout && this.accessibilityManager.setDetails({ layout: this.props.layout }), this.props.margin !== M.margin) { var N, A; this.accessibilityManager.setDetails({ offset: { left: (N = this.props.margin.left) !== null && N !== void 0 ? N : 0, top: (A = this.props.margin.top) !== null && A !== void 0 ? A : 0 } }) } return null } }, { key: "componentDidUpdate", value: function (M) { b4([al(M.children, Po)], [al(this.props.children, Po)]) || this.displayDefaultTooltip() } }, { key: "componentWillUnmount", value: function () { this.removeListener(), this.throttleTriggeredAfterMouseMove.cancel() } }, { key: "getTooltipEventType", value: function () { var M = al(this.props.children, Po); if (M && typeof M.props.shared == "boolean") { var C = M.props.shared ? "axis" : "item"; return o.indexOf(C) >= 0 ? C : a } return a } }, { key: "getMouseInfo", value: function (M) { if (!this.container) return null; var C = this.container, N = C.getBoundingClientRect(), A = gVe(N), j = { chartX: Math.round(M.pageX - A.left), chartY: Math.round(M.pageY - A.top) }, O = N.width / C.offsetWidth || 1, I = this.inRange(j.chartX, j.chartY, O); if (!I) return null; var D = this.state, F = D.xAxisMap, B = D.yAxisMap, G = this.getTooltipEventType(), z = JZ(this.state, this.props.data, this.props.layout, I); if (G !== "axis" && F && B) { var q = kh(F).scale, Y = kh(B).scale, Z = q && q.invert ? q.invert(j.chartX) : null, $ = Y && Y.invert ? Y.invert(j.chartY) : null; return rt(rt({}, j), {}, { xValue: Z, yValue: $ }, z) } return z ? rt(rt({}, j), z) : null } }, { key: "inRange", value: function (M, C) { var N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, A = this.props.layout, j = M / N, O = C / N; if (A === "horizontal" || A === "vertical") { var I = this.state.offset, D = j >= I.left && j <= I.left + I.width && O >= I.top && O <= I.top + I.height; return D ? { x: j, y: O } : null } var F = this.state, B = F.angleAxisMap, G = F.radiusAxisMap; if (B && G) { var z = kh(B); return eK({ x: j, y: O }, z) } return null } }, { key: "parseEventsOfWrapper", value: function () { var M = this.props.children, C = this.getTooltipEventType(), N = al(M, Po), A = {}; N && C === "axis" && (N.props.trigger === "click" ? A = { onClick: this.handleClick } : A = { onMouseEnter: this.handleMouseEnter, onDoubleClick: this.handleDoubleClick, onMouseMove: this.handleMouseMove, onMouseLeave: this.handleMouseLeave, onTouchMove: this.handleTouchMove, onTouchStart: this.handleTouchStart, onTouchEnd: this.handleTouchEnd, onContextMenu: this.handleContextMenu }); var j = iN(this.props, this.handleOuterEvent); return rt(rt({}, j), A) } }, { key: "addListener", value: function () { y3.on(x3, this.handleReceiveSyncEvent) } }, { key: "removeListener", value: function () { y3.removeListener(x3, this.handleReceiveSyncEvent) } }, { key: "filterFormatItem", value: function (M, C, N) { for (var A = this.state.formattedGraphicalItems, j = 0, O = A.length; j < O; j++) { var I = A[j]; if (I.item === M || I.props.key === M.key || C === lf(I.item.type) && N === I.childIndex) return I } return null } }, { key: "renderClipPath", value: function () { var M = this.clipPathId, C = this.state.offset, N = C.left, A = C.top, j = C.height, O = C.width; return P.createElement("defs", null, P.createElement("clipPath", { id: M }, P.createElement("rect", { x: N, y: A, height: j, width: O }))) } }, { key: "getXScales", value: function () { var M = this.state.xAxisMap; return M ? Object.entries(M).reduce(function (C, N) { var A = KZ(N, 2), j = A[0], O = A[1]; return rt(rt({}, C), {}, kn({}, j, O.scale)) }, {}) : null } }, { key: "getYScales", value: function () { var M = this.state.yAxisMap; return M ? Object.entries(M).reduce(function (C, N) { var A = KZ(N, 2), j = A[0], O = A[1]; return rt(rt({}, C), {}, kn({}, j, O.scale)) }, {}) : null } }, { key: "getXScaleByAxisId", value: function (M) { var C; return (C = this.state.xAxisMap) === null || C === void 0 || (C = C[M]) === null || C === void 0 ? void 0 : C.scale } }, { key: "getYScaleByAxisId", value: function (M) { var C; return (C = this.state.yAxisMap) === null || C === void 0 || (C = C[M]) === null || C === void 0 ? void 0 : C.scale } }, { key: "getItemByXY", value: function (M) { var C = this.state, N = C.formattedGraphicalItems, A = C.activeItem; if (N && N.length) for (var j = 0, O = N.length; j < O; j++) { var I = N[j], D = I.props, F = I.item, B = F.type.defaultProps !== void 0 ? rt(rt({}, F.type.defaultProps), F.props) : F.props, G = lf(F.type); if (G === "Bar") { var z = (D.data || []).find(function ($) { return AXe(M, $) }); if (z) return { graphicalItem: I, payload: z } } else if (G === "RadialBar") { var q = (D.data || []).find(function ($) { return eK(M, $) }); if (q) return { graphicalItem: I, payload: q } } else if (aP(I, A) || sP(I, A) || SS(I, A)) { var Y = QYe({ graphicalItem: I, activeTooltipItem: A, itemData: B.data }), Z = B.activeIndex === void 0 ? Y : B.activeIndex; return { graphicalItem: rt(rt({}, I), {}, { childIndex: Z }), payload: SS(I, A) ? B.data[Y] : I.props.data[Y] } } } return null } }, { key: "render", value: function () { var M = this; if (!fG(this)) return null; var C = this.props, N = C.children, A = C.className, j = C.width, O = C.height, I = C.style, D = C.compact, F = C.title, B = C.desc, G = ZZ(C, iet), z = vn(G, !1); if (D) return P.createElement(CZ, { state: this.state, width: this.props.width, height: this.props.height, clipPathId: this.clipPathId }, P.createElement(S4, Xy({}, z, { width: j, height: O, title: F, desc: B }), this.renderClipPath(), pG(N, this.renderMap))); if (this.props.accessibilityLayer) { var q, Y; z.tabIndex = (q = this.props.tabIndex) !== null && q !== void 0 ? q : 0, z.role = (Y = this.props.role) !== null && Y !== void 0 ? Y : "application", z.onKeyDown = function ($) { M.accessibilityManager.keyboardEvent($) }, z.onFocus = function () { M.accessibilityManager.focus() } } var Z = this.parseEventsOfWrapper(); return P.createElement(CZ, { state: this.state, width: this.props.width, height: this.props.height, clipPathId: this.clipPathId }, P.createElement("div", Xy({ className: zn("recharts-wrapper", A), style: rt({ position: "relative", cursor: "default", width: j, height: O }, I) }, Z, { ref: function (V) { M.container = V } }), P.createElement(S4, Xy({}, z, { width: j, height: O, title: F, desc: B, style: _et }), this.renderClipPath(), pG(N, this.renderMap)), this.renderLegend(), this.renderTooltip())) } }]) })(S.Component); kn(g, "displayName", n), kn(g, "defaultProps", rt({ layout: "horizontal", stackOffset: "none", barCategoryGap: "10%", barGap: 4, margin: { top: 5, right: 5, bottom: 5, left: 5 }, reverseStackOrder: !1, syncMethod: "index" }, f)), kn(g, "getDerivedStateFromProps", function (v, b) { var E = v.dataKey, M = v.data, C = v.children, N = v.width, A = v.height, j = v.layout, O = v.stackOffset, I = v.margin, D = b.dataStartIndex, F = b.dataEndIndex; if (b.updateId === void 0) { var B = eQ(v); return rt(rt(rt({}, B), {}, { updateId: 0 }, m(rt(rt({ props: v }, B), {}, { updateId: 0 }), b)), {}, { prevDataKey: E, prevData: M, prevWidth: N, prevHeight: A, prevLayout: j, prevStackOffset: O, prevMargin: I, prevChildren: C }) } if (E !== b.prevDataKey || M !== b.prevData || N !== b.prevWidth || A !== b.prevHeight || j !== b.prevLayout || O !== b.prevStackOffset || !tx(I, b.prevMargin)) { var G = eQ(v), z = { chartX: b.chartX, chartY: b.chartY, isTooltipActive: b.isTooltipActive }, q = rt(rt({}, JZ(b, M, j)), {}, { updateId: b.updateId + 1 }), Y = rt(rt(rt({}, G), z), q); return rt(rt(rt({}, Y), m(rt({ props: v }, Y), b)), {}, { prevDataKey: E, prevData: M, prevWidth: N, prevHeight: A, prevLayout: j, prevStackOffset: O, prevMargin: I, prevChildren: C }) } if (!b4(C, b.prevChildren)) { var Z, $, V, K, X = al(C, Yx), Q = X && (Z = ($ = X.props) === null || $ === void 0 ? void 0 : $.startIndex) !== null && Z !== void 0 ? Z : D, re = X && (V = (K = X.props) === null || K === void 0 ? void 0 : K.endIndex) !== null && V !== void 0 ? V : F, ce = Q !== D || re !== F, be = !An(M), de = be && !ce ? b.updateId : b.updateId + 1; return rt(rt({ updateId: de }, m(rt(rt({ props: v }, b), {}, { updateId: de, dataStartIndex: Q, dataEndIndex: re }), b)), {}, { prevChildren: C, dataStartIndex: Q, dataEndIndex: re }) } return null }), kn(g, "renderActiveDot", function (v, b, E) { var M; return S.isValidElement(v) ? M = S.cloneElement(v, b) : Rn(v) ? M = v(b) : M = P.createElement(Gu, b), P.createElement(ar, { className: "recharts-active-dot", key: E }, M) }); var x = S.forwardRef(function (b, E) { return P.createElement(g, Xy({}, b, { ref: E })) }); return x.displayName = g.displayName, x }, Lhe = k_({ chartName: "LineChart", GraphicalChild: op, axisComponents: [{ axisType: "xAxis", AxisComp: $o }, { axisType: "yAxis", AxisComp: zo }], formatAxisMap: lP }), Fhe = k_({ chartName: "BarChart", GraphicalChild: Ap, defaultTooltipEventType: "axis", validateTooltipEventTypes: ["axis", "item"], axisComponents: [{ axisType: "xAxis", AxisComp: $o }, { axisType: "yAxis", AxisComp: zo }], formatAxisMap: lP }), ket = k_({ chartName: "PieChart", GraphicalChild: Af, validateTooltipEventTypes: ["item"], defaultTooltipEventType: "item", legendContent: "children", axisComponents: [{ axisType: "angleAxis", AxisComp: iP }, { axisType: "radiusAxis", AxisComp: nP }], formatAxisMap: X9e, defaultProps: { layout: "centric", startAngle: 0, endAngle: 360, cx: "50%", cy: "50%", innerRadius: 0, outerRadius: "80%" } }), Iet = k_({ chartName: "ScatterChart", GraphicalChild: R_, defaultTooltipEventType: "item", validateTooltipEventTypes: ["item"], axisComponents: [{ axisType: "xAxis", AxisComp: $o }, { axisType: "yAxis", AxisComp: zo }, { axisType: "zAxis", AxisComp: j_ }], formatAxisMap: lP }), Uhe = k_({ chartName: "AreaChart", GraphicalChild: Pf, axisComponents: [{ axisType: "xAxis", AxisComp: $o }, { axisType: "yAxis", AxisComp: zo }], formatAxisMap: lP }); const Oet = t => { S.useEffect((() => { const e = () => { t() }; return e(), window.addEventListener("resize", e), () => window.removeEventListener("resize", e) }), [t]) }, si = { Increase: "increase", ModerateIncrease: "moderateIncrease", Decrease: "decrease", ModerateDecrease: "moderateDecrease", Unchanged: "unchanged" }, Gt = { Slate: "slate", Gray: "gray", Zinc: "zinc", Neutral: "neutral", Stone: "stone", Red: "red", Orange: "orange", Amber: "amber", Yellow: "yellow", Lime: "lime", Green: "green", Emerald: "emerald", Teal: "teal", Cyan: "cyan", Sky: "sky", Blue: "blue", Indigo: "indigo", Violet: "violet", Purple: "purple", Fuchsia: "fuchsia", Pink: "pink", Rose: "rose" }, pP = { SM: "sm" }, ix = { Left: "left", Right: "right" }, nQ = { Top: "top", Bottom: "bottom" }, Dt = { background: 500, darkBackground: 600, border: 500, darkBorder: 700, ring: 300, iconRing: 500, lightText: 400, text: 500, iconText: 600, darkText: 700 }, nd = [Gt.Blue, Gt.Cyan, Gt.Sky, Gt.Indigo, Gt.Violet, Gt.Purple, Gt.Fuchsia, Gt.Slate, Gt.Gray, Gt.Zinc, Gt.Neutral, Gt.Stone, Gt.Red, Gt.Orange, Gt.Amber, Gt.Yellow, Gt.Lime, Gt.Green, Gt.Emerald, Gt.Teal, Gt.Pink, Gt.Rose], me = Dxe({ extend: { classGroups: { shadow: [{ shadow: [{ tremor: ["input", "card", "dropdown"], "dark-tremor": ["input", "card", "dropdown"] }] }], rounded: [{ rounded: [{ tremor: ["small", "default", "full"], "dark-tremor": ["small", "default", "full"] }] }], "font-size": [{ text: [{ tremor: ["default", "title", "metric"], "dark-tremor": ["default", "title", "metric"] }] }] } } }), Det = ["slate", "gray", "zinc", "neutral", "stone", "red", "orange", "amber", "yellow", "lime", "green", "emerald", "teal", "cyan", "sky", "blue", "indigo", "violet", "purple", "fuchsia", "pink", "rose"], Let = t => Det.includes(t), Bhe = (t, e) => { if (e || t === si.Unchanged) return t; switch (t) { case si.Increase: return si.Decrease; case si.ModerateIncrease: return si.ModerateDecrease; case si.Decrease: return si.Increase; case si.ModerateDecrease: return si.ModerateIncrease }return "" }, Ou = t => t.toString(), _z = t => t.reduce(((e, n) => e + n), 0), Fet = (t, e) => { for (let n = 0; n < e.length; n++)if (e[n] === t) return !0; return !1 }; function jf(t) { return e => { t.forEach((n => { typeof n == "function" ? n(e) : n != null && (n.current = e) })) } } function Pn(t) { return e => `tremor-${t}-${e}` } function jt(t, e) { const n = Let(t); if (t === "white" || t === "black" || t === "transparent" || !e || !n) { const r = (i => i.includes("#") || i.includes("--") || i.includes("rgb"))(t) ? `[${t}]` : t; return { bgColor: `bg-${r} dark:bg-${r}`, hoverBgColor: `hover:bg-${r} dark:hover:bg-${r}`, selectBgColor: `data-[selected]:bg-${r} dark:data-[selected]:bg-${r}`, textColor: `text-${r} dark:text-${r}`, selectTextColor: `data-[selected]:text-${r} dark:data-[selected]:text-${r}`, hoverTextColor: `hover:text-${r} dark:hover:text-${r}`, borderColor: `border-${r} dark:border-${r}`, selectBorderColor: `data-[selected]:border-${r} dark:data-[selected]:border-${r}`, hoverBorderColor: `hover:border-${r} dark:hover:border-${r}`, ringColor: `ring-${r} dark:ring-${r}`, strokeColor: `stroke-${r} dark:stroke-${r}`, fillColor: `fill-${r} dark:fill-${r}` } } return { bgColor: `bg-${t}-${e} dark:bg-${t}-${e}`, selectBgColor: `data-[selected]:bg-${t}-${e} dark:data-[selected]:bg-${t}-${e}`, hoverBgColor: `hover:bg-${t}-${e} dark:hover:bg-${t}-${e}`, textColor: `text-${t}-${e} dark:text-${t}-${e}`, selectTextColor: `data-[selected]:text-${t}-${e} dark:data-[selected]:text-${t}-${e}`, hoverTextColor: `hover:text-${t}-${e} dark:hover:text-${t}-${e}`, borderColor: `border-${t}-${e} dark:border-${t}-${e}`, selectBorderColor: `data-[selected]:border-${t}-${e} dark:data-[selected]:border-${t}-${e}`, hoverBorderColor: `hover:border-${t}-${e} dark:hover:border-${t}-${e}`, ringColor: `ring-${t}-${e} dark:ring-${t}-${e}`, strokeColor: `stroke-${t}-${e} dark:stroke-${t}-${e}`, fillColor: `fill-${t}-${e} dark:fill-${t}-${e}` } } const Uet = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({}, e, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }), P.createElement("path", { d: "M8 12L14 6V18L8 12Z" })) }, Bet = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({}, e, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }), P.createElement("path", { d: "M16 12L10 18V6L16 12Z" })) }, Ez = Pn("Legend"), $et = ({ name: t, color: e, onClick: n, activeLegend: r }) => { const i = !!n; return P.createElement("li", { className: me(Ez("legendItem"), "group inline-flex items-center px-2 py-0.5 rounded-tremor-small transition whitespace-nowrap", i ? "cursor-pointer" : "cursor-default", "text-tremor-content", i ? "hover:bg-tremor-background-subtle" : "", "dark:text-dark-tremor-content", i ? "dark:hover:bg-dark-tremor-background-subtle" : ""), onClick: a => { a.stopPropagation(), n?.(t, e) } }, P.createElement("svg", { className: me("flex-none h-2 w-2 mr-1.5", jt(e, Dt.text).textColor, r && r !== t ? "opacity-40" : "opacity-100"), fill: "currentColor", viewBox: "0 0 8 8" }, P.createElement("circle", { cx: 4, cy: 4, r: 4 })), P.createElement("p", { className: me("whitespace-nowrap truncate text-tremor-default", "text-tremor-content", i ? "group-hover:text-tremor-content-emphasis" : "", "dark:text-dark-tremor-content", r && r !== t ? "opacity-40" : "opacity-100", i ? "dark:group-hover:text-dark-tremor-content-emphasis" : "") }, t)) }, rQ = ({ icon: t, onClick: e, disabled: n }) => { const r = t, [i, a] = P.useState(!1), s = P.useRef(null); return P.useEffect((() => (i ? s.current = setInterval((() => { e?.() }), 300) : clearInterval(s.current), () => clearInterval(s.current))), [i, e]), S.useEffect((() => { n && (clearInterval(s.current), a(!1)) }), [n]), P.createElement("button", { type: "button", className: me(Ez("legendSliderButton"), "w-5 group inline-flex items-center truncate rounded-tremor-small transition", n ? "cursor-not-allowed" : "cursor-pointer", n ? "text-tremor-content-subtle" : "text-tremor-content hover:text-tremor-content-emphasis hover:bg-tremor-background-subtle", n ? "dark:text-dark-tremor-subtle" : "dark:text-dark-tremor dark:hover:text-tremor-content-emphasis dark:hover:bg-dark-tremor-background-subtle"), disabled: n, onClick: o => { o.stopPropagation(), e?.() }, onMouseDown: o => { o.stopPropagation(), a(!0) }, onMouseUp: o => { o.stopPropagation(), a(!1) } }, P.createElement(r, { className: "w-full" })) }, $he = P.forwardRef(((t, e) => { const { categories: n, colors: r = nd, className: i, onClickLegendItem: a, activeLegend: s, enableLegendSlider: o = !1 } = t, c = Et(t, ["categories", "colors", "className", "onClickLegendItem", "activeLegend", "enableLegendSlider"]), u = P.useRef(null), d = P.useRef(null), [f, h] = P.useState(null), [m, g] = P.useState(null), x = P.useRef(null), v = S.useCallback((() => { const C = u?.current; if (!C) return; const N = C.scrollLeft > 0, A = C.scrollWidth - C.clientWidth > C.scrollLeft; h({ left: N, right: A }) }), [h]), b = S.useCallback((C => { var N, A; const j = u?.current, O = d?.current, I = (N = j?.clientWidth) !== null && N !== void 0 ? N : 0, D = (A = O?.clientWidth) !== null && A !== void 0 ? A : 0; j && o && (j.scrollTo({ left: C === "left" ? j.scrollLeft - I + D : j.scrollLeft + I - D, behavior: "smooth" }), setTimeout((() => { v() }), 400)) }), [o, v]); P.useEffect((() => { const C = N => { N === "ArrowLeft" ? b("left") : N === "ArrowRight" && b("right") }; return m ? (C(m), x.current = setInterval((() => { C(m) }), 300)) : clearInterval(x.current), () => clearInterval(x.current) }), [m, b]); const E = C => { C.stopPropagation(), C.key !== "ArrowLeft" && C.key !== "ArrowRight" || (C.preventDefault(), g(C.key)) }, M = C => { C.stopPropagation(), g(null) }; return P.useEffect((() => { const C = u?.current; return o && (v(), C?.addEventListener("keydown", E), C?.addEventListener("keyup", M)), () => { C?.removeEventListener("keydown", E), C?.removeEventListener("keyup", M) } }), [v, o]), P.createElement("ol", Object.assign({ ref: e, className: me(Ez("root"), "relative overflow-hidden", i) }, c), P.createElement("div", { ref: u, tabIndex: 0, className: me("h-full flex", o ? f?.right || f?.left ? "pl-4 pr-12  items-center overflow-auto snap-mandatory [&::-webkit-scrollbar]:hidden [scrollbar-width:none]" : "" : "flex-wrap") }, n.map(((C, N) => P.createElement($et, { key: `item-${N}`, name: C, color: r[N % r.length], onClick: a, activeLegend: s })))), o && (f?.right || f?.left) ? P.createElement(P.Fragment, null, P.createElement("div", { className: me("bg-tremor-background", "dark:bg-dark-tremor-background", "absolute flex top-0 pr-1 bottom-0 right-0 items-center justify-center h-full"), ref: d }, P.createElement(rQ, { icon: Uet, onClick: () => { g(null), b("left") }, disabled: !f?.left }), P.createElement(rQ, { icon: Bet, onClick: () => { g(null), b("right") }, disabled: !f?.right }))) : null) })); $he.displayName = "Legend"; const mP = ({ payload: t }, e, n, r, i, a) => { const s = S.useRef(null); Oet((() => { var c, u; n((u = (c = s.current) === null || c === void 0 ? void 0 : c.clientHeight) ? Number(u) + 20 : 60) })); const o = t.filter((c => c.type !== "none")); return P.createElement("div", { ref: s, className: "flex items-center justify-end" }, P.createElement($he, { categories: o.map((c => c.value)), colors: o.map((c => e.get(c.value))), onClickLegendItem: i, activeLegend: r, enableLegendSlider: a })) }, Mz = ({ children: t }) => P.createElement("div", { className: me("rounded-tremor-default text-tremor-default border", "bg-tremor-background shadow-tremor-dropdown border-tremor-border", "dark:bg-dark-tremor-background dark:shadow-dark-tremor-dropdown dark:border-dark-tremor-border") }, t), Tz = ({ value: t, name: e, color: n }) => P.createElement("div", { className: "flex items-center justify-between space-x-8" }, P.createElement("div", { className: "flex items-center space-x-2" }, P.createElement("span", { className: me("shrink-0 rounded-tremor-full border-2 h-3 w-3", "border-tremor-background shadow-tremor-card", "dark:border-dark-tremor-background dark:shadow-dark-tremor-card", jt(n, Dt.background).bgColor) }), P.createElement("p", { className: me("text-right whitespace-nowrap", "text-tremor-content", "dark:text-dark-tremor-content") }, e)), P.createElement("p", { className: me("font-medium tabular-nums text-right whitespace-nowrap", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, t)), Cz = ({ active: t, payload: e, label: n, categoryColors: r, valueFormatter: i }) => { if (t && e) { const a = e.filter((s => s.type !== "none")); return P.createElement(Mz, null, P.createElement("div", { className: me("border-tremor-border border-b px-4 py-2", "dark:border-dark-tremor-border") }, P.createElement("p", { className: me("font-medium", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, n)), P.createElement("div", { className: me("px-4 py-2 space-y-1") }, a.map((({ value: s, name: o }, c) => { var u; return P.createElement(Tz, { key: `id-${c}`, value: i(s), name: o, color: (u = r.get(o)) !== null && u !== void 0 ? u : Gt.Blue }) })))) } return null }, Rf = ({ className: t, noDataText: e = "No data" }) => P.createElement("div", { className: me("flex items-center justify-center w-full h-full border border-dashed rounded-tremor-default", "border-tremor-border", "dark:border-dark-tremor-border", t) }, P.createElement("p", { className: me("text-tremor-content text-tremor-default", "dark:text-dark-tremor-content") }, e)), Qg = (t, e) => { const n = new Map; return t.forEach(((r, i) => { n.set(r, e[i % e.length]) })), n }, lp = (t, e, n) => [t ? "auto" : e ?? 0, n ?? "auto"], zet = (t, e) => { if (!e) return []; const n = new Set; return t.forEach((r => { n.add(r[e]) })), Array.from(n) }; function AS(t, e) { if (t === e) return !0; if (typeof t != "object" || typeof e != "object" || t === null || e === null) return !1; const n = Object.keys(t), r = Object.keys(e); if (n.length !== r.length) return !1; for (const i of n) if (!r.includes(i) || !AS(t[i], e[i])) return !1; return !0 } function ax(t, e) { const n = []; for (const r of t) if (Object.prototype.hasOwnProperty.call(r, e) && (n.push(r[e]), n.length > 1)) return !1; return !0 } const Vet = P.forwardRef(((t, e) => { const { data: n = [], categories: r = [], index: i, stack: a = !1, colors: s = nd, valueFormatter: o = Ou, startEndOnly: c = !1, showXAxis: u = !0, showYAxis: d = !0, yAxisWidth: f = 56, intervalType: h = "equidistantPreserveStart", showAnimation: m = !1, animationDuration: g = 900, showTooltip: x = !0, showLegend: v = !0, showGridLines: b = !0, showGradient: E = !0, autoMinValue: M = !1, curveType: C = "linear", minValue: N, maxValue: A, connectNulls: j = !1, allowDecimals: O = !0, noDataText: I, className: D, onValueChange: F, enableLegendSlider: B = !1, customTooltip: G, rotateLabelX: z, padding: q = !u && !d || c && !d ? { left: 0, right: 0 } : { left: 20, right: 20 }, tickGap: Y = 5, xAxisLabel: Z, yAxisLabel: $ } = t, V = Et(t, ["data", "categories", "index", "stack", "colors", "valueFormatter", "startEndOnly", "showXAxis", "showYAxis", "yAxisWidth", "intervalType", "showAnimation", "animationDuration", "showTooltip", "showLegend", "showGridLines", "showGradient", "autoMinValue", "curveType", "minValue", "maxValue", "connectNulls", "allowDecimals", "noDataText", "className", "onValueChange", "enableLegendSlider", "customTooltip", "rotateLabelX", "padding", "tickGap", "xAxisLabel", "yAxisLabel"]), K = G, [X, Q] = S.useState(60), [re, ce] = S.useState(void 0), [be, de] = S.useState(void 0), ae = Qg(r, s), se = lp(M, N, A), he = !!F; function Ae(Ce) { he && (Ce === be && !re || ax(n, Ce) && re && re.dataKey === Ce ? (de(void 0), F?.(null)) : (de(Ce), F?.({ eventType: "category", categoryClicked: Ce })), ce(void 0)) } return P.createElement("div", Object.assign({ ref: e, className: me("w-full h-80", D) }, V), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Uhe, { data: n, onClick: he && (be || re) ? () => { ce(void 0), de(void 0), F?.(null) } : void 0, margin: { bottom: Z ? 30 : void 0, left: $ ? 20 : void 0, right: $ ? 5 : void 0, top: 5 } }, b ? P.createElement(P_, { className: me("stroke-1", "stroke-tremor-border", "dark:stroke-dark-tremor-border"), horizontal: !0, vertical: !1 }) : null, P.createElement($o, { padding: q, hide: !u, dataKey: i, tick: { transform: "translate(0, 6)" }, ticks: c ? [n[0][i], n[n.length - 1][i]] : void 0, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), interval: c ? "preserveStartEnd" : h, tickLine: !1, axisLine: !1, minTickGap: Y, angle: z?.angle, dy: z?.verticalShift, height: z?.xAxisHeight }, Z && P.createElement(ei, { position: "insideBottom", offset: -20, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, Z)), P.createElement(zo, { width: f, hide: !d, axisLine: !1, tickLine: !1, type: "number", domain: se, tick: { transform: "translate(-3, 0)" }, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickFormatter: o, allowDecimals: O }, $ && P.createElement(ei, { position: "insideLeft", style: { textAnchor: "middle" }, angle: -90, offset: -15, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, $)), P.createElement(Po, { wrapperStyle: { outline: "none" }, isAnimationActive: !1, cursor: { stroke: "#d1d5db", strokeWidth: 1 }, content: x ? ({ active: Ce, payload: fe, label: oe }) => K ? P.createElement(K, { payload: fe?.map((xe => { var _e; return Object.assign(Object.assign({}, xe), { color: (_e = ae.get(xe.dataKey)) !== null && _e !== void 0 ? _e : Gt.Gray }) })), active: Ce, label: oe }) : P.createElement(Cz, { active: Ce, payload: fe, label: oe, valueFormatter: o, categoryColors: ae }) : P.createElement(P.Fragment, null), position: { y: 0 } }), v ? P.createElement(Ru, { verticalAlign: "top", height: X, content: ({ payload: Ce }) => mP({ payload: Ce }, ae, Q, be, he ? fe => Ae(fe) : void 0, B) }) : null, r.map((Ce => { var fe, oe, xe; const _e = ((fe = ae.get(Ce)) !== null && fe !== void 0 ? fe : Gt.Gray).replace("#", ""); return P.createElement("defs", { key: Ce }, E ? P.createElement("linearGradient", { className: jt((oe = ae.get(Ce)) !== null && oe !== void 0 ? oe : Gt.Gray, Dt.text).textColor, id: _e, x1: "0", y1: "0", x2: "0", y2: "1" }, P.createElement("stop", { offset: "5%", stopColor: "currentColor", stopOpacity: re || be && be !== Ce ? .15 : .4 }), P.createElement("stop", { offset: "95%", stopColor: "currentColor", stopOpacity: 0 })) : P.createElement("linearGradient", { className: jt((xe = ae.get(Ce)) !== null && xe !== void 0 ? xe : Gt.Gray, Dt.text).textColor, id: _e, x1: "0", y1: "0", x2: "0", y2: "1" }, P.createElement("stop", { stopColor: "currentColor", stopOpacity: re || be && be !== Ce ? .1 : .3 }))) })), r.map((Ce => { var fe, oe; const xe = ((fe = ae.get(Ce)) !== null && fe !== void 0 ? fe : Gt.Gray).replace("#", ""); return P.createElement(Pf, { className: jt((oe = ae.get(Ce)) !== null && oe !== void 0 ? oe : Gt.Gray, Dt.text).strokeColor, strokeOpacity: re || be && be !== Ce ? .3 : 1, activeDot: _e => { var je; const { cx: ke, cy: Ze, stroke: Xe, strokeLinecap: nt, strokeLinejoin: Tt, strokeWidth: St, dataKey: ee } = _e; return P.createElement(Gu, { className: me("stroke-tremor-background dark:stroke-dark-tremor-background", F ? "cursor-pointer" : "", jt((je = ae.get(ee)) !== null && je !== void 0 ? je : Gt.Gray, Dt.text).fillColor), cx: ke, cy: Ze, r: 5, fill: "", stroke: Xe, strokeLinecap: nt, strokeLinejoin: Tt, strokeWidth: St, onClick: (ne, Re) => (function (Ue, et) { et.stopPropagation(), he && (Ue.index === re?.index && Ue.dataKey === re?.dataKey || ax(n, Ue.dataKey) && be && be === Ue.dataKey ? (de(void 0), ce(void 0), F?.(null)) : (de(Ue.dataKey), ce({ index: Ue.index, dataKey: Ue.dataKey }), F?.(Object.assign({ eventType: "dot", categoryClicked: Ue.dataKey }, Ue.payload)))) })(_e, Re) }) }, dot: _e => { var je; const { stroke: ke, strokeLinecap: Ze, strokeLinejoin: Xe, strokeWidth: nt, cx: Tt, cy: St, dataKey: ee, index: ne } = _e; return ax(n, Ce) && !(re || be && be !== Ce) || re?.index === ne && re?.dataKey === Ce ? P.createElement(Gu, { key: ne, cx: Tt, cy: St, r: 5, stroke: ke, fill: "", strokeLinecap: Ze, strokeLinejoin: Xe, strokeWidth: nt, className: me("stroke-tremor-background dark:stroke-dark-tremor-background", F ? "cursor-pointer" : "", jt((je = ae.get(ee)) !== null && je !== void 0 ? je : Gt.Gray, Dt.text).fillColor) }) : P.createElement(S.Fragment, { key: ne }) }, key: Ce, name: Ce, type: C, dataKey: Ce, stroke: "", fill: `url(#${xe})`, strokeWidth: 2, strokeLinejoin: "round", strokeLinecap: "round", isAnimationActive: m, animationDuration: g, stackId: a ? "a" : void 0, connectNulls: j }) })), F ? r.map((Ce => P.createElement(op, { className: me("cursor-pointer"), strokeOpacity: 0, key: Ce, name: Ce, type: C, dataKey: Ce, stroke: "transparent", fill: "transparent", legendType: "none", tooltipType: "none", strokeWidth: 12, connectNulls: j, onClick: (fe, oe) => { oe.stopPropagation(); const { name: xe } = fe; Ae(xe) } }))) : null) : P.createElement(Rf, { noDataText: I }))) })); Vet.displayName = "AreaChart"; const Nz = P.forwardRef(((t, e) => { const { data: n = [], categories: r = [], index: i, colors: a = nd, valueFormatter: s = Ou, layout: o = "horizontal", stack: c = !1, relative: u = !1, startEndOnly: d = !1, animationDuration: f = 900, showAnimation: h = !1, showXAxis: m = !0, showYAxis: g = !0, yAxisWidth: x = 56, intervalType: v = "equidistantPreserveStart", showTooltip: b = !0, showLegend: E = !0, showGridLines: M = !0, autoMinValue: C = !1, minValue: N, maxValue: A, allowDecimals: j = !0, noDataText: O, onValueChange: I, enableLegendSlider: D = !1, customTooltip: F, rotateLabelX: B, barCategoryGap: G, tickGap: z = 5, xAxisLabel: q, yAxisLabel: Y, className: Z, padding: $ = m || g ? { left: 20, right: 20 } : { left: 0, right: 0 } } = t, V = Et(t, ["data", "categories", "index", "colors", "valueFormatter", "layout", "stack", "relative", "startEndOnly", "animationDuration", "showAnimation", "showXAxis", "showYAxis", "yAxisWidth", "intervalType", "showTooltip", "showLegend", "showGridLines", "autoMinValue", "minValue", "maxValue", "allowDecimals", "noDataText", "onValueChange", "enableLegendSlider", "customTooltip", "rotateLabelX", "barCategoryGap", "tickGap", "xAxisLabel", "yAxisLabel", "className", "padding"]), K = F, [X, Q] = S.useState(60), re = Qg(r, a), [ce, be] = P.useState(void 0), [de, ae] = S.useState(void 0), se = !!I; function he(Ce, fe, oe) { var xe, _e, je, ke; oe.stopPropagation(), I && (AS(ce, Object.assign(Object.assign({}, Ce.payload), { value: Ce.value })) ? (ae(void 0), be(void 0), I?.(null)) : (ae((_e = (xe = Ce.tooltipPayload) === null || xe === void 0 ? void 0 : xe[0]) === null || _e === void 0 ? void 0 : _e.dataKey), be(Object.assign(Object.assign({}, Ce.payload), { value: Ce.value })), I?.(Object.assign({ eventType: "bar", categoryClicked: (ke = (je = Ce.tooltipPayload) === null || je === void 0 ? void 0 : je[0]) === null || ke === void 0 ? void 0 : ke.dataKey }, Ce.payload)))) } const Ae = lp(C, N, A); return P.createElement("div", Object.assign({ ref: e, className: me("w-full h-80", Z) }, V), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Fhe, { barCategoryGap: G, data: n, stackOffset: c ? "sign" : u ? "expand" : "none", layout: o === "vertical" ? "vertical" : "horizontal", onClick: se && (de || ce) ? () => { be(void 0), ae(void 0), I?.(null) } : void 0, margin: { bottom: q ? 30 : void 0, left: Y ? 20 : void 0, right: Y ? 5 : void 0, top: 5 } }, M ? P.createElement(P_, { className: me("stroke-1", "stroke-tremor-border", "dark:stroke-dark-tremor-border"), horizontal: o !== "vertical", vertical: o === "vertical" }) : null, o !== "vertical" ? P.createElement($o, { padding: $, hide: !m, dataKey: i, interval: d ? "preserveStartEnd" : v, tick: { transform: "translate(0, 6)" }, ticks: d ? [n[0][i], n[n.length - 1][i]] : void 0, fill: "", stroke: "", className: me("mt-4 text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickLine: !1, axisLine: !1, angle: B?.angle, dy: B?.verticalShift, height: B?.xAxisHeight, minTickGap: z }, q && P.createElement(ei, { position: "insideBottom", offset: -20, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, q)) : P.createElement($o, { hide: !m, type: "number", tick: { transform: "translate(-3, 0)" }, domain: Ae, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickLine: !1, axisLine: !1, tickFormatter: s, minTickGap: z, allowDecimals: j, angle: B?.angle, dy: B?.verticalShift, height: B?.xAxisHeight }, q && P.createElement(ei, { position: "insideBottom", offset: -20, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, q)), o !== "vertical" ? P.createElement(zo, { width: x, hide: !g, axisLine: !1, tickLine: !1, type: "number", domain: Ae, tick: { transform: "translate(-3, 0)" }, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickFormatter: u ? Ce => `${(100 * Ce).toString()} %` : s, allowDecimals: j }, Y && P.createElement(ei, { position: "insideLeft", style: { textAnchor: "middle" }, angle: -90, offset: -15, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, Y)) : P.createElement(zo, { width: x, hide: !g, dataKey: i, axisLine: !1, tickLine: !1, ticks: d ? [n[0][i], n[n.length - 1][i]] : void 0, type: "category", interval: "preserveStartEnd", tick: { transform: "translate(0, 6)" }, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content") }, Y && P.createElement(ei, { position: "insideLeft", style: { textAnchor: "middle" }, angle: -90, offset: -15, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, Y)), P.createElement(Po, { wrapperStyle: { outline: "none" }, isAnimationActive: !1, cursor: { fill: "#d1d5db", opacity: "0.15" }, content: b ? ({ active: Ce, payload: fe, label: oe }) => K ? P.createElement(K, { payload: fe?.map((xe => { var _e; return Object.assign(Object.assign({}, xe), { color: (_e = re.get(xe.dataKey)) !== null && _e !== void 0 ? _e : Gt.Gray }) })), active: Ce, label: oe }) : P.createElement(Cz, { active: Ce, payload: fe, label: oe, valueFormatter: s, categoryColors: re }) : P.createElement(P.Fragment, null), position: { y: 0 } }), E ? P.createElement(Ru, { verticalAlign: "top", height: X, content: ({ payload: Ce }) => mP({ payload: Ce }, re, Q, de, se ? fe => { return oe = fe, void (se && (oe !== de || ce ? (ae(oe), I?.({ eventType: "category", categoryClicked: oe })) : (ae(void 0), I?.(null)), be(void 0))); var oe } : void 0, D) }) : null, r.map((Ce => { var fe; return P.createElement(Ap, { className: me(jt((fe = re.get(Ce)) !== null && fe !== void 0 ? fe : Gt.Gray, Dt.background).fillColor, I ? "cursor-pointer" : ""), key: Ce, name: Ce, type: "linear", stackId: c || u ? "a" : void 0, dataKey: Ce, fill: "", isAnimationActive: h, animationDuration: f, shape: oe => ((xe, _e, je, ke) => { const { fillOpacity: Ze, name: Xe, payload: nt, value: Tt } = xe; let { x: St, width: ee, y: ne, height: Re } = xe; return ke === "horizontal" && Re < 0 ? (ne += Re, Re = Math.abs(Re)) : ke === "vertical" && ee < 0 && (St += ee, ee = Math.abs(ee)), P.createElement("rect", { x: St, y: ne, width: ee, height: Re, opacity: _e || je && je !== Xe ? AS(_e, Object.assign(Object.assign({}, nt), { value: Tt })) ? Ze : .3 : Ze }) })(oe, ce, de, o), onClick: he }) }))) : P.createElement(Rf, { noDataText: O }))) })); Nz.displayName = "BarChart"; const Het = ({ active: t, payload: e, valueFormatter: n }) => { if (t && e?.[0]) { const r = e?.[0]; return P.createElement(Mz, null, P.createElement("div", { className: me("px-4 py-2") }, P.createElement(Tz, { value: n(r.value), name: r.name, color: r.payload.color }))) } return null }, Wet = (t, e) => t.map(((n, r) => { const i = r < e.length ? e[r] : Gt.Gray; return Object.assign(Object.assign({}, n), { color: i, className: jt(i ?? Gt.Gray, Dt.background).fillColor, fill: "" }) })), Get = (t, e, n, r) => t || e(((i, a) => _z(i.map((s => s[a]))))(n, r)), qet = t => { const { cx: e, cy: n, innerRadius: r, outerRadius: i, startAngle: a, endAngle: s, className: o } = t; return P.createElement("g", null, P.createElement(fz, { cx: e, cy: n, innerRadius: r, outerRadius: i, startAngle: a, endAngle: s, className: o, fill: "", opacity: .3, style: { outline: "none" } })) }, Xet = P.forwardRef(((t, e) => { const { data: n = [], category: r = "value", index: i = "name", colors: a = nd, variant: s = "donut", valueFormatter: o = Ou, label: c, showLabel: u = !0, animationDuration: d = 900, showAnimation: f = !1, showTooltip: h = !0, noDataText: m, onValueChange: g, customTooltip: x, className: v } = t, b = Et(t, ["data", "category", "index", "colors", "variant", "valueFormatter", "label", "showLabel", "animationDuration", "showAnimation", "showTooltip", "noDataText", "onValueChange", "customTooltip", "className"]), E = x, M = s == "donut", C = Get(c, o, n, r), [N, A] = P.useState(void 0), j = !!g; return S.useEffect((() => { const O = document.querySelectorAll(".recharts-pie-sector"); O && O.forEach((I => { I.setAttribute("style", "outline: none") })) }), [N]), P.createElement("div", Object.assign({ ref: e, className: me("w-full h-40", v) }, b), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(ket, { onClick: j && N ? () => { A(void 0), g?.(null) } : void 0, margin: { top: 0, left: 0, right: 0, bottom: 0 } }, u && M ? P.createElement("text", { className: me("fill-tremor-content-emphasis", "dark:fill-dark-tremor-content-emphasis"), x: "50%", y: "50%", textAnchor: "middle", dominantBaseline: "middle" }, C) : null, P.createElement(Af, { className: me("stroke-tremor-background dark:stroke-dark-tremor-background", g ? "cursor-pointer" : "cursor-default"), data: Wet(n, a), cx: "50%", cy: "50%", startAngle: 90, endAngle: -270, innerRadius: M ? "75%" : "0%", outerRadius: "100%", stroke: "", strokeLinejoin: "round", dataKey: r, nameKey: i, isAnimationActive: f, animationDuration: d, onClick: function (O, I, D) { D.stopPropagation(), j && (N === I ? (A(void 0), g?.(null)) : (A(I), g?.(Object.assign({ eventType: "slice" }, O.payload.payload)))) }, activeIndex: N, inactiveShape: qet, style: { outline: "none" } }), P.createElement(Po, { wrapperStyle: { outline: "none" }, isAnimationActive: !1, content: h ? ({ active: O, payload: I }) => { var D; return E ? P.createElement(E, { payload: I?.map((F => { var B, G, z; return Object.assign(Object.assign({}, F), { color: (z = (G = (B = I?.[0]) === null || B === void 0 ? void 0 : B.payload) === null || G === void 0 ? void 0 : G.color) !== null && z !== void 0 ? z : Gt.Gray }) })), active: O, label: (D = I?.[0]) === null || D === void 0 ? void 0 : D.name }) : P.createElement(Het, { active: O, payload: I, valueFormatter: o }) } : P.createElement(P.Fragment, null) })) : P.createElement(Rf, { noDataText: m }))) })); Xet.displayName = "DonutChart"; const Az = P.forwardRef(((t, e) => { const { data: n = [], categories: r = [], index: i, colors: a = nd, valueFormatter: s = Ou, startEndOnly: o = !1, showXAxis: c = !0, showYAxis: u = !0, yAxisWidth: d = 56, intervalType: f = "equidistantPreserveStart", animationDuration: h = 900, showAnimation: m = !1, showTooltip: g = !0, showLegend: x = !0, showGridLines: v = !0, autoMinValue: b = !1, curveType: E = "linear", minValue: M, maxValue: C, connectNulls: N = !1, allowDecimals: A = !0, noDataText: j, className: O, onValueChange: I, enableLegendSlider: D = !1, customTooltip: F, rotateLabelX: B, padding: G = c || u ? { left: 20, right: 20 } : { left: 0, right: 0 }, tickGap: z = 5, xAxisLabel: q, yAxisLabel: Y } = t, Z = Et(t, ["data", "categories", "index", "colors", "valueFormatter", "startEndOnly", "showXAxis", "showYAxis", "yAxisWidth", "intervalType", "animationDuration", "showAnimation", "showTooltip", "showLegend", "showGridLines", "autoMinValue", "curveType", "minValue", "maxValue", "connectNulls", "allowDecimals", "noDataText", "className", "onValueChange", "enableLegendSlider", "customTooltip", "rotateLabelX", "padding", "tickGap", "xAxisLabel", "yAxisLabel"]), $ = F, [V, K] = S.useState(60), [X, Q] = S.useState(void 0), [re, ce] = S.useState(void 0), be = Qg(r, a), de = lp(b, M, C), ae = !!I; function se(he) { ae && (he === re && !X || ax(n, he) && X && X.dataKey === he ? (ce(void 0), I?.(null)) : (ce(he), I?.({ eventType: "category", categoryClicked: he })), Q(void 0)) } return P.createElement("div", Object.assign({ ref: e, className: me("w-full h-80", O) }, Z), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Lhe, { data: n, onClick: ae && (re || X) ? () => { Q(void 0), ce(void 0), I?.(null) } : void 0, margin: { bottom: q ? 30 : void 0, left: Y ? 20 : void 0, right: Y ? 5 : void 0, top: 5 } }, v ? P.createElement(P_, { className: me("stroke-1", "stroke-tremor-border", "dark:stroke-dark-tremor-border"), horizontal: !0, vertical: !1 }) : null, P.createElement($o, { padding: G, hide: !c, dataKey: i, interval: o ? "preserveStartEnd" : f, tick: { transform: "translate(0, 6)" }, ticks: o ? [n[0][i], n[n.length - 1][i]] : void 0, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickLine: !1, axisLine: !1, minTickGap: z, angle: B?.angle, dy: B?.verticalShift, height: B?.xAxisHeight }, q && P.createElement(ei, { position: "insideBottom", offset: -20, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, q)), P.createElement(zo, { width: d, hide: !u, axisLine: !1, tickLine: !1, type: "number", domain: de, tick: { transform: "translate(-3, 0)" }, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickFormatter: s, allowDecimals: A }, Y && P.createElement(ei, { position: "insideLeft", style: { textAnchor: "middle" }, angle: -90, offset: -15, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, Y)), P.createElement(Po, { wrapperStyle: { outline: "none" }, isAnimationActive: !1, cursor: { stroke: "#d1d5db", strokeWidth: 1 }, content: g ? ({ active: he, payload: Ae, label: Ce }) => $ ? P.createElement($, { payload: Ae?.map((fe => { var oe; return Object.assign(Object.assign({}, fe), { color: (oe = be.get(fe.dataKey)) !== null && oe !== void 0 ? oe : Gt.Gray }) })), active: he, label: Ce }) : P.createElement(Cz, { active: he, payload: Ae, label: Ce, valueFormatter: s, categoryColors: be }) : P.createElement(P.Fragment, null), position: { y: 0 } }), x ? P.createElement(Ru, { verticalAlign: "top", height: V, content: ({ payload: he }) => mP({ payload: he }, be, K, re, ae ? Ae => se(Ae) : void 0, D) }) : null, r.map((he => { var Ae; return P.createElement(op, { className: me(jt((Ae = be.get(he)) !== null && Ae !== void 0 ? Ae : Gt.Gray, Dt.text).strokeColor), strokeOpacity: X || re && re !== he ? .3 : 1, activeDot: Ce => { var fe; const { cx: oe, cy: xe, stroke: _e, strokeLinecap: je, strokeLinejoin: ke, strokeWidth: Ze, dataKey: Xe } = Ce; return P.createElement(Gu, { className: me("stroke-tremor-background dark:stroke-dark-tremor-background", I ? "cursor-pointer" : "", jt((fe = be.get(Xe)) !== null && fe !== void 0 ? fe : Gt.Gray, Dt.text).fillColor), cx: oe, cy: xe, r: 5, fill: "", stroke: _e, strokeLinecap: je, strokeLinejoin: ke, strokeWidth: Ze, onClick: (nt, Tt) => (function (St, ee) { ee.stopPropagation(), ae && (St.index === X?.index && St.dataKey === X?.dataKey || ax(n, St.dataKey) && re && re === St.dataKey ? (ce(void 0), Q(void 0), I?.(null)) : (ce(St.dataKey), Q({ index: St.index, dataKey: St.dataKey }), I?.(Object.assign({ eventType: "dot", categoryClicked: St.dataKey }, St.payload)))) })(Ce, Tt) }) }, dot: Ce => { var fe; const { stroke: oe, strokeLinecap: xe, strokeLinejoin: _e, strokeWidth: je, cx: ke, cy: Ze, dataKey: Xe, index: nt } = Ce; return ax(n, he) && !(X || re && re !== he) || X?.index === nt && X?.dataKey === he ? P.createElement(Gu, { key: nt, cx: ke, cy: Ze, r: 5, stroke: oe, fill: "", strokeLinecap: xe, strokeLinejoin: _e, strokeWidth: je, className: me("stroke-tremor-background dark:stroke-dark-tremor-background", I ? "cursor-pointer" : "", jt((fe = be.get(Xe)) !== null && fe !== void 0 ? fe : Gt.Gray, Dt.text).fillColor) }) : P.createElement(S.Fragment, { key: nt }) }, key: he, name: he, type: E, dataKey: he, stroke: "", strokeWidth: 2, strokeLinejoin: "round", strokeLinecap: "round", isAnimationActive: m, animationDuration: h, connectNulls: N }) })), I ? r.map((he => P.createElement(op, { className: me("cursor-pointer"), strokeOpacity: 0, key: he, name: he, type: E, dataKey: he, stroke: "transparent", fill: "transparent", legendType: "none", tooltipType: "none", strokeWidth: 12, connectNulls: N, onClick: (Ae, Ce) => { Ce.stopPropagation(); const { name: fe } = Ae; se(fe) } }))) : null) : P.createElement(Rf, { noDataText: j }))) })); Az.displayName = "LineChart"; const Yet = ({ children: t }) => P.createElement("div", { className: me("rounded-tremor-default text-tremor-default border", "bg-tremor-background shadow-tremor-dropdown border-tremor-border", "dark:bg-dark-tremor-background dark:shadow-dark-tremor-dropdown dark:border-dark-tremor-border") }, t), Ket = ({ value: t, name: e }) => P.createElement("div", { className: "flex items-center justify-between space-x-8" }, P.createElement("div", { className: "flex items-center space-x-2" }, P.createElement("p", { className: me("text-right whitespace-nowrap", "text-tremor-content", "dark:text-dark-tremor-content") }, e)), P.createElement("p", { className: me("font-medium tabular-nums text-right whitespace-nowrap", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, t)), Zet = ({ label: t, active: e, payload: n, valueFormatter: r, axis: i, category: a, categoryColors: s }) => { var o, c; return e && n ? P.createElement(Yet, null, P.createElement("div", { className: me("flex items-center space-x-2 border-b px-4 py-2", "border-tremor-border", "dark:border-dark-tremor-border") }, P.createElement("span", { className: me("shrink-0 rounded-tremor-full border-2 h-3 w-3", "border-tremor-background shadow-tremor-card", "dark:border-dark-tremor-background dark:shadow-dark-tremor-card", jt(a && (c = s.get((o = n?.[0]) === null || o === void 0 ? void 0 : o.payload[a])) !== null && c !== void 0 ? c : Gt.Blue, Dt.background).bgColor) }), P.createElement("p", { className: me("font-medium", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, t)), P.createElement("div", { className: me("px-4 py-2 space-y-1") }, n.map((({ value: u, name: d }, f) => { var h, m; const g = (h = Object.keys(i).find((v => i[v] === d))) !== null && h !== void 0 ? h : "", x = (m = r[g]) !== null && m !== void 0 ? m : Ou; return P.createElement(Ket, { key: `id-${f}`, value: r && x ? x(u) : `${u}`, name: d }) })))) : null }, Qet = P.forwardRef(((t, e) => { const { data: n = [], x: r, y: i, size: a, category: s, colors: o = nd, showOpacity: c = !1, sizeRange: u = [1, 1e3], valueFormatter: d = { x: Ou, y: Ou, size: Ou }, startEndOnly: f = !1, showXAxis: h = !0, showYAxis: m = !0, yAxisWidth: g = 56, intervalType: x = "equidistantPreserveStart", animationDuration: v = 900, showAnimation: b = !1, showTooltip: E = !0, showLegend: M = !0, showGridLines: C = !0, autoMinXValue: N = !1, minXValue: A, maxXValue: j, autoMinYValue: O = !1, minYValue: I, maxYValue: D, allowDecimals: F = !0, noDataText: B, onValueChange: G, customTooltip: z, rotateLabelX: q, className: Y, enableLegendSlider: Z = !1, tickGap: $ = 5, xAxisLabel: V, yAxisLabel: K } = t, X = Et(t, ["data", "x", "y", "size", "category", "colors", "showOpacity", "sizeRange", "valueFormatter", "startEndOnly", "showXAxis", "showYAxis", "yAxisWidth", "intervalType", "animationDuration", "showAnimation", "showTooltip", "showLegend", "showGridLines", "autoMinXValue", "minXValue", "maxXValue", "autoMinYValue", "minYValue", "maxYValue", "allowDecimals", "noDataText", "onValueChange", "customTooltip", "rotateLabelX", "className", "enableLegendSlider", "tickGap", "xAxisLabel", "yAxisLabel"]), Q = z, [re, ce] = S.useState(60), [be, de] = P.useState(void 0), [ae, se] = S.useState(void 0), he = !!G; function Ae(_e, je, ke) { ke.stopPropagation(), he && (AS(be, _e.node) ? (se(void 0), de(void 0), G?.(null)) : (de(_e.node), se(_e.payload[s]), G?.(Object.assign({ eventType: "bubble", categoryClicked: _e.payload[s] }, _e.payload)))) } const Ce = zet(n, s), fe = Qg(Ce, o), oe = lp(N, A, j), xe = lp(O, I, D); return P.createElement("div", Object.assign({ ref: e, className: me("w-full h-80", Y) }, X), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Iet, { onClick: he && (ae || be) ? () => { de(void 0), se(void 0), G?.(null) } : void 0, margin: { bottom: V ? 20 : void 0, left: 20, right: 20, top: 5 } }, C ? P.createElement(P_, { className: me("stroke-1", "stroke-tremor-border", "dark:stroke-dark-tremor-border"), horizontal: !0, vertical: !0 }) : null, r ? P.createElement($o, { hide: !h, dataKey: r, interval: f ? "preserveStartEnd" : x, tick: { transform: "translate(0, 6)" }, ticks: f ? [n[0][r], n[n.length - 1][r]] : void 0, type: "number", name: r, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), tickLine: !1, tickFormatter: d.x, axisLine: !1, minTickGap: $, domain: oe, allowDataOverflow: !0, angle: q?.angle, dy: q?.verticalShift, height: q?.xAxisHeight }, V && P.createElement(ei, { position: "insideBottom", offset: -20, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, V)) : null, i ? P.createElement(zo, { width: g, hide: !m, axisLine: !1, tickLine: !1, dataKey: i, type: "number", name: i, domain: xe, tick: { transform: "translate(-3, 0)" }, tickFormatter: d.y, fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content"), allowDecimals: F, allowDataOverflow: !0 }, K && P.createElement(ei, { position: "insideLeft", style: { textAnchor: "middle" }, angle: -90, offset: -15, className: "fill-tremor-content-emphasis text-tremor-default font-medium dark:fill-dark-tremor-content-emphasis" }, K)) : null, P.createElement(Po, { wrapperStyle: { outline: "none" }, isAnimationActive: !1, cursor: { stroke: "#d1d5db", strokeWidth: 1 }, content: E ? ({ active: _e, payload: je, label: ke }) => { var Ze, Xe; const nt = s ? (Xe = (Ze = je?.[0]) === null || Ze === void 0 ? void 0 : Ze.payload) === null || Xe === void 0 ? void 0 : Xe[s] : ke; return Q ? P.createElement(Q, { payload: je?.map((Tt => { var St; return Object.assign(Object.assign({}, Tt), { color: (St = fe.get(nt)) !== null && St !== void 0 ? St : Gt.Gray }) })), active: _e, label: nt }) : P.createElement(Zet, { active: _e, payload: je, label: nt, valueFormatter: d, axis: { x: r, y: i, size: a }, category: s, categoryColors: fe }) } : P.createElement(P.Fragment, null) }), a ? P.createElement(j_, { dataKey: a, type: "number", range: u, name: a }) : null, Ce.map((_e => { var je, ke; return P.createElement(R_, { className: me(jt((je = fe.get(_e)) !== null && je !== void 0 ? je : Gt.Gray, Dt.text).fillColor, c ? jt((ke = fe.get(_e)) !== null && ke !== void 0 ? ke : Gt.Gray, Dt.text).strokeColor : "", G ? "cursor-pointer" : ""), fill: `url(#${fe.get(_e)})`, fillOpacity: c ? .7 : 1, key: _e, name: _e, data: s ? n.filter((Ze => Ze[s] === _e)) : n, isAnimationActive: b, animationDuration: v, shape: Ze => ((Xe, nt, Tt) => { const { cx: St, cy: ee, width: ne, node: Re, fillOpacity: Ue, name: et } = Xe; return P.createElement(Gu, { cx: St, cy: ee, r: ne / 2, opacity: nt || Tt && Tt !== et ? AS(nt, Re) ? Ue : .3 : Ue }) })(Ze, be, ae), onClick: Ae }) })), M ? P.createElement(Ru, { verticalAlign: "top", height: re, content: ({ payload: _e }) => mP({ payload: _e }, fe, ce, ae, he ? je => { return ke = je, void (he && (ke !== ae || be ? (se(ke), G?.({ eventType: "category", categoryClicked: ke })) : (se(void 0), G?.(null)), de(void 0))); var ke } : void 0, Z) }) : null) : P.createElement(Rf, { noDataText: B }))) })); Qet.displayName = "ScatterChart"; const zhe = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M16.1716 10.9999L10.8076 5.63589L12.2218 4.22168L20 11.9999L12.2218 19.778L10.8076 18.3638L16.1716 12.9999H4V10.9999H16.1716Z" })) }, Jet = ["100%", "75%", "50%", "25%", "0%"], ett = P.forwardRef(((t, e) => {
	var n, r; const { data: i, evolutionGradient: a = !1, gradient: s = !0, valueFormatter: o = Ou, className: c, calculateFrom: u = "first", color: d, variant: f = "base", showGridLines: h = !0, showYAxis: m = u !== "previous", showXAxis: g = !0, showArrow: x = !0, xAxisLabel: v = "", yAxisLabel: b = "", yAxisPadding: E = m ? b ? 70 : 45 : 0, showTooltip: M = !0, onValueChange: C, customTooltip: N, noDataText: A, rotateLabelX: j, barGap: O = "20%" } = t, I = Et(t, ["data", "evolutionGradient", "gradient", "valueFormatter", "className", "calculateFrom", "color", "variant", "showGridLines", "showYAxis", "showXAxis", "showArrow", "xAxisLabel", "yAxisLabel", "yAxisPadding", "showTooltip", "onValueChange", "customTooltip", "noDataText", "rotateLabelX", "barGap"]), D = g && v ? 25 : 15, F = N, B = P.useRef(null), G = P.useRef(null), [z, q] = P.useState(0), [Y, Z] = P.useState(0), [$, V] = P.useState({ x: 0, y: 0 }), [K, X] = P.useState(void 0), Q = !!C, re = P.useMemo((() => Math.max(...i.map((fe => fe.value)))), [i]), ce = z - 10 - E, be = P.useMemo((() => { if (typeof O == "number") return O; if (typeof O == "string" && O.endsWith("%")) { const fe = parseFloat(O.slice(0, -1)); return ce * fe / 100 / (i.length - 1) } return console.error('Invalid barGap value. It must be a number or a percentage string (e.g., "10%").'), 30 }), [ce, i.length, O]), de = P.useMemo((() => (ce - (i.length - 1) * be - be) / i.length), [ce, be, i.length]), ae = Y - 10 - (g ? (j?.xAxisHeight || D) + (g && v ? 30 : 10) : 0), se = u === "previous", he = f === "center"; P.useLayoutEffect((() => { const fe = () => { if (B.current) { const oe = B.current.getBoundingClientRect(); q(oe.width), Z(oe.height) } }; return fe(), window.addEventListener("resize", fe), () => { window.removeEventListener("resize", fe) } }), [c]), P.useEffect((() => { const fe = () => { if (G.current) { const oe = G.current.getBoundingClientRect(); oe.right > window.innerWidth && (G.current.style.left = z - oe.width + "px") } }; return fe(), window.addEventListener("resize", fe), () => { window.removeEventListener("resize", fe) } }), [$, z]); const Ae = P.useMemo((() => ae <= 0 ? [] : i.reduce(((fe, oe, xe) => { var _e, je, ke, Ze; const Xe = fe[xe - 1], nt = oe.value, Tt = se && (_e = Xe?.value) !== null && _e !== void 0 ? _e : re, St = se && (je = Xe?.barHeight) !== null && je !== void 0 ? je : ae, ee = nt / Tt, ne = ee * St, Re = xe * (de + be) + .5 * be, Ue = St - ne + (se ? ae - ((ke = Xe?.barHeight) !== null && ke !== void 0 ? ke : ae) : 0), et = (Ze = i[xe + 1]) === null || Ze === void 0 ? void 0 : Ze.value, Ge = et / Tt, Xt = Ge * St, yt = (xe + 1) * (de + be) + .5 * be; return fe.push({ value: nt, normalizedValue: ee, name: oe.name, startX: Re, startY: Ue, barHeight: ne, nextValue: et, nextNormalizedValue: Ge, nextBarHeight: Xt, nextStartX: yt }), fe }), [])), [i, ae, se, de, be, re]), Ce = fe => { var oe; const xe = (oe = B.current) === null || oe === void 0 ? void 0 : oe.getBoundingClientRect(); if (!xe) return; const _e = xe.x, je = xe.y + window.scrollY, ke = _e + window.scrollX + E + 5, Ze = ke + (xe.width - E - 5), Xe = je + (xe.height - 5 - (g ? D : 0)); if (fe.pageX < ke || fe.pageX > Ze || fe.pageY < je || fe.pageY > Xe) return console.log("out of bounds"), V({ x: 0, y: 0 }); const nt = fe.pageX - _e - de / 2 - E - 5, Tt = Ae.reduce(((ee, ne) => Math.abs(ne.startX - nt) < Math.abs(ee.startX - nt) ? ne : ee)), St = Ae.findIndex((ee => ee === Tt)); V({ x: Tt.startX, y: Tt.startY, data: { dataKey: Tt.name, name: Tt.name, value: Tt.value, color: d ?? Gt.Blue, className: me(jt(d ?? Gt.Blue, Dt.text).textColor, Q ? "cursor-pointer" : "cursor-default"), fill: "", payload: Tt }, index: St }) }; return P.createElement("div", Object.assign({ ref: e, className: me("tremor-wrapper relative w-full h-80", c) }, I), i?.length ? P.createElement(P.Fragment, null, P.createElement("svg", { ref: B, xmlns: "http://www.w3.org/2000/svg", className: me("w-full h-full"), onMouseMove: fe => { const oe = { clientX: fe.clientX, clientY: fe.clientY, pageX: fe.pageX, pageY: fe.pageY }; Ce(oe) }, onTouchMove: fe => { const oe = fe.touches[0]; Ce(oe) }, onMouseLeave: () => V({ x: 0, y: 0 }), onTouchEnd: () => V({ x: 0, y: 0 }) }, Jet.map(((fe, oe) => P.createElement(P.Fragment, { key: `y-axis-${oe}` }, h ? P.createElement("line", { x1: E + 5, y1: oe * ae / 4 + 5, x2: z - 5, y2: oe * ae / 4 + 5, stroke: "currentColor", className: me("stroke-1", "stroke-tremor-border", "dark:stroke-dark-tremor-border") }) : null, P.createElement("text", { x: E - 10 + 5, y: oe * ae / 4 + 5 + 5, textAnchor: "end", fill: "", stroke: "", className: me("text-tremor-label", "fill-tremor-content", "dark:fill-dark-tremor-content") }, fe)))), Ae.map(((fe, oe) => { var xe, _e; return P.createElement("g", { key: `bar-${oe}` }, P.createElement("rect", { x: fe.startX - .5 * be + 5 + E, y: 5, width: de + be, height: ae, fill: "currentColor", className: me("z-0", $.index === oe ? "text-[#d1d5db]/15" : "text-transparent") }), s ? P.createElement("rect", { x: fe.startX + 5 + E, y: ae - (se && ((xe = Ae[oe - 1]) === null || xe === void 0 ? void 0 : xe.barHeight) || ae) + 5, width: de, height: (ae - fe.barHeight - (se && ae - ((_e = Ae[oe - 1]) === null || _e === void 0 ? void 0 : _e.barHeight) || 0)) / (he ? 2 : 1), fill: "url(#base-gradient)", className: me(K && K.index !== oe ? "opacity-30" : "") }) : null, P.createElement("rect", { x: fe.startX + 5 + E, y: (he ? ae / 2 - fe.barHeight / 2 : fe.startY) + 5, width: de, height: fe.barHeight, fill: "currentColor", className: me(jt(d ?? Gt.Blue, Dt.text).textColor, K && K.index !== oe ? "opacity-30" : "", Q ? "cursor-pointer" : "cursor-default"), onClick: je => (function (ke, Ze, Xe) { Xe.stopPropagation(), Q && (Ze === K?.index ? (X(void 0), C(void 0)) : (X({ data: ke, index: Ze }), C({ eventType: "bar", categoryClicked: ke.name, [ke.name]: ke.value, percentage: ke.normalizedValue }))) })(fe, oe, je) }), s && he ? P.createElement("rect", { x: fe.startX + 5 + E, y: ae / 2 + fe.barHeight / 2 + 5, width: de, height: (ae - fe.barHeight) / 2, fill: "url(#base-gradient-revert)", className: me(K && K.index !== oe ? "opacity-30" : "") }) : null, g ? P.createElement("foreignObject", { x: fe.startX + 5 + E, y: ae + 5 + 10, width: de, height: j?.xAxisHeight || D, transform: j ? `rotate(${j?.angle}, ${fe.startX + de / 2 + 5 + E}, ${ae + (j?.xAxisHeight || D) / 2 + 5 + (j?.verticalShift || 0)})` : void 0 }, P.createElement("div", { className: me("truncate text-center !text-tremor-label", "text-tremor-content", "dark:text-dark-tremor-content"), title: fe.name }, fe.name)) : null) })), Ae.map(((fe, oe) => P.createElement(P.Fragment, { key: `gradient-${oe}` }, oe < i.length - 1 && a ? P.createElement(P.Fragment, null, he ? P.createElement(P.Fragment, null, P.createElement("polygon", {
		points: `
                                    ${fe.startX + de + 5 + E}, ${ae / 2 + fe.nextBarHeight / 4 + 5}
                                    ${fe.nextStartX + 5 + E}, ${ae / 2 + fe.nextBarHeight / 4 + 5}
                                    ${fe.nextStartX + 5 + E}, ${ae / 2 - fe.nextBarHeight / 2 + 5}
                                    ${fe.startX + de + 5 + E}, ${ae / 2 - fe.barHeight / 2 + 5}
                                  `, fill: "url(#base-gradient)", className: me("z-10", K && K.index !== oe ? "opacity-30" : "")
	}), P.createElement("polygon", {
		points: `
                                    ${fe.startX + de + 5 + E}, ${ae / 2 + fe.barHeight / 2 + 5}
                                    ${fe.nextStartX + 5 + E}, ${ae / 2 + fe.nextBarHeight / 2 + 5}
                                    ${fe.nextStartX + 5 + E}, ${ae / 2 - fe.nextBarHeight / 4 + 5}
                                    ${fe.startX + de + 5 + E}, ${ae / 2 - fe.nextBarHeight / 4 + 5}
                                  `, fill: "url(#base-gradient-revert)", className: me("z-10", K && K.index !== oe ? "opacity-30" : "")
	})) : P.createElement("polygon", {
		points: `
                                  ${fe.startX + de + 5 + E}, ${fe.startY + 5} 
                                  ${fe.nextStartX + 5 + E}, ${ae - fe.nextBarHeight + 5} 
                                  ${fe.nextStartX + 5 + E}, ${ae + 5} 
                                  ${fe.startX + de + 5 + E}, ${ae + 5}
                                `, fill: "url(#base-gradient)", className: me("z-10", K && K.index !== oe ? "opacity-30" : "")
	})) : null, oe < i.length - 1 && g && x && be >= 14 ? P.createElement("foreignObject", { x: fe.startX + de + 5 + E - 6 + be / 2, y: ae + 5 + 11, width: 12, height: j?.xAxisHeight || D }, P.createElement("div", { className: me("text-tremor-content", "dark:text-dark-tremor-content") }, P.createElement(zhe, { className: "size-3.5 shrink-0" }))) : null))), P.createElement("linearGradient", { id: "base-gradient", x1: "0%", y1: "0%", x2: "0%", y2: "100%", className: me(jt(d ?? Gt.Blue, Dt.text).textColor) }, P.createElement("stop", { offset: "5%", stopColor: "currentColor", stopOpacity: .4 }), P.createElement("stop", { offset: "95%", stopColor: "currentColor", stopOpacity: 0 })), P.createElement("linearGradient", { id: "base-gradient-revert", x1: "0%", y1: "0%", x2: "0%", y2: "100%", className: me(jt(d ?? Gt.Blue, Dt.text).textColor) }, P.createElement("stop", { offset: "5%", stopColor: "currentColor", stopOpacity: 0 }), P.createElement("stop", { offset: "95%", stopColor: "currentColor", stopOpacity: .4 })), g && v ? P.createElement("text", { x: z / 2 + E / 2, y: ae + 5 + 50, style: { textAnchor: "middle" }, fill: "", stroke: "", className: me("text-tremor-default cursor-default font-medium", "fill-tremor-content-emphasis", "dark:fill-dark-tremor-content-emphasis") }, v) : null, m && b ? P.createElement("text", { x: -5, y: ae / 2 + 10, textAnchor: "middle", style: { textAnchor: "middle" }, transform: `rotate(-90, 0, ${ae / 2})`, fill: "", stroke: "", className: me("text-tremor-default cursor-default font-medium", "fill-tremor-content-emphasis", "dark:fill-dark-tremor-content-emphasis") }, b) : null), M ? P.createElement("div", { ref: G, className: me("absolute top-0 pointer-events-none", $.data ? "visible" : "hidden"), tabIndex: -1, role: "dialog", style: { left: $.x + .66 * de } }, F ? P.createElement(F, { payload: $.data ? [$.data] : [], active: !!$.data, label: (n = $.data) === null || n === void 0 ? void 0 : n.name }) : P.createElement(Mz, null, P.createElement("div", { className: me("border-tremor-border border-b px-4 py-2", "dark:border-dark-tremor-border") }, P.createElement("p", { className: me("font-medium", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, (r = $?.data) === null || r === void 0 ? void 0 : r.name)), P.createElement("div", { className: me("px-4 py-2 space-y-1") }, $.data ? P.createElement(Tz, { value: o($.data.value), name: `${(100 * $.data.payload.normalizedValue).toFixed(2)}%`, color: d ?? Gt.Blue }) : null))) : null) : P.createElement(Rf, { noDataText: A }))
})); ett.displayName = "FunnelChart"; var UT = typeof document < "u" ? S.useLayoutEffect : S.useEffect; function iA(t, e) { if (t === e) return !0; if (typeof t != typeof e) return !1; if (typeof t == "function" && t.toString() === e.toString()) return !0; let n, r, i; if (t && e && typeof t == "object") { if (Array.isArray(t)) { if (n = t.length, n != e.length) return !1; for (r = n; r-- !== 0;)if (!iA(t[r], e[r])) return !1; return !0 } if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length) return !1; for (r = n; r-- !== 0;)if (!Object.prototype.hasOwnProperty.call(e, i[r])) return !1; for (r = n; r-- !== 0;) { const a = i[r]; if (!(a === "_owner" && t.$$typeof) && !iA(t[a], e[a])) return !1 } return !0 } return t !== t && e !== e } function iQ(t) { const e = S.useRef(t); return UT(() => { e.current = t }), e } function ttt(t) { t === void 0 && (t = {}); const { placement: e = "bottom", strategy: n = "absolute", middleware: r = [], platform: i, whileElementsMounted: a, open: s } = t, [o, c] = S.useState({ x: null, y: null, strategy: n, placement: e, middlewareData: {}, isPositioned: !1 }), [u, d] = S.useState(r); iA(u, r) || d(r); const f = S.useRef(null), h = S.useRef(null), m = S.useRef(o), g = iQ(a), x = iQ(i), [v, b] = S.useState(null), [E, M] = S.useState(null), C = S.useCallback(D => { f.current !== D && (f.current = D, b(D)) }, []), N = S.useCallback(D => { h.current !== D && (h.current = D, M(D)) }, []), A = S.useCallback(() => { if (!f.current || !h.current) return; const D = { placement: e, strategy: n, middleware: u }; x.current && (D.platform = x.current), Cee(f.current, h.current, D).then(F => { const B = { ...F, isPositioned: !0 }; j.current && !iA(m.current, B) && (m.current = B, xi.flushSync(() => { c(B) })) }) }, [u, e, n, x]); UT(() => { s === !1 && m.current.isPositioned && (m.current.isPositioned = !1, c(D => ({ ...D, isPositioned: !1 }))) }, [s]); const j = S.useRef(!1); UT(() => (j.current = !0, () => { j.current = !1 }), []), UT(() => { if (v && E) { if (g.current) return g.current(v, E, A); A() } }, [v, E, A, g]); const O = S.useMemo(() => ({ reference: f, floating: h, setReference: C, setFloating: N }), [C, N]), I = S.useMemo(() => ({ reference: v, floating: E }), [v, E]); return S.useMemo(() => ({ ...o, update: A, refs: O, elements: I, reference: C, floating: N }), [o, A, O, I, C, N]) } var PS = typeof document < "u" ? S.useLayoutEffect : S.useEffect; let w3 = !1, ntt = 0; const aQ = () => "floating-ui-" + ntt++; function rtt() { const [t, e] = S.useState(() => w3 ? aQ() : void 0); return PS(() => { t == null && e(aQ()) }, []), S.useEffect(() => { w3 || (w3 = !0) }, []), t } const itt = Yh.useId, sQ = itt || rtt; function att() { const t = new Map; return { emit(e, n) { var r; (r = t.get(e)) == null || r.forEach(i => i(n)) }, on(e, n) { t.set(e, [...t.get(e) || [], n]) }, off(e, n) { t.set(e, (t.get(e) || []).filter(r => r !== n)) } } } const stt = S.createContext(null), ott = S.createContext(null), Vhe = () => { var t; return ((t = S.useContext(stt)) == null ? void 0 : t.id) || null }, Pz = () => S.useContext(ott); function Bh(t) { return t?.ownerDocument || document } function ltt() { const t = navigator.userAgentData; return t != null && t.platform ? t.platform : navigator.platform } function ctt() { const t = navigator.userAgentData; return t && Array.isArray(t.brands) ? t.brands.map(e => { let { brand: n, version: r } = e; return n + "/" + r }).join(" ") : navigator.userAgent } function jz(t) { return Bh(t).defaultView || window } function Mu(t) { return t ? t instanceof jz(t).Element : !1 } function Hhe(t) { return t ? t instanceof jz(t).HTMLElement : !1 } function utt(t) { if (typeof ShadowRoot > "u") return !1; const e = jz(t).ShadowRoot; return t instanceof e || t instanceof ShadowRoot } function dtt(t) { if (t.mozInputSource === 0 && t.isTrusted) return !0; const e = /Android/i; return (e.test(ltt()) || e.test(ctt())) && t.pointerType ? t.type === "click" && t.buttons === 1 : t.detail === 0 && !t.pointerType } function ftt(t) { return t.width === 0 && t.height === 0 || t.width === 1 && t.height === 1 && t.pressure === 0 && t.detail === 0 && t.pointerType !== "mouse" || t.width < 1 && t.height < 1 && t.pressure === 0 && t.detail === 0 } function Whe(t, e) { const n = ["mouse", "pen"]; return n.push("", void 0), n.includes(t) } function oQ(t) { const e = S.useRef(t); return PS(() => { e.current = t }), e } const lQ = "data-floating-ui-safe-polygon"; function S3(t, e, n) { return n && !Whe(n) ? 0 : typeof t == "number" ? t : t?.[e] } const htt = function (t, e) { let { enabled: n = !0, delay: r = 0, handleClose: i = null, mouseOnly: a = !1, restMs: s = 0, move: o = !0 } = e === void 0 ? {} : e; const { open: c, onOpenChange: u, dataRef: d, events: f, elements: { domReference: h, floating: m }, refs: g } = t, x = Pz(), v = Vhe(), b = oQ(i), E = oQ(r), M = S.useRef(), C = S.useRef(), N = S.useRef(), A = S.useRef(), j = S.useRef(!0), O = S.useRef(!1), I = S.useRef(() => { }), D = S.useCallback(() => { var z; const q = (z = d.current.openEvent) == null ? void 0 : z.type; return q?.includes("mouse") && q !== "mousedown" }, [d]); S.useEffect(() => { if (!n) return; function z() { clearTimeout(C.current), clearTimeout(A.current), j.current = !0 } return f.on("dismiss", z), () => { f.off("dismiss", z) } }, [n, f]), S.useEffect(() => { if (!n || !b.current || !c) return; function z() { D() && u(!1) } const q = Bh(m).documentElement; return q.addEventListener("mouseleave", z), () => { q.removeEventListener("mouseleave", z) } }, [m, c, u, n, b, d, D]); const F = S.useCallback(function (z) { z === void 0 && (z = !0); const q = S3(E.current, "close", M.current); q && !N.current ? (clearTimeout(C.current), C.current = setTimeout(() => u(!1), q)) : z && (clearTimeout(C.current), u(!1)) }, [E, u]), B = S.useCallback(() => { I.current(), N.current = void 0 }, []), G = S.useCallback(() => { if (O.current) { const z = Bh(g.floating.current).body; z.style.pointerEvents = "", z.removeAttribute(lQ), O.current = !1 } }, [g]); return S.useEffect(() => { if (!n) return; function z() { return d.current.openEvent ? ["click", "mousedown"].includes(d.current.openEvent.type) : !1 } function q($) { if (clearTimeout(C.current), j.current = !1, a && !Whe(M.current) || s > 0 && S3(E.current, "open") === 0) return; d.current.openEvent = $; const V = S3(E.current, "open", M.current); V ? C.current = setTimeout(() => { u(!0) }, V) : u(!0) } function Y($) { if (z()) return; I.current(); const V = Bh(m); if (clearTimeout(A.current), b.current) { c || clearTimeout(C.current), N.current = b.current({ ...t, tree: x, x: $.clientX, y: $.clientY, onClose() { G(), B(), F() } }); const K = N.current; V.addEventListener("mousemove", K), I.current = () => { V.removeEventListener("mousemove", K) }; return } F() } function Z($) { z() || b.current == null || b.current({ ...t, tree: x, x: $.clientX, y: $.clientY, onClose() { G(), B(), F() } })($) } if (Mu(h)) { const $ = h; return c && $.addEventListener("mouseleave", Z), m?.addEventListener("mouseleave", Z), o && $.addEventListener("mousemove", q, { once: !0 }), $.addEventListener("mouseenter", q), $.addEventListener("mouseleave", Y), () => { c && $.removeEventListener("mouseleave", Z), m?.removeEventListener("mouseleave", Z), o && $.removeEventListener("mousemove", q), $.removeEventListener("mouseenter", q), $.removeEventListener("mouseleave", Y) } } }, [h, m, n, t, a, s, o, F, B, G, u, c, x, E, b, d]), PS(() => { var z; if (n && c && (z = b.current) != null && z.__options.blockPointerEvents && D()) { const Z = Bh(m).body; if (Z.setAttribute(lQ, ""), Z.style.pointerEvents = "none", O.current = !0, Mu(h) && m) { var q, Y; const $ = h, V = x == null || (q = x.nodesRef.current.find(K => K.id === v)) == null || (Y = q.context) == null ? void 0 : Y.elements.floating; return V && (V.style.pointerEvents = ""), $.style.pointerEvents = "auto", m.style.pointerEvents = "auto", () => { $.style.pointerEvents = "", m.style.pointerEvents = "" } } } }, [n, c, v, m, h, x, b, d, D]), PS(() => { c || (M.current = void 0, B(), G()) }, [c, B, G]), S.useEffect(() => () => { B(), clearTimeout(C.current), clearTimeout(A.current), G() }, [n, B, G]), S.useMemo(() => { if (!n) return {}; function z(q) { M.current = q.pointerType } return { reference: { onPointerDown: z, onPointerEnter: z, onMouseMove() { c || s === 0 || (clearTimeout(A.current), A.current = setTimeout(() => { j.current || u(!0) }, s)) } }, floating: { onMouseEnter() { clearTimeout(C.current) }, onMouseLeave() { f.emit("dismiss", { type: "mouseLeave", data: { returnFocus: !1 } }), F(!1) } } } }, [f, n, s, c, u, F]) }; function ptt(t) { let e = t.activeElement; for (; ((n = e) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null;) { var n, r; e = e.shadowRoot.activeElement } return e } function cQ(t, e) { if (!t || !e) return !1; const n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && utt(n)) { let r = e; do { if (r && t === r) return !0; r = r.parentNode || r.host } while (r) } return !1 } function _3(t, e) { let n = t.filter(i => { var a; return i.parentId === e && ((a = i.context) == null ? void 0 : a.open) }) || [], r = n; for (; r.length;)r = t.filter(i => { var a; return (a = r) == null ? void 0 : a.some(s => { var o; return i.parentId === s.id && ((o = i.context) == null ? void 0 : o.open) }) }) || [], n = n.concat(r); return n } function mtt(t) { return "composedPath" in t ? t.composedPath()[0] : t.target } const gtt = Yh.useInsertionEffect, vtt = gtt || (t => t()); function Ghe(t) { const e = S.useRef(() => { }); return vtt(() => { e.current = t }), S.useCallback(function () { for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return e.current == null ? void 0 : e.current(...r) }, []) } function BT(t, e) { if (e == null) return !1; if ("composedPath" in t) return t.composedPath().includes(e); const n = t; return n.target != null && e.contains(n.target) } const ytt = { pointerdown: "onPointerDown", mousedown: "onMouseDown", click: "onClick" }, xtt = { pointerdown: "onPointerDownCapture", mousedown: "onMouseDownCapture", click: "onClickCapture" }, btt = function (t) { var e, n; return t === void 0 && (t = !0), { escapeKeyBubbles: typeof t == "boolean" ? t : (e = t.escapeKey) != null ? e : !0, outsidePressBubbles: typeof t == "boolean" ? t : (n = t.outsidePress) != null ? n : !0 } }, wtt = function (t, e) { let { open: n, onOpenChange: r, events: i, nodeId: a, elements: { reference: s, domReference: o, floating: c }, dataRef: u } = t, { enabled: d = !0, escapeKey: f = !0, outsidePress: h = !0, outsidePressEvent: m = "pointerdown", referencePress: g = !1, referencePressEvent: x = "pointerdown", ancestorScroll: v = !1, bubbles: b = !0 } = {}; const E = Pz(), M = Vhe() != null, C = Ghe(typeof h == "function" ? h : () => !1), N = typeof h == "function" ? C : h, A = S.useRef(!1), { escapeKeyBubbles: j, outsidePressBubbles: O } = btt(b); return S.useEffect(() => { if (!n || !d) return; u.current.__escapeKeyBubbles = j, u.current.__outsidePressBubbles = O; function I(z) { if (z.key === "Escape") { const q = E ? _3(E.nodesRef.current, a) : []; if (q.length > 0) { let Y = !0; if (q.forEach(Z => { var $; if (($ = Z.context) != null && $.open && !Z.context.dataRef.current.__escapeKeyBubbles) { Y = !1; return } }), !Y) return } i.emit("dismiss", { type: "escapeKey", data: { returnFocus: { preventScroll: !1 } } }), r(!1) } } function D(z) { const q = A.current; if (A.current = !1, q || typeof N == "function" && !N(z)) return; const Y = mtt(z); if (Hhe(Y) && c) { const V = c.ownerDocument.defaultView || window, K = Y.scrollWidth > Y.clientWidth, X = Y.scrollHeight > Y.clientHeight; let Q = X && z.offsetX > Y.clientWidth; if (X && V.getComputedStyle(Y).direction === "rtl" && (Q = z.offsetX <= Y.offsetWidth - Y.clientWidth), Q || K && z.offsetY > Y.clientHeight) return } const Z = E && _3(E.nodesRef.current, a).some(V => { var K; return BT(z, (K = V.context) == null ? void 0 : K.elements.floating) }); if (BT(z, c) || BT(z, o) || Z) return; const $ = E ? _3(E.nodesRef.current, a) : []; if ($.length > 0) { let V = !0; if ($.forEach(K => { var X; if ((X = K.context) != null && X.open && !K.context.dataRef.current.__outsidePressBubbles) { V = !1; return } }), !V) return } i.emit("dismiss", { type: "outsidePress", data: { returnFocus: M ? { preventScroll: !0 } : dtt(z) || ftt(z) } }), r(!1) } function F() { r(!1) } const B = Bh(c); f && B.addEventListener("keydown", I), N && B.addEventListener(m, D); let G = []; return v && (Mu(o) && (G = Hh(o)), Mu(c) && (G = G.concat(Hh(c))), !Mu(s) && s && s.contextElement && (G = G.concat(Hh(s.contextElement)))), G = G.filter(z => { var q; return z !== ((q = B.defaultView) == null ? void 0 : q.visualViewport) }), G.forEach(z => { z.addEventListener("scroll", F, { passive: !0 }) }), () => { f && B.removeEventListener("keydown", I), N && B.removeEventListener(m, D), G.forEach(z => { z.removeEventListener("scroll", F) }) } }, [u, c, o, s, f, N, m, i, E, a, n, r, v, d, j, O, M]), S.useEffect(() => { A.current = !1 }, [N, m]), S.useMemo(() => d ? { reference: { [ytt[x]]: () => { g && (i.emit("dismiss", { type: "referencePress", data: { returnFocus: !1 } }), r(!1)) } }, floating: { [xtt[m]]: () => { A.current = !0 } } } : {}, [d, i, g, m, x, r]) }, Stt = function (t, e) { let { open: n, onOpenChange: r, dataRef: i, events: a, refs: s, elements: { floating: o, domReference: c } } = t, { enabled: u = !0, keyboardOnly: d = !0 } = {}; const f = S.useRef(""), h = S.useRef(!1), m = S.useRef(); return S.useEffect(() => { if (!u) return; const x = Bh(o).defaultView || window; function v() { !n && Hhe(c) && c === ptt(Bh(c)) && (h.current = !0) } return x.addEventListener("blur", v), () => { x.removeEventListener("blur", v) } }, [o, c, n, u]), S.useEffect(() => { if (!u) return; function g(x) { (x.type === "referencePress" || x.type === "escapeKey") && (h.current = !0) } return a.on("dismiss", g), () => { a.off("dismiss", g) } }, [a, u]), S.useEffect(() => () => { clearTimeout(m.current) }, []), S.useMemo(() => u ? { reference: { onPointerDown(g) { let { pointerType: x } = g; f.current = x, h.current = !!(x && d) }, onMouseLeave() { h.current = !1 }, onFocus(g) { var x; h.current || g.type === "focus" && ((x = i.current.openEvent) == null ? void 0 : x.type) === "mousedown" && i.current.openEvent && BT(i.current.openEvent, c) || (i.current.openEvent = g.nativeEvent, r(!0)) }, onBlur(g) { h.current = !1; const x = g.relatedTarget, v = Mu(x) && x.hasAttribute("data-floating-ui-focus-guard") && x.getAttribute("data-type") === "outside"; m.current = setTimeout(() => { cQ(s.floating.current, x) || cQ(c, x) || v || r(!1) }) } } } : {}, [u, d, c, s, i, r]) }, _tt = function (t, e) { let { open: n } = t, { enabled: r = !0, role: i = "dialog" } = e === void 0 ? {} : e; const a = sQ(), s = sQ(); return S.useMemo(() => { const o = { id: a, role: i }; return r ? i === "tooltip" ? { reference: { "aria-describedby": n ? a : void 0 }, floating: o } : { reference: { "aria-expanded": n ? "true" : "false", "aria-haspopup": i === "alertdialog" ? "dialog" : i, "aria-controls": n ? a : void 0, ...i === "listbox" && { role: "combobox" }, ...i === "menu" && { id: s } }, floating: { ...o, ...i === "menu" && { "aria-labelledby": s } } } : {} }, [r, i, n, a, s]) }; function Ett(t) { t === void 0 && (t = {}); const { open: e = !1, onOpenChange: n, nodeId: r } = t, i = ttt(t), a = Pz(), s = S.useRef(null), o = S.useRef({}), c = S.useState(() => att())[0], [u, d] = S.useState(null), f = S.useCallback(b => { const E = Mu(b) ? { getBoundingClientRect: () => b.getBoundingClientRect(), contextElement: b } : b; i.refs.setReference(E) }, [i.refs]), h = S.useCallback(b => { (Mu(b) || b === null) && (s.current = b, d(b)), (Mu(i.refs.reference.current) || i.refs.reference.current === null || b !== null && !Mu(b)) && i.refs.setReference(b) }, [i.refs]), m = S.useMemo(() => ({ ...i.refs, setReference: h, setPositionReference: f, domReference: s }), [i.refs, h, f]), g = S.useMemo(() => ({ ...i.elements, domReference: u }), [i.elements, u]), x = Ghe(n), v = S.useMemo(() => ({ ...i, refs: m, elements: g, dataRef: o, nodeId: r, events: c, open: e, onOpenChange: x }), [i, r, c, e, x, m, g]); return PS(() => { const b = a?.nodesRef.current.find(E => E.id === r); b && (b.context = v) }), S.useMemo(() => ({ ...i, context: v, refs: m, reference: h, positionReference: f }), [i, m, v, h, f]) } function E3(t, e, n) { const r = new Map; return { ...n === "floating" && { tabIndex: -1 }, ...t, ...e.map(i => i ? i[n] : null).concat(t).reduce((i, a) => (a && Object.entries(a).forEach(s => { let [o, c] = s; if (o.indexOf("on") === 0) { if (r.has(o) || r.set(o, []), typeof c == "function") { var u; (u = r.get(o)) == null || u.push(c), i[o] = function () { for (var d, f = arguments.length, h = new Array(f), m = 0; m < f; m++)h[m] = arguments[m]; (d = r.get(o)) == null || d.forEach(g => g(...h)) } } } else i[o] = c }), i), {}) } } const Mtt = function (t) { t === void 0 && (t = []); const e = t, n = S.useCallback(a => E3(a, t, "reference"), e), r = S.useCallback(a => E3(a, t, "floating"), e), i = S.useCallback(a => E3(a, t, "item"), t.map(a => a?.item)); return S.useMemo(() => ({ getReferenceProps: n, getFloatingProps: r, getItemProps: i }), [n, r, i]) }, Xl = t => { const [e, n] = S.useState(!1), [r, i] = S.useState(), { x: a, y: s, refs: o, strategy: c, context: u } = Ett({ open: e, onOpenChange: v => { if (v && t) { const b = setTimeout((() => { n(v) }), t); i(b) } else clearTimeout(r), n(v) }, placement: "top", whileElementsMounted: A5, middleware: [Eee(5), Tee({ fallbackAxisSideDirection: "start" }), Mee()] }), d = htt(u, { move: !1 }), f = Stt(u), h = wtt(u), m = _tt(u, { role: "tooltip" }), { getReferenceProps: g, getFloatingProps: x } = Mtt([d, f, h, m]); return { tooltipProps: { open: e, x: a, y: s, refs: o, strategy: c, getFloatingProps: x }, getReferenceProps: g } }, gl = ({ text: t, open: e, x: n, y: r, refs: i, strategy: a, getFloatingProps: s }) => e && t ? P.createElement("div", Object.assign({ className: me("max-w-xs text-sm z-20 rounded-tremor-default opacity-100 px-2.5 py-1", "text-white bg-tremor-background-emphasis", "dark:text-tremor-content-emphasis dark:bg-white"), ref: i.setFloating, style: { position: a, top: r ?? 0, left: n ?? 0 } }, s()), t) : null; gl.displayName = "Tooltip"; const M3 = { xs: { paddingX: "px-2", paddingY: "py-0.5", fontSize: "text-xs" }, sm: { paddingX: "px-2.5", paddingY: "py-0.5", fontSize: "text-sm" }, md: { paddingX: "px-3", paddingY: "py-0.5", fontSize: "text-md" }, lg: { paddingX: "px-3.5", paddingY: "py-0.5", fontSize: "text-lg" }, xl: { paddingX: "px-4", paddingY: "py-1", fontSize: "text-xl" } }, uQ = { xs: { height: "h-4", width: "w-4" }, sm: { height: "h-4", width: "w-4" }, md: { height: "h-4", width: "w-4" }, lg: { height: "h-5", width: "w-5" }, xl: { height: "h-6", width: "w-6" } }, T3 = Pn("Badge"), Ttt = P.forwardRef(((t, e) => { const { color: n, icon: r, size: i = pP.SM, tooltip: a, className: s, children: o } = t, c = Et(t, ["color", "icon", "size", "tooltip", "className", "children"]), u = r || null, { tooltipProps: d, getReferenceProps: f } = Xl(); return P.createElement("span", Object.assign({ ref: jf([e, d.refs.setReference]), className: me(T3("root"), "w-max shrink-0 inline-flex justify-center items-center cursor-default rounded-tremor-small ring-1 ring-inset", n ? me(jt(n, Dt.background).bgColor, jt(n, Dt.iconText).textColor, jt(n, Dt.iconRing).ringColor, "bg-opacity-10 ring-opacity-20", "dark:bg-opacity-5 dark:ring-opacity-60") : me("bg-tremor-brand-faint text-tremor-brand-emphasis ring-tremor-brand/20", "dark:bg-dark-tremor-brand-muted/50 dark:text-dark-tremor-brand dark:ring-dark-tremor-subtle/20"), M3[i].paddingX, M3[i].paddingY, M3[i].fontSize, s) }, f, c), P.createElement(gl, Object.assign({ text: a }, d)), u ? P.createElement(u, { className: me(T3("icon"), "shrink-0 -ml-1 mr-1.5", uQ[i].height, uQ[i].width) }) : null, P.createElement("span", { className: me(T3("text"), "whitespace-nowrap") }, o)) })); Ttt.displayName = "Badge"; const Ctt = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M13.0001 16.1716L18.3641 10.8076L19.7783 12.2218L12.0001 20L4.22192 12.2218L5.63614 10.8076L11.0001 16.1716V4H13.0001V16.1716Z" })) }, Ntt = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M14.5895 16.0032L5.98291 7.39664L7.39712 5.98242L16.0037 14.589V7.00324H18.0037V18.0032H7.00373V16.0032H14.5895Z" })) }, Att = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M13.0001 7.82843V20H11.0001V7.82843L5.63614 13.1924L4.22192 11.7782L12.0001 4L19.7783 11.7782L18.3641 13.1924L13.0001 7.82843Z" })) }, Ptt = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M16.0037 9.41421L7.39712 18.0208L5.98291 16.6066L14.5895 8H7.00373V6H18.0037V17H16.0037V9.41421Z" })) }, jtt = { xs: { paddingX: "px-2", paddingY: "py-0.5", fontSize: "text-xs" }, sm: { paddingX: "px-2.5", paddingY: "py-1", fontSize: "text-sm" }, md: { paddingX: "px-3", paddingY: "py-1.5", fontSize: "text-md" }, lg: { paddingX: "px-3.5", paddingY: "py-1.5", fontSize: "text-lg" }, xl: { paddingX: "px-3.5", paddingY: "py-1.5", fontSize: "text-xl" } }, Rtt = { xs: { paddingX: "px-2", paddingY: "py-0.5", fontSize: "text-xs" }, sm: { paddingX: "px-2.5", paddingY: "py-0.5", fontSize: "text-sm" }, md: { paddingX: "px-3", paddingY: "py-0.5", fontSize: "text-md" }, lg: { paddingX: "px-3.5", paddingY: "py-0.5", fontSize: "text-lg" }, xl: { paddingX: "px-4", paddingY: "py-1", fontSize: "text-xl" } }, dQ = { xs: { height: "h-4", width: "w-4" }, sm: { height: "h-4", width: "w-4" }, md: { height: "h-4", width: "w-4" }, lg: { height: "h-5", width: "w-5" }, xl: { height: "h-6", width: "w-6" } }, C3 = { [si.Increase]: { bgColor: jt(Gt.Emerald, Dt.background).bgColor, textColor: jt(Gt.Emerald, Dt.iconText).textColor, ringColor: jt(Gt.Emerald, Dt.iconRing).ringColor }, [si.ModerateIncrease]: { bgColor: jt(Gt.Emerald, Dt.background).bgColor, textColor: jt(Gt.Emerald, Dt.iconText).textColor, ringColor: jt(Gt.Emerald, Dt.iconRing).ringColor }, [si.Decrease]: { bgColor: jt(Gt.Red, Dt.background).bgColor, textColor: jt(Gt.Red, Dt.iconText).textColor, ringColor: jt(Gt.Red, Dt.iconRing).ringColor }, [si.ModerateDecrease]: { bgColor: jt(Gt.Red, Dt.background).bgColor, textColor: jt(Gt.Red, Dt.iconText).textColor, ringColor: jt(Gt.Red, Dt.iconRing).ringColor }, [si.Unchanged]: { bgColor: jt(Gt.Orange, Dt.background).bgColor, textColor: jt(Gt.Orange, Dt.iconText).textColor, ringColor: jt(Gt.Orange, Dt.iconRing).ringColor } }, ktt = { [si.Increase]: Att, [si.ModerateIncrease]: Ptt, [si.Decrease]: Ctt, [si.ModerateDecrease]: Ntt, [si.Unchanged]: zhe }, N3 = Pn("BadgeDelta"), Itt = P.forwardRef(((t, e) => { const { deltaType: n = si.Increase, isIncreasePositive: r = !0, size: i = pP.SM, tooltip: a, children: s, className: o } = t, c = Et(t, ["deltaType", "isIncreasePositive", "size", "tooltip", "children", "className"]), u = ktt[n], d = Bhe(n, r), f = s ? Rtt : jtt, { tooltipProps: h, getReferenceProps: m } = Xl(); return P.createElement("span", Object.assign({ ref: jf([e, h.refs.setReference]), className: me(N3("root"), "w-max shrink-0 inline-flex justify-center items-center cursor-default rounded-tremor-small ring-1 ring-inset", C3[d].bgColor, C3[d].textColor, C3[d].ringColor, f[i].paddingX, f[i].paddingY, f[i].fontSize, "bg-opacity-10 ring-opacity-20", "dark:bg-opacity-5 dark:ring-opacity-60", o) }, m, c), P.createElement(gl, Object.assign({ text: a }, h)), P.createElement(u, { className: me(N3("icon"), "shrink-0", s ? me("-ml-1 mr-1.5") : dQ[i].height, dQ[i].width) }), s ? P.createElement("span", { className: me(N3("text"), "whitespace-nowrap") }, s) : null) })); Itt.displayName = "BadgeDelta"; const fQ = { xs: { paddingX: "px-1.5", paddingY: "py-1.5" }, sm: { paddingX: "px-1.5", paddingY: "py-1.5" }, md: { paddingX: "px-2", paddingY: "py-2" }, lg: { paddingX: "px-2", paddingY: "py-2" }, xl: { paddingX: "px-2.5", paddingY: "py-2.5" } }, hQ = { xs: { height: "h-3", width: "w-3" }, sm: { height: "h-5", width: "w-5" }, md: { height: "h-5", width: "w-5" }, lg: { height: "h-7", width: "w-7" }, xl: { height: "h-9", width: "w-9" } }, uT = { simple: { rounded: "", border: "", ring: "", shadow: "" }, light: { rounded: "rounded-tremor-default", border: "", ring: "", shadow: "" }, shadow: { rounded: "rounded-tremor-default", border: "border", ring: "", shadow: "shadow-tremor-card dark:shadow-dark-tremor-card" }, solid: { rounded: "rounded-tremor-default", border: "border-2", ring: "ring-1", shadow: "" }, outlined: { rounded: "rounded-tremor-default", border: "border", ring: "ring-2", shadow: "" } }, Ott = (t, e) => { switch (t) { case "simple": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand dark:text-dark-tremor-brand", bgColor: "", borderColor: "", ringColor: "" }; case "light": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand dark:text-dark-tremor-brand", bgColor: e ? me(jt(e, Dt.background).bgColor, "bg-opacity-20") : "bg-tremor-brand-muted dark:bg-dark-tremor-brand-muted", borderColor: "", ringColor: "" }; case "shadow": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand dark:text-dark-tremor-brand", bgColor: e ? me(jt(e, Dt.background).bgColor, "bg-opacity-20") : "bg-tremor-background dark:bg-dark-tremor-background", borderColor: "border-tremor-border dark:border-dark-tremor-border", ringColor: "" }; case "solid": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand-inverted dark:text-dark-tremor-brand-inverted", bgColor: e ? me(jt(e, Dt.background).bgColor, "bg-opacity-20") : "bg-tremor-brand dark:bg-dark-tremor-brand", borderColor: "border-tremor-brand-inverted dark:border-dark-tremor-brand-inverted", ringColor: "ring-tremor-ring dark:ring-dark-tremor-ring" }; case "outlined": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand dark:text-dark-tremor-brand", bgColor: e ? me(jt(e, Dt.background).bgColor, "bg-opacity-20") : "bg-tremor-background dark:bg-dark-tremor-background", borderColor: e ? jt(e, Dt.ring).borderColor : "border-tremor-brand-subtle dark:border-dark-tremor-brand-subtle", ringColor: e ? me(jt(e, Dt.ring).ringColor, "ring-opacity-40") : "ring-tremor-brand-muted dark:ring-dark-tremor-brand-muted" } } }, pQ = Pn("Icon"), Dtt = { Simple: "simple" }, qhe = P.forwardRef(((t, e) => { const { icon: n, variant: r = Dtt.Simple, tooltip: i, size: a = pP.SM, color: s, className: o } = t, c = Et(t, ["icon", "variant", "tooltip", "size", "color", "className"]), u = n, d = Ott(r, s), { tooltipProps: f, getReferenceProps: h } = Xl(); return P.createElement("span", Object.assign({ ref: jf([e, f.refs.setReference]), className: me(pQ("root"), "inline-flex shrink-0 items-center justify-center", d.bgColor, d.textColor, d.borderColor, d.ringColor, uT[r].rounded, uT[r].border, uT[r].shadow, uT[r].ring, fQ[a].paddingX, fQ[a].paddingY, o) }, h, c), P.createElement(gl, Object.assign({ text: i }, f)), P.createElement(u, { className: me(pQ("icon"), "shrink-0", hQ[a].height, hQ[a].width) })) })); qhe.displayName = "Icon"; const zF = 0, VF = 1, aA = 2, sA = 3, oA = 4, Ltt = 5, Xhe = 6, Ftt = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"], Yhe = t => ({ _s: t, status: Ftt[t], isEnter: t < sA, isMounted: t !== Xhe, isResolved: t === aA || t > oA }), HF = t => t ? Xhe : Ltt, Utt = (t, e) => { switch (t) { case VF: case zF: return aA; case oA: case sA: return HF(e) } }, Btt = t => typeof t == "object" ? [t.enter, t.exit] : [t, t], $tt = (t, e) => setTimeout(() => { isNaN(document.body.offsetTop) || t(e + 1) }, 0), mQ = (t, e, n, r, i) => { clearTimeout(r.current); const a = Yhe(t); e(a), n.current = a, i && i({ current: a }) }, ztt = ({ enter: t = !0, exit: e = !0, preEnter: n, preExit: r, timeout: i, initialEntered: a, mountOnEnter: s, unmountOnExit: o, onStateChange: c } = {}) => { const [u, d] = S.useState(() => Yhe(a ? aA : HF(s))), f = S.useRef(u), h = S.useRef(), [m, g] = Btt(i), x = S.useCallback(() => { const b = Utt(f.current._s, o); b && mQ(b, d, f, h, c) }, [c, o]), v = S.useCallback(b => { const E = C => { switch (mQ(C, d, f, h, c), C) { case VF: m >= 0 && (h.current = setTimeout(x, m)); break; case oA: g >= 0 && (h.current = setTimeout(x, g)); break; case zF: case sA: h.current = $tt(E, C); break } }, M = f.current.isEnter; typeof b != "boolean" && (b = !M), b ? !M && E(t ? n ? zF : VF : aA) : M && E(e ? r ? sA : oA : HF(o)) }, [x, c, t, e, n, r, m, g, o]); return [u, v, x] }, Vtt = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({}, e, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }), P.createElement("path", { fill: "none", d: "M0 0h24v24H0z" }), P.createElement("path", { d: "M18.364 5.636L16.95 7.05A7 7 0 1 0 19 12h2a9 9 0 1 1-2.636-6.364z" })) }, gQ = { xs: { height: "h-4", width: "w-4" }, sm: { height: "h-5", width: "w-5" }, md: { height: "h-5", width: "w-5" }, lg: { height: "h-6", width: "w-6" }, xl: { height: "h-6", width: "w-6" } }, Htt = t => t !== "light" ? { xs: { paddingX: "px-2.5", paddingY: "py-1.5", fontSize: "text-xs" }, sm: { paddingX: "px-4", paddingY: "py-2", fontSize: "text-sm" }, md: { paddingX: "px-4", paddingY: "py-2", fontSize: "text-md" }, lg: { paddingX: "px-4", paddingY: "py-2.5", fontSize: "text-lg" }, xl: { paddingX: "px-4", paddingY: "py-3", fontSize: "text-xl" } } : { xs: { paddingX: "", paddingY: "", fontSize: "text-xs" }, sm: { paddingX: "", paddingY: "", fontSize: "text-sm" }, md: { paddingX: "", paddingY: "", fontSize: "text-md" }, lg: { paddingX: "", paddingY: "", fontSize: "text-lg" }, xl: { paddingX: "", paddingY: "", fontSize: "text-xl" } }, dT = (t, e) => { switch (t) { case "primary": return { textColor: e ? jt("white").textColor : "text-tremor-brand-inverted dark:text-dark-tremor-brand-inverted", hoverTextColor: e ? jt("white").textColor : "text-tremor-brand-inverted dark:text-dark-tremor-brand-inverted", bgColor: e ? jt(e, Dt.background).bgColor : "bg-tremor-brand dark:bg-dark-tremor-brand", hoverBgColor: e ? jt(e, Dt.darkBackground).hoverBgColor : "hover:bg-tremor-brand-emphasis dark:hover:bg-dark-tremor-brand-emphasis", borderColor: e ? jt(e, Dt.border).borderColor : "border-tremor-brand dark:border-dark-tremor-brand", hoverBorderColor: e ? jt(e, Dt.darkBorder).hoverBorderColor : "hover:border-tremor-brand-emphasis dark:hover:border-dark-tremor-brand-emphasis" }; case "secondary": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand dark:text-dark-tremor-brand", hoverTextColor: e ? jt(e, Dt.text).textColor : "hover:text-tremor-brand-emphasis dark:hover:text-dark-tremor-brand-emphasis", bgColor: jt("transparent").bgColor, hoverBgColor: e ? me(jt(e, Dt.background).hoverBgColor, "hover:bg-opacity-20 dark:hover:bg-opacity-20") : "hover:bg-tremor-brand-faint dark:hover:bg-dark-tremor-brand-faint", borderColor: e ? jt(e, Dt.border).borderColor : "border-tremor-brand dark:border-dark-tremor-brand" }; case "light": return { textColor: e ? jt(e, Dt.text).textColor : "text-tremor-brand dark:text-dark-tremor-brand", hoverTextColor: e ? jt(e, Dt.darkText).hoverTextColor : "hover:text-tremor-brand-emphasis dark:hover:text-dark-tremor-brand-emphasis", bgColor: jt("transparent").bgColor, borderColor: "", hoverBorderColor: "" } } }, lA = Pn("Button"), vQ = ({ loading: t, iconSize: e, iconPosition: n, Icon: r, needMargin: i, transitionStatus: a }) => { const s = i ? n === ix.Left ? me("-ml-1", "mr-1.5") : me("-mr-1", "ml-1.5") : "", o = me("w-0 h-0"), c = { default: o, entering: o, entered: e, exiting: e, exited: o }; return t ? P.createElement(Vtt, { className: me(lA("icon"), "animate-spin shrink-0", s, c.default, c[a]), style: { transition: "width 150ms" } }) : P.createElement(r, { className: me(lA("icon"), "shrink-0", e, s) }) }, Wtt = P.forwardRef(((t, e) => { const { icon: n, iconPosition: r = ix.Left, size: i = pP.SM, color: a, variant: s = "primary", disabled: o, loading: c = !1, loadingText: u, children: d, tooltip: f, className: h } = t, m = Et(t, ["icon", "iconPosition", "size", "color", "variant", "disabled", "loading", "loadingText", "children", "tooltip", "className"]), g = n, x = c || o, v = g !== void 0 || c, b = c && u, E = !(!d && !b), M = me(gQ[i].height, gQ[i].width), C = s !== "light" ? me("rounded-tremor-default border", "shadow-tremor-input", "dark:shadow-dark-tremor-input") : "", N = dT(s, a), A = Htt(s)[i], { tooltipProps: j, getReferenceProps: O } = Xl(300), [I, D] = ztt({ timeout: 50 }); return S.useEffect((() => { D(c) }), [c]), P.createElement("button", Object.assign({ ref: jf([e, j.refs.setReference]), className: me(lA("root"), "shrink-0 inline-flex justify-center items-center group font-medium outline-none", C, A.paddingX, A.paddingY, A.fontSize, N.textColor, N.bgColor, N.borderColor, N.hoverBorderColor, x ? "opacity-50 cursor-not-allowed" : me(dT(s, a).hoverTextColor, dT(s, a).hoverBgColor, dT(s, a).hoverBorderColor), h), disabled: x }, O, m), P.createElement(gl, Object.assign({ text: f }, j)), v && r !== ix.Right ? P.createElement(vQ, { loading: c, iconSize: M, iconPosition: r, Icon: g, transitionStatus: I.status, needMargin: E }) : null, b || d ? P.createElement("span", { className: me(lA("text"), "text-tremor-default whitespace-nowrap") }, b ? u : d) : null, v && r === ix.Right ? P.createElement(vQ, { loading: c, iconSize: M, iconPosition: r, Icon: g, transitionStatus: I.status, needMargin: E }) : null) })); Wtt.displayName = "Button"; const Khe = typeof document < "u" ? P.useLayoutEffect : () => { }; var A3; const Gtt = (A3 = P.useInsertionEffect) !== null && A3 !== void 0 ? A3 : Khe; function qtt(t) { const e = S.useRef(null); return Gtt(() => { e.current = t }, [t]), S.useCallback((...n) => { const r = e.current; return r?.(...n) }, []) } const Pp = t => { var e; return (e = t?.ownerDocument) !== null && e !== void 0 ? e : document }, sg = t => t && "window" in t && t.window === t ? t : Pp(t).defaultView || window; function Xtt(t) { return t !== null && typeof t == "object" && "nodeType" in t && typeof t.nodeType == "number" } function Ytt(t) { return Xtt(t) && t.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in t } let Ktt = !1; function Rz() { return Ktt } function Zhe(t, e) { if (!Rz()) return e && t ? t.contains(e) : !1; if (!t || !e) return !1; let n = e; for (; n !== null;) { if (n === t) return !0; n.tagName === "SLOT" && n.assignedSlot ? n = n.assignedSlot.parentNode : Ytt(n) ? n = n.host : n = n.parentNode } return !1 } const WF = (t = document) => { var e; if (!Rz()) return t.activeElement; let n = t.activeElement; for (; n && "shadowRoot" in n && (!((e = n.shadowRoot) === null || e === void 0) && e.activeElement);)n = n.shadowRoot.activeElement; return n }; function Qhe(t) { return Rz() && t.target.shadowRoot && t.composedPath ? t.composedPath()[0] : t.target } function Ztt(t) { var e; if (typeof window > "u" || window.navigator == null) return !1; let n = (e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.brands; return Array.isArray(n) && n.some(r => t.test(r.brand)) || t.test(window.navigator.userAgent) } function Qtt(t) { var e; return typeof window < "u" && window.navigator != null ? t.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : !1 } function Jhe(t) { let e = null; return () => (e == null && (e = t()), e) } const Jtt = Jhe(function () { return Qtt(/^Mac/i) }), ent = Jhe(function () { return Ztt(/Android/i) }); function epe() { let t = S.useRef(new Map), e = S.useCallback((i, a, s, o) => { let c = o?.once ? (...u) => { t.current.delete(s), s(...u) } : s; t.current.set(s, { type: a, eventTarget: i, fn: c, options: o }), i.addEventListener(a, c, o) }, []), n = S.useCallback((i, a, s, o) => { var c; let u = ((c = t.current.get(s)) === null || c === void 0 ? void 0 : c.fn) || s; i.removeEventListener(a, u, o), t.current.delete(s) }, []), r = S.useCallback(() => { t.current.forEach((i, a) => { n(i.eventTarget, i.type, a, i.options) }) }, [n]); return S.useEffect(() => r, [r]), { addGlobalListener: e, removeGlobalListener: n, removeAllGlobalListeners: r } } function tnt(t) { return t.pointerType === "" && t.isTrusted ? !0 : ent() && t.pointerType ? t.type === "click" && t.buttons === 1 : t.detail === 0 && !t.pointerType } function tpe(t) { let e = t; return e.nativeEvent = t, e.isDefaultPrevented = () => e.defaultPrevented, e.isPropagationStopped = () => e.cancelBubble, e.persist = () => { }, e } function nnt(t, e) { Object.defineProperty(t, "target", { value: e }), Object.defineProperty(t, "currentTarget", { value: e }) } function npe(t) { let e = S.useRef({ isFocused: !1, observer: null }); Khe(() => { const r = e.current; return () => { r.observer && (r.observer.disconnect(), r.observer = null) } }, []); let n = qtt(r => { t?.(r) }); return S.useCallback(r => { if (r.target instanceof HTMLButtonElement || r.target instanceof HTMLInputElement || r.target instanceof HTMLTextAreaElement || r.target instanceof HTMLSelectElement) { e.current.isFocused = !0; let i = r.target, a = s => { if (e.current.isFocused = !1, i.disabled) { let o = tpe(s); n(o) } e.current.observer && (e.current.observer.disconnect(), e.current.observer = null) }; i.addEventListener("focusout", a, { once: !0 }), e.current.observer = new MutationObserver(() => { if (e.current.isFocused && i.disabled) { var s; (s = e.current.observer) === null || s === void 0 || s.disconnect(); let o = i === document.activeElement ? null : document.activeElement; i.dispatchEvent(new FocusEvent("blur", { relatedTarget: o })), i.dispatchEvent(new FocusEvent("focusout", { bubbles: !0, relatedTarget: o })) } }), e.current.observer.observe(i, { attributes: !0, attributeFilter: ["disabled"] }) } }, [n]) } let rnt = !1, I_ = null, GF = new Set, d1 = new Map, Dg = !1, qF = !1; const int = { Tab: !0, Escape: !0 }; function kz(t, e) { for (let n of GF) n(t, e) } function ant(t) { return !(t.metaKey || !Jtt() && t.altKey || t.ctrlKey || t.key === "Control" || t.key === "Shift" || t.key === "Meta") } function cA(t) { Dg = !0, ant(t) && (I_ = "keyboard", kz("keyboard", t)) } function sx(t) { I_ = "pointer", (t.type === "mousedown" || t.type === "pointerdown") && (Dg = !0, kz("pointer", t)) } function rpe(t) { tnt(t) && (Dg = !0, I_ = "virtual") } function ipe(t) { t.target === window || t.target === document || rnt || !t.isTrusted || (!Dg && !qF && (I_ = "virtual", kz("virtual", t)), Dg = !1, qF = !1) } function ape() { Dg = !1, qF = !0 } function XF(t) { if (typeof window > "u" || typeof document > "u" || d1.get(sg(t))) return; const e = sg(t), n = Pp(t); let r = e.HTMLElement.prototype.focus; e.HTMLElement.prototype.focus = function () { Dg = !0, r.apply(this, arguments) }, n.addEventListener("keydown", cA, !0), n.addEventListener("keyup", cA, !0), n.addEventListener("click", rpe, !0), e.addEventListener("focus", ipe, !0), e.addEventListener("blur", ape, !1), typeof PointerEvent < "u" && (n.addEventListener("pointerdown", sx, !0), n.addEventListener("pointermove", sx, !0), n.addEventListener("pointerup", sx, !0)), e.addEventListener("beforeunload", () => { spe(t) }, { once: !0 }), d1.set(e, { focus: r }) } const spe = (t, e) => { const n = sg(t), r = Pp(t); e && r.removeEventListener("DOMContentLoaded", e), d1.has(n) && (n.HTMLElement.prototype.focus = d1.get(n).focus, r.removeEventListener("keydown", cA, !0), r.removeEventListener("keyup", cA, !0), r.removeEventListener("click", rpe, !0), n.removeEventListener("focus", ipe, !0), n.removeEventListener("blur", ape, !1), typeof PointerEvent < "u" && (r.removeEventListener("pointerdown", sx, !0), r.removeEventListener("pointermove", sx, !0), r.removeEventListener("pointerup", sx, !0)), d1.delete(n)) }; function snt(t) { const e = Pp(t); let n; return e.readyState !== "loading" ? XF(t) : (n = () => { XF(t) }, e.addEventListener("DOMContentLoaded", n)), () => spe(t, n) } typeof document < "u" && snt(); function ope() { return I_ !== "pointer" } const ont = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]); function lnt(t, e, n) { let r = Pp(n?.target); const i = typeof window < "u" ? sg(n?.target).HTMLInputElement : HTMLInputElement, a = typeof window < "u" ? sg(n?.target).HTMLTextAreaElement : HTMLTextAreaElement, s = typeof window < "u" ? sg(n?.target).HTMLElement : HTMLElement, o = typeof window < "u" ? sg(n?.target).KeyboardEvent : KeyboardEvent; return t = t || r.activeElement instanceof i && !ont.has(r.activeElement.type) || r.activeElement instanceof a || r.activeElement instanceof s && r.activeElement.isContentEditable, !(t && e === "keyboard" && n instanceof o && !int[n.key]) } function cnt(t, e, n) { XF(), S.useEffect(() => { let r = (i, a) => { lnt(!!n?.isTextInput, i, a) && t(ope()) }; return GF.add(r), () => { GF.delete(r) } }, e) } function unt(t) { let { isDisabled: e, onFocus: n, onBlur: r, onFocusChange: i } = t; const a = S.useCallback(c => { if (c.target === c.currentTarget) return r && r(c), i && i(!1), !0 }, [r, i]), s = npe(a), o = S.useCallback(c => { const u = Pp(c.target), d = u ? WF(u) : WF(); c.target === c.currentTarget && d === Qhe(c.nativeEvent) && (n && n(c), i && i(!0), s(c)) }, [i, n, s]); return { focusProps: { onFocus: !e && (n || i || r) ? o : void 0, onBlur: !e && (r || i) ? a : void 0 } } } function dnt(t) { let { isDisabled: e, onBlurWithin: n, onFocusWithin: r, onFocusWithinChange: i } = t, a = S.useRef({ isFocusWithin: !1 }), { addGlobalListener: s, removeAllGlobalListeners: o } = epe(), c = S.useCallback(f => { f.currentTarget.contains(f.target) && a.current.isFocusWithin && !f.currentTarget.contains(f.relatedTarget) && (a.current.isFocusWithin = !1, o(), n && n(f), i && i(!1)) }, [n, i, a, o]), u = npe(c), d = S.useCallback(f => { if (!f.currentTarget.contains(f.target)) return; const h = Pp(f.target), m = WF(h); if (!a.current.isFocusWithin && m === Qhe(f.nativeEvent)) { r && r(f), i && i(!0), a.current.isFocusWithin = !0, u(f); let g = f.currentTarget; s(h, "focus", x => { if (a.current.isFocusWithin && !Zhe(g, x.target)) { let v = new h.defaultView.FocusEvent("blur", { relatedTarget: x.target }); nnt(v, g); let b = tpe(v); c(b) } }, { capture: !0 }) } }, [r, i, u, s, c]); return e ? { focusWithinProps: { onFocus: void 0, onBlur: void 0 } } : { focusWithinProps: { onFocus: d, onBlur: c } } } let YF = !1, fT = 0; function fnt() { YF = !0, setTimeout(() => { YF = !1 }, 50) } function yQ(t) { t.pointerType === "touch" && fnt() } function hnt() { if (!(typeof document > "u")) return fT === 0 && typeof PointerEvent < "u" && document.addEventListener("pointerup", yQ), fT++, () => { fT--, !(fT > 0) && typeof PointerEvent < "u" && document.removeEventListener("pointerup", yQ) } } function Jg(t) { let { onHoverStart: e, onHoverChange: n, onHoverEnd: r, isDisabled: i } = t, [a, s] = S.useState(!1), o = S.useRef({ isHovered: !1, ignoreEmulatedMouseEvents: !1, pointerType: "", target: null }).current; S.useEffect(hnt, []); let { addGlobalListener: c, removeAllGlobalListeners: u } = epe(), { hoverProps: d, triggerHoverEnd: f } = S.useMemo(() => { let h = (x, v) => { if (o.pointerType = v, i || v === "touch" || o.isHovered || !x.currentTarget.contains(x.target)) return; o.isHovered = !0; let b = x.currentTarget; o.target = b, c(Pp(x.target), "pointerover", E => { o.isHovered && o.target && !Zhe(o.target, E.target) && m(E, E.pointerType) }, { capture: !0 }), e && e({ type: "hoverstart", target: b, pointerType: v }), n && n(!0), s(!0) }, m = (x, v) => { let b = o.target; o.pointerType = "", o.target = null, !(v === "touch" || !o.isHovered || !b) && (o.isHovered = !1, u(), r && r({ type: "hoverend", target: b, pointerType: v }), n && n(!1), s(!1)) }, g = {}; return typeof PointerEvent < "u" && (g.onPointerEnter = x => { YF && x.pointerType === "mouse" || h(x, x.pointerType) }, g.onPointerLeave = x => { !i && x.currentTarget.contains(x.target) && m(x, x.pointerType) }), { hoverProps: g, triggerHoverEnd: m } }, [e, n, r, i, o, c, u]); return S.useEffect(() => { i && f({ currentTarget: o.target }, o.pointerType) }, [i]), { hoverProps: d, isHovered: a } } function jp(t = {}) { let { autoFocus: e = !1, isTextInput: n, within: r } = t, i = S.useRef({ isFocused: !1, isFocusVisible: e || ope() }), [a, s] = S.useState(!1), [o, c] = S.useState(() => i.current.isFocused && i.current.isFocusVisible), u = S.useCallback(() => c(i.current.isFocused && i.current.isFocusVisible), []), d = S.useCallback(m => { i.current.isFocused = m, s(m), u() }, [u]); cnt(m => { i.current.isFocusVisible = m, u() }, [], { isTextInput: n }); let { focusProps: f } = unt({ isDisabled: r, onFocusChange: d }), { focusWithinProps: h } = dnt({ isDisabled: !r, onFocusWithinChange: d }); return { isFocused: a, isFocusVisible: o, focusProps: r ? h : f } } var pnt = Object.defineProperty, mnt = (t, e, n) => e in t ? pnt(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, P3 = (t, e, n) => (mnt(t, typeof e != "symbol" ? e + "" : e, n), n); let gnt = class { constructor() { P3(this, "current", this.detect()), P3(this, "handoffState", "pending"), P3(this, "currentId", 0) } set(e) { this.current !== e && (this.handoffState = "pending", this.currentId = 0, this.current = e) } reset() { this.set(this.detect()) } nextId() { return ++this.currentId } get isServer() { return this.current === "server" } get isClient() { return this.current === "client" } detect() { return typeof window > "u" || typeof document > "u" ? "server" : "client" } handoff() { this.handoffState === "pending" && (this.handoffState = "complete") } get isHandoffComplete() { return this.handoffState === "complete" } }, vg = new gnt; function rd(t) { return vg.isServer ? null : t instanceof Node ? t.ownerDocument : t != null && t.hasOwnProperty("current") && t.current instanceof Node ? t.current.ownerDocument : document } function O_(t) { typeof queueMicrotask == "function" ? queueMicrotask(t) : Promise.resolve().then(t).catch(e => setTimeout(() => { throw e })) } function Gc() { let t = [], e = { addEventListener(n, r, i, a) { return n.addEventListener(r, i, a), e.add(() => n.removeEventListener(r, i, a)) }, requestAnimationFrame(...n) { let r = requestAnimationFrame(...n); return e.add(() => cancelAnimationFrame(r)) }, nextFrame(...n) { return e.requestAnimationFrame(() => e.requestAnimationFrame(...n)) }, setTimeout(...n) { let r = setTimeout(...n); return e.add(() => clearTimeout(r)) }, microTask(...n) { let r = { current: !0 }; return O_(() => { r.current && n[0]() }), e.add(() => { r.current = !1 }) }, style(n, r, i) { let a = n.style.getPropertyValue(r); return Object.assign(n.style, { [r]: i }), this.add(() => { Object.assign(n.style, { [r]: a }) }) }, group(n) { let r = Gc(); return n(r), this.add(() => r.dispose()) }, add(n) { return t.includes(n) || t.push(n), () => { let r = t.indexOf(n); if (r >= 0) for (let i of t.splice(r, 1)) i() } }, dispose() { for (let n of t.splice(0)) n() } }; return e } function id() { let [t] = S.useState(Gc); return S.useEffect(() => () => t.dispose(), [t]), t } let fr = (t, e) => { vg.isServer ? S.useEffect(t, e) : S.useLayoutEffect(t, e) }; function no(t) { let e = S.useRef(t); return fr(() => { e.current = t }, [t]), e } let ct = function (t) { let e = no(t); return P.useCallback((...n) => e.current(...n), [e]) }; function vnt(t) { let e = t.width / 2, n = t.height / 2; return { top: t.clientY - n, right: t.clientX + e, bottom: t.clientY + n, left: t.clientX - e } } function ynt(t, e) { return !(!t || !e || t.right < e.left || t.left > e.right || t.bottom < e.top || t.top > e.bottom) } function H0({ disabled: t = !1 } = {}) { let e = S.useRef(null), [n, r] = S.useState(!1), i = id(), a = ct(() => { e.current = null, r(!1), i.dispose() }), s = ct(o => { if (i.dispose(), e.current === null) { e.current = o.currentTarget, r(!0); { let c = rd(o.currentTarget); i.addEventListener(c, "pointerup", a, !1), i.addEventListener(c, "pointermove", u => { if (e.current) { let d = vnt(u); r(ynt(d, e.current.getBoundingClientRect())) } }, !1), i.addEventListener(c, "pointercancel", a, !1) } } }); return { pressed: n, pressProps: t ? {} : { onPointerDown: s, onPointerUp: a, onClick: a } } } let xnt = S.createContext(void 0); function D_() { return S.useContext(xnt) } function KF(...t) { return Array.from(new Set(t.flatMap(e => typeof e == "string" ? e.split(" ") : []))).filter(Boolean).join(" ") } function Er(t, e, ...n) { if (t in e) { let i = e[t]; return typeof i == "function" ? i(...n) : i } let r = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map(i => `"${i}"`).join(", ")}.`); throw Error.captureStackTrace && Error.captureStackTrace(r, Er), r } var js = (t => (t[t.None = 0] = "None", t[t.RenderStrategy = 1] = "RenderStrategy", t[t.Static = 2] = "Static", t))(js || {}), $h = (t => (t[t.Unmount = 0] = "Unmount", t[t.Hidden = 1] = "Hidden", t))($h || {}); function mr() { let t = wnt(); return S.useCallback(e => bnt({ mergeRefs: t, ...e }), [t]) } function bnt({ ourProps: t, theirProps: e, slot: n, defaultTag: r, features: i, visible: a = !0, name: s, mergeRefs: o }) { o = o ?? Snt; let c = lpe(e, t); if (a) return hT(c, n, r, s, o); let u = i ?? 0; if (u & 2) { let { static: d = !1, ...f } = c; if (d) return hT(f, n, r, s, o) } if (u & 1) { let { unmount: d = !0, ...f } = c; return Er(d ? 0 : 1, { 0() { return null }, 1() { return hT({ ...f, hidden: !0, style: { display: "none" } }, n, r, s, o) } }) } return hT(c, n, r, s, o) } function hT(t, e = {}, n, r, i) {
	let { as: a = n, children: s, refName: o = "ref", ...c } = j3(t, ["unmount", "static"]), u = t.ref !== void 0 ? { [o]: t.ref } : {}, d = typeof s == "function" ? s(e) : s; "className" in c && c.className && typeof c.className == "function" && (c.className = c.className(e)), c["aria-labelledby"] && c["aria-labelledby"] === c.id && (c["aria-labelledby"] = void 0); let f = {}; if (e) { let h = !1, m = []; for (let [g, x] of Object.entries(e)) typeof x == "boolean" && (h = !0), x === !0 && m.push(g.replace(/([A-Z])/g, v => `-${v.toLowerCase()}`)); if (h) { f["data-headlessui-state"] = m.join(" "); for (let g of m) f[`data-${g}`] = "" } } if (a === S.Fragment && (Object.keys(Ph(c)).length > 0 || Object.keys(Ph(f)).length > 0)) if (!S.isValidElement(d) || Array.isArray(d) && d.length > 1) {
		if (Object.keys(Ph(c)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${r} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(Ph(c)).concat(Object.keys(Ph(f))).map(h => `  - ${h}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(h => `  - ${h}`).join(`
`)].join(`
`))
	} else { let h = d.props, m = h?.className, g = typeof m == "function" ? (...b) => KF(m(...b), c.className) : KF(m, c.className), x = g ? { className: g } : {}, v = lpe(d.props, Ph(j3(c, ["ref"]))); for (let b in f) b in v && delete f[b]; return S.cloneElement(d, Object.assign({}, v, f, u, { ref: i(_nt(d), u.ref) }, x)) } return S.createElement(a, Object.assign({}, j3(c, ["ref"]), a !== S.Fragment && u, a !== S.Fragment && f), d)
} function wnt() { let t = S.useRef([]), e = S.useCallback(n => { for (let r of t.current) r != null && (typeof r == "function" ? r(n) : r.current = n) }, []); return (...n) => { if (!n.every(r => r == null)) return t.current = n, e } } function Snt(...t) { return t.every(e => e == null) ? void 0 : e => { for (let n of t) n != null && (typeof n == "function" ? n(e) : n.current = e) } } function lpe(...t) { if (t.length === 0) return {}; if (t.length === 1) return t[0]; let e = {}, n = {}; for (let r of t) for (let i in r) i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : e[i] = r[i]; if (e.disabled || e["aria-disabled"]) for (let r in n) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(r) && (n[r] = [i => { var a; return (a = i?.preventDefault) == null ? void 0 : a.call(i) }]); for (let r in n) Object.assign(e, { [r](i, ...a) { let s = n[r]; for (let o of s) { if ((i instanceof Event || i?.nativeEvent instanceof Event) && i.defaultPrevented) return; o(i, ...a) } } }); return e } function vl(...t) { if (t.length === 0) return {}; if (t.length === 1) return t[0]; let e = {}, n = {}; for (let r of t) for (let i in r) i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : e[i] = r[i]; for (let r in n) Object.assign(e, { [r](...i) { let a = n[r]; for (let s of a) s?.(...i) } }); return e } function dr(t) { var e; return Object.assign(S.forwardRef(t), { displayName: (e = t.displayName) != null ? e : t.name }) } function Ph(t) { let e = Object.assign({}, t); for (let n in e) e[n] === void 0 && delete e[n]; return e } function j3(t, e = []) { let n = Object.assign({}, t); for (let r of e) r in n && delete n[r]; return n } function _nt(t) { return P.version.split(".")[0] >= "19" ? t.props.ref : t.ref } function Iz(t, e, n) { let [r, i] = S.useState(n), a = t !== void 0, s = S.useRef(a), o = S.useRef(!1), c = S.useRef(!1); return a && !s.current && !o.current ? (o.current = !0, s.current = a, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !a && s.current && !c.current && (c.current = !0, s.current = a, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [a ? t : r, ct(u => (a || i(u), e?.(u)))] } function Oz(t) { let [e] = S.useState(t); return e } function cpe(t = {}, e = null, n = []) { for (let [r, i] of Object.entries(t)) dpe(n, upe(e, r), i); return n } function upe(t, e) { return t ? t + "[" + e + "]" : e } function dpe(t, e, n) { if (Array.isArray(n)) for (let [r, i] of n.entries()) dpe(t, upe(e, r.toString()), i); else n instanceof Date ? t.push([e, n.toISOString()]) : typeof n == "boolean" ? t.push([e, n ? "1" : "0"]) : typeof n == "string" ? t.push([e, n]) : typeof n == "number" ? t.push([e, `${n}`]) : n == null ? t.push([e, ""]) : cpe(n, e, t) } function fpe(t) { var e, n; let r = (e = t?.form) != null ? e : t.closest("form"); if (r) { for (let i of r.elements) if (i !== t && (i.tagName === "INPUT" && i.type === "submit" || i.tagName === "BUTTON" && i.type === "submit" || i.nodeName === "INPUT" && i.type === "image")) { i.click(); return } (n = r.requestSubmit) == null || n.call(r) } } let Ent = "span"; var qu = (t => (t[t.None = 1] = "None", t[t.Focusable = 2] = "Focusable", t[t.Hidden = 4] = "Hidden", t))(qu || {}); function Mnt(t, e) { var n; let { features: r = 1, ...i } = t, a = { ref: e, "aria-hidden": (r & 2) === 2 ? !0 : (n = i["aria-hidden"]) != null ? n : void 0, hidden: (r & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(r & 4) === 4 && (r & 2) !== 2 && { display: "none" } } }; return mr()({ ourProps: a, theirProps: i, slot: {}, defaultTag: Ent, name: "Hidden" }) } let Xu = dr(Mnt), Tnt = S.createContext(null); function Cnt({ children: t }) { let e = S.useContext(Tnt); if (!e) return P.createElement(P.Fragment, null, t); let { target: n } = e; return n ? xi.createPortal(P.createElement(P.Fragment, null, t), n) : null } function Dz({ data: t, form: e, disabled: n, onReset: r, overrides: i }) { let [a, s] = S.useState(null), o = id(); return S.useEffect(() => { if (r && a) return o.addEventListener(a, "reset", r) }, [a, e, r]), P.createElement(Cnt, null, P.createElement(Nnt, { setForm: s, formId: e }), cpe(t).map(([c, u]) => P.createElement(Xu, { features: qu.Hidden, ...Ph({ key: c, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: e, disabled: n, name: c, value: u, ...i }) }))) } function Nnt({ setForm: t, formId: e }) { return S.useEffect(() => { if (e) { let n = document.getElementById(e); n && t(n) } }, [t, e]), e ? null : P.createElement(Xu, { features: qu.Hidden, as: "input", type: "hidden", hidden: !0, readOnly: !0, ref: n => { if (!n) return; let r = n.closest("form"); r && t(r) } }) } let Ant = S.createContext(void 0); function gP() { return S.useContext(Ant) } function W0(t) { let e = t.parentElement, n = null; for (; e && !(e instanceof HTMLFieldSetElement);)e instanceof HTMLLegendElement && (n = e), e = e.parentElement; let r = e?.getAttribute("disabled") === ""; return r && Pnt(n) ? !1 : r } function Pnt(t) { if (!t) return !1; let e = t.previousElementSibling; for (; e !== null;) { if (e instanceof HTMLLegendElement) return !1; e = e.previousElementSibling } return !0 } let hpe = Symbol(); function Lz(t, e = !0) { return Object.assign(t, { [hpe]: e }) } function Mr(...t) { let e = S.useRef(t); S.useEffect(() => { e.current = t }, [t]); let n = ct(r => { for (let i of e.current) i != null && (typeof i == "function" ? i(r) : i.current = r) }); return t.every(r => r == null || r?.[hpe]) ? void 0 : n } let vP = S.createContext(null); vP.displayName = "DescriptionContext"; function ppe() { let t = S.useContext(vP); if (t === null) { let e = new Error("You used a <Description /> component, but it is not inside a relevant parent."); throw Error.captureStackTrace && Error.captureStackTrace(e, ppe), e } return t } function Fz() { var t, e; return (e = (t = S.useContext(vP)) == null ? void 0 : t.value) != null ? e : void 0 } function mpe() { let [t, e] = S.useState([]); return [t.length > 0 ? t.join(" ") : void 0, S.useMemo(() => function (n) { let r = ct(a => (e(s => [...s, a]), () => e(s => { let o = s.slice(), c = o.indexOf(a); return c !== -1 && o.splice(c, 1), o }))), i = S.useMemo(() => ({ register: r, slot: n.slot, name: n.name, props: n.props, value: n.value }), [r, n.slot, n.name, n.props, n.value]); return P.createElement(vP.Provider, { value: i }, n.children) }, [e])] } let jnt = "p"; function Rnt(t, e) { let n = S.useId(), r = D_(), { id: i = `headlessui-description-${n}`, ...a } = t, s = ppe(), o = Mr(e); fr(() => s.register(i), [i, s.register]); let c = r || !1, u = S.useMemo(() => ({ ...s.slot, disabled: c }), [s.slot, c]), d = { ref: o, ...s.props, id: i }; return mr()({ ourProps: d, theirProps: a, slot: u, defaultTag: jnt, name: s.name || "Description" }) } let knt = dr(Rnt), gpe = Object.assign(knt, {}); var Sn = (t => (t.Space = " ", t.Enter = "Enter", t.Escape = "Escape", t.Backspace = "Backspace", t.Delete = "Delete", t.ArrowLeft = "ArrowLeft", t.ArrowUp = "ArrowUp", t.ArrowRight = "ArrowRight", t.ArrowDown = "ArrowDown", t.Home = "Home", t.End = "End", t.PageUp = "PageUp", t.PageDown = "PageDown", t.Tab = "Tab", t))(Sn || {}); let yP = S.createContext(null); yP.displayName = "LabelContext"; function vpe() { let t = S.useContext(yP); if (t === null) { let e = new Error("You used a <Label /> component, but it is not inside a relevant parent."); throw Error.captureStackTrace && Error.captureStackTrace(e, vpe), e } return t } function G0(t) { var e, n, r; let i = (n = (e = S.useContext(yP)) == null ? void 0 : e.value) != null ? n : void 0; return ((r = t?.length) != null ? r : 0) > 0 ? [i, ...t].filter(Boolean).join(" ") : i } function Uz({ inherit: t = !1 } = {}) { let e = G0(), [n, r] = S.useState([]), i = t ? [e, ...n].filter(Boolean) : n; return [i.length > 0 ? i.join(" ") : void 0, S.useMemo(() => function (a) { let s = ct(c => (r(u => [...u, c]), () => r(u => { let d = u.slice(), f = d.indexOf(c); return f !== -1 && d.splice(f, 1), d }))), o = S.useMemo(() => ({ register: s, slot: a.slot, name: a.name, props: a.props, value: a.value }), [s, a.slot, a.name, a.props, a.value]); return P.createElement(yP.Provider, { value: o }, a.children) }, [r])] } let Int = "label"; function Ont(t, e) { var n; let r = S.useId(), i = vpe(), a = gP(), s = D_(), { id: o = `headlessui-label-${r}`, htmlFor: c = a ?? ((n = i.props) == null ? void 0 : n.htmlFor), passive: u = !1, ...d } = t, f = Mr(e); fr(() => i.register(o), [o, i.register]); let h = ct(v => { let b = v.currentTarget; if (b instanceof HTMLLabelElement && v.preventDefault(), i.props && "onClick" in i.props && typeof i.props.onClick == "function" && i.props.onClick(v), b instanceof HTMLLabelElement) { let E = document.getElementById(b.htmlFor); if (E) { let M = E.getAttribute("disabled"); if (M === "true" || M === "") return; let C = E.getAttribute("aria-disabled"); if (C === "true" || C === "") return; (E instanceof HTMLInputElement && (E.type === "radio" || E.type === "checkbox") || E.role === "radio" || E.role === "checkbox" || E.role === "switch") && E.click(), E.focus({ preventScroll: !0 }) } } }), m = s || !1, g = S.useMemo(() => ({ ...i.slot, disabled: m }), [i.slot, m]), x = { ref: f, ...i.props, id: o, htmlFor: c, onClick: h }; return u && ("onClick" in x && (delete x.htmlFor, delete x.onClick), "onClick" in d && delete d.onClick), mr()({ ourProps: x, theirProps: d, slot: g, defaultTag: c ? Int : "div", name: i.name || "Label" }) } let Dnt = dr(Ont), Bz = Object.assign(Dnt, {}), Lnt = S.createContext(() => { }); function $z({ value: t, children: e }) { return P.createElement(Lnt.Provider, { value: t }, e) } function Cy(t, e, n) {
	let r = n.initialDeps ?? [], i; function a() {
		var s, o, c, u; let d; n.key && ((s = n.debug) != null && s.call(n)) && (d = Date.now()); const f = t(); if (!(f.length !== r.length || f.some((g, x) => r[x] !== g))) return i; r = f; let m; if (n.key && ((o = n.debug) != null && o.call(n)) && (m = Date.now()), i = e(...f), n.key && ((c = n.debug) != null && c.call(n))) {
			const g = Math.round((Date.now() - d) * 100) / 100, x = Math.round((Date.now() - m) * 100) / 100, v = x / 16, b = (E, M) => { for (E = String(E); E.length < M;)E = " " + E; return E }; console.info(`%c ${b(x, 5)} /${b(g, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * v, 120))}deg 100% 31%);`, n?.key)
		} return (u = n?.onChange) == null || u.call(n, i), i
	} return a.updateDeps = s => { r = s }, a
} function xQ(t, e) { if (t === void 0) throw new Error("Unexpected undefined"); return t } const Fnt = (t, e) => Math.abs(t - e) < 1.01, Unt = (t, e, n) => { let r; return function (...i) { t.clearTimeout(r), r = t.setTimeout(() => e.apply(this, i), n) } }, bQ = t => { const { offsetWidth: e, offsetHeight: n } = t; return { width: e, height: n } }, Bnt = t => t, $nt = t => { const e = Math.max(t.startIndex - t.overscan, 0), n = Math.min(t.endIndex + t.overscan, t.count - 1), r = []; for (let i = e; i <= n; i++)r.push(i); return r }, znt = (t, e) => { const n = t.scrollElement; if (!n) return; const r = t.targetWindow; if (!r) return; const i = s => { const { width: o, height: c } = s; e({ width: Math.round(o), height: Math.round(c) }) }; if (i(bQ(n)), !r.ResizeObserver) return () => { }; const a = new r.ResizeObserver(s => { const o = () => { const c = s[0]; if (c?.borderBoxSize) { const u = c.borderBoxSize[0]; if (u) { i({ width: u.inlineSize, height: u.blockSize }); return } } i(bQ(n)) }; t.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(o) : o() }); return a.observe(n, { box: "border-box" }), () => { a.unobserve(n) } }, wQ = { passive: !0 }, SQ = typeof window > "u" ? !0 : "onscrollend" in window, Vnt = (t, e) => { const n = t.scrollElement; if (!n) return; const r = t.targetWindow; if (!r) return; let i = 0; const a = t.options.useScrollendEvent && SQ ? () => { } : Unt(r, () => { e(i, !1) }, t.options.isScrollingResetDelay), s = d => () => { const { horizontal: f, isRtl: h } = t.options; i = f ? n.scrollLeft * (h && -1 || 1) : n.scrollTop, a(), e(i, d) }, o = s(!0), c = s(!1); c(), n.addEventListener("scroll", o, wQ); const u = t.options.useScrollendEvent && SQ; return u && n.addEventListener("scrollend", c, wQ), () => { n.removeEventListener("scroll", o), u && n.removeEventListener("scrollend", c) } }, Hnt = (t, e, n) => { if (e?.borderBoxSize) { const r = e.borderBoxSize[0]; if (r) return Math.round(r[n.options.horizontal ? "inlineSize" : "blockSize"]) } return t[n.options.horizontal ? "offsetWidth" : "offsetHeight"] }, Wnt = (t, { adjustments: e = 0, behavior: n }, r) => { var i, a; const s = t + e; (a = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || a.call(i, { [r.options.horizontal ? "left" : "top"]: s, behavior: n }) }; class Gnt { constructor(e) { this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.measurementsCache = [], this.itemSizeCache = new Map, this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = new Map, this.observer = (() => { let n = null; const r = () => n || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : n = new this.targetWindow.ResizeObserver(i => { i.forEach(a => { const s = () => { this._measureElement(a.target, a) }; this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(s) : s() }) })); return { disconnect: () => { var i; (i = r()) == null || i.disconnect(), n = null }, observe: i => { var a; return (a = r()) == null ? void 0 : a.observe(i, { box: "border-box" }) }, unobserve: i => { var a; return (a = r()) == null ? void 0 : a.unobserve(i) } } })(), this.range = null, this.setOptions = n => { Object.entries(n).forEach(([r, i]) => { typeof i > "u" && delete n[r] }), this.options = { debug: !1, initialOffset: 0, overscan: 1, paddingStart: 0, paddingEnd: 0, scrollPaddingStart: 0, scrollPaddingEnd: 0, horizontal: !1, getItemKey: Bnt, rangeExtractor: $nt, onChange: () => { }, measureElement: Hnt, initialRect: { width: 0, height: 0 }, scrollMargin: 0, gap: 0, indexAttribute: "data-index", initialMeasurementsCache: [], lanes: 1, isScrollingResetDelay: 150, enabled: !0, isRtl: !1, useScrollendEvent: !1, useAnimationFrameWithResizeObserver: !1, ...n } }, this.notify = n => { var r, i; (i = (r = this.options).onChange) == null || i.call(r, this, n) }, this.maybeNotify = Cy(() => (this.calculateRange(), [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]), n => { this.notify(n) }, { key: !1, debug: () => this.options.debug, initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null] }), this.cleanup = () => { this.unsubs.filter(Boolean).forEach(n => n()), this.unsubs = [], this.observer.disconnect(), this.scrollElement = null, this.targetWindow = null }, this._didMount = () => () => { this.cleanup() }, this._willUpdate = () => { var n; const r = this.options.enabled ? this.options.getScrollElement() : null; if (this.scrollElement !== r) { if (this.cleanup(), !r) { this.maybeNotify(); return } this.scrollElement = r, this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((n = this.scrollElement) == null ? void 0 : n.window) ?? null, this.elementsCache.forEach(i => { this.observer.observe(i) }), this._scrollToOffset(this.getScrollOffset(), { adjustments: void 0, behavior: void 0 }), this.unsubs.push(this.options.observeElementRect(this, i => { this.scrollRect = i, this.maybeNotify() })), this.unsubs.push(this.options.observeElementOffset(this, (i, a) => { this.scrollAdjustments = 0, this.scrollDirection = a ? this.getScrollOffset() < i ? "forward" : "backward" : null, this.scrollOffset = i, this.isScrolling = a, this.maybeNotify() })) } }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (n, r) => { const i = new Map, a = new Map; for (let s = r - 1; s >= 0; s--) { const o = n[s]; if (i.has(o.lane)) continue; const c = a.get(o.lane); if (c == null || o.end > c.end ? a.set(o.lane, o) : o.end < c.end && i.set(o.lane, !0), i.size === this.options.lanes) break } return a.size === this.options.lanes ? Array.from(a.values()).sort((s, o) => s.end === o.end ? s.index - o.index : s.end - o.end)[0] : void 0 }, this.getMeasurementOptions = Cy(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey, this.options.enabled], (n, r, i, a, s) => (this.pendingMeasuredCacheIndexes = [], { count: n, paddingStart: r, scrollMargin: i, getItemKey: a, enabled: s }), { key: !1 }), this.getMeasurements = Cy(() => [this.getMeasurementOptions(), this.itemSizeCache], ({ count: n, paddingStart: r, scrollMargin: i, getItemKey: a, enabled: s }, o) => { if (!s) return this.measurementsCache = [], this.itemSizeCache.clear(), []; this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach(d => { this.itemSizeCache.set(d.key, d.size) })); const c = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0; this.pendingMeasuredCacheIndexes = []; const u = this.measurementsCache.slice(0, c); for (let d = c; d < n; d++) { const f = a(d), h = this.options.lanes === 1 ? u[d - 1] : this.getFurthestMeasurement(u, d), m = h ? h.end + this.options.gap : r + i, g = o.get(f), x = typeof g == "number" ? g : this.options.estimateSize(d), v = m + x, b = h ? h.lane : d % this.options.lanes; u[d] = { index: d, start: m, size: x, end: v, key: f, lane: b } } return this.measurementsCache = u, u }, { key: !1, debug: () => this.options.debug }), this.calculateRange = Cy(() => [this.getMeasurements(), this.getSize(), this.getScrollOffset(), this.options.lanes], (n, r, i, a) => this.range = n.length > 0 && r > 0 ? qnt({ measurements: n, outerSize: r, scrollOffset: i, lanes: a }) : null, { key: !1, debug: () => this.options.debug }), this.getVirtualIndexes = Cy(() => { let n = null, r = null; const i = this.calculateRange(); return i && (n = i.startIndex, r = i.endIndex), this.maybeNotify.updateDeps([this.isScrolling, n, r]), [this.options.rangeExtractor, this.options.overscan, this.options.count, n, r] }, (n, r, i, a, s) => a === null || s === null ? [] : n({ startIndex: a, endIndex: s, overscan: r, count: i }), { key: !1, debug: () => this.options.debug }), this.indexFromElement = n => { const r = this.options.indexAttribute, i = n.getAttribute(r); return i ? parseInt(i, 10) : (console.warn(`Missing attribute name '${r}={index}' on measured element.`), -1) }, this._measureElement = (n, r) => { const i = this.indexFromElement(n), a = this.measurementsCache[i]; if (!a) return; const s = a.key, o = this.elementsCache.get(s); o !== n && (o && this.observer.unobserve(o), this.observer.observe(n), this.elementsCache.set(s, n)), n.isConnected && this.resizeItem(i, this.options.measureElement(n, r, this)) }, this.resizeItem = (n, r) => { const i = this.measurementsCache[n]; if (!i) return; const a = this.itemSizeCache.get(i.key) ?? i.size, s = r - a; s !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, s, this) : i.start < this.getScrollOffset() + this.scrollAdjustments) && this._scrollToOffset(this.getScrollOffset(), { adjustments: this.scrollAdjustments += s, behavior: void 0 }), this.pendingMeasuredCacheIndexes.push(i.index), this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r)), this.notify(!1)) }, this.measureElement = n => { if (!n) { this.elementsCache.forEach((r, i) => { r.isConnected || (this.observer.unobserve(r), this.elementsCache.delete(i)) }); return } this._measureElement(n, void 0) }, this.getVirtualItems = Cy(() => [this.getVirtualIndexes(), this.getMeasurements()], (n, r) => { const i = []; for (let a = 0, s = n.length; a < s; a++) { const o = n[a], c = r[o]; i.push(c) } return i }, { key: !1, debug: () => this.options.debug }), this.getVirtualItemForOffset = n => { const r = this.getMeasurements(); if (r.length !== 0) return xQ(r[ype(0, r.length - 1, i => xQ(r[i]).start, n)]) }, this.getOffsetForAlignment = (n, r, i = 0) => { const a = this.getSize(), s = this.getScrollOffset(); r === "auto" && (r = n >= s + a ? "end" : "start"), r === "center" ? n += (i - a) / 2 : r === "end" && (n -= a); const o = this.getTotalSize() + this.options.scrollMargin - a; return Math.max(Math.min(o, n), 0) }, this.getOffsetForIndex = (n, r = "auto") => { n = Math.max(0, Math.min(n, this.options.count - 1)); const i = this.measurementsCache[n]; if (!i) return; const a = this.getSize(), s = this.getScrollOffset(); if (r === "auto") if (i.end >= s + a - this.options.scrollPaddingEnd) r = "end"; else if (i.start <= s + this.options.scrollPaddingStart) r = "start"; else return [s, r]; const o = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart; return [this.getOffsetForAlignment(o, r, i.size), r] }, this.isDynamicMode = () => this.elementsCache.size > 0, this.scrollToOffset = (n, { align: r = "start", behavior: i } = {}) => { i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getOffsetForAlignment(n, r), { adjustments: void 0, behavior: i }) }, this.scrollToIndex = (n, { align: r = "auto", behavior: i } = {}) => { i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), n = Math.max(0, Math.min(n, this.options.count - 1)); let a = 0; const s = 10, o = u => { if (!this.targetWindow) return; const d = this.getOffsetForIndex(n, u); if (!d) { console.warn("Failed to get offset for index:", n); return } const [f, h] = d; this._scrollToOffset(f, { adjustments: void 0, behavior: i }), this.targetWindow.requestAnimationFrame(() => { const m = this.getScrollOffset(), g = this.getOffsetForIndex(n, h); if (!g) { console.warn("Failed to get offset for index:", n); return } Fnt(g[0], m) || c(h) }) }, c = u => { this.targetWindow && (a++, a < s ? this.targetWindow.requestAnimationFrame(() => o(u)) : console.warn(`Failed to scroll to index ${n} after ${s} attempts.`)) }; o(r) }, this.scrollBy = (n, { behavior: r } = {}) => { r === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getScrollOffset() + n, { adjustments: void 0, behavior: r }) }, this.getTotalSize = () => { var n; const r = this.getMeasurements(); let i; if (r.length === 0) i = this.options.paddingStart; else if (this.options.lanes === 1) i = ((n = r[r.length - 1]) == null ? void 0 : n.end) ?? 0; else { const a = Array(this.options.lanes).fill(null); let s = r.length - 1; for (; s >= 0 && a.some(o => o === null);) { const o = r[s]; a[o.lane] === null && (a[o.lane] = o.end), s-- } i = Math.max(...a.filter(o => o !== null)) } return Math.max(i - this.options.scrollMargin + this.options.paddingEnd, 0) }, this._scrollToOffset = (n, { adjustments: r, behavior: i }) => { this.options.scrollToFn(n, { behavior: i, adjustments: r }, this) }, this.measure = () => { this.itemSizeCache = new Map, this.notify(!1) }, this.setOptions(e) } } const ype = (t, e, n, r) => { for (; t <= e;) { const i = (t + e) / 2 | 0, a = n(i); if (a < r) t = i + 1; else if (a > r) e = i - 1; else return i } return t > 0 ? t - 1 : 0 }; function qnt({ measurements: t, outerSize: e, scrollOffset: n, lanes: r }) { const i = t.length - 1, a = c => t[c].start; if (t.length <= r) return { startIndex: 0, endIndex: i }; let s = ype(0, i, a, n), o = s; if (r === 1) for (; o < i && t[o].end < n + e;)o++; else if (r > 1) { const c = Array(r).fill(0); for (; o < i && c.some(d => d < n + e);) { const d = t[o]; c[d.lane] = d.end, o++ } const u = Array(r).fill(n + e); for (; s >= 0 && u.some(d => d >= n);) { const d = t[s]; u[d.lane] = d.start, s-- } s = Math.max(0, s - s % r), o = Math.min(i, o + (r - 1 - o % r)) } return { startIndex: s, endIndex: o } } const _Q = typeof document < "u" ? S.useLayoutEffect : S.useEffect; function Xnt(t) { const e = S.useReducer(() => ({}), {})[1], n = { ...t, onChange: (i, a) => { var s; a ? xi.flushSync(e) : e(), (s = t.onChange) == null || s.call(t, i, a) } }, [r] = S.useState(() => new Gnt(n)); return r.setOptions(n), _Q(() => r._didMount(), []), _Q(() => r._willUpdate()), r } function Ynt(t) { return Xnt({ observeElementRect: znt, observeElementOffset: Vnt, scrollToFn: Wnt, ...t }) } function Knt(t, e) { return t !== null && e !== null && typeof t == "object" && typeof e == "object" && "id" in t && "id" in e ? t.id === e.id : t === e } function xpe(t = Knt) { return S.useCallback((e, n) => { if (typeof t == "string") { let r = t; return e?.[r] === n?.[r] } return t(e, n) }, [t]) } function Znt(t) { if (t === null) return { width: 0, height: 0 }; let { width: e, height: n } = t.getBoundingClientRect(); return { width: e, height: n } } function uA(t, e = !1) { let [n, r] = S.useReducer(() => ({}), {}), i = S.useMemo(() => Znt(t), [t, n]); return fr(() => { if (!t) return; let a = new ResizeObserver(r); return a.observe(t), () => { a.disconnect() } }, [t]), e ? { width: `${i.width}px`, height: `${i.height}px` } : i } let Qnt = class extends Map { constructor(e) { super(), this.factory = e } get(e) { let n = super.get(e); return n === void 0 && (n = this.factory(e), this.set(e, n)), n } }; function bpe(t, e) { let n = t(), r = new Set; return { getSnapshot() { return n }, subscribe(i) { return r.add(i), () => r.delete(i) }, dispatch(i, ...a) { let s = e[i].call(n, ...a); s && (n = s, r.forEach(o => o())) } } } function wpe(t) { return S.useSyncExternalStore(t.subscribe, t.getSnapshot, t.getSnapshot) } let Jnt = new Qnt(() => bpe(() => [], { ADD(t) { return this.includes(t) ? this : [...this, t] }, REMOVE(t) { let e = this.indexOf(t); if (e === -1) return this; let n = this.slice(); return n.splice(e, 1), n } })); function q0(t, e) { let n = Jnt.get(e), r = S.useId(), i = wpe(n); if (fr(() => { if (t) return n.dispatch("ADD", r), () => n.dispatch("REMOVE", r) }, [n, t]), !t) return !1; let a = i.indexOf(r), s = i.length; return a === -1 && (a = s, s += 1), a === s - 1 } let ZF = new Map, f1 = new Map; function EQ(t) { var e; let n = (e = f1.get(t)) != null ? e : 0; return f1.set(t, n + 1), n !== 0 ? () => MQ(t) : (ZF.set(t, { "aria-hidden": t.getAttribute("aria-hidden"), inert: t.inert }), t.setAttribute("aria-hidden", "true"), t.inert = !0, () => MQ(t)) } function MQ(t) { var e; let n = (e = f1.get(t)) != null ? e : 1; if (n === 1 ? f1.delete(t) : f1.set(t, n - 1), n !== 1) return; let r = ZF.get(t); r && (r["aria-hidden"] === null ? t.removeAttribute("aria-hidden") : t.setAttribute("aria-hidden", r["aria-hidden"]), t.inert = r.inert, ZF.delete(t)) } function zz(t, { allowed: e, disallowed: n } = {}) { let r = q0(t, "inert-others"); fr(() => { var i, a; if (!r) return; let s = Gc(); for (let c of (i = n?.()) != null ? i : []) c && s.add(EQ(c)); let o = (a = e?.()) != null ? a : []; for (let c of o) { if (!c) continue; let u = rd(c); if (!u) continue; let d = c.parentElement; for (; d && d !== u.body;) { for (let f of d.children) o.some(h => f.contains(h)) || s.add(EQ(f)); d = d.parentElement } } return s.dispose }, [r, e, n]) } function xP(t, e, n) { let r = no(i => { let a = i.getBoundingClientRect(); a.x === 0 && a.y === 0 && a.width === 0 && a.height === 0 && n() }); S.useEffect(() => { if (!t) return; let i = e === null ? null : e instanceof HTMLElement ? e : e.current; if (!i) return; let a = Gc(); if (typeof ResizeObserver < "u") { let s = new ResizeObserver(() => r.current(i)); s.observe(i), a.add(() => s.disconnect()) } if (typeof IntersectionObserver < "u") { let s = new IntersectionObserver(() => r.current(i)); s.observe(i), a.add(() => s.disconnect()) } return () => a.dispose() }, [e, r, t]) } let dA = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(t => `${t}:not([tabindex='-1'])`).join(","), ert = ["[data-autofocus]"].map(t => `${t}:not([tabindex='-1'])`).join(","); var qr = (t => (t[t.First = 1] = "First", t[t.Previous = 2] = "Previous", t[t.Next = 4] = "Next", t[t.Last = 8] = "Last", t[t.WrapAround = 16] = "WrapAround", t[t.NoScroll = 32] = "NoScroll", t[t.AutoFocus = 64] = "AutoFocus", t))(qr || {}), Tu = (t => (t[t.Error = 0] = "Error", t[t.Overflow = 1] = "Overflow", t[t.Success = 2] = "Success", t[t.Underflow = 3] = "Underflow", t))(Tu || {}), trt = (t => (t[t.Previous = -1] = "Previous", t[t.Next = 1] = "Next", t))(trt || {}); function L_(t = document.body) { return t == null ? [] : Array.from(t.querySelectorAll(dA)).sort((e, n) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER))) } function nrt(t = document.body) { return t == null ? [] : Array.from(t.querySelectorAll(ert)).sort((e, n) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER))) } var bP = (t => (t[t.Strict = 0] = "Strict", t[t.Loose = 1] = "Loose", t))(bP || {}); function Vz(t, e = 0) { var n; return t === ((n = rd(t)) == null ? void 0 : n.body) ? !1 : Er(e, { 0() { return t.matches(dA) }, 1() { let r = t; for (; r !== null;) { if (r.matches(dA)) return !0; r = r.parentElement } return !1 } }) } var rrt = (t => (t[t.Keyboard = 0] = "Keyboard", t[t.Mouse = 1] = "Mouse", t))(rrt || {}); typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", t => { t.metaKey || t.altKey || t.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0), document.addEventListener("click", t => { t.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0)); function uf(t) { t?.focus({ preventScroll: !0 }) } let irt = ["textarea", "input"].join(","); function art(t) { var e, n; return (n = (e = t?.matches) == null ? void 0 : e.call(t, irt)) != null ? n : !1 } function zh(t, e = n => n) { return t.slice().sort((n, r) => { let i = e(n), a = e(r); if (i === null || a === null) return 0; let s = i.compareDocumentPosition(a); return s & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : s & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0 }) } function srt(t, e) { return Ra(L_(), e, { relativeTo: t }) } function Ra(t, e, { sorted: n = !0, relativeTo: r = null, skipElements: i = [] } = {}) { let a = Array.isArray(t) ? t.length > 0 ? t[0].ownerDocument : document : t.ownerDocument, s = Array.isArray(t) ? n ? zh(t) : t : e & 64 ? nrt(t) : L_(t); i.length > 0 && s.length > 1 && (s = s.filter(m => !i.some(g => g != null && "current" in g ? g?.current === m : g === m))), r = r ?? a.activeElement; let o = (() => { if (e & 5) return 1; if (e & 10) return -1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), c = (() => { if (e & 1) return 0; if (e & 2) return Math.max(0, s.indexOf(r)) - 1; if (e & 4) return Math.max(0, s.indexOf(r)) + 1; if (e & 8) return s.length - 1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), u = e & 32 ? { preventScroll: !0 } : {}, d = 0, f = s.length, h; do { if (d >= f || d + f <= 0) return 0; let m = c + d; if (e & 16) m = (m + f) % f; else { if (m < 0) return 3; if (m >= f) return 1 } h = s[m], h?.focus(u), d += o } while (h !== a.activeElement); return e & 6 && art(h) && h.select(), 2 } function Spe() { return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0 } function ort() { return /Android/gi.test(window.navigator.userAgent) } function _pe() { return Spe() || ort() } function Mw(t, e, n, r) { let i = no(n); S.useEffect(() => { if (!t) return; function a(s) { i.current(s) } return document.addEventListener(e, a, r), () => document.removeEventListener(e, a, r) }, [t, e, r]) } function Epe(t, e, n, r) { let i = no(n); S.useEffect(() => { if (!t) return; function a(s) { i.current(s) } return window.addEventListener(e, a, r), () => window.removeEventListener(e, a, r) }, [t, e, r]) } const TQ = 30; function wP(t, e, n) { let r = q0(t, "outside-click"), i = no(n), a = S.useCallback(function (c, u) { if (c.defaultPrevented) return; let d = u(c); if (d === null || !d.getRootNode().contains(d) || !d.isConnected) return; let f = (function h(m) { return typeof m == "function" ? h(m()) : Array.isArray(m) || m instanceof Set ? m : [m] })(e); for (let h of f) if (h !== null && (h.contains(d) || c.composed && c.composedPath().includes(h))) return; return !Vz(d, bP.Loose) && d.tabIndex !== -1 && c.preventDefault(), i.current(c, d) }, [i, e]), s = S.useRef(null); Mw(r, "pointerdown", c => { var u, d; s.current = ((d = (u = c.composedPath) == null ? void 0 : u.call(c)) == null ? void 0 : d[0]) || c.target }, !0), Mw(r, "mousedown", c => { var u, d; s.current = ((d = (u = c.composedPath) == null ? void 0 : u.call(c)) == null ? void 0 : d[0]) || c.target }, !0), Mw(r, "click", c => { _pe() || s.current && (a(c, () => s.current), s.current = null) }, !0); let o = S.useRef({ x: 0, y: 0 }); Mw(r, "touchstart", c => { o.current.x = c.touches[0].clientX, o.current.y = c.touches[0].clientY }, !0), Mw(r, "touchend", c => { let u = { x: c.changedTouches[0].clientX, y: c.changedTouches[0].clientY }; if (!(Math.abs(u.x - o.current.x) >= TQ || Math.abs(u.y - o.current.y) >= TQ)) return a(c, () => c.target instanceof HTMLElement ? c.target : null) }, !0), Epe(r, "blur", c => a(c, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0) } function Jc(...t) { return S.useMemo(() => rd(...t), [...t]) } function SP(t, e, n, r) { let i = no(n); S.useEffect(() => { t = t ?? window; function a(s) { i.current(s) } return t.addEventListener(e, a, r), () => t.removeEventListener(e, a, r) }, [t, e, r]) } function Mpe(t) { let e = S.useRef({ value: "", selectionStart: null, selectionEnd: null }); return SP(t, "blur", n => { let r = n.target; r instanceof HTMLInputElement && (e.current = { value: r.value, selectionStart: r.selectionStart, selectionEnd: r.selectionEnd }) }), ct(() => { if (document.activeElement !== t && t instanceof HTMLInputElement && t.isConnected) { if (t.focus({ preventScroll: !0 }), t.value !== e.current.value) t.setSelectionRange(t.value.length, t.value.length); else { let { selectionStart: n, selectionEnd: r } = e.current; n !== null && r !== null && t.setSelectionRange(n, r) } e.current = { value: "", selectionStart: null, selectionEnd: null } } }) } function X0(t, e) { return S.useMemo(() => { var n; if (t.type) return t.type; let r = (n = t.as) != null ? n : "button"; if (typeof r == "string" && r.toLowerCase() === "button" || e?.tagName === "BUTTON" && !e.hasAttribute("type")) return "button" }, [t.type, t.as, e]) } function lrt() { let t; return { before({ doc: e }) { var n; let r = e.documentElement, i = (n = e.defaultView) != null ? n : window; t = Math.max(0, i.innerWidth - r.clientWidth) }, after({ doc: e, d: n }) { let r = e.documentElement, i = Math.max(0, r.clientWidth - r.offsetWidth), a = Math.max(0, t - i); n.style(r, "paddingRight", `${a}px`) } } } function crt() { return Spe() ? { before({ doc: t, d: e, meta: n }) { function r(i) { return n.containers.flatMap(a => a()).some(a => a.contains(i)) } e.microTask(() => { var i; if (window.getComputedStyle(t.documentElement).scrollBehavior !== "auto") { let o = Gc(); o.style(t.documentElement, "scrollBehavior", "auto"), e.add(() => e.microTask(() => o.dispose())) } let a = (i = window.scrollY) != null ? i : window.pageYOffset, s = null; e.addEventListener(t, "click", o => { if (o.target instanceof HTMLElement) try { let c = o.target.closest("a"); if (!c) return; let { hash: u } = new URL(c.href), d = t.querySelector(u); d && !r(d) && (s = d) } catch { } }, !0), e.addEventListener(t, "touchstart", o => { if (o.target instanceof HTMLElement) if (r(o.target)) { let c = o.target; for (; c.parentElement && r(c.parentElement);)c = c.parentElement; e.style(c, "overscrollBehavior", "contain") } else e.style(o.target, "touchAction", "none") }), e.addEventListener(t, "touchmove", o => { if (o.target instanceof HTMLElement) { if (o.target.tagName === "INPUT") return; if (r(o.target)) { let c = o.target; for (; c.parentElement && c.dataset.headlessuiPortal !== "" && !(c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth);)c = c.parentElement; c.dataset.headlessuiPortal === "" && o.preventDefault() } else o.preventDefault() } }, { passive: !1 }), e.add(() => { var o; let c = (o = window.scrollY) != null ? o : window.pageYOffset; a !== c && window.scrollTo(0, a), s && s.isConnected && (s.scrollIntoView({ block: "nearest" }), s = null) }) }) } } : {} } function urt() { return { before({ doc: t, d: e }) { e.style(t.documentElement, "overflow", "hidden") } } } function drt(t) { let e = {}; for (let n of t) Object.assign(e, n(e)); return e } let og = bpe(() => new Map, { PUSH(t, e) { var n; let r = (n = this.get(t)) != null ? n : { doc: t, count: 0, d: Gc(), meta: new Set }; return r.count++, r.meta.add(e), this.set(t, r), this }, POP(t, e) { let n = this.get(t); return n && (n.count--, n.meta.delete(e)), this }, SCROLL_PREVENT({ doc: t, d: e, meta: n }) { let r = { doc: t, d: e, meta: drt(n) }, i = [crt(), lrt(), urt()]; i.forEach(({ before: a }) => a?.(r)), i.forEach(({ after: a }) => a?.(r)) }, SCROLL_ALLOW({ d: t }) { t.dispose() }, TEARDOWN({ doc: t }) { this.delete(t) } }); og.subscribe(() => { let t = og.getSnapshot(), e = new Map; for (let [n] of t) e.set(n, n.documentElement.style.overflow); for (let n of t.values()) { let r = e.get(n.doc) === "hidden", i = n.count !== 0; (i && !r || !i && r) && og.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n), n.count === 0 && og.dispatch("TEARDOWN", n) } }); function frt(t, e, n = () => ({ containers: [] })) { let r = wpe(og), i = e ? r.get(e) : void 0, a = i ? i.count > 0 : !1; return fr(() => { if (!(!e || !t)) return og.dispatch("PUSH", e, n), () => og.dispatch("POP", e, n) }, [t, e]), a } function _P(t, e, n = () => [document.body]) { let r = q0(t, "scroll-lock"); frt(r, e, i => { var a; return { containers: [...(a = i.containers) != null ? a : [], n] } }) } function CQ(t) { return [t.screenX, t.screenY] } function Tpe() { let t = S.useRef([-1, -1]); return { wasMoved(e) { let n = CQ(e); return t.current[0] === n[0] && t.current[1] === n[1] ? !1 : (t.current = n, !0) }, update(e) { t.current = CQ(e) } } } function hrt(t = 0) { let [e, n] = S.useState(t), r = S.useCallback(c => n(c), [e]), i = S.useCallback(c => n(u => u | c), [e]), a = S.useCallback(c => (e & c) === c, [e]), s = S.useCallback(c => n(u => u & ~c), [n]), o = S.useCallback(c => n(u => u ^ c), [n]); return { flags: e, setFlag: r, addFlag: i, hasFlag: a, removeFlag: s, toggleFlag: o } } var prt = {}, NQ, AQ; typeof process < "u" && typeof globalThis < "u" && typeof Element < "u" && ((NQ = process == null ? void 0 : prt) == null ? void 0 : NQ.NODE_ENV) === "test" && typeof ((AQ = Element?.prototype) == null ? void 0 : AQ.getAnimations) > "u" && (Element.prototype.getAnimations = function () {
	return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), []
}); var mrt = (t => (t[t.None = 0] = "None", t[t.Closed = 1] = "Closed", t[t.Enter = 2] = "Enter", t[t.Leave = 4] = "Leave", t))(mrt || {}); function Y0(t) { let e = {}; for (let n in t) t[n] === !0 && (e[`data-${n}`] = ""); return e } function K0(t, e, n, r) { let [i, a] = S.useState(n), { hasFlag: s, addFlag: o, removeFlag: c } = hrt(t && i ? 3 : 0), u = S.useRef(!1), d = S.useRef(!1), f = id(); return fr(() => { var h; if (t) { if (n && a(!0), !e) { n && o(3); return } return (h = r?.start) == null || h.call(r, n), grt(e, { inFlight: u, prepare() { d.current ? d.current = !1 : d.current = u.current, u.current = !0, !d.current && (n ? (o(3), c(4)) : (o(4), c(2))) }, run() { d.current ? n ? (c(3), o(4)) : (c(4), o(3)) : n ? c(1) : o(1) }, done() { var m; d.current && typeof e.getAnimations == "function" && e.getAnimations().length > 0 || (u.current = !1, c(7), n || a(!1), (m = r?.end) == null || m.call(r, n)) } }) } }, [t, n, e, f]), t ? [i, { closed: s(1), enter: s(2), leave: s(4), transition: s(2) || s(4) }] : [n, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }] } function grt(t, { prepare: e, run: n, done: r, inFlight: i }) { let a = Gc(); return yrt(t, { prepare: e, inFlight: i }), a.nextFrame(() => { n(), a.requestAnimationFrame(() => { a.add(vrt(t, r)) }) }), a.dispose } function vrt(t, e) { var n, r; let i = Gc(); if (!t) return i.dispose; let a = !1; i.add(() => { a = !0 }); let s = (r = (n = t.getAnimations) == null ? void 0 : n.call(t).filter(o => o instanceof CSSTransition)) != null ? r : []; return s.length === 0 ? (e(), i.dispose) : (Promise.allSettled(s.map(o => o.finished)).then(() => { a || e() }), i.dispose) } function yrt(t, { inFlight: e, prepare: n }) { if (e != null && e.current) { n(); return } let r = t.style.transition; t.style.transition = "none", n(), t.offsetHeight, t.style.transition = r } function xrt(t, { container: e, accept: n, walk: r }) { let i = S.useRef(n), a = S.useRef(r); S.useEffect(() => { i.current = n, a.current = r }, [n, r]), fr(() => { if (!e || !t) return; let s = rd(e); if (!s) return; let o = i.current, c = a.current, u = Object.assign(f => o(f), { acceptNode: o }), d = s.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, u, !1); for (; d.nextNode();)c(d.currentNode) }, [e, t, i, a]) } function jS(t, e) { let n = S.useRef([]), r = ct(t); S.useEffect(() => { let i = [...n.current]; for (let [a, s] of e.entries()) if (n.current[a] !== s) { let o = r(e, i); return n.current = e, o } }, [r, ...e]) } function brt() { const t = navigator.userAgentData; return t && Array.isArray(t.brands) ? t.brands.map(e => { let { brand: n, version: r } = e; return n + "/" + r }).join(" ") : navigator.userAgent } const Cpe = { ...Yh }, wrt = Cpe.useInsertionEffect, Srt = wrt || (t => t()); function Npe(t) { const e = S.useRef(() => { }); return Srt(() => { e.current = t }), S.useCallback(function () { for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return e.current == null ? void 0 : e.current(...r) }, []) } var QF = typeof document < "u" ? S.useLayoutEffect : S.useEffect; let PQ = !1, _rt = 0; const jQ = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + _rt++; function Ert() { const [t, e] = S.useState(() => PQ ? jQ() : void 0); return QF(() => { t == null && e(jQ()) }, []), S.useEffect(() => { PQ = !0 }, []), t } const Mrt = Cpe.useId, Trt = Mrt || Ert; function Crt() { const t = new Map; return { emit(e, n) { var r; (r = t.get(e)) == null || r.forEach(i => i(n)) }, on(e, n) { t.set(e, [...t.get(e) || [], n]) }, off(e, n) { var r; t.set(e, ((r = t.get(e)) == null ? void 0 : r.filter(i => i !== n)) || []) } } } const Nrt = S.createContext(null), Art = S.createContext(null), Prt = () => { var t; return ((t = S.useContext(Nrt)) == null ? void 0 : t.id) || null }, jrt = () => S.useContext(Art), Rrt = "data-floating-ui-focusable"; function krt(t) { const { open: e = !1, onOpenChange: n, elements: r } = t, i = Trt(), a = S.useRef({}), [s] = S.useState(() => Crt()), o = Prt() != null, [c, u] = S.useState(r.reference), d = Npe((m, g, x) => { a.current.openEvent = m ? g : void 0, s.emit("openchange", { open: m, event: g, reason: x, nested: o }), n?.(m, g, x) }), f = S.useMemo(() => ({ setPositionReference: u }), []), h = S.useMemo(() => ({ reference: c || r.reference || null, floating: r.floating || null, domReference: r.reference }), [c, r.reference, r.floating]); return S.useMemo(() => ({ dataRef: a, open: e, onOpenChange: d, elements: h, events: s, floatingId: i, refs: f }), [e, d, h, s, i, f]) } function Irt(t) { t === void 0 && (t = {}); const { nodeId: e } = t, n = krt({ ...t, elements: { reference: null, floating: null, ...t.elements } }), r = t.rootContext || n, i = r.elements, [a, s] = S.useState(null), [o, c] = S.useState(null), d = i?.domReference || a, f = S.useRef(null), h = jrt(); QF(() => { d && (f.current = d) }, [d]); const m = Aee({ ...t, elements: { ...i, ...o && { reference: o } } }), g = S.useCallback(M => { const C = Zs(M) ? { getBoundingClientRect: () => M.getBoundingClientRect(), contextElement: M } : M; c(C), m.refs.setReference(C) }, [m.refs]), x = S.useCallback(M => { (Zs(M) || M === null) && (f.current = M, s(M)), (Zs(m.refs.reference.current) || m.refs.reference.current === null || M !== null && !Zs(M)) && m.refs.setReference(M) }, [m.refs]), v = S.useMemo(() => ({ ...m.refs, setReference: x, setPositionReference: g, domReference: f }), [m.refs, x, g]), b = S.useMemo(() => ({ ...m.elements, domReference: d }), [m.elements, d]), E = S.useMemo(() => ({ ...m, ...r, refs: v, elements: b, nodeId: e }), [m, v, b, e, r]); return QF(() => { r.dataRef.current.floatingContext = E; const M = h?.nodesRef.current.find(C => C.id === e); M && (M.context = E) }), S.useMemo(() => ({ ...m, context: E, refs: v, elements: b }), [m, v, b, E]) } const RQ = "active", kQ = "selected"; function R3(t, e, n) { const r = new Map, i = n === "item"; let a = t; if (i && t) { const { [RQ]: s, [kQ]: o, ...c } = t; a = c } return { ...n === "floating" && { tabIndex: -1, [Rrt]: "" }, ...a, ...e.map(s => { const o = s ? s[n] : null; return typeof o == "function" ? t ? o(t) : null : o }).concat(t).reduce((s, o) => (o && Object.entries(o).forEach(c => { let [u, d] = c; if (!(i && [RQ, kQ].includes(u))) if (u.indexOf("on") === 0) { if (r.has(u) || r.set(u, []), typeof d == "function") { var f; (f = r.get(u)) == null || f.push(d), s[u] = function () { for (var h, m = arguments.length, g = new Array(m), x = 0; x < m; x++)g[x] = arguments[x]; return (h = r.get(u)) == null ? void 0 : h.map(v => v(...g)).find(v => v !== void 0) } } } else s[u] = d }), s), {}) } } function Ort(t) { t === void 0 && (t = []); const e = t.map(o => o?.reference), n = t.map(o => o?.floating), r = t.map(o => o?.item), i = S.useCallback(o => R3(o, t, "reference"), e), a = S.useCallback(o => R3(o, t, "floating"), n), s = S.useCallback(o => R3(o, t, "item"), r); return S.useMemo(() => ({ getReferenceProps: i, getFloatingProps: a, getItemProps: s }), [i, a, s]) } function IQ(t, e) { return { ...t, rects: { ...t.rects, floating: { ...t.rects.floating, height: e } } } } const Drt = t => ({ name: "inner", options: t, async fn(e) { const { listRef: n, overflowRef: r, onFallbackChange: i, offset: a = 0, index: s = 0, minItemsVisible: o = 4, referenceOverflowThreshold: c = 0, scrollRef: u, ...d } = Uu(t, e), { rects: f, elements: { floating: h } } = e, m = n.current[s], g = u?.current || h, x = h.clientTop || g.clientTop, v = h.clientTop !== 0, b = g.clientTop !== 0, E = h === g; if (!m) return {}; const M = { ...e, ...await P5(-m.offsetTop - h.clientTop - f.reference.height / 2 - m.offsetHeight / 2 - a).fn(e) }, C = await Pj(IQ(M, g.scrollHeight + x + h.clientTop), d), N = await Pj(M, { ...d, elementContext: "reference" }), A = Ms(0, C.top), j = M.y + A, D = (g.scrollHeight > g.clientHeight ? F => F : y1)(Ms(0, g.scrollHeight + (v && E || b ? x * 2 : 0) - A - Ms(0, C.bottom))); if (g.style.maxHeight = D + "px", g.scrollTop = A, i) { const F = g.offsetHeight < m.offsetHeight * pf(o, n.current.length) - 1 || N.top >= -c || N.bottom >= -c; xi.flushSync(() => i(F)) } return r && (r.current = await Pj(IQ({ ...M, y: j }, g.offsetHeight + x + h.clientTop), d)), { y: j } } }); function Lrt(t, e) { const { open: n, elements: r } = t, { enabled: i = !0, overflowRef: a, scrollRef: s, onChange: o } = e, c = Npe(o), u = S.useRef(!1), d = S.useRef(null), f = S.useRef(null); S.useEffect(() => { if (!i) return; function m(x) { if (x.ctrlKey || !g || a.current == null) return; const v = x.deltaY, b = a.current.top >= -.5, E = a.current.bottom >= -.5, M = g.scrollHeight - g.clientHeight, C = v < 0 ? -1 : 1, N = v < 0 ? "max" : "min"; g.scrollHeight <= g.clientHeight || (!b && v > 0 || !E && v < 0 ? (x.preventDefault(), xi.flushSync(() => { c(A => A + Math[N](v, M * C)) })) : /firefox/i.test(brt()) && (g.scrollTop += v)) } const g = s?.current || r.floating; if (n && g) return g.addEventListener("wheel", m), requestAnimationFrame(() => { d.current = g.scrollTop, a.current != null && (f.current = { ...a.current }) }), () => { d.current = null, f.current = null, g.removeEventListener("wheel", m) } }, [i, n, r.floating, a, s, c]); const h = S.useMemo(() => ({ onKeyDown() { u.current = !0 }, onWheel() { u.current = !1 }, onPointerMove() { u.current = !1 }, onScroll() { const m = s?.current || r.floating; if (!(!a.current || !m || !u.current)) { if (d.current !== null) { const g = m.scrollTop - d.current; (a.current.bottom < -.5 && g < -1 || a.current.top < -.5 && g > 1) && xi.flushSync(() => c(x => x + g)) } requestAnimationFrame(() => { d.current = m.scrollTop }) } } }), [r.floating, c, a, s]); return S.useMemo(() => i ? { floating: h } : {}, [i, h]) } let Z0 = S.createContext({ styles: void 0, setReference: () => { }, setFloating: () => { }, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} }); Z0.displayName = "FloatingContext"; let Hz = S.createContext(null); Hz.displayName = "PlacementContext"; function Wz(t) { return S.useMemo(() => t ? typeof t == "string" ? { to: t } : t : null, [t]) } function Gz() { return S.useContext(Z0).setReference } function Frt() { return S.useContext(Z0).getReferenceProps } function qz() { let { getFloatingProps: t, slot: e } = S.useContext(Z0); return S.useCallback((...n) => Object.assign({}, t(...n), { "data-anchor": e.anchor }), [t, e]) } function Xz(t = null) { t === !1 && (t = null), typeof t == "string" && (t = { to: t }); let e = S.useContext(Hz), n = S.useMemo(() => t, [JSON.stringify(t, (i, a) => { var s; return (s = a?.outerHTML) != null ? s : a })]); fr(() => { e?.(n ?? null) }, [e, n]); let r = S.useContext(Z0); return S.useMemo(() => [r.setFloating, t ? r.styles : {}], [r.setFloating, t, r.styles]) } let OQ = 4; function Yz({ children: t, enabled: e = !0 }) { let [n, r] = S.useState(null), [i, a] = S.useState(0), s = S.useRef(null), [o, c] = S.useState(null); Urt(o); let u = e && n !== null && o !== null, { to: d = "bottom", gap: f = 0, offset: h = 0, padding: m = 0, inner: g } = Brt(n, o), [x, v = "center"] = d.split(" "); fr(() => { u && a(0) }, [u]); let { refs: b, floatingStyles: E, context: M } = Irt({ open: u, placement: x === "selection" ? v === "center" ? "bottom" : `bottom-${v}` : v === "center" ? `${x}` : `${x}-${v}`, strategy: "absolute", transform: !1, middleware: [P5({ mainAxis: x === "selection" ? 0 : f, crossAxis: h }), Pee({ padding: m }), x !== "selection" && jee({ padding: m }), x === "selection" && g ? Drt({ ...g, padding: m, overflowRef: s, offset: i, minItemsVisible: OQ, referenceOverflowThreshold: m, onFallbackChange(F) { var B, G; if (!F) return; let z = M.elements.floating; if (!z) return; let q = parseFloat(getComputedStyle(z).scrollPaddingBottom) || 0, Y = Math.min(OQ, z.childElementCount), Z = 0, $ = 0; for (let V of (G = (B = M.elements.floating) == null ? void 0 : B.childNodes) != null ? G : []) if (V instanceof HTMLElement) { let K = V.offsetTop, X = K + V.clientHeight + q, Q = z.scrollTop, re = Q + z.clientHeight; if (K >= Q && X <= re) Y--; else { $ = Math.max(0, Math.min(X, re) - Math.max(K, Q)), Z = V.clientHeight; break } } Y >= 1 && a(V => { let K = Z * Y - $ + q; return V >= K ? V : K }) } }) : null, Ree({ padding: m, apply({ availableWidth: F, availableHeight: B, elements: G }) { Object.assign(G.floating.style, { overflow: "auto", maxWidth: `${F}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${B}px)` }) } })].filter(Boolean), whileElementsMounted: A5 }), [C = x, N = v] = M.placement.split("-"); x === "selection" && (C = "selection"); let A = S.useMemo(() => ({ anchor: [C, N].filter(Boolean).join(" ") }), [C, N]), j = Lrt(M, { overflowRef: s, onChange: a }), { getReferenceProps: O, getFloatingProps: I } = Ort([j]), D = ct(F => { c(F), b.setFloating(F) }); return S.createElement(Hz.Provider, { value: r }, S.createElement(Z0.Provider, { value: { setFloating: D, setReference: b.setReference, styles: E, getReferenceProps: O, getFloatingProps: I, slot: A } }, t)) } function Urt(t) { fr(() => { if (!t) return; let e = new MutationObserver(() => { let n = window.getComputedStyle(t).maxHeight, r = parseFloat(n); if (isNaN(r)) return; let i = parseInt(n); isNaN(i) || r !== i && (t.style.maxHeight = `${Math.ceil(r)}px`) }); return e.observe(t, { attributes: !0, attributeFilter: ["style"] }), () => { e.disconnect() } }, [t]) } function Brt(t, e) { var n, r, i; let a = k3((n = t?.gap) != null ? n : "var(--anchor-gap, 0)", e), s = k3((r = t?.offset) != null ? r : "var(--anchor-offset, 0)", e), o = k3((i = t?.padding) != null ? i : "var(--anchor-padding, 0)", e); return { ...t, gap: a, offset: s, padding: o } } function k3(t, e, n = void 0) { let r = id(), i = ct((c, u) => { if (c == null) return [n, null]; if (typeof c == "number") return [c, null]; if (typeof c == "string") { if (!u) return [n, null]; let d = DQ(c, u); return [d, f => { let h = Ape(c); { let m = h.map(g => window.getComputedStyle(u).getPropertyValue(g)); r.requestAnimationFrame(function g() { r.nextFrame(g); let x = !1; for (let [b, E] of h.entries()) { let M = window.getComputedStyle(u).getPropertyValue(E); if (m[b] !== M) { m[b] = M, x = !0; break } } if (!x) return; let v = DQ(c, u); d !== v && (f(v), d = v) }) } return r.dispose }] } return [n, null] }), a = S.useMemo(() => i(t, e)[0], [t, e]), [s = a, o] = S.useState(); return fr(() => { let [c, u] = i(t, e); if (o(c), !!u) return u(o) }, [t, e]), s } function Ape(t) { let e = /var\((.*)\)/.exec(t); if (e) { let n = e[1].indexOf(","); if (n === -1) return [e[1]]; let r = e[1].slice(0, n).trim(), i = e[1].slice(n + 1).trim(); return i ? [r, ...Ape(i)] : [r] } return [] } function DQ(t, e) { let n = document.createElement("div"); e.appendChild(n), n.style.setProperty("margin-top", "0px", "important"), n.style.setProperty("margin-top", t, "important"); let r = parseFloat(window.getComputedStyle(n).marginTop) || 0; return e.removeChild(n), r } function $rt({ children: t, freeze: e }) { let n = fA(e, t); return P.createElement(P.Fragment, null, n) } function fA(t, e) { let [n, r] = S.useState(e); return !t && n !== e && r(e), t ? n : e } let EP = S.createContext(null); EP.displayName = "OpenClosedContext"; var Yr = (t => (t[t.Open = 1] = "Open", t[t.Closed = 2] = "Closed", t[t.Closing = 4] = "Closing", t[t.Opening = 8] = "Opening", t))(Yr || {}); function kf() { return S.useContext(EP) } function F_({ value: t, children: e }) { return P.createElement(EP.Provider, { value: t }, e) } function Kz({ children: t }) { return P.createElement(EP.Provider, { value: null }, t) } function zrt(t) { function e() { document.readyState !== "loading" && (t(), document.removeEventListener("DOMContentLoaded", e)) } typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", e), e()) } let yu = []; zrt(() => { function t(e) { if (!(e.target instanceof HTMLElement) || e.target === document.body || yu[0] === e.target) return; let n = e.target; n = n.closest(dA), yu.unshift(n ?? e.target), yu = yu.filter(r => r != null && r.isConnected), yu.splice(10) } window.addEventListener("click", t, { capture: !0 }), window.addEventListener("mousedown", t, { capture: !0 }), window.addEventListener("focus", t, { capture: !0 }), document.body.addEventListener("click", t, { capture: !0 }), document.body.addEventListener("mousedown", t, { capture: !0 }), document.body.addEventListener("focus", t, { capture: !0 }) }); function Vrt(t) { throw new Error("Unexpected object: " + t) } var pr = (t => (t[t.First = 0] = "First", t[t.Previous = 1] = "Previous", t[t.Next = 2] = "Next", t[t.Last = 3] = "Last", t[t.Specific = 4] = "Specific", t[t.Nothing = 5] = "Nothing", t))(pr || {}); function h1(t, e) { let n = e.resolveItems(); if (n.length <= 0) return null; let r = e.resolveActiveIndex(), i = r ?? -1; switch (t.focus) { case 0: { for (let a = 0; a < n.length; ++a)if (!e.resolveDisabled(n[a], a, n)) return a; return r } case 1: { i === -1 && (i = n.length); for (let a = i - 1; a >= 0; --a)if (!e.resolveDisabled(n[a], a, n)) return a; return r } case 2: { for (let a = i + 1; a < n.length; ++a)if (!e.resolveDisabled(n[a], a, n)) return a; return r } case 3: { for (let a = n.length - 1; a >= 0; --a)if (!e.resolveDisabled(n[a], a, n)) return a; return r } case 4: { for (let a = 0; a < n.length; ++a)if (e.resolveId(n[a], a, n) === t.id) return a; return r } case 5: return null; default: Vrt(t) } } var Zz = (t => (t[t.Left = 0] = "Left", t[t.Right = 2] = "Right", t))(Zz || {}); function Ppe(t) { let e = ct(t), n = S.useRef(!1); S.useEffect(() => (n.current = !1, () => { n.current = !0, O_(() => { n.current && e() }) }), [e]) } function Hrt() { let t = typeof document > "u"; return "useSyncExternalStore" in Yh ? (e => e.useSyncExternalStore)(Yh)(() => () => { }, () => !1, () => !t) : !1 } function U_() { let t = Hrt(), [e, n] = S.useState(vg.isHandoffComplete); return e && vg.isHandoffComplete === !1 && n(!1), S.useEffect(() => { e !== !0 && n(!0) }, [e]), S.useEffect(() => vg.handoff(), []), t ? !1 : e } let jpe = S.createContext(!1); function Wrt() { return S.useContext(jpe) } function LQ(t) { return P.createElement(jpe.Provider, { value: t.force }, t.children) } function Grt(t) { let e = Wrt(), n = S.useContext(kpe), r = Jc(t), [i, a] = S.useState(() => { var s; if (!e && n !== null) return (s = n.current) != null ? s : null; if (vg.isServer) return null; let o = r?.getElementById("headlessui-portal-root"); if (o) return o; if (r === null) return null; let c = r.createElement("div"); return c.setAttribute("id", "headlessui-portal-root"), r.body.appendChild(c) }); return S.useEffect(() => { i !== null && (r != null && r.body.contains(i) || r == null || r.body.appendChild(i)) }, [i, r]), S.useEffect(() => { e || n !== null && a(n.current) }, [n, a, e]), i } let Rpe = S.Fragment, qrt = dr(function (t, e) { let n = t, r = S.useRef(null), i = Mr(Lz(f => { r.current = f }), e), a = Jc(r), s = Grt(r), [o] = S.useState(() => { var f; return vg.isServer ? null : (f = a?.createElement("div")) != null ? f : null }), c = S.useContext(JF), u = U_(); fr(() => { !s || !o || s.contains(o) || (o.setAttribute("data-headlessui-portal", ""), s.appendChild(o)) }, [s, o]), fr(() => { if (o && c) return c.register(o) }, [c, o]), Ppe(() => { var f; !s || !o || (o instanceof Node && s.contains(o) && s.removeChild(o), s.childNodes.length <= 0 && ((f = s.parentElement) == null || f.removeChild(s))) }); let d = mr(); return u ? !s || !o ? null : xi.createPortal(d({ ourProps: { ref: i }, theirProps: n, slot: {}, defaultTag: Rpe, name: "Portal" }), o) : null }); function Xrt(t, e) { let n = Mr(e), { enabled: r = !0, ...i } = t, a = mr(); return r ? P.createElement(qrt, { ...i, ref: n }) : a({ ourProps: { ref: n }, theirProps: i, slot: {}, defaultTag: Rpe, name: "Portal" }) } let Yrt = S.Fragment, kpe = S.createContext(null); function Krt(t, e) { let { target: n, ...r } = t, i = { ref: Mr(e) }, a = mr(); return P.createElement(kpe.Provider, { value: n }, a({ ourProps: i, theirProps: r, defaultTag: Yrt, name: "Popover.Group" })) } let JF = S.createContext(null); function Ipe() { let t = S.useContext(JF), e = S.useRef([]), n = ct(a => (e.current.push(a), t && t.register(a), () => r(a))), r = ct(a => { let s = e.current.indexOf(a); s !== -1 && e.current.splice(s, 1), t && t.unregister(a) }), i = S.useMemo(() => ({ register: n, unregister: r, portals: e }), [n, r, e]); return [e, S.useMemo(() => function ({ children: a }) { return P.createElement(JF.Provider, { value: i }, a) }, [i])] } let Zrt = dr(Xrt), Ope = dr(Krt), MP = Object.assign(Zrt, { Group: Ope }); var Qrt = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(Qrt || {}), Jrt = (t => (t[t.Single = 0] = "Single", t[t.Multi = 1] = "Multi", t))(Jrt || {}), eit = (t => (t[t.Pointer = 0] = "Pointer", t[t.Focus = 1] = "Focus", t[t.Other = 2] = "Other", t))(eit || {}), tit = (t => (t[t.OpenCombobox = 0] = "OpenCombobox", t[t.CloseCombobox = 1] = "CloseCombobox", t[t.GoToOption = 2] = "GoToOption", t[t.SetTyping = 3] = "SetTyping", t[t.RegisterOption = 4] = "RegisterOption", t[t.UnregisterOption = 5] = "UnregisterOption", t[t.SetActivationTrigger = 6] = "SetActivationTrigger", t[t.UpdateVirtualConfiguration = 7] = "UpdateVirtualConfiguration", t[t.SetInputElement = 8] = "SetInputElement", t[t.SetButtonElement = 9] = "SetButtonElement", t[t.SetOptionsElement = 10] = "SetOptionsElement", t))(tit || {}); function I3(t, e = n => n) { let n = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null, r = e(t.options.slice()), i = r.length > 0 && r[0].dataRef.current.order !== null ? r.sort((s, o) => s.dataRef.current.order - o.dataRef.current.order) : zh(r, s => s.dataRef.current.domRef.current), a = n ? i.indexOf(n) : null; return a === -1 && (a = null), { options: i, activeOptionIndex: a } } let nit = { 1(t) { var e; return (e = t.dataRef.current) != null && e.disabled || t.comboboxState === 1 ? t : { ...t, activeOptionIndex: null, comboboxState: 1, isTyping: !1, activationTrigger: 2, __demoMode: !1 } }, 0(t) { var e, n; if ((e = t.dataRef.current) != null && e.disabled || t.comboboxState === 0) return t; if ((n = t.dataRef.current) != null && n.value) { let r = t.dataRef.current.calculateIndex(t.dataRef.current.value); if (r !== -1) return { ...t, activeOptionIndex: r, comboboxState: 0, __demoMode: !1 } } return { ...t, comboboxState: 0, __demoMode: !1 } }, 3(t, e) { return t.isTyping === e.isTyping ? t : { ...t, isTyping: e.isTyping } }, 2(t, e) { var n, r, i, a; if ((n = t.dataRef.current) != null && n.disabled || t.optionsElement && !((r = t.dataRef.current) != null && r.optionsPropsRef.current.static) && t.comboboxState === 1) return t; if (t.virtual) { let { options: u, disabled: d } = t.virtual, f = e.focus === pr.Specific ? e.idx : h1(e, { resolveItems: () => u, resolveActiveIndex: () => { var m, g; return (g = (m = t.activeOptionIndex) != null ? m : u.findIndex(x => !d(x))) != null ? g : null }, resolveDisabled: d, resolveId() { throw new Error("Function not implemented.") } }), h = (i = e.trigger) != null ? i : 2; return t.activeOptionIndex === f && t.activationTrigger === h ? t : { ...t, activeOptionIndex: f, activationTrigger: h, isTyping: !1, __demoMode: !1 } } let s = I3(t); if (s.activeOptionIndex === null) { let u = s.options.findIndex(d => !d.dataRef.current.disabled); u !== -1 && (s.activeOptionIndex = u) } let o = e.focus === pr.Specific ? e.idx : h1(e, { resolveItems: () => s.options, resolveActiveIndex: () => s.activeOptionIndex, resolveId: u => u.id, resolveDisabled: u => u.dataRef.current.disabled }), c = (a = e.trigger) != null ? a : 2; return t.activeOptionIndex === o && t.activationTrigger === c ? t : { ...t, ...s, isTyping: !1, activeOptionIndex: o, activationTrigger: c, __demoMode: !1 } }, 4: (t, e) => { var n, r, i; if ((n = t.dataRef.current) != null && n.virtual) return { ...t, options: [...t.options, e.payload] }; let a = e.payload, s = I3(t, c => (c.push(a), c)); t.activeOptionIndex === null && (r = t.dataRef.current) != null && r.isSelected(e.payload.dataRef.current.value) && (s.activeOptionIndex = s.options.indexOf(a)); let o = { ...t, ...s, activationTrigger: 2 }; return (i = t.dataRef.current) != null && i.__demoMode && t.dataRef.current.value === void 0 && (o.activeOptionIndex = 0), o }, 5: (t, e) => { var n; if ((n = t.dataRef.current) != null && n.virtual) return { ...t, options: t.options.filter(i => i.id !== e.id) }; let r = I3(t, i => { let a = i.findIndex(s => s.id === e.id); return a !== -1 && i.splice(a, 1), i }); return { ...t, ...r, activationTrigger: 2 } }, 6: (t, e) => t.activationTrigger === e.trigger ? t : { ...t, activationTrigger: e.trigger }, 7: (t, e) => { var n, r; if (t.virtual === null) return { ...t, virtual: { options: e.options, disabled: (n = e.disabled) != null ? n : () => !1 } }; if (t.virtual.options === e.options && t.virtual.disabled === e.disabled) return t; let i = t.activeOptionIndex; if (t.activeOptionIndex !== null) { let a = e.options.indexOf(t.virtual.options[t.activeOptionIndex]); a !== -1 ? i = a : i = null } return { ...t, activeOptionIndex: i, virtual: { options: e.options, disabled: (r = e.disabled) != null ? r : () => !1 } } }, 8: (t, e) => t.inputElement === e.element ? t : { ...t, inputElement: e.element }, 9: (t, e) => t.buttonElement === e.element ? t : { ...t, buttonElement: e.element }, 10: (t, e) => t.optionsElement === e.element ? t : { ...t, optionsElement: e.element } }, Qz = S.createContext(null); Qz.displayName = "ComboboxActionsContext"; function B_(t) { let e = S.useContext(Qz); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Combobox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, B_), n } return e } let Dpe = S.createContext(null); function rit(t) { let e = Q0("VirtualProvider"), { options: n } = e.virtual, [r, i] = S.useMemo(() => { let u = e.optionsElement; if (!u) return [0, 0]; let d = window.getComputedStyle(u); return [parseFloat(d.paddingBlockStart || d.paddingTop), parseFloat(d.paddingBlockEnd || d.paddingBottom)] }, [e.optionsElement]), a = Ynt({ enabled: n.length !== 0, scrollPaddingStart: r, scrollPaddingEnd: i, count: n.length, estimateSize() { return 40 }, getScrollElement() { return e.optionsElement }, overscan: 12 }), [s, o] = S.useState(0); fr(() => { o(u => u + 1) }, [n]); let c = a.getVirtualItems(); return c.length === 0 ? null : P.createElement(Dpe.Provider, { value: a }, P.createElement("div", { style: { position: "relative", width: "100%", height: `${a.getTotalSize()}px` }, ref: u => { u && e.activationTrigger !== 0 && e.activeOptionIndex !== null && n.length > e.activeOptionIndex && a.scrollToIndex(e.activeOptionIndex) } }, c.map(u => { var d; return P.createElement(S.Fragment, { key: u.key }, P.cloneElement((d = t.children) == null ? void 0 : d.call(t, { ...t.slot, option: n[u.index] }), { key: `${s}-${u.key}`, "data-index": u.index, "aria-setsize": n.length, "aria-posinset": u.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${u.start}px)`, overflowAnchor: "none" } })) }))) } let RS = S.createContext(null); RS.displayName = "ComboboxDataContext"; function Q0(t) { let e = S.useContext(RS); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Combobox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, Q0), n } return e } function iit(t, e) { return Er(e.type, nit, t, e) } let ait = S.Fragment; function sit(t, e) { var n, r; let i = D_(), { value: a, defaultValue: s, onChange: o, form: c, name: u, by: d, disabled: f = i || !1, onClose: h, __demoMode: m = !1, multiple: g = !1, immediate: x = !1, virtual: v = null, nullable: b, ...E } = t, M = Oz(s), [C = g ? [] : void 0, N] = Iz(a, o, M), [A, j] = S.useReducer(iit, { dataRef: S.createRef(), comboboxState: m ? 0 : 1, isTyping: !1, options: [], virtual: v ? { options: v.options, disabled: (n = v.disabled) != null ? n : () => !1 } : null, activeOptionIndex: null, activationTrigger: 2, inputElement: null, buttonElement: null, optionsElement: null, __demoMode: m }), O = S.useRef(!1), I = S.useRef({ static: !1, hold: !1 }), D = xpe(d), F = ct(xe => v ? d === null ? v.options.indexOf(xe) : v.options.findIndex(_e => D(_e, xe)) : A.options.findIndex(_e => D(_e.dataRef.current.value, xe))), B = S.useCallback(xe => Er(z.mode, { 1: () => C.some(_e => D(_e, xe)), 0: () => D(C, xe) }), [C]), G = ct(xe => A.activeOptionIndex === F(xe)), z = S.useMemo(() => ({ ...A, immediate: x, optionsPropsRef: I, value: C, defaultValue: M, disabled: f, mode: g ? 1 : 0, virtual: v ? A.virtual : null, get activeOptionIndex() { if (O.current && A.activeOptionIndex === null && (v ? v.options.length > 0 : A.options.length > 0)) { if (v) { let _e = v.options.findIndex(je => { var ke, Ze; return !((Ze = (ke = v.disabled) == null ? void 0 : ke.call(v, je)) != null && Ze) }); if (_e !== -1) return _e } let xe = A.options.findIndex(_e => !_e.dataRef.current.disabled); if (xe !== -1) return xe } return A.activeOptionIndex }, calculateIndex: F, compare: D, isSelected: B, isActive: G }), [C, M, f, g, m, A, v]); fr(() => { var xe; v && j({ type: 7, options: v.options, disabled: (xe = v.disabled) != null ? xe : null }) }, [v, v?.options, v?.disabled]), fr(() => { A.dataRef.current = z }, [z]); let q = z.comboboxState === 0; wP(q, [z.buttonElement, z.inputElement, z.optionsElement], () => se.closeCombobox()); let Y = S.useMemo(() => { var xe, _e, je; return { open: z.comboboxState === 0, disabled: f, activeIndex: z.activeOptionIndex, activeOption: z.activeOptionIndex === null ? null : z.virtual ? z.virtual.options[(xe = z.activeOptionIndex) != null ? xe : 0] : (je = (_e = z.options[z.activeOptionIndex]) == null ? void 0 : _e.dataRef.current.value) != null ? je : null, value: C } }, [z, f, C]), Z = ct(() => { if (z.activeOptionIndex !== null) { if (se.setIsTyping(!1), z.virtual) re(z.virtual.options[z.activeOptionIndex]); else { let { dataRef: xe } = z.options[z.activeOptionIndex]; re(xe.current.value) } se.goToOption(pr.Specific, z.activeOptionIndex) } }), $ = ct(() => { j({ type: 0 }), O.current = !0 }), V = ct(() => { j({ type: 1 }), O.current = !1, h?.() }), K = ct(xe => { j({ type: 3, isTyping: xe }) }), X = ct((xe, _e, je) => (O.current = !1, xe === pr.Specific ? j({ type: 2, focus: pr.Specific, idx: _e, trigger: je }) : j({ type: 2, focus: xe, trigger: je }))), Q = ct((xe, _e) => (j({ type: 4, payload: { id: xe, dataRef: _e } }), () => { z.isActive(_e.current.value) && (O.current = !0), j({ type: 5, id: xe }) })), re = ct(xe => Er(z.mode, { 0() { return N?.(xe) }, 1() { let _e = z.value.slice(), je = _e.findIndex(ke => D(ke, xe)); return je === -1 ? _e.push(xe) : _e.splice(je, 1), N?.(_e) } })), ce = ct(xe => { j({ type: 6, trigger: xe }) }), be = ct(xe => { j({ type: 8, element: xe }) }), de = ct(xe => { j({ type: 9, element: xe }) }), ae = ct(xe => { j({ type: 10, element: xe }) }), se = S.useMemo(() => ({ onChange: re, registerOption: Q, goToOption: X, setIsTyping: K, closeCombobox: V, openCombobox: $, setActivationTrigger: ce, selectActiveOption: Z, setInputElement: be, setButtonElement: de, setOptionsElement: ae }), []), [he, Ae] = Uz(), Ce = e === null ? {} : { ref: e }, fe = S.useCallback(() => { if (M !== void 0) return N?.(M) }, [N, M]), oe = mr(); return P.createElement(Ae, { value: he, props: { htmlFor: (r = z.inputElement) == null ? void 0 : r.id }, slot: { open: z.comboboxState === 0, disabled: f } }, P.createElement(Yz, null, P.createElement(Qz.Provider, { value: se }, P.createElement(RS.Provider, { value: z }, P.createElement(F_, { value: Er(z.comboboxState, { 0: Yr.Open, 1: Yr.Closed }) }, u != null && P.createElement(Dz, { disabled: f, data: C != null ? { [u]: C } : {}, form: c, onReset: fe }), oe({ ourProps: Ce, theirProps: E, slot: Y, defaultTag: ait, name: "Combobox" })))))) } let oit = "input"; function lit(t, e) { var n, r, i, a, s; let o = Q0("Combobox.Input"), c = B_("Combobox.Input"), u = S.useId(), d = gP(), { id: f = d || `headlessui-combobox-input-${u}`, onChange: h, displayValue: m, disabled: g = o.disabled || !1, autoFocus: x = !1, type: v = "text", ...b } = t, E = S.useRef(null), M = Mr(E, e, Gz(), c.setInputElement), C = Jc(o.inputElement), N = id(), A = ct(() => { c.onChange(null), o.optionsElement && (o.optionsElement.scrollTop = 0), c.goToOption(pr.Nothing) }), j = S.useMemo(() => { var re; return typeof m == "function" && o.value !== void 0 ? (re = m(o.value)) != null ? re : "" : typeof o.value == "string" ? o.value : "" }, [o.value, m]); jS(([re, ce], [be, de]) => { if (o.isTyping) return; let ae = E.current; ae && ((de === 0 && ce === 1 || re !== be) && (ae.value = re), requestAnimationFrame(() => { if (o.isTyping || !ae || C?.activeElement !== ae) return; let { selectionStart: se, selectionEnd: he } = ae; Math.abs((he ?? 0) - (se ?? 0)) === 0 && se === 0 && ae.setSelectionRange(ae.value.length, ae.value.length) })) }, [j, o.comboboxState, C, o.isTyping]), jS(([re], [ce]) => { if (re === 0 && ce === 1) { if (o.isTyping) return; let be = E.current; if (!be) return; let de = be.value, { selectionStart: ae, selectionEnd: se, selectionDirection: he } = be; be.value = "", be.value = de, he !== null ? be.setSelectionRange(ae, se, he) : be.setSelectionRange(ae, se) } }, [o.comboboxState]); let O = S.useRef(!1), I = ct(() => { O.current = !0 }), D = ct(() => { N.nextFrame(() => { O.current = !1 }) }), F = ct(re => { switch (c.setIsTyping(!0), re.key) { case Sn.Enter: if (o.comboboxState !== 0 || O.current) return; if (re.preventDefault(), re.stopPropagation(), o.activeOptionIndex === null) { c.closeCombobox(); return } c.selectActiveOption(), o.mode === 0 && c.closeCombobox(); break; case Sn.ArrowDown: return re.preventDefault(), re.stopPropagation(), Er(o.comboboxState, { 0: () => c.goToOption(pr.Next), 1: () => c.openCombobox() }); case Sn.ArrowUp: return re.preventDefault(), re.stopPropagation(), Er(o.comboboxState, { 0: () => c.goToOption(pr.Previous), 1: () => { xi.flushSync(() => c.openCombobox()), o.value || c.goToOption(pr.Last) } }); case Sn.Home: if (re.shiftKey) break; return re.preventDefault(), re.stopPropagation(), c.goToOption(pr.First); case Sn.PageUp: return re.preventDefault(), re.stopPropagation(), c.goToOption(pr.First); case Sn.End: if (re.shiftKey) break; return re.preventDefault(), re.stopPropagation(), c.goToOption(pr.Last); case Sn.PageDown: return re.preventDefault(), re.stopPropagation(), c.goToOption(pr.Last); case Sn.Escape: return o.comboboxState !== 0 ? void 0 : (re.preventDefault(), o.optionsElement && !o.optionsPropsRef.current.static && re.stopPropagation(), o.mode === 0 && o.value === null && A(), c.closeCombobox()); case Sn.Tab: if (o.comboboxState !== 0) return; o.mode === 0 && o.activationTrigger !== 1 && c.selectActiveOption(), c.closeCombobox(); break } }), B = ct(re => { h?.(re), o.mode === 0 && re.target.value === "" && A(), c.openCombobox() }), G = ct(re => { var ce, be, de; let ae = (ce = re.relatedTarget) != null ? ce : yu.find(se => se !== re.currentTarget); if (!((be = o.optionsElement) != null && be.contains(ae)) && !((de = o.buttonElement) != null && de.contains(ae)) && o.comboboxState === 0) return re.preventDefault(), o.mode === 0 && o.value === null && A(), c.closeCombobox() }), z = ct(re => { var ce, be, de; let ae = (ce = re.relatedTarget) != null ? ce : yu.find(se => se !== re.currentTarget); (be = o.buttonElement) != null && be.contains(ae) || (de = o.optionsElement) != null && de.contains(ae) || o.disabled || o.immediate && o.comboboxState !== 0 && N.microTask(() => { xi.flushSync(() => c.openCombobox()), c.setActivationTrigger(1) }) }), q = G0(), Y = Fz(), { isFocused: Z, focusProps: $ } = jp({ autoFocus: x }), { isHovered: V, hoverProps: K } = Jg({ isDisabled: g }), X = S.useMemo(() => ({ open: o.comboboxState === 0, disabled: g, hover: V, focus: Z, autofocus: x }), [o, V, Z, x, g]), Q = vl({ ref: M, id: f, role: "combobox", type: v, "aria-controls": (n = o.optionsElement) == null ? void 0 : n.id, "aria-expanded": o.comboboxState === 0, "aria-activedescendant": o.activeOptionIndex === null ? void 0 : o.virtual ? (r = o.options.find(re => !re.dataRef.current.disabled && o.compare(re.dataRef.current.value, o.virtual.options[o.activeOptionIndex]))) == null ? void 0 : r.id : (i = o.options[o.activeOptionIndex]) == null ? void 0 : i.id, "aria-labelledby": q, "aria-describedby": Y, "aria-autocomplete": "list", defaultValue: (s = (a = t.defaultValue) != null ? a : o.defaultValue !== void 0 ? m?.(o.defaultValue) : null) != null ? s : o.defaultValue, disabled: g || void 0, autoFocus: x, onCompositionStart: I, onCompositionEnd: D, onKeyDown: F, onChange: B, onFocus: z, onBlur: G }, $, K); return mr()({ ourProps: Q, theirProps: b, slot: X, defaultTag: oit, name: "Combobox.Input" }) } let cit = "button"; function uit(t, e) { var n; let r = Q0("Combobox.Button"), i = B_("Combobox.Button"), a = Mr(e, i.setButtonElement), s = S.useId(), { id: o = `headlessui-combobox-button-${s}`, disabled: c = r.disabled || !1, autoFocus: u = !1, ...d } = t, f = Mpe(r.inputElement), h = ct(j => { switch (j.key) { case Sn.Space: case Sn.Enter: j.preventDefault(), j.stopPropagation(), r.comboboxState === 1 && xi.flushSync(() => i.openCombobox()), f(); return; case Sn.ArrowDown: j.preventDefault(), j.stopPropagation(), r.comboboxState === 1 && (xi.flushSync(() => i.openCombobox()), r.value || i.goToOption(pr.First)), f(); return; case Sn.ArrowUp: j.preventDefault(), j.stopPropagation(), r.comboboxState === 1 && (xi.flushSync(() => i.openCombobox()), r.value || i.goToOption(pr.Last)), f(); return; case Sn.Escape: if (r.comboboxState !== 0) return; j.preventDefault(), r.optionsElement && !r.optionsPropsRef.current.static && j.stopPropagation(), xi.flushSync(() => i.closeCombobox()), f(); return; default: return } }), m = ct(j => { j.preventDefault(), !W0(j.currentTarget) && (j.button === Zz.Left && (r.comboboxState === 0 ? i.closeCombobox() : i.openCombobox()), f()) }), g = G0([o]), { isFocusVisible: x, focusProps: v } = jp({ autoFocus: u }), { isHovered: b, hoverProps: E } = Jg({ isDisabled: c }), { pressed: M, pressProps: C } = H0({ disabled: c }), N = S.useMemo(() => ({ open: r.comboboxState === 0, active: M || r.comboboxState === 0, disabled: c, value: r.value, hover: b, focus: x }), [r, b, x, M, c]), A = vl({ ref: a, id: o, type: X0(t, r.buttonElement), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": (n = r.optionsElement) == null ? void 0 : n.id, "aria-expanded": r.comboboxState === 0, "aria-labelledby": g, disabled: c || void 0, autoFocus: u, onMouseDown: m, onKeyDown: h }, v, E, C); return mr()({ ourProps: A, theirProps: d, slot: N, defaultTag: cit, name: "Combobox.Button" }) } let dit = "div", fit = js.RenderStrategy | js.Static; function hit(t, e) { var n, r, i; let a = S.useId(), { id: s = `headlessui-combobox-options-${a}`, hold: o = !1, anchor: c, portal: u = !1, modal: d = !0, transition: f = !1, ...h } = t, m = Q0("Combobox.Options"), g = B_("Combobox.Options"), x = Wz(c); x && (u = !0); let [v, b] = Xz(x), [E, M] = S.useState(null), C = qz(), N = Mr(e, x ? v : null, g.setOptionsElement, M), A = Jc(m.optionsElement), j = kf(), [O, I] = K0(f, E, j !== null ? (j & Yr.Open) === Yr.Open : m.comboboxState === 0); xP(O, m.inputElement, g.closeCombobox); let D = m.__demoMode ? !1 : d && m.comboboxState === 0; _P(D, A); let F = m.__demoMode ? !1 : d && m.comboboxState === 0; zz(F, { allowed: S.useCallback(() => [m.inputElement, m.buttonElement, m.optionsElement], [m.inputElement, m.buttonElement, m.optionsElement]) }), fr(() => { var Q; m.optionsPropsRef.current.static = (Q = t.static) != null ? Q : !1 }, [m.optionsPropsRef, t.static]), fr(() => { m.optionsPropsRef.current.hold = o }, [m.optionsPropsRef, o]), xrt(m.comboboxState === 0, { container: m.optionsElement, accept(Q) { return Q.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : Q.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT }, walk(Q) { Q.setAttribute("role", "none") } }); let B = G0([(n = m.buttonElement) == null ? void 0 : n.id]), G = S.useMemo(() => ({ open: m.comboboxState === 0, option: void 0 }), [m.comboboxState]), z = ct(() => { g.setActivationTrigger(0) }), q = ct(Q => { Q.preventDefault(), g.setActivationTrigger(0) }), Y = vl(x ? C() : {}, { "aria-labelledby": B, role: "listbox", "aria-multiselectable": m.mode === 1 ? !0 : void 0, id: s, ref: N, style: { ...h.style, ...b, "--input-width": uA(m.inputElement, !0).width, "--button-width": uA(m.buttonElement, !0).width }, onWheel: m.activationTrigger === 0 ? void 0 : z, onMouseDown: q, ...Y0(I) }), Z = O && m.comboboxState === 1, $ = fA(Z, (r = m.virtual) == null ? void 0 : r.options), V = fA(Z, m.value), K = ct(Q => m.compare(V, Q)); if (m.virtual) { if ($ === void 0) throw new Error("Missing `options` in virtual mode"); Object.assign(h, { children: P.createElement(RS.Provider, { value: $ !== m.virtual.options ? { ...m, virtual: { ...m.virtual, options: $ } } : m }, P.createElement(rit, { slot: G }, h.children)) }) } let X = mr(); return P.createElement(MP, { enabled: u ? t.static || O : !1 }, P.createElement(RS.Provider, { value: m.mode === 1 ? m : { ...m, isSelected: K } }, X({ ourProps: Y, theirProps: { ...h, children: P.createElement($rt, { freeze: Z }, typeof h.children == "function" ? (i = h.children) == null ? void 0 : i.call(h, G) : h.children) }, slot: G, defaultTag: dit, features: fit, visible: O, name: "Combobox.Options" }))) } let pit = "div"; function mit(t, e) { var n, r, i, a; let s = Q0("Combobox.Option"), o = B_("Combobox.Option"), c = S.useId(), { id: u = `headlessui-combobox-option-${c}`, value: d, disabled: f = (i = (r = (n = s.virtual) == null ? void 0 : n.disabled) == null ? void 0 : r.call(n, d)) != null ? i : !1, order: h = null, ...m } = t, g = Mpe(s.inputElement), x = s.virtual ? s.activeOptionIndex === s.calculateIndex(d) : s.activeOptionIndex === null ? !1 : ((a = s.options[s.activeOptionIndex]) == null ? void 0 : a.id) === u, v = s.isSelected(d), b = S.useRef(null), E = no({ disabled: f, value: d, domRef: b, order: h }), M = S.useContext(Dpe), C = Mr(e, b, M ? M.measureElement : null), N = ct(() => { o.setIsTyping(!1), o.onChange(d) }); fr(() => o.registerOption(u, E), [E, u]); let A = S.useRef(!(s.virtual || s.__demoMode)); fr(() => { if (!s.virtual && !s.__demoMode) return Gc().requestAnimationFrame(() => { A.current = !0 }) }, [s.virtual, s.__demoMode]), fr(() => { if (A.current && s.comboboxState === 0 && x && s.activationTrigger !== 0) return Gc().requestAnimationFrame(() => { var q, Y; (Y = (q = b.current) == null ? void 0 : q.scrollIntoView) == null || Y.call(q, { block: "nearest" }) }) }, [b, x, s.comboboxState, s.activationTrigger, s.activeOptionIndex]); let j = ct(q => { q.preventDefault(), q.button === Zz.Left && (f || (N(), _pe() || requestAnimationFrame(() => g()), s.mode === 0 && o.closeCombobox())) }), O = ct(() => { if (f) return o.goToOption(pr.Nothing); let q = s.calculateIndex(d); o.goToOption(pr.Specific, q) }), I = Tpe(), D = ct(q => I.update(q)), F = ct(q => { if (!I.wasMoved(q) || f || x) return; let Y = s.calculateIndex(d); o.goToOption(pr.Specific, Y, 0) }), B = ct(q => { I.wasMoved(q) && (f || x && (s.optionsPropsRef.current.hold || o.goToOption(pr.Nothing))) }), G = S.useMemo(() => ({ active: x, focus: x, selected: v, disabled: f }), [x, v, f]), z = { id: u, ref: C, role: "option", tabIndex: f === !0 ? void 0 : -1, "aria-disabled": f === !0 ? !0 : void 0, "aria-selected": v, disabled: void 0, onMouseDown: j, onFocus: O, onPointerEnter: D, onMouseEnter: D, onPointerMove: F, onMouseMove: F, onPointerLeave: B, onMouseLeave: B }; return mr()({ ourProps: z, theirProps: m, slot: G, defaultTag: pit, name: "Combobox.Option" }) } let git = dr(sit), Lpe = dr(uit), Fpe = dr(lit), vit = Bz, Upe = dr(hit), Bpe = dr(mit), yit = Object.assign(git, { Input: Fpe, Button: Lpe, Label: vit, Options: Upe, Option: Bpe }); function xit(t, e = typeof document < "u" ? document.defaultView : null, n) { let r = q0(t, "escape"); SP(e, "keydown", i => { r && (i.defaultPrevented || i.key === Sn.Escape && n(i)) }) } function bit() { var t; let [e] = S.useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [n, r] = S.useState((t = e?.matches) != null ? t : !1); return fr(() => { if (!e) return; function i(a) { r(a.matches) } return e.addEventListener("change", i), () => e.removeEventListener("change", i) }, [e]), n } function $pe({ defaultContainers: t = [], portals: e, mainTreeNode: n } = {}) { let r = Jc(n), i = ct(() => { var a, s; let o = []; for (let c of t) c !== null && (c instanceof HTMLElement ? o.push(c) : "current" in c && c.current instanceof HTMLElement && o.push(c.current)); if (e != null && e.current) for (let c of e.current) o.push(c); for (let c of (a = r?.querySelectorAll("html > *, body > *")) != null ? a : []) c !== document.body && c !== document.head && c instanceof HTMLElement && c.id !== "headlessui-portal-root" && (n && (c.contains(n) || c.contains((s = n?.getRootNode()) == null ? void 0 : s.host)) || o.some(u => c.contains(u)) || o.push(c)); return o }); return { resolveContainers: i, contains: ct(a => i().some(s => s.contains(a))) } } let zpe = S.createContext(null); function hA({ children: t, node: e }) { let [n, r] = S.useState(null), i = Jz(e ?? n); return P.createElement(zpe.Provider, { value: i }, t, i === null && P.createElement(Xu, { features: qu.Hidden, ref: a => { var s, o; if (a) { for (let c of (o = (s = rd(a)) == null ? void 0 : s.querySelectorAll("html > *, body > *")) != null ? o : []) if (c !== document.body && c !== document.head && c instanceof HTMLElement && c != null && c.contains(a)) { r(c); break } } } })) } function Jz(t = null) { var e; return (e = S.useContext(zpe)) != null ? e : t } function TP() { let t = S.useRef(!1); return fr(() => (t.current = !0, () => { t.current = !1 }), []), t } var ul = (t => (t[t.Forwards = 0] = "Forwards", t[t.Backwards = 1] = "Backwards", t))(ul || {}); function e6() { let t = S.useRef(0); return Epe(!0, "keydown", e => { e.key === "Tab" && (t.current = e.shiftKey ? 1 : 0) }, !0), t } function Vpe(t) { if (!t) return new Set; if (typeof t == "function") return new Set(t()); let e = new Set; for (let n of t.current) n.current instanceof HTMLElement && e.add(n.current); return e } let wit = "div"; var Gm = (t => (t[t.None = 0] = "None", t[t.InitialFocus = 1] = "InitialFocus", t[t.TabLock = 2] = "TabLock", t[t.FocusLock = 4] = "FocusLock", t[t.RestoreFocus = 8] = "RestoreFocus", t[t.AutoFocus = 16] = "AutoFocus", t))(Gm || {}); function Sit(t, e) { let n = S.useRef(null), r = Mr(n, e), { initialFocus: i, initialFocusFallback: a, containers: s, features: o = 15, ...c } = t; U_() || (o = 0); let u = Jc(n); Tit(o, { ownerDocument: u }); let d = Cit(o, { ownerDocument: u, container: n, initialFocus: i, initialFocusFallback: a }); Nit(o, { ownerDocument: u, container: n, containers: s, previousActiveElement: d }); let f = e6(), h = ct(E => { let M = n.current; M && (C => C())(() => { Er(f.current, { [ul.Forwards]: () => { Ra(M, qr.First, { skipElements: [E.relatedTarget, a] }) }, [ul.Backwards]: () => { Ra(M, qr.Last, { skipElements: [E.relatedTarget, a] }) } }) }) }), m = q0(!!(o & 2), "focus-trap#tab-lock"), g = id(), x = S.useRef(!1), v = { ref: r, onKeyDown(E) { E.key == "Tab" && (x.current = !0, g.requestAnimationFrame(() => { x.current = !1 })) }, onBlur(E) { if (!(o & 4)) return; let M = Vpe(s); n.current instanceof HTMLElement && M.add(n.current); let C = E.relatedTarget; C instanceof HTMLElement && C.dataset.headlessuiFocusGuard !== "true" && (Hpe(M, C) || (x.current ? Ra(n.current, Er(f.current, { [ul.Forwards]: () => qr.Next, [ul.Backwards]: () => qr.Previous }) | qr.WrapAround, { relativeTo: E.target }) : E.target instanceof HTMLElement && uf(E.target))) } }, b = mr(); return P.createElement(P.Fragment, null, m && P.createElement(Xu, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: h, features: qu.Focusable }), b({ ourProps: v, theirProps: c, defaultTag: wit, name: "FocusTrap" }), m && P.createElement(Xu, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: h, features: qu.Focusable })) } let _it = dr(Sit), Eit = Object.assign(_it, { features: Gm }); function Mit(t = !0) { let e = S.useRef(yu.slice()); return jS(([n], [r]) => { r === !0 && n === !1 && O_(() => { e.current.splice(0) }), r === !1 && n === !0 && (e.current = yu.slice()) }, [t, yu, e]), ct(() => { var n; return (n = e.current.find(r => r != null && r.isConnected)) != null ? n : null }) } function Tit(t, { ownerDocument: e }) { let n = !!(t & 8), r = Mit(n); jS(() => { n || e?.activeElement === e?.body && uf(r()) }, [n]), Ppe(() => { n && uf(r()) }) } function Cit(t, { ownerDocument: e, container: n, initialFocus: r, initialFocusFallback: i }) { let a = S.useRef(null), s = q0(!!(t & 1), "focus-trap#initial-focus"), o = TP(); return jS(() => { if (t === 0) return; if (!s) { i != null && i.current && uf(i.current); return } let c = n.current; c && O_(() => { if (!o.current) return; let u = e?.activeElement; if (r != null && r.current) { if (r?.current === u) { a.current = u; return } } else if (c.contains(u)) { a.current = u; return } if (r != null && r.current) uf(r.current); else { if (t & 16) { if (Ra(c, qr.First | qr.AutoFocus) !== Tu.Error) return } else if (Ra(c, qr.First) !== Tu.Error) return; if (i != null && i.current && (uf(i.current), e?.activeElement === i.current)) return; console.warn("There are no focusable elements inside the <FocusTrap />") } a.current = e?.activeElement }) }, [i, s, t]), a } function Nit(t, { ownerDocument: e, container: n, containers: r, previousActiveElement: i }) { let a = TP(), s = !!(t & 4); SP(e?.defaultView, "focus", o => { if (!s || !a.current) return; let c = Vpe(r); n.current instanceof HTMLElement && c.add(n.current); let u = i.current; if (!u) return; let d = o.target; d && d instanceof HTMLElement ? Hpe(c, d) ? (i.current = d, uf(d)) : (o.preventDefault(), o.stopPropagation(), uf(u)) : uf(i.current) }, !0) } function Hpe(t, e) { for (let n of t) if (n.contains(e)) return !0; return !1 } function Wpe(t) { var e; return !!(t.enter || t.enterFrom || t.enterTo || t.leave || t.leaveFrom || t.leaveTo) || ((e = t.as) != null ? e : qpe) !== S.Fragment || P.Children.count(t.children) === 1 } let CP = S.createContext(null); CP.displayName = "TransitionContext"; var Ait = (t => (t.Visible = "visible", t.Hidden = "hidden", t))(Ait || {}); function Pit() { let t = S.useContext(CP); if (t === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />."); return t } function jit() { let t = S.useContext(NP); if (t === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />."); return t } let NP = S.createContext(null); NP.displayName = "NestingContext"; function AP(t) { return "children" in t ? AP(t.children) : t.current.filter(({ el: e }) => e.current !== null).filter(({ state: e }) => e === "visible").length > 0 } function Gpe(t, e) { let n = no(t), r = S.useRef([]), i = TP(), a = id(), s = ct((m, g = $h.Hidden) => { let x = r.current.findIndex(({ el: v }) => v === m); x !== -1 && (Er(g, { [$h.Unmount]() { r.current.splice(x, 1) }, [$h.Hidden]() { r.current[x].state = "hidden" } }), a.microTask(() => { var v; !AP(r) && i.current && ((v = n.current) == null || v.call(n)) })) }), o = ct(m => { let g = r.current.find(({ el: x }) => x === m); return g ? g.state !== "visible" && (g.state = "visible") : r.current.push({ el: m, state: "visible" }), () => s(m, $h.Unmount) }), c = S.useRef([]), u = S.useRef(Promise.resolve()), d = S.useRef({ enter: [], leave: [] }), f = ct((m, g, x) => { c.current.splice(0), e && (e.chains.current[g] = e.chains.current[g].filter(([v]) => v !== m)), e?.chains.current[g].push([m, new Promise(v => { c.current.push(v) })]), e?.chains.current[g].push([m, new Promise(v => { Promise.all(d.current[g].map(([b, E]) => E)).then(() => v()) })]), g === "enter" ? u.current = u.current.then(() => e?.wait.current).then(() => x(g)) : x(g) }), h = ct((m, g, x) => { Promise.all(d.current[g].splice(0).map(([v, b]) => b)).then(() => { var v; (v = c.current.shift()) == null || v() }).then(() => x(g)) }); return S.useMemo(() => ({ children: r, register: o, unregister: s, onStart: f, onStop: h, wait: u, chains: d }), [o, s, r, f, h, d, u]) } let qpe = S.Fragment, Xpe = js.RenderStrategy; function Rit(t, e) { var n, r; let { transition: i = !0, beforeEnter: a, afterEnter: s, beforeLeave: o, afterLeave: c, enter: u, enterFrom: d, enterTo: f, entered: h, leave: m, leaveFrom: g, leaveTo: x, ...v } = t, [b, E] = S.useState(null), M = S.useRef(null), C = Wpe(t), N = Mr(...C ? [M, e, E] : e === null ? [] : [e]), A = (n = v.unmount) == null || n ? $h.Unmount : $h.Hidden, { show: j, appear: O, initial: I } = Pit(), [D, F] = S.useState(j ? "visible" : "hidden"), B = jit(), { register: G, unregister: z } = B; fr(() => G(M), [G, M]), fr(() => { if (A === $h.Hidden && M.current) { if (j && D !== "visible") { F("visible"); return } return Er(D, { hidden: () => z(M), visible: () => G(M) }) } }, [D, M, G, z, j, A]); let q = U_(); fr(() => { if (C && q && D === "visible" && M.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?") }, [M, D, q, C]); let Y = I && !O, Z = O && j && I, $ = S.useRef(!1), V = Gpe(() => { $.current || (F("hidden"), z(M)) }, B), K = ct(ae => { $.current = !0; let se = ae ? "enter" : "leave"; V.onStart(M, se, he => { he === "enter" ? a?.() : he === "leave" && o?.() }) }), X = ct(ae => { let se = ae ? "enter" : "leave"; $.current = !1, V.onStop(M, se, he => { he === "enter" ? s?.() : he === "leave" && c?.() }), se === "leave" && !AP(V) && (F("hidden"), z(M)) }); S.useEffect(() => { C && i || (K(j), X(j)) }, [j, C, i]); let Q = !(!i || !C || !q || Y), [, re] = K0(Q, b, j, { start: K, end: X }), ce = Ph({ ref: N, className: ((r = KF(v.className, Z && u, Z && d, re.enter && u, re.enter && re.closed && d, re.enter && !re.closed && f, re.leave && m, re.leave && !re.closed && g, re.leave && re.closed && x, !re.transition && j && h)) == null ? void 0 : r.trim()) || void 0, ...Y0(re) }), be = 0; D === "visible" && (be |= Yr.Open), D === "hidden" && (be |= Yr.Closed), re.enter && (be |= Yr.Opening), re.leave && (be |= Yr.Closing); let de = mr(); return P.createElement(NP.Provider, { value: V }, P.createElement(F_, { value: be }, de({ ourProps: ce, theirProps: v, defaultTag: qpe, features: Xpe, visible: D === "visible", name: "Transition.Child" }))) } function kit(t, e) { let { show: n, appear: r = !1, unmount: i = !0, ...a } = t, s = S.useRef(null), o = Wpe(t), c = Mr(...o ? [s, e] : e === null ? [] : [e]); U_(); let u = kf(); if (n === void 0 && u !== null && (n = (u & Yr.Open) === Yr.Open), n === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop."); let [d, f] = S.useState(n ? "visible" : "hidden"), h = Gpe(() => { n || f("hidden") }), [m, g] = S.useState(!0), x = S.useRef([n]); fr(() => { m !== !1 && x.current[x.current.length - 1] !== n && (x.current.push(n), g(!1)) }, [x, n]); let v = S.useMemo(() => ({ show: n, appear: r, initial: m }), [n, r, m]); fr(() => { n ? f("visible") : !AP(h) && s.current !== null && f("hidden") }, [n, h]); let b = { unmount: i }, E = ct(() => { var N; m && g(!1), (N = t.beforeEnter) == null || N.call(t) }), M = ct(() => { var N; m && g(!1), (N = t.beforeLeave) == null || N.call(t) }), C = mr(); return P.createElement(NP.Provider, { value: h }, P.createElement(CP.Provider, { value: v }, C({ ourProps: { ...b, as: S.Fragment, children: P.createElement(Ype, { ref: c, ...b, ...a, beforeEnter: E, beforeLeave: M }) }, theirProps: {}, defaultTag: S.Fragment, features: Xpe, visible: d === "visible", name: "Transition" }))) } function Iit(t, e) { let n = S.useContext(CP) !== null, r = kf() !== null; return P.createElement(P.Fragment, null, !n && r ? P.createElement(e5, { ref: e, ...t }) : P.createElement(Ype, { ref: e, ...t })) } let e5 = dr(kit), Ype = dr(Rit), PP = dr(Iit), cp = Object.assign(e5, { Child: PP, Root: e5 }); var Oit = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(Oit || {}), Dit = (t => (t[t.SetTitleId = 0] = "SetTitleId", t))(Dit || {}); let Lit = { 0(t, e) { return t.titleId === e.id ? t : { ...t, titleId: e.id } } }, t6 = S.createContext(null); t6.displayName = "DialogContext"; function jP(t) { let e = S.useContext(t6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Dialog /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, jP), n } return e } function Fit(t, e) { return Er(e.type, Lit, t, e) } let FQ = dr(function (t, e) { let n = S.useId(), { id: r = `headlessui-dialog-${n}`, open: i, onClose: a, initialFocus: s, role: o = "dialog", autoFocus: c = !0, __demoMode: u = !1, unmount: d = !1, ...f } = t, h = S.useRef(!1); o = (function () { return o === "dialog" || o === "alertdialog" ? o : (h.current || (h.current = !0, console.warn(`Invalid role [${o}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog") })(); let m = kf(); i === void 0 && m !== null && (i = (m & Yr.Open) === Yr.Open); let g = S.useRef(null), x = Mr(g, e), v = Jc(g), b = i ? 0 : 1, [E, M] = S.useReducer(Fit, { titleId: null, descriptionId: null, panelRef: S.createRef() }), C = ct(() => a(!1)), N = ct(X => M({ type: 0, id: X })), A = U_() ? b === 0 : !1, [j, O] = Ipe(), I = { get current() { var X; return (X = E.panelRef.current) != null ? X : g.current } }, D = Jz(), { resolveContainers: F } = $pe({ mainTreeNode: D, portals: j, defaultContainers: [I] }), B = m !== null ? (m & Yr.Closing) === Yr.Closing : !1; zz(u || B ? !1 : A, { allowed: ct(() => { var X, Q; return [(Q = (X = g.current) == null ? void 0 : X.closest("[data-headlessui-portal]")) != null ? Q : null] }), disallowed: ct(() => { var X; return [(X = D?.closest("body > *:not(#headlessui-portal-root)")) != null ? X : null] }) }), wP(A, F, X => { X.preventDefault(), C() }), xit(A, v?.defaultView, X => { X.preventDefault(), X.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), C() }), _P(u || B ? !1 : A, v, F), xP(A, g, C); let [G, z] = mpe(), q = S.useMemo(() => [{ dialogState: b, close: C, setTitleId: N, unmount: d }, E], [b, E, C, N, d]), Y = S.useMemo(() => ({ open: b === 0 }), [b]), Z = { ref: x, id: r, role: o, tabIndex: -1, "aria-modal": u ? void 0 : b === 0 ? !0 : void 0, "aria-labelledby": E.titleId, "aria-describedby": G, unmount: d }, $ = !bit(), V = Gm.None; A && !u && (V |= Gm.RestoreFocus, V |= Gm.TabLock, c && (V |= Gm.AutoFocus), $ && (V |= Gm.InitialFocus)); let K = mr(); return P.createElement(Kz, null, P.createElement(LQ, { force: !0 }, P.createElement(MP, null, P.createElement(t6.Provider, { value: q }, P.createElement(Ope, { target: g }, P.createElement(LQ, { force: !1 }, P.createElement(z, { slot: Y }, P.createElement(O, null, P.createElement(Eit, { initialFocus: s, initialFocusFallback: g, containers: F, features: V }, P.createElement($z, { value: C }, K({ ourProps: Z, theirProps: f, slot: Y, defaultTag: Uit, features: Bit, visible: b === 0, name: "Dialog" }))))))))))) }), Uit = "div", Bit = js.RenderStrategy | js.Static; function $it(t, e) { let { transition: n = !1, open: r, ...i } = t, a = kf(), s = t.hasOwnProperty("open") || a !== null, o = t.hasOwnProperty("onClose"); if (!s && !o) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component."); if (!s) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop."); if (!o) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop."); if (!a && typeof t.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${t.open}`); if (typeof t.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${t.onClose}`); return (r !== void 0 || n) && !i.static ? P.createElement(hA, null, P.createElement(cp, { show: r, transition: n, unmount: i.unmount }, P.createElement(FQ, { ref: e, ...i }))) : P.createElement(hA, null, P.createElement(FQ, { ref: e, open: r, ...i })) } let zit = "div"; function Vit(t, e) { let n = S.useId(), { id: r = `headlessui-dialog-panel-${n}`, transition: i = !1, ...a } = t, [{ dialogState: s, unmount: o }, c] = jP("Dialog.Panel"), u = Mr(e, c.panelRef), d = S.useMemo(() => ({ open: s === 0 }), [s]), f = ct(v => { v.stopPropagation() }), h = { ref: u, id: r, onClick: f }, m = i ? PP : S.Fragment, g = i ? { unmount: o } : {}, x = mr(); return P.createElement(m, { ...g }, x({ ourProps: h, theirProps: a, slot: d, defaultTag: zit, name: "Dialog.Panel" })) } let Hit = "div"; function Wit(t, e) { let { transition: n = !1, ...r } = t, [{ dialogState: i, unmount: a }] = jP("Dialog.Backdrop"), s = S.useMemo(() => ({ open: i === 0 }), [i]), o = { ref: e, "aria-hidden": !0 }, c = n ? PP : S.Fragment, u = n ? { unmount: a } : {}, d = mr(); return P.createElement(c, { ...u }, d({ ourProps: o, theirProps: r, slot: s, defaultTag: Hit, name: "Dialog.Backdrop" })) } let Git = "h2"; function qit(t, e) { let n = S.useId(), { id: r = `headlessui-dialog-title-${n}`, ...i } = t, [{ dialogState: a, setTitleId: s }] = jP("Dialog.Title"), o = Mr(e); S.useEffect(() => (s(r), () => s(null)), [r, s]); let c = S.useMemo(() => ({ open: a === 0 }), [a]), u = { ref: o, id: r }; return mr()({ ourProps: u, theirProps: i, slot: c, defaultTag: Git, name: "Dialog.Title" }) } let Xit = dr($it), Kpe = dr(Vit), Yit = dr(Wit), Kit = dr(qit), Zit = Object.assign(Xit, { Panel: Kpe, Title: Kit, Description: gpe }); var UQ; let Qit = (UQ = P.startTransition) != null ? UQ : function (t) { t() }; var Jit = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(Jit || {}), eat = (t => (t[t.ToggleDisclosure = 0] = "ToggleDisclosure", t[t.CloseDisclosure = 1] = "CloseDisclosure", t[t.SetButtonId = 2] = "SetButtonId", t[t.SetPanelId = 3] = "SetPanelId", t[t.SetButtonElement = 4] = "SetButtonElement", t[t.SetPanelElement = 5] = "SetPanelElement", t))(eat || {}); let tat = { 0: t => ({ ...t, disclosureState: Er(t.disclosureState, { 0: 1, 1: 0 }) }), 1: t => t.disclosureState === 1 ? t : { ...t, disclosureState: 1 }, 2(t, e) { return t.buttonId === e.buttonId ? t : { ...t, buttonId: e.buttonId } }, 3(t, e) { return t.panelId === e.panelId ? t : { ...t, panelId: e.panelId } }, 4(t, e) { return t.buttonElement === e.element ? t : { ...t, buttonElement: e.element } }, 5(t, e) { return t.panelElement === e.element ? t : { ...t, panelElement: e.element } } }, n6 = S.createContext(null); n6.displayName = "DisclosureContext"; function r6(t) { let e = S.useContext(n6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Disclosure /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, r6), n } return e } let i6 = S.createContext(null); i6.displayName = "DisclosureAPIContext"; function Zpe(t) { let e = S.useContext(i6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Disclosure /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, Zpe), n } return e } let a6 = S.createContext(null); a6.displayName = "DisclosurePanelContext"; function nat() { return S.useContext(a6) } function rat(t, e) { return Er(e.type, tat, t, e) } let iat = S.Fragment; function aat(t, e) { let { defaultOpen: n = !1, ...r } = t, i = S.useRef(null), a = Mr(e, Lz(x => { i.current = x }, t.as === void 0 || t.as === S.Fragment)), s = S.useReducer(rat, { disclosureState: n ? 0 : 1, buttonElement: null, panelElement: null, buttonId: null, panelId: null }), [{ disclosureState: o, buttonId: c }, u] = s, d = ct(x => { u({ type: 1 }); let v = rd(i); if (!v || !c) return; let b = x ? x instanceof HTMLElement ? x : x.current instanceof HTMLElement ? x.current : v.getElementById(c) : v.getElementById(c); b?.focus() }), f = S.useMemo(() => ({ close: d }), [d]), h = S.useMemo(() => ({ open: o === 0, close: d }), [o, d]), m = { ref: a }, g = mr(); return P.createElement(n6.Provider, { value: s }, P.createElement(i6.Provider, { value: f }, P.createElement($z, { value: d }, P.createElement(F_, { value: Er(o, { 0: Yr.Open, 1: Yr.Closed }) }, g({ ourProps: m, theirProps: r, slot: h, defaultTag: iat, name: "Disclosure" }))))) } let sat = "button"; function oat(t, e) { let n = S.useId(), { id: r = `headlessui-disclosure-button-${n}`, disabled: i = !1, autoFocus: a = !1, ...s } = t, [o, c] = r6("Disclosure.Button"), u = nat(), d = u === null ? !1 : u === o.panelId, f = S.useRef(null), h = Mr(f, e, ct(I => { if (!d) return c({ type: 4, element: I }) })); S.useEffect(() => { if (!d) return c({ type: 2, buttonId: r }), () => { c({ type: 2, buttonId: null }) } }, [r, c, d]); let m = ct(I => { var D; if (d) { if (o.disclosureState === 1) return; switch (I.key) { case Sn.Space: case Sn.Enter: I.preventDefault(), I.stopPropagation(), c({ type: 0 }), (D = o.buttonElement) == null || D.focus(); break } } else switch (I.key) { case Sn.Space: case Sn.Enter: I.preventDefault(), I.stopPropagation(), c({ type: 0 }); break } }), g = ct(I => { switch (I.key) { case Sn.Space: I.preventDefault(); break } }), x = ct(I => { var D; W0(I.currentTarget) || i || (d ? (c({ type: 0 }), (D = o.buttonElement) == null || D.focus()) : c({ type: 0 })) }), { isFocusVisible: v, focusProps: b } = jp({ autoFocus: a }), { isHovered: E, hoverProps: M } = Jg({ isDisabled: i }), { pressed: C, pressProps: N } = H0({ disabled: i }), A = S.useMemo(() => ({ open: o.disclosureState === 0, hover: E, active: C, disabled: i, focus: v, autofocus: a }), [o, E, C, v, i, a]), j = X0(t, o.buttonElement), O = vl(d ? { ref: h, type: j, disabled: i || void 0, autoFocus: a, onKeyDown: m, onClick: x } : { ref: h, id: r, type: j, "aria-expanded": o.disclosureState === 0, "aria-controls": o.panelElement ? o.panelId : void 0, disabled: i || void 0, autoFocus: a, onKeyDown: m, onKeyUp: g, onClick: x }, b, M, N); return mr()({ ourProps: O, theirProps: s, slot: A, defaultTag: sat, name: "Disclosure.Button" }) } let lat = "div", cat = js.RenderStrategy | js.Static; function uat(t, e) { let n = S.useId(), { id: r = `headlessui-disclosure-panel-${n}`, transition: i = !1, ...a } = t, [s, o] = r6("Disclosure.Panel"), { close: c } = Zpe("Disclosure.Panel"), [u, d] = S.useState(null), f = Mr(e, ct(E => { Qit(() => o({ type: 5, element: E })) }), d); S.useEffect(() => (o({ type: 3, panelId: r }), () => { o({ type: 3, panelId: null }) }), [r, o]); let h = kf(), [m, g] = K0(i, u, h !== null ? (h & Yr.Open) === Yr.Open : s.disclosureState === 0), x = S.useMemo(() => ({ open: s.disclosureState === 0, close: c }), [s.disclosureState, c]), v = { ref: f, id: r, ...Y0(g) }, b = mr(); return P.createElement(Kz, null, P.createElement(a6.Provider, { value: s.panelId }, b({ ourProps: v, theirProps: a, slot: x, defaultTag: lat, features: cat, visible: m, name: "Disclosure.Panel" }))) } let dat = dr(aat), fat = dr(oat), hat = dr(uat), s6 = Object.assign(dat, { Button: fat, Panel: hat }); function pat(t, e) { let n = S.useRef({ left: 0, top: 0 }); if (fr(() => { if (!e) return; let i = e.getBoundingClientRect(); i && (n.current = i) }, [t, e]), e == null || !t || e === document.activeElement) return !1; let r = e.getBoundingClientRect(); return r.top !== n.current.top || r.left !== n.current.left } let BQ = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g; function $Q(t) { var e, n; let r = (e = t.innerText) != null ? e : "", i = t.cloneNode(!0); if (!(i instanceof HTMLElement)) return r; let a = !1; for (let o of i.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) o.remove(), a = !0; let s = a ? (n = i.innerText) != null ? n : "" : r; return BQ.test(s) && (s = s.replace(BQ, "")), s } function mat(t) { let e = t.getAttribute("aria-label"); if (typeof e == "string") return e.trim(); let n = t.getAttribute("aria-labelledby"); if (n) { let r = n.split(" ").map(i => { let a = document.getElementById(i); if (a) { let s = a.getAttribute("aria-label"); return typeof s == "string" ? s.trim() : $Q(a).trim() } return null }).filter(Boolean); if (r.length > 0) return r.join(", ") } return $Q(t).trim() } function gat(t) { let e = S.useRef(""), n = S.useRef(""); return ct(() => { let r = t.current; if (!r) return ""; let i = r.innerText; if (e.current === i) return n.current; let a = mat(r).trim().toLowerCase(); return e.current = i, n.current = a, a }) } var vat = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(vat || {}), yat = (t => (t[t.Single = 0] = "Single", t[t.Multi = 1] = "Multi", t))(yat || {}), xat = (t => (t[t.Pointer = 0] = "Pointer", t[t.Other = 1] = "Other", t))(xat || {}), bat = (t => (t[t.OpenListbox = 0] = "OpenListbox", t[t.CloseListbox = 1] = "CloseListbox", t[t.GoToOption = 2] = "GoToOption", t[t.Search = 3] = "Search", t[t.ClearSearch = 4] = "ClearSearch", t[t.RegisterOption = 5] = "RegisterOption", t[t.UnregisterOption = 6] = "UnregisterOption", t[t.SetButtonElement = 7] = "SetButtonElement", t[t.SetOptionsElement = 8] = "SetOptionsElement", t))(bat || {}); function O3(t, e = n => n) { let n = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null, r = zh(e(t.options.slice()), a => a.dataRef.current.domRef.current), i = n ? r.indexOf(n) : null; return i === -1 && (i = null), { options: r, activeOptionIndex: i } } let wat = { 1(t) { return t.dataRef.current.disabled || t.listboxState === 1 ? t : { ...t, activeOptionIndex: null, listboxState: 1, __demoMode: !1 } }, 0(t) { if (t.dataRef.current.disabled || t.listboxState === 0) return t; let e = t.activeOptionIndex, { isSelected: n } = t.dataRef.current, r = t.options.findIndex(i => n(i.dataRef.current.value)); return r !== -1 && (e = r), { ...t, listboxState: 0, activeOptionIndex: e, __demoMode: !1 } }, 2(t, e) { var n, r, i, a, s; if (t.dataRef.current.disabled || t.listboxState === 1) return t; let o = { ...t, searchQuery: "", activationTrigger: (n = e.trigger) != null ? n : 1, __demoMode: !1 }; if (e.focus === pr.Nothing) return { ...o, activeOptionIndex: null }; if (e.focus === pr.Specific) return { ...o, activeOptionIndex: t.options.findIndex(d => d.id === e.id) }; if (e.focus === pr.Previous) { let d = t.activeOptionIndex; if (d !== null) { let f = t.options[d].dataRef.current.domRef, h = h1(e, { resolveItems: () => t.options, resolveActiveIndex: () => t.activeOptionIndex, resolveId: m => m.id, resolveDisabled: m => m.dataRef.current.disabled }); if (h !== null) { let m = t.options[h].dataRef.current.domRef; if (((r = f.current) == null ? void 0 : r.previousElementSibling) === m.current || ((i = m.current) == null ? void 0 : i.previousElementSibling) === null) return { ...o, activeOptionIndex: h } } } } else if (e.focus === pr.Next) { let d = t.activeOptionIndex; if (d !== null) { let f = t.options[d].dataRef.current.domRef, h = h1(e, { resolveItems: () => t.options, resolveActiveIndex: () => t.activeOptionIndex, resolveId: m => m.id, resolveDisabled: m => m.dataRef.current.disabled }); if (h !== null) { let m = t.options[h].dataRef.current.domRef; if (((a = f.current) == null ? void 0 : a.nextElementSibling) === m.current || ((s = m.current) == null ? void 0 : s.nextElementSibling) === null) return { ...o, activeOptionIndex: h } } } } let c = O3(t), u = h1(e, { resolveItems: () => c.options, resolveActiveIndex: () => c.activeOptionIndex, resolveId: d => d.id, resolveDisabled: d => d.dataRef.current.disabled }); return { ...o, ...c, activeOptionIndex: u } }, 3: (t, e) => { if (t.dataRef.current.disabled || t.listboxState === 1) return t; let n = t.searchQuery !== "" ? 0 : 1, r = t.searchQuery + e.value.toLowerCase(), i = (t.activeOptionIndex !== null ? t.options.slice(t.activeOptionIndex + n).concat(t.options.slice(0, t.activeOptionIndex + n)) : t.options).find(s => { var o; return !s.dataRef.current.disabled && ((o = s.dataRef.current.textValue) == null ? void 0 : o.startsWith(r)) }), a = i ? t.options.indexOf(i) : -1; return a === -1 || a === t.activeOptionIndex ? { ...t, searchQuery: r } : { ...t, searchQuery: r, activeOptionIndex: a, activationTrigger: 1 } }, 4(t) { return t.dataRef.current.disabled || t.listboxState === 1 || t.searchQuery === "" ? t : { ...t, searchQuery: "" } }, 5: (t, e) => { let n = { id: e.id, dataRef: e.dataRef }, r = O3(t, i => [...i, n]); return t.activeOptionIndex === null && t.dataRef.current.isSelected(e.dataRef.current.value) && (r.activeOptionIndex = r.options.indexOf(n)), { ...t, ...r } }, 6: (t, e) => { let n = O3(t, r => { let i = r.findIndex(a => a.id === e.id); return i !== -1 && r.splice(i, 1), r }); return { ...t, ...n, activationTrigger: 1 } }, 7: (t, e) => t.buttonElement === e.element ? t : { ...t, buttonElement: e.element }, 8: (t, e) => t.optionsElement === e.element ? t : { ...t, optionsElement: e.element } }, o6 = S.createContext(null); o6.displayName = "ListboxActionsContext"; function RP(t) { let e = S.useContext(o6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Listbox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, RP), n } return e } let kP = S.createContext(null); kP.displayName = "ListboxDataContext"; function $_(t) { let e = S.useContext(kP); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Listbox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, $_), n } return e } function Sat(t, e) { return Er(e.type, wat, t, e) } let _at = S.Fragment; function Eat(t, e) { var n; let r = D_(), { value: i, defaultValue: a, form: s, name: o, onChange: c, by: u, invalid: d = !1, disabled: f = r || !1, horizontal: h = !1, multiple: m = !1, __demoMode: g = !1, ...x } = t; const v = h ? "horizontal" : "vertical"; let b = Mr(e), E = Oz(a), [M = m ? [] : void 0, C] = Iz(i, c, E), [N, A] = S.useReducer(Sat, { dataRef: S.createRef(), listboxState: g ? 0 : 1, options: [], searchQuery: "", activeOptionIndex: null, activationTrigger: 1, optionsVisible: !1, buttonElement: null, optionsElement: null, __demoMode: g }), j = S.useRef({ static: !1, hold: !1 }), O = S.useRef(new Map), I = xpe(u), D = S.useCallback(fe => Er(F.mode, { 1: () => M.some(oe => I(oe, fe)), 0: () => I(M, fe) }), [M]), F = S.useMemo(() => ({ ...N, value: M, disabled: f, invalid: d, mode: m ? 1 : 0, orientation: v, compare: I, isSelected: D, optionsPropsRef: j, listRef: O }), [M, f, d, m, N, O]); fr(() => { N.dataRef.current = F }, [F]); let B = F.listboxState === 0; wP(B, [F.buttonElement, F.optionsElement], (fe, oe) => { var xe; A({ type: 1 }), Vz(oe, bP.Loose) || (fe.preventDefault(), (xe = F.buttonElement) == null || xe.focus()) }); let G = S.useMemo(() => ({ open: F.listboxState === 0, disabled: f, invalid: d, value: M }), [F, f, M, d]), z = ct(fe => { let oe = F.options.find(xe => xe.id === fe); oe && X(oe.dataRef.current.value) }), q = ct(() => { if (F.activeOptionIndex !== null) { let { dataRef: fe, id: oe } = F.options[F.activeOptionIndex]; X(fe.current.value), A({ type: 2, focus: pr.Specific, id: oe }) } }), Y = ct(() => A({ type: 0 })), Z = ct(() => A({ type: 1 })), $ = id(), V = ct((fe, oe, xe) => { $.dispose(), $.microTask(() => fe === pr.Specific ? A({ type: 2, focus: pr.Specific, id: oe, trigger: xe }) : A({ type: 2, focus: fe, trigger: xe })) }), K = ct((fe, oe) => (A({ type: 5, id: fe, dataRef: oe }), () => A({ type: 6, id: fe }))), X = ct(fe => Er(F.mode, { 0() { return C?.(fe) }, 1() { let oe = F.value.slice(), xe = oe.findIndex(_e => I(_e, fe)); return xe === -1 ? oe.push(fe) : oe.splice(xe, 1), C?.(oe) } })), Q = ct(fe => A({ type: 3, value: fe })), re = ct(() => A({ type: 4 })), ce = ct(fe => { A({ type: 7, element: fe }) }), be = ct(fe => { A({ type: 8, element: fe }) }), de = S.useMemo(() => ({ onChange: X, registerOption: K, goToOption: V, closeListbox: Z, openListbox: Y, selectActiveOption: q, selectOption: z, search: Q, clearSearch: re, setButtonElement: ce, setOptionsElement: be }), []), [ae, se] = Uz({ inherit: !0 }), he = { ref: b }, Ae = S.useCallback(() => { if (E !== void 0) return C?.(E) }, [C, E]), Ce = mr(); return P.createElement(se, { value: ae, props: { htmlFor: (n = F.buttonElement) == null ? void 0 : n.id }, slot: { open: F.listboxState === 0, disabled: f } }, P.createElement(Yz, null, P.createElement(o6.Provider, { value: de }, P.createElement(kP.Provider, { value: F }, P.createElement(F_, { value: Er(F.listboxState, { 0: Yr.Open, 1: Yr.Closed }) }, o != null && M != null && P.createElement(Dz, { disabled: f, data: { [o]: M }, form: s, onReset: Ae }), Ce({ ourProps: he, theirProps: x, slot: G, defaultTag: _at, name: "Listbox" })))))) } let Mat = "button"; function Tat(t, e) { var n; let r = $_("Listbox.Button"), i = RP("Listbox.Button"), a = S.useId(), s = gP(), { id: o = s || `headlessui-listbox-button-${a}`, disabled: c = r.disabled || !1, autoFocus: u = !1, ...d } = t, f = Mr(e, Gz(), i.setButtonElement), h = Frt(), m = ct(F => { switch (F.key) { case Sn.Enter: fpe(F.currentTarget); break; case Sn.Space: case Sn.ArrowDown: F.preventDefault(), xi.flushSync(() => i.openListbox()), r.value || i.goToOption(pr.First); break; case Sn.ArrowUp: F.preventDefault(), xi.flushSync(() => i.openListbox()), r.value || i.goToOption(pr.Last); break } }), g = ct(F => { switch (F.key) { case Sn.Space: F.preventDefault(); break } }), x = ct(F => { var B; if (W0(F.currentTarget)) return F.preventDefault(); r.listboxState === 0 ? (xi.flushSync(() => i.closeListbox()), (B = r.buttonElement) == null || B.focus({ preventScroll: !0 })) : (F.preventDefault(), i.openListbox()) }), v = ct(F => F.preventDefault()), b = G0([o]), E = Fz(), { isFocusVisible: M, focusProps: C } = jp({ autoFocus: u }), { isHovered: N, hoverProps: A } = Jg({ isDisabled: c }), { pressed: j, pressProps: O } = H0({ disabled: c }), I = S.useMemo(() => ({ open: r.listboxState === 0, active: j || r.listboxState === 0, disabled: c, invalid: r.invalid, value: r.value, hover: N, focus: M, autofocus: u }), [r.listboxState, r.value, c, N, M, j, r.invalid, u]), D = vl(h(), { ref: f, id: o, type: X0(t, r.buttonElement), "aria-haspopup": "listbox", "aria-controls": (n = r.optionsElement) == null ? void 0 : n.id, "aria-expanded": r.listboxState === 0, "aria-labelledby": b, "aria-describedby": E, disabled: c || void 0, autoFocus: u, onKeyDown: m, onKeyUp: g, onKeyPress: v, onClick: x }, C, A, O); return mr()({ ourProps: D, theirProps: d, slot: I, defaultTag: Mat, name: "Listbox.Button" }) } let Qpe = S.createContext(!1), Cat = "div", Nat = js.RenderStrategy | js.Static; function Aat(t, e) { var n, r; let i = S.useId(), { id: a = `headlessui-listbox-options-${i}`, anchor: s, portal: o = !1, modal: c = !0, transition: u = !1, ...d } = t, f = Wz(s), [h, m] = S.useState(null); f && (o = !0); let g = $_("Listbox.Options"), x = RP("Listbox.Options"), v = Jc(g.optionsElement), b = kf(), [E, M] = K0(u, h, b !== null ? (b & Yr.Open) === Yr.Open : g.listboxState === 0); xP(E, g.buttonElement, x.closeListbox); let C = g.__demoMode ? !1 : c && g.listboxState === 0; _P(C, v); let N = g.__demoMode ? !1 : c && g.listboxState === 0; zz(N, { allowed: S.useCallback(() => [g.buttonElement, g.optionsElement], [g.buttonElement, g.optionsElement]) }); let A = g.listboxState !== 0, j = pat(A, g.buttonElement) ? !1 : E, O = E && g.listboxState === 1, I = fA(O, g.value), D = ct(re => g.compare(I, re)), F = S.useMemo(() => { var re; if (f == null || !((re = f?.to) != null && re.includes("selection"))) return null; let ce = g.options.findIndex(be => D(be.dataRef.current.value)); return ce === -1 && (ce = 0), ce }, [f, g.options]), B = (() => { if (f == null) return; if (F === null) return { ...f, inner: void 0 }; let re = Array.from(g.listRef.current.values()); return { ...f, inner: { listRef: { current: re }, index: F } } })(), [G, z] = Xz(B), q = qz(), Y = Mr(e, f ? G : null, x.setOptionsElement, m), Z = id(); S.useEffect(() => { var re; let ce = g.optionsElement; ce && g.listboxState === 0 && ce !== ((re = rd(ce)) == null ? void 0 : re.activeElement) && ce?.focus({ preventScroll: !0 }) }, [g.listboxState, g.optionsElement]); let $ = ct(re => { var ce, be; switch (Z.dispose(), re.key) { case Sn.Space: if (g.searchQuery !== "") return re.preventDefault(), re.stopPropagation(), x.search(re.key); case Sn.Enter: if (re.preventDefault(), re.stopPropagation(), g.activeOptionIndex !== null) { let { dataRef: de } = g.options[g.activeOptionIndex]; x.onChange(de.current.value) } g.mode === 0 && (xi.flushSync(() => x.closeListbox()), (ce = g.buttonElement) == null || ce.focus({ preventScroll: !0 })); break; case Er(g.orientation, { vertical: Sn.ArrowDown, horizontal: Sn.ArrowRight }): return re.preventDefault(), re.stopPropagation(), x.goToOption(pr.Next); case Er(g.orientation, { vertical: Sn.ArrowUp, horizontal: Sn.ArrowLeft }): return re.preventDefault(), re.stopPropagation(), x.goToOption(pr.Previous); case Sn.Home: case Sn.PageUp: return re.preventDefault(), re.stopPropagation(), x.goToOption(pr.First); case Sn.End: case Sn.PageDown: return re.preventDefault(), re.stopPropagation(), x.goToOption(pr.Last); case Sn.Escape: re.preventDefault(), re.stopPropagation(), xi.flushSync(() => x.closeListbox()), (be = g.buttonElement) == null || be.focus({ preventScroll: !0 }); return; case Sn.Tab: re.preventDefault(), re.stopPropagation(), xi.flushSync(() => x.closeListbox()), srt(g.buttonElement, re.shiftKey ? qr.Previous : qr.Next); break; default: re.key.length === 1 && (x.search(re.key), Z.setTimeout(() => x.clearSearch(), 350)); break } }), V = (n = g.buttonElement) == null ? void 0 : n.id, K = S.useMemo(() => ({ open: g.listboxState === 0 }), [g.listboxState]), X = vl(f ? q() : {}, { id: a, ref: Y, "aria-activedescendant": g.activeOptionIndex === null || (r = g.options[g.activeOptionIndex]) == null ? void 0 : r.id, "aria-multiselectable": g.mode === 1 ? !0 : void 0, "aria-labelledby": V, "aria-orientation": g.orientation, onKeyDown: $, role: "listbox", tabIndex: g.listboxState === 0 ? 0 : void 0, style: { ...d.style, ...z, "--button-width": uA(g.buttonElement, !0).width }, ...Y0(M) }), Q = mr(); return P.createElement(MP, { enabled: o ? t.static || E : !1 }, P.createElement(kP.Provider, { value: g.mode === 1 ? g : { ...g, isSelected: D } }, Q({ ourProps: X, theirProps: d, slot: K, defaultTag: Cat, features: Nat, visible: j, name: "Listbox.Options" }))) } let Pat = "div"; function jat(t, e) { let n = S.useId(), { id: r = `headlessui-listbox-option-${n}`, disabled: i = !1, value: a, ...s } = t, o = S.useContext(Qpe) === !0, c = $_("Listbox.Option"), u = RP("Listbox.Option"), d = c.activeOptionIndex !== null ? c.options[c.activeOptionIndex].id === r : !1, f = c.isSelected(a), h = S.useRef(null), m = gat(h), g = no({ disabled: i, value: a, domRef: h, get textValue() { return m() } }), x = Mr(e, h, I => { I ? c.listRef.current.set(r, I) : c.listRef.current.delete(r) }); fr(() => { if (!c.__demoMode && c.listboxState === 0 && d && c.activationTrigger !== 0) return Gc().requestAnimationFrame(() => { var I, D; (D = (I = h.current) == null ? void 0 : I.scrollIntoView) == null || D.call(I, { block: "nearest" }) }) }, [h, d, c.__demoMode, c.listboxState, c.activationTrigger, c.activeOptionIndex]), fr(() => { if (!o) return u.registerOption(r, g) }, [g, r, o]); let v = ct(I => { var D; if (i) return I.preventDefault(); u.onChange(a), c.mode === 0 && (xi.flushSync(() => u.closeListbox()), (D = c.buttonElement) == null || D.focus({ preventScroll: !0 })) }), b = ct(() => { if (i) return u.goToOption(pr.Nothing); u.goToOption(pr.Specific, r) }), E = Tpe(), M = ct(I => { E.update(I), !i && (d || u.goToOption(pr.Specific, r, 0)) }), C = ct(I => { E.wasMoved(I) && (i || d || u.goToOption(pr.Specific, r, 0)) }), N = ct(I => { E.wasMoved(I) && (i || d && u.goToOption(pr.Nothing)) }), A = S.useMemo(() => ({ active: d, focus: d, selected: f, disabled: i, selectedOption: f && o }), [d, f, i, o]), j = o ? {} : { id: r, ref: x, role: "option", tabIndex: i === !0 ? void 0 : -1, "aria-disabled": i === !0 ? !0 : void 0, "aria-selected": f, disabled: void 0, onClick: v, onFocus: b, onPointerEnter: M, onMouseEnter: M, onPointerMove: C, onMouseMove: C, onPointerLeave: N, onMouseLeave: N }, O = mr(); return !f && o ? null : O({ ourProps: j, theirProps: s, slot: A, defaultTag: Pat, name: "Listbox.Option" }) } let Rat = S.Fragment; function kat(t, e) { let { options: n, placeholder: r, ...i } = t, a = { ref: Mr(e) }, s = $_("ListboxSelectedOption"), o = S.useMemo(() => ({}), []), c = s.value === void 0 || s.value === null || s.mode === 1 && Array.isArray(s.value) && s.value.length === 0, u = mr(); return P.createElement(Qpe.Provider, { value: !0 }, u({ ourProps: a, theirProps: { ...i, children: P.createElement(P.Fragment, null, r && c ? r : n) }, slot: o, defaultTag: Rat, name: "ListboxSelectedOption" })) } let Iat = dr(Eat), IP = dr(Tat), Oat = Bz, OP = dr(Aat), l6 = dr(jat), Dat = dr(kat), c6 = Object.assign(Iat, { Button: IP, Label: Oat, Options: OP, Option: l6, SelectedOption: Dat }); var Lat = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(Lat || {}), Fat = (t => (t[t.TogglePopover = 0] = "TogglePopover", t[t.ClosePopover = 1] = "ClosePopover", t[t.SetButton = 2] = "SetButton", t[t.SetButtonId = 3] = "SetButtonId", t[t.SetPanel = 4] = "SetPanel", t[t.SetPanelId = 5] = "SetPanelId", t))(Fat || {}); let Uat = { 0: t => ({ ...t, popoverState: Er(t.popoverState, { 0: 1, 1: 0 }), __demoMode: !1 }), 1(t) { return t.popoverState === 1 ? t : { ...t, popoverState: 1, __demoMode: !1 } }, 2(t, e) { return t.button === e.button ? t : { ...t, button: e.button } }, 3(t, e) { return t.buttonId === e.buttonId ? t : { ...t, buttonId: e.buttonId } }, 4(t, e) { return t.panel === e.panel ? t : { ...t, panel: e.panel } }, 5(t, e) { return t.panelId === e.panelId ? t : { ...t, panelId: e.panelId } } }, u6 = S.createContext(null); u6.displayName = "PopoverContext"; function DP(t) { let e = S.useContext(u6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Popover /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, DP), n } return e } let LP = S.createContext(null); LP.displayName = "PopoverAPIContext"; function d6(t) { let e = S.useContext(LP); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Popover /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, d6), n } return e } let f6 = S.createContext(null); f6.displayName = "PopoverGroupContext"; function Jpe() { return S.useContext(f6) } let FP = S.createContext(null); FP.displayName = "PopoverPanelContext"; function Bat() { return S.useContext(FP) } function $at(t, e) { return Er(e.type, Uat, t, e) } let zat = "div"; function Vat(t, e) { var n; let { __demoMode: r = !1, ...i } = t, a = S.useRef(null), s = Mr(e, Lz(V => { a.current = V })), o = S.useRef([]), c = S.useReducer($at, { __demoMode: r, popoverState: r ? 0 : 1, buttons: o, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: S.createRef(), afterPanelSentinel: S.createRef(), afterButtonSentinel: S.createRef() }), [{ popoverState: u, button: d, buttonId: f, panel: h, panelId: m, beforePanelSentinel: g, afterPanelSentinel: x, afterButtonSentinel: v }, b] = c, E = Jc((n = a.current) != null ? n : d), M = S.useMemo(() => { if (!d || !h) return !1; for (let be of document.querySelectorAll("body > *")) if (Number(be?.contains(d)) ^ Number(be?.contains(h))) return !0; let V = L_(), K = V.indexOf(d), X = (K + V.length - 1) % V.length, Q = (K + 1) % V.length, re = V[X], ce = V[Q]; return !h.contains(re) && !h.contains(ce) }, [d, h]), C = no(f), N = no(m), A = S.useMemo(() => ({ buttonId: C, panelId: N, close: () => b({ type: 1 }) }), [C, N, b]), j = Jpe(), O = j?.registerPopover, I = ct(() => { var V; return (V = j?.isFocusWithinPopoverGroup()) != null ? V : E?.activeElement && (d?.contains(E.activeElement) || h?.contains(E.activeElement)) }); S.useEffect(() => O?.(A), [O, A]); let [D, F] = Ipe(), B = Jz(d), G = $pe({ mainTreeNode: B, portals: D, defaultContainers: [d, h] }); SP(E?.defaultView, "focus", V => { var K, X, Q, re, ce, be; V.target !== window && V.target instanceof HTMLElement && u === 0 && (I() || d && h && (G.contains(V.target) || (X = (K = g.current) == null ? void 0 : K.contains) != null && X.call(K, V.target) || (re = (Q = x.current) == null ? void 0 : Q.contains) != null && re.call(Q, V.target) || (be = (ce = v.current) == null ? void 0 : ce.contains) != null && be.call(ce, V.target) || b({ type: 1 }))) }, !0), wP(u === 0, G.resolveContainers, (V, K) => { b({ type: 1 }), Vz(K, bP.Loose) || (V.preventDefault(), d?.focus()) }); let z = ct(V => { b({ type: 1 }); let K = V ? V instanceof HTMLElement ? V : "current" in V && V.current instanceof HTMLElement ? V.current : d : d; K?.focus() }), q = S.useMemo(() => ({ close: z, isPortalled: M }), [z, M]), Y = S.useMemo(() => ({ open: u === 0, close: z }), [u, z]), Z = { ref: s }, $ = mr(); return P.createElement(hA, { node: B }, P.createElement(Yz, null, P.createElement(FP.Provider, { value: null }, P.createElement(u6.Provider, { value: c }, P.createElement(LP.Provider, { value: q }, P.createElement($z, { value: z }, P.createElement(F_, { value: Er(u, { 0: Yr.Open, 1: Yr.Closed }) }, P.createElement(F, null, $({ ourProps: Z, theirProps: i, slot: Y, defaultTag: zat, name: "Popover" }))))))))) } let Hat = "button"; function Wat(t, e) { let n = S.useId(), { id: r = `headlessui-popover-button-${n}`, disabled: i = !1, autoFocus: a = !1, ...s } = t, [o, c] = DP("Popover.Button"), { isPortalled: u } = d6("Popover.Button"), d = S.useRef(null), f = `headlessui-focus-sentinel-${S.useId()}`, h = Jpe(), m = h?.closeOthers, g = Bat() !== null; S.useEffect(() => { if (!g) return c({ type: 3, buttonId: r }), () => { c({ type: 3, buttonId: null }) } }, [g, r, c]); let [x] = S.useState(() => Symbol()), v = Mr(d, e, Gz(), ct(K => { if (!g) { if (K) o.buttons.current.push(x); else { let X = o.buttons.current.indexOf(x); X !== -1 && o.buttons.current.splice(X, 1) } o.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), K && c({ type: 2, button: K }) } })), b = Mr(d, e), E = Jc(d), M = ct(K => { var X, Q, re; if (g) { if (o.popoverState === 1) return; switch (K.key) { case Sn.Space: case Sn.Enter: K.preventDefault(), (Q = (X = K.target).click) == null || Q.call(X), c({ type: 1 }), (re = o.button) == null || re.focus(); break } } else switch (K.key) { case Sn.Space: case Sn.Enter: K.preventDefault(), K.stopPropagation(), o.popoverState === 1 && m?.(o.buttonId), c({ type: 0 }); break; case Sn.Escape: if (o.popoverState !== 0) return m?.(o.buttonId); if (!d.current || E != null && E.activeElement && !d.current.contains(E.activeElement)) return; K.preventDefault(), K.stopPropagation(), c({ type: 1 }); break } }), C = ct(K => { g || K.key === Sn.Space && K.preventDefault() }), N = ct(K => { var X, Q; W0(K.currentTarget) || i || (g ? (c({ type: 1 }), (X = o.button) == null || X.focus()) : (K.preventDefault(), K.stopPropagation(), o.popoverState === 1 && m?.(o.buttonId), c({ type: 0 }), (Q = o.button) == null || Q.focus())) }), A = ct(K => { K.preventDefault(), K.stopPropagation() }), { isFocusVisible: j, focusProps: O } = jp({ autoFocus: a }), { isHovered: I, hoverProps: D } = Jg({ isDisabled: i }), { pressed: F, pressProps: B } = H0({ disabled: i }), G = o.popoverState === 0, z = S.useMemo(() => ({ open: G, active: F || G, disabled: i, hover: I, focus: j, autofocus: a }), [G, I, j, F, i, a]), q = X0(t, o.button), Y = vl(g ? { ref: b, type: q, onKeyDown: M, onClick: N, disabled: i || void 0, autoFocus: a } : { ref: v, id: o.buttonId, type: q, "aria-expanded": o.popoverState === 0, "aria-controls": o.panel ? o.panelId : void 0, disabled: i || void 0, autoFocus: a, onKeyDown: M, onKeyUp: C, onClick: N, onMouseDown: A }, O, D, B), Z = e6(), $ = ct(() => { let K = o.panel; if (!K) return; function X() { Er(Z.current, { [ul.Forwards]: () => Ra(K, qr.First), [ul.Backwards]: () => Ra(K, qr.Last) }) === Tu.Error && Ra(L_().filter(Q => Q.dataset.headlessuiFocusGuard !== "true"), Er(Z.current, { [ul.Forwards]: qr.Next, [ul.Backwards]: qr.Previous }), { relativeTo: o.button }) } X() }), V = mr(); return P.createElement(P.Fragment, null, V({ ourProps: Y, theirProps: s, slot: z, defaultTag: Hat, name: "Popover.Button" }), G && !g && u && P.createElement(Xu, { id: f, ref: o.afterButtonSentinel, features: qu.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: $ })) } let Gat = "div", qat = js.RenderStrategy | js.Static; function eme(t, e) { let n = S.useId(), { id: r = `headlessui-popover-backdrop-${n}`, transition: i = !1, ...a } = t, [{ popoverState: s }, o] = DP("Popover.Backdrop"), [c, u] = S.useState(null), d = Mr(e, u), f = kf(), [h, m] = K0(i, c, f !== null ? (f & Yr.Open) === Yr.Open : s === 0), g = ct(b => { if (W0(b.currentTarget)) return b.preventDefault(); o({ type: 1 }) }), x = S.useMemo(() => ({ open: s === 0 }), [s]), v = { ref: d, id: r, "aria-hidden": !0, onClick: g, ...Y0(m) }; return mr()({ ourProps: v, theirProps: a, slot: x, defaultTag: Gat, features: qat, visible: h, name: "Popover.Backdrop" }) } let Xat = "div", Yat = js.RenderStrategy | js.Static; function Kat(t, e) { let n = S.useId(), { id: r = `headlessui-popover-panel-${n}`, focus: i = !1, anchor: a, portal: s = !1, modal: o = !1, transition: c = !1, ...u } = t, [d, f] = DP("Popover.Panel"), { close: h, isPortalled: m } = d6("Popover.Panel"), g = `headlessui-focus-sentinel-before-${n}`, x = `headlessui-focus-sentinel-after-${n}`, v = S.useRef(null), b = Wz(a), [E, M] = Xz(b), C = qz(); b && (s = !0); let [N, A] = S.useState(null), j = Mr(v, e, b ? E : null, ct(K => f({ type: 4, panel: K })), A), O = Jc(v); fr(() => (f({ type: 5, panelId: r }), () => { f({ type: 5, panelId: null }) }), [r, f]); let I = kf(), [D, F] = K0(c, N, I !== null ? (I & Yr.Open) === Yr.Open : d.popoverState === 0); xP(D, d.button, () => { f({ type: 1 }) }); let B = d.__demoMode ? !1 : o && D; _P(B, O); let G = ct(K => { var X; switch (K.key) { case Sn.Escape: if (d.popoverState !== 0 || !v.current || O != null && O.activeElement && !v.current.contains(O.activeElement)) return; K.preventDefault(), K.stopPropagation(), f({ type: 1 }), (X = d.button) == null || X.focus(); break } }); S.useEffect(() => { var K; t.static || d.popoverState === 1 && ((K = t.unmount) == null || K) && f({ type: 4, panel: null }) }, [d.popoverState, t.unmount, t.static, f]), S.useEffect(() => { if (d.__demoMode || !i || d.popoverState !== 0 || !v.current) return; let K = O?.activeElement; v.current.contains(K) || Ra(v.current, qr.First) }, [d.__demoMode, i, v.current, d.popoverState]); let z = S.useMemo(() => ({ open: d.popoverState === 0, close: h }), [d.popoverState, h]), q = vl(b ? C() : {}, { ref: j, id: r, onKeyDown: G, onBlur: i && d.popoverState === 0 ? K => { var X, Q, re, ce, be; let de = K.relatedTarget; de && v.current && ((X = v.current) != null && X.contains(de) || (f({ type: 1 }), ((re = (Q = d.beforePanelSentinel.current) == null ? void 0 : Q.contains) != null && re.call(Q, de) || (be = (ce = d.afterPanelSentinel.current) == null ? void 0 : ce.contains) != null && be.call(ce, de)) && de.focus({ preventScroll: !0 }))) } : void 0, tabIndex: -1, style: { ...u.style, ...M, "--button-width": uA(d.button, !0).width }, ...Y0(F) }), Y = e6(), Z = ct(() => { let K = v.current; if (!K) return; function X() { Er(Y.current, { [ul.Forwards]: () => { var Q; Ra(K, qr.First) === Tu.Error && ((Q = d.afterPanelSentinel.current) == null || Q.focus()) }, [ul.Backwards]: () => { var Q; (Q = d.button) == null || Q.focus({ preventScroll: !0 }) } }) } X() }), $ = ct(() => { let K = v.current; if (!K) return; function X() { Er(Y.current, { [ul.Forwards]: () => { if (!d.button) return; let Q = L_(), re = Q.indexOf(d.button), ce = Q.slice(0, re + 1), be = [...Q.slice(re + 1), ...ce]; for (let de of be.slice()) if (de.dataset.headlessuiFocusGuard === "true" || N != null && N.contains(de)) { let ae = be.indexOf(de); ae !== -1 && be.splice(ae, 1) } Ra(be, qr.First, { sorted: !1 }) }, [ul.Backwards]: () => { var Q; Ra(K, qr.Previous) === Tu.Error && ((Q = d.button) == null || Q.focus()) } }) } X() }), V = mr(); return P.createElement(Kz, null, P.createElement(FP.Provider, { value: r }, P.createElement(LP.Provider, { value: { close: h, isPortalled: m } }, P.createElement(MP, { enabled: s ? t.static || D : !1 }, D && m && P.createElement(Xu, { id: g, ref: d.beforePanelSentinel, features: qu.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: Z }), V({ ourProps: q, theirProps: u, slot: z, defaultTag: Xat, features: Yat, visible: D, name: "Popover.Panel" }), D && m && P.createElement(Xu, { id: x, ref: d.afterPanelSentinel, features: qu.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: $ }))))) } let Zat = "div"; function Qat(t, e) { let n = S.useRef(null), r = Mr(n, e), [i, a] = S.useState([]), s = ct(x => { a(v => { let b = v.indexOf(x); if (b !== -1) { let E = v.slice(); return E.splice(b, 1), E } return v }) }), o = ct(x => (a(v => [...v, x]), () => s(x))), c = ct(() => { var x; let v = rd(n); if (!v) return !1; let b = v.activeElement; return (x = n.current) != null && x.contains(b) ? !0 : i.some(E => { var M, C; return ((M = v.getElementById(E.buttonId.current)) == null ? void 0 : M.contains(b)) || ((C = v.getElementById(E.panelId.current)) == null ? void 0 : C.contains(b)) }) }), u = ct(x => { for (let v of i) v.buttonId.current !== x && v.close() }), d = S.useMemo(() => ({ registerPopover: o, unregisterPopover: s, isFocusWithinPopoverGroup: c, closeOthers: u }), [o, s, c, u]), f = S.useMemo(() => ({}), []), h = t, m = { ref: r }, g = mr(); return P.createElement(hA, null, P.createElement(f6.Provider, { value: d }, g({ ourProps: m, theirProps: h, slot: f, defaultTag: Zat, name: "Popover.Group" }))) } let Jat = dr(Vat), h6 = dr(Wat), est = dr(eme), tst = dr(eme), p6 = dr(Kat), nst = dr(Qat), tme = Object.assign(Jat, { Button: h6, Backdrop: tst, Overlay: est, Panel: p6, Group: nst }), m6 = S.createContext(null); m6.displayName = "GroupContext"; let rst = S.Fragment; function ist(t) { var e; let [n, r] = S.useState(null), [i, a] = Uz(), [s, o] = mpe(), c = S.useMemo(() => ({ switch: n, setSwitch: r }), [n, r]), u = {}, d = t, f = mr(); return P.createElement(o, { name: "Switch.Description", value: s }, P.createElement(a, { name: "Switch.Label", value: i, props: { htmlFor: (e = c.switch) == null ? void 0 : e.id, onClick(h) { n && (h.currentTarget instanceof HTMLLabelElement && h.preventDefault(), n.click(), n.focus({ preventScroll: !0 })) } } }, P.createElement(m6.Provider, { value: c }, f({ ourProps: u, theirProps: d, slot: {}, defaultTag: rst, name: "Switch.Group" })))) } let ast = "button"; function sst(t, e) { var n; let r = S.useId(), i = gP(), a = D_(), { id: s = i || `headlessui-switch-${r}`, disabled: o = a || !1, checked: c, defaultChecked: u, onChange: d, name: f, value: h, form: m, autoFocus: g = !1, ...x } = t, v = S.useContext(m6), [b, E] = S.useState(null), M = S.useRef(null), C = Mr(M, e, v === null ? null : v.setSwitch, E), N = Oz(u), [A, j] = Iz(c, d, N ?? !1), O = id(), [I, D] = S.useState(!1), F = ct(() => { D(!0), j?.(!A), O.nextFrame(() => { D(!1) }) }), B = ct(ae => { if (W0(ae.currentTarget)) return ae.preventDefault(); ae.preventDefault(), F() }), G = ct(ae => { ae.key === Sn.Space ? (ae.preventDefault(), F()) : ae.key === Sn.Enter && fpe(ae.currentTarget) }), z = ct(ae => ae.preventDefault()), q = G0(), Y = Fz(), { isFocusVisible: Z, focusProps: $ } = jp({ autoFocus: g }), { isHovered: V, hoverProps: K } = Jg({ isDisabled: o }), { pressed: X, pressProps: Q } = H0({ disabled: o }), re = S.useMemo(() => ({ checked: A, disabled: o, hover: V, focus: Z, active: X, autofocus: g, changing: I }), [A, V, Z, X, o, I, g]), ce = vl({ id: s, ref: C, role: "switch", type: X0(t, b), tabIndex: t.tabIndex === -1 ? 0 : (n = t.tabIndex) != null ? n : 0, "aria-checked": A, "aria-labelledby": q, "aria-describedby": Y, disabled: o || void 0, autoFocus: g, onClick: B, onKeyUp: G, onKeyPress: z }, $, K, Q), be = S.useCallback(() => { if (N !== void 0) return j?.(N) }, [j, N]), de = mr(); return P.createElement(P.Fragment, null, f != null && P.createElement(Dz, { disabled: o, data: { [f]: h || "on" }, overrides: { type: "checkbox", checked: A }, form: m, onReset: be }), de({ ourProps: ce, theirProps: x, slot: re, defaultTag: ast, name: "Switch" })) } let ost = dr(sst), lst = ist, cst = Bz, ust = gpe, dst = Object.assign(ost, { Group: lst, Label: cst, Description: ust }); function fst({ onFocus: t }) { let [e, n] = S.useState(!0), r = TP(); return e ? P.createElement(Xu, { as: "button", type: "button", features: qu.Focusable, onFocus: i => { i.preventDefault(); let a, s = 50; function o() { if (s-- <= 0) { a && cancelAnimationFrame(a); return } if (t()) { if (cancelAnimationFrame(a), !r.current) return; n(!1); return } a = requestAnimationFrame(o) } a = requestAnimationFrame(o) } }) : null } const nme = S.createContext(null); function hst() { return { groups: new Map, get(t, e) { var n; let r = this.groups.get(t); r || (r = new Map, this.groups.set(t, r)); let i = (n = r.get(e)) != null ? n : 0; r.set(e, i + 1); let a = Array.from(r.keys()).indexOf(e); function s() { let o = r.get(e); o > 1 ? r.set(e, o - 1) : r.delete(e) } return [a, s] } } } function pst({ children: t }) { let e = S.useRef(hst()); return S.createElement(nme.Provider, { value: e }, t) } function rme(t) { let e = S.useContext(nme); if (!e) throw new Error("You must wrap your component in a <StableCollection>"); let n = S.useId(), [r, i] = e.current.get(t, n); return S.useEffect(() => i, []), r } var mst = (t => (t[t.Forwards = 0] = "Forwards", t[t.Backwards = 1] = "Backwards", t))(mst || {}), gst = (t => (t[t.Less = -1] = "Less", t[t.Equal = 0] = "Equal", t[t.Greater = 1] = "Greater", t))(gst || {}), vst = (t => (t[t.SetSelectedIndex = 0] = "SetSelectedIndex", t[t.RegisterTab = 1] = "RegisterTab", t[t.UnregisterTab = 2] = "UnregisterTab", t[t.RegisterPanel = 3] = "RegisterPanel", t[t.UnregisterPanel = 4] = "UnregisterPanel", t))(vst || {}); let yst = { 0(t, e) { var n; let r = zh(t.tabs, d => d.current), i = zh(t.panels, d => d.current), a = r.filter(d => { var f; return !((f = d.current) != null && f.hasAttribute("disabled")) }), s = { ...t, tabs: r, panels: i }; if (e.index < 0 || e.index > r.length - 1) { let d = Er(Math.sign(e.index - t.selectedIndex), { [-1]: () => 1, 0: () => Er(Math.sign(e.index), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }); if (a.length === 0) return s; let f = Er(d, { 0: () => r.indexOf(a[0]), 1: () => r.indexOf(a[a.length - 1]) }); return { ...s, selectedIndex: f === -1 ? t.selectedIndex : f } } let o = r.slice(0, e.index), c = [...r.slice(e.index), ...o].find(d => a.includes(d)); if (!c) return s; let u = (n = r.indexOf(c)) != null ? n : t.selectedIndex; return u === -1 && (u = t.selectedIndex), { ...s, selectedIndex: u } }, 1(t, e) { if (t.tabs.includes(e.tab)) return t; let n = t.tabs[t.selectedIndex], r = zh([...t.tabs, e.tab], a => a.current), i = t.selectedIndex; return t.info.current.isControlled || (i = r.indexOf(n), i === -1 && (i = t.selectedIndex)), { ...t, tabs: r, selectedIndex: i } }, 2(t, e) { return { ...t, tabs: t.tabs.filter(n => n !== e.tab) } }, 3(t, e) { return t.panels.includes(e.panel) ? t : { ...t, panels: zh([...t.panels, e.panel], n => n.current) } }, 4(t, e) { return { ...t, panels: t.panels.filter(n => n !== e.panel) } } }, g6 = S.createContext(null); g6.displayName = "TabsDataContext"; function c0(t) { let e = S.useContext(g6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Tab.Group /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, c0), n } return e } let v6 = S.createContext(null); v6.displayName = "TabsActionsContext"; function y6(t) { let e = S.useContext(v6); if (e === null) { let n = new Error(`<${t} /> is missing a parent <Tab.Group /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(n, y6), n } return e } function xst(t, e) { return Er(e.type, yst, t, e) } let bst = "div"; function wst(t, e) { let { defaultIndex: n = 0, vertical: r = !1, manual: i = !1, onChange: a, selectedIndex: s = null, ...o } = t; const c = r ? "vertical" : "horizontal", u = i ? "manual" : "auto"; let d = s !== null, f = no({ isControlled: d }), h = Mr(e), [m, g] = S.useReducer(xst, { info: f, selectedIndex: s ?? n, tabs: [], panels: [] }), x = S.useMemo(() => ({ selectedIndex: m.selectedIndex }), [m.selectedIndex]), v = no(a || (() => { })), b = no(m.tabs), E = S.useMemo(() => ({ orientation: c, activation: u, ...m }), [c, u, m]), M = ct(D => (g({ type: 1, tab: D }), () => g({ type: 2, tab: D }))), C = ct(D => (g({ type: 3, panel: D }), () => g({ type: 4, panel: D }))), N = ct(D => { A.current !== D && v.current(D), d || g({ type: 0, index: D }) }), A = no(d ? t.selectedIndex : m.selectedIndex), j = S.useMemo(() => ({ registerTab: M, registerPanel: C, change: N }), []); fr(() => { g({ type: 0, index: s ?? n }) }, [s]), fr(() => { if (A.current === void 0 || m.tabs.length <= 0) return; let D = zh(m.tabs, F => F.current); D.some((F, B) => m.tabs[B] !== F) && N(D.indexOf(m.tabs[A.current])) }); let O = { ref: h }, I = mr(); return P.createElement(pst, null, P.createElement(v6.Provider, { value: j }, P.createElement(g6.Provider, { value: E }, E.tabs.length <= 0 && P.createElement(fst, { onFocus: () => { var D, F; for (let B of b.current) if (((D = B.current) == null ? void 0 : D.tabIndex) === 0) return (F = B.current) == null || F.focus(), !0; return !1 } }), I({ ourProps: O, theirProps: o, slot: x, defaultTag: bst, name: "Tabs" })))) } let Sst = "div"; function _st(t, e) { let { orientation: n, selectedIndex: r } = c0("Tab.List"), i = Mr(e), a = S.useMemo(() => ({ selectedIndex: r }), [r]), s = t, o = { ref: i, role: "tablist", "aria-orientation": n }; return mr()({ ourProps: o, theirProps: s, slot: a, defaultTag: Sst, name: "Tabs.List" }) } let Est = "button"; function Mst(t, e) { var n, r; let i = S.useId(), { id: a = `headlessui-tabs-tab-${i}`, disabled: s = !1, autoFocus: o = !1, ...c } = t, { orientation: u, activation: d, selectedIndex: f, tabs: h, panels: m } = c0("Tab"), g = y6("Tab"), x = c0("Tab"), [v, b] = S.useState(null), E = S.useRef(null), M = Mr(E, e, b); fr(() => g.registerTab(E), [g, E]); let C = rme("tabs"), N = h.indexOf(E); N === -1 && (N = C); let A = N === f, j = ct(K => { var X; let Q = K(); if (Q === Tu.Success && d === "auto") { let re = (X = rd(E)) == null ? void 0 : X.activeElement, ce = x.tabs.findIndex(be => be.current === re); ce !== -1 && g.change(ce) } return Q }), O = ct(K => { let X = h.map(Q => Q.current).filter(Boolean); if (K.key === Sn.Space || K.key === Sn.Enter) { K.preventDefault(), K.stopPropagation(), g.change(N); return } switch (K.key) { case Sn.Home: case Sn.PageUp: return K.preventDefault(), K.stopPropagation(), j(() => Ra(X, qr.First)); case Sn.End: case Sn.PageDown: return K.preventDefault(), K.stopPropagation(), j(() => Ra(X, qr.Last)) }if (j(() => Er(u, { vertical() { return K.key === Sn.ArrowUp ? Ra(X, qr.Previous | qr.WrapAround) : K.key === Sn.ArrowDown ? Ra(X, qr.Next | qr.WrapAround) : Tu.Error }, horizontal() { return K.key === Sn.ArrowLeft ? Ra(X, qr.Previous | qr.WrapAround) : K.key === Sn.ArrowRight ? Ra(X, qr.Next | qr.WrapAround) : Tu.Error } })) === Tu.Success) return K.preventDefault() }), I = S.useRef(!1), D = ct(() => { var K; I.current || (I.current = !0, (K = E.current) == null || K.focus({ preventScroll: !0 }), g.change(N), O_(() => { I.current = !1 })) }), F = ct(K => { K.preventDefault() }), { isFocusVisible: B, focusProps: G } = jp({ autoFocus: o }), { isHovered: z, hoverProps: q } = Jg({ isDisabled: s }), { pressed: Y, pressProps: Z } = H0({ disabled: s }), $ = S.useMemo(() => ({ selected: A, hover: z, active: Y, focus: B, autofocus: o, disabled: s }), [A, z, B, Y, o, s]), V = vl({ ref: M, onKeyDown: O, onMouseDown: F, onClick: D, id: a, role: "tab", type: X0(t, v), "aria-controls": (r = (n = m[N]) == null ? void 0 : n.current) == null ? void 0 : r.id, "aria-selected": A, tabIndex: A ? 0 : -1, disabled: s || void 0, autoFocus: o }, G, q, Z); return mr()({ ourProps: V, theirProps: c, slot: $, defaultTag: Est, name: "Tabs.Tab" }) } let Tst = "div"; function Cst(t, e) { let { selectedIndex: n } = c0("Tab.Panels"), r = Mr(e), i = S.useMemo(() => ({ selectedIndex: n }), [n]), a = t, s = { ref: r }; return mr()({ ourProps: s, theirProps: a, slot: i, defaultTag: Tst, name: "Tabs.Panels" }) } let Nst = "div", Ast = js.RenderStrategy | js.Static; function Pst(t, e) { var n, r, i, a; let s = S.useId(), { id: o = `headlessui-tabs-panel-${s}`, tabIndex: c = 0, ...u } = t, { selectedIndex: d, tabs: f, panels: h } = c0("Tab.Panel"), m = y6("Tab.Panel"), g = S.useRef(null), x = Mr(g, e); fr(() => m.registerPanel(g), [m, g]); let v = rme("panels"), b = h.indexOf(g); b === -1 && (b = v); let E = b === d, { isFocusVisible: M, focusProps: C } = jp(), N = S.useMemo(() => ({ selected: E, focus: M }), [E, M]), A = vl({ ref: x, id: o, role: "tabpanel", "aria-labelledby": (r = (n = f[b]) == null ? void 0 : n.current) == null ? void 0 : r.id, tabIndex: E ? c : -1 }, C), j = mr(); return !E && ((i = u.unmount) == null || i) && !((a = u.static) != null && a) ? P.createElement(Xu, { "aria-hidden": "true", ...A }) : j({ ourProps: A, theirProps: u, slot: N, defaultTag: Nst, features: Ast, visible: E, name: "Tabs.Panel" }) } let jst = dr(Mst), Rst = dr(wst), kst = dr(_st), Ist = dr(Cst), Ost = dr(Pst), UP = Object.assign(jst, { Group: Rst, List: kst, Panels: Ist, Panel: Ost }); const ime = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({}, e, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor" }), P.createElement("path", { fillRule: "evenodd", d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z", clipRule: "evenodd" })) }, z_ = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 10.5858L9.17157 7.75736L7.75736 9.17157L10.5858 12L7.75736 14.8284L9.17157 16.2426L12 13.4142L14.8284 16.2426L16.2426 14.8284L13.4142 12L16.2426 9.17157L14.8284 7.75736L12 10.5858Z" })) }, zQ = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M10.8284 12.0007L15.7782 16.9504L14.364 18.3646L8 12.0007L14.364 5.63672L15.7782 7.05093L10.8284 12.0007Z" })) }, VQ = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M13.1717 12.0007L8.22192 7.05093L9.63614 5.63672L16.0001 12.0007L9.63614 18.3646L8.22192 16.9504L13.1717 12.0007Z" })) }, Dst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M4.83582 12L11.0429 18.2071L12.4571 16.7929L7.66424 12L12.4571 7.20712L11.0429 5.79291L4.83582 12ZM10.4857 12L16.6928 18.2071L18.107 16.7929L13.3141 12L18.107 7.20712L16.6928 5.79291L10.4857 12Z" })) }, Lst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M19.1642 12L12.9571 5.79291L11.5429 7.20712L16.3358 12L11.5429 16.7929L12.9571 18.2071L19.1642 12ZM13.5143 12L7.30722 5.79291L5.89301 7.20712L10.6859 12L5.89301 16.7929L7.30722 18.2071L13.5143 12Z" })) }, ame = P.forwardRef(((t, e) => { const { color: n, className: r, children: i } = t; return P.createElement("p", { ref: e, className: me("text-tremor-default", n ? jt(n, Dt.text).textColor : me("text-tremor-content", "dark:text-dark-tremor-content"), r) }, i) })); ame.displayName = "Text"; const pT = t => { var { onClick: e, icon: n } = t, r = Et(t, ["onClick", "icon"]); const i = n; return P.createElement("button", Object.assign({ type: "button", className: me("flex items-center justify-center p-1 h-7 w-7 outline-none focus:ring-2 transition duration-100 border border-tremor-border dark:border-dark-tremor-border hover:bg-tremor-background-muted dark:hover:bg-dark-tremor-background-muted rounded-tremor-small focus:border-tremor-brand-subtle select-none dark:focus:border-dark-tremor-brand-subtle focus:ring-tremor-brand-muted dark:focus:ring-dark-tremor-brand-muted text-tremor-content-subtle dark:text-dark-tremor-content-subtle hover:text-tremor-content dark:hover:text-dark-tremor-content") }, r), P.createElement(qhe, { onClick: e, icon: i, variant: "simple", color: "slate", size: "sm" })) }; function x6(t) { var { mode: e, defaultMonth: n, selected: r, onSelect: i, locale: a, disabled: s, enableYearNavigation: o, classNames: c, weekStartsOn: u = 0 } = t, d = Et(t, ["mode", "defaultMonth", "selected", "onSelect", "locale", "disabled", "enableYearNavigation", "classNames", "weekStartsOn"]); return P.createElement(cue, Object.assign({ showOutsideDays: !0, mode: e, defaultMonth: n, selected: r, onSelect: i, locale: a, disabled: s, weekStartsOn: u, classNames: Object.assign({ months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0", month: "space-y-4", caption: "flex justify-center pt-2 relative items-center", caption_label: "text-tremor-default text-tremor-content-emphasis dark:text-dark-tremor-content-emphasis font-medium", nav: "space-x-1 flex items-center", nav_button: "flex items-center justify-center p-1 h-7 w-7 outline-none focus:ring-2 transition duration-100 border border-tremor-border dark:border-dark-tremor-border hover:bg-tremor-background-muted dark:hover:bg-dark-tremor-background-muted rounded-tremor-small focus:border-tremor-brand-subtle dark:focus:border-dark-tremor-brand-subtle focus:ring-tremor-brand-muted dark:focus:ring-dark-tremor-brand-muted text-tremor-content-subtle dark:text-dark-tremor-content-subtle hover:text-tremor-content dark:hover:text-dark-tremor-content", nav_button_previous: "absolute left-1", nav_button_next: "absolute right-1", table: "w-full border-collapse space-y-1", head_row: "flex", head_cell: "w-9 font-normal text-center text-tremor-content-subtle dark:text-dark-tremor-content-subtle", row: "flex w-full mt-0.5", cell: "text-center p-0 relative focus-within:relative text-tremor-default text-tremor-content-emphasis dark:text-dark-tremor-content-emphasis", day: "h-9 w-9 p-0 hover:bg-tremor-background-subtle dark:hover:bg-dark-tremor-background-subtle outline-tremor-brand dark:outline-dark-tremor-brand rounded-tremor-default", day_today: "font-bold", day_selected: "aria-selected:bg-tremor-background-emphasis aria-selected:text-tremor-content-inverted dark:aria-selected:bg-dark-tremor-background-emphasis dark:aria-selected:text-dark-tremor-content-inverted ", day_disabled: "text-tremor-content-subtle dark:text-dark-tremor-content-subtle disabled:hover:bg-transparent", day_outside: "text-tremor-content-subtle dark:text-dark-tremor-content-subtle" }, c), components: { IconLeft: f => { var h = Et(f, []); return P.createElement(zQ, Object.assign({ className: "h-4 w-4" }, h)) }, IconRight: f => { var h = Et(f, []); return P.createElement(VQ, Object.assign({ className: "h-4 w-4" }, h)) }, Caption: f => { var h = Et(f, []); const { goToMonth: m, nextMonth: g, previousMonth: x, currentMonth: v } = I0(); return P.createElement("div", { className: "flex justify-between items-center" }, P.createElement("div", { className: "flex items-center space-x-1" }, o && P.createElement(pT, { onClick: () => v && m(m4(v, -1)), icon: Dst }), P.createElement(pT, { onClick: () => x && m(x), icon: zQ })), P.createElement(ame, { className: "text-tremor-default tabular-nums capitalize text-tremor-content-emphasis dark:text-dark-tremor-content-emphasis font-medium" }, xr(h.displayMonth, "LLLL yyy", { locale: a })), P.createElement("div", { className: "flex items-center space-x-1" }, P.createElement(pT, { onClick: () => g && m(g), icon: VQ }), o && P.createElement(pT, { onClick: () => v && m(m4(v, 1)), icon: Lst }))) } } }, d)) } x6.displayName = "DateRangePicker"; const Fst = Pn("DatePicker"), up = (t, e) => { const n = e !== void 0, [r, i] = S.useState(t); return [n ? e : r, a => { n || i(a) }] }, HQ = Pn("DateRangePicker"), Ust = (t, e, n, r) => { var i; if (n && (t = (i = r.get(n)) === null || i === void 0 ? void 0 : i.from), t) return vi(t && !e ? t : Wce([t, e])) }, Bst = (t, e, n, r) => { var i, a; if (n && (t = vi((a = (i = r.get(n)) === null || i === void 0 ? void 0 : i.to) !== null && a !== void 0 ? a : Rh())), t) return vi(t && !e ? t : Gce([t, e])) }, D3 = [{ value: "tdy", text: "Today", from: Rh() }, { value: "w", text: "Last 7 days", from: G7(Rh(), { days: 7 }) }, { value: "t", text: "Last 30 days", from: G7(Rh(), { days: 30 }) }, { value: "m", text: "Month to Date", from: ds(Rh()) }, { value: "y", text: "Year to Date", from: u$(Rh()) }], sme = (t, e, n, r) => {
	const i = n?.code || "en-US"; if (!t && !e) return ""; if (t && !e) { if (r) return xr(t, r); const a = { year: "numeric", month: "short", day: "numeric" }; return t.toLocaleDateString(i, a) } if (t && e) {
		if (i5e(t, e)) { if (r) return xr(t, r); const a = { year: "numeric", month: "short", day: "numeric" }; return t.toLocaleDateString(i, a) } if (t.getMonth() === e.getMonth() && t.getFullYear() === e.getFullYear()) {
			if (r) return `${xr(t, r)} - ${xr(e, r)}`; const a = { month: "short", day: "numeric" }; return `${t.toLocaleDateString(i, a)} - 
                    ${e.getDate()}, ${e.getFullYear()}`
		} {
			if (r) return `${xr(t, r)} - ${xr(e, r)}`; const a = { year: "numeric", month: "short", day: "numeric" }; return `${t.toLocaleDateString(i, a)} - 
                    ${e.toLocaleDateString(i, a)}`
		}
	} return ""
}, kS = t => ["string", "number"].includes(typeof t) ? t : t instanceof Array ? t.map(kS).join("") : typeof t == "object" && t ? kS(t.props.children) : void 0; function b6(t) { const e = new Map; return P.Children.map(t, (n => { var r; e.set(n.props.value, (r = kS(n)) !== null && r !== void 0 ? r : n.props.value) })), e } function t5(t, e) { return P.Children.map(e, (n => { var r; if (((r = kS(n)) !== null && r !== void 0 ? r : n.props.value).toLowerCase().includes(t.toLowerCase())) return n })) } const dp = (t, e, n = !1) => me(e ? "bg-tremor-background-subtle dark:bg-dark-tremor-background-subtle" : "bg-tremor-background dark:bg-dark-tremor-background", !e && "hover:bg-tremor-background-muted dark:hover:bg-dark-tremor-background-muted", t ? "text-tremor-content-emphasis dark:text-dark-tremor-content-emphasis" : "text-tremor-content dark:text-dark-tremor-content", e && "text-tremor-content-subtle dark:text-dark-tremor-content-subtle", n && "text-red-500 placeholder:text-red-500 dark:text-red-500 dark:placeholder:text-red-500", n ? "border-red-500 dark:border-red-500" : "border-tremor-border dark:border-dark-tremor-border"); function Lg(t) { return t != null && t !== "" } const $st = Rh(), zst = P.forwardRef(((t, e) => { var n; const { value: r, defaultValue: i, onValueChange: a, minDate: s, maxDate: o, placeholder: c = "Select date", disabled: u = !1, locale: d = b_, enableClear: f = !0, displayFormat: h, className: m, enableYearNavigation: g = !1, weekStartsOn: x = 0, disabledDates: v } = t, b = Et(t, ["value", "defaultValue", "onValueChange", "minDate", "maxDate", "placeholder", "disabled", "locale", "enableClear", "displayFormat", "className", "enableYearNavigation", "weekStartsOn", "disabledDates"]), [E, M] = up(i, r), C = S.useMemo((() => { const O = []; return s && O.push({ before: s }), o && O.push({ after: o }), [...O, ...v ?? []] }), [s, o, v]), N = E ? sme(E, void 0, d, h) : c, A = ds((n = E ?? o) !== null && n !== void 0 ? n : $st), j = f && !u; return P.createElement(tme, Object.assign({ ref: e, as: "div", className: me("relative w-full min-w-[10rem] text-tremor-default", "focus:ring-2 focus:ring-tremor-brand-muted dark:focus:ring-dark-tremor-brand-muted", m) }, b), P.createElement(h6, { disabled: u, className: me("w-full outline-none text-left whitespace-nowrap truncate focus:ring-2 transition duration-100 rounded-tremor-default flex flex-nowrap border pl-3 py-2", "border-tremor-border shadow-tremor-input text-tremor-content-emphasis focus:border-tremor-brand-subtle focus:ring-tremor-brand-muted", "dark:border-dark-tremor-border dark:shadow-dark-tremor-input dark:text-dark-tremor-content-emphasis dark:focus:border-dark-tremor-brand-subtle dark:focus:ring-dark-tremor-brand-muted", j ? "pr-8" : "pr-4", dp(Lg(E), u)) }, P.createElement(ime, { className: me(Fst("calendarIcon"), "flex-none shrink-0 h-5 w-5 mr-2 -ml-0.5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle"), "aria-hidden": "true" }), P.createElement("p", { className: "truncate" }, N)), j && E ? P.createElement("button", { type: "button", className: me("absolute outline-none inset-y-0 right-0 flex items-center transition duration-100 mr-4"), onClick: O => { O.preventDefault(), a?.(void 0), M(void 0) } }, P.createElement(z_, { className: me("flex-none h-4 w-4", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })) : null, P.createElement(cp, { enter: "transition ease duration-100 transform", enterFrom: "opacity-0 -translate-y-4", enterTo: "opacity-100 translate-y-0", leave: "transition ease duration-100 transform", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 -translate-y-4" }, P.createElement(p6, { anchor: "bottom start", className: me("z-10 min-w-min divide-y overflow-y-auto outline-none rounded-tremor-default p-3 border [--anchor-gap:4px]", "bg-tremor-background border-tremor-border divide-tremor-border shadow-tremor-dropdown", "dark:bg-dark-tremor-background dark:border-dark-tremor-border dark:divide-dark-tremor-border dark:shadow-dark-tremor-dropdown") }, (({ close: O }) => P.createElement(x6, { showOutsideDays: !0, mode: "single", defaultMonth: A, selected: E, weekStartsOn: x, onSelect: I => { a?.(I), M(I), O() }, locale: d, disabled: C, enableYearNavigation: g }))))) })); zst.displayName = "DatePicker"; const w6 = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M11.9999 13.1714L16.9497 8.22168L18.3639 9.63589L11.9999 15.9999L5.63599 9.63589L7.0502 8.22168L11.9999 13.1714Z" })) }, L3 = Pn("Select"), Vst = P.forwardRef(((t, e) => { const { defaultValue: n = "", value: r, onValueChange: i, placeholder: a = "Select...", disabled: s = !1, icon: o, enableClear: c = !1, required: u, children: d, name: f, error: h = !1, errorMessage: m, className: g, id: x } = t, v = Et(t, ["defaultValue", "value", "onValueChange", "placeholder", "disabled", "icon", "enableClear", "required", "children", "name", "error", "errorMessage", "className", "id"]), b = S.useRef(null), E = S.Children.toArray(d), [M, C] = up(n, r), N = o, A = S.useMemo((() => { const j = P.Children.toArray(d).filter(S.isValidElement); return b6(j) }), [d]); return P.createElement("div", { className: me("w-full min-w-[10rem] text-tremor-default", g) }, P.createElement("div", { className: "relative" }, P.createElement("select", { title: "select-hidden", required: u, className: me("h-full w-full absolute left-0 top-0 -z-10 opacity-0"), value: M, onChange: j => { j.preventDefault() }, name: f, disabled: s, id: x, onFocus: () => { const j = b.current; j && j.focus() } }, P.createElement("option", { className: "hidden", value: "", disabled: !0, hidden: !0 }, a), E.map((j => { const O = j.props.value, I = j.props.children; return P.createElement("option", { className: "hidden", key: O, value: O }, I) }))), P.createElement(c6, Object.assign({ as: "div", ref: e, defaultValue: M, value: M, onChange: j => { i?.(j), C(j) }, disabled: s, id: x }, v), (({ value: j }) => { var O; return P.createElement(P.Fragment, null, P.createElement(IP, { ref: b, className: me("w-full outline-none text-left whitespace-nowrap truncate rounded-tremor-default focus:ring-2 transition duration-100 border pr-8 py-2", "border-tremor-border shadow-tremor-input focus:border-tremor-brand-subtle focus:ring-tremor-brand-muted", "dark:border-dark-tremor-border dark:shadow-dark-tremor-input dark:focus:border-dark-tremor-brand-subtle dark:focus:ring-dark-tremor-brand-muted", N ? "pl-10" : "pl-3", dp(Lg(j), s, h)) }, N && P.createElement("span", { className: me("absolute inset-y-0 left-0 flex items-center ml-px pl-2.5") }, P.createElement(N, { className: me(L3("Icon"), "flex-none h-5 w-5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })), P.createElement("span", { className: "w-[90%] block truncate" }, j && (O = A.get(j)) !== null && O !== void 0 ? O : a), P.createElement("span", { className: me("absolute inset-y-0 right-0 flex items-center mr-3") }, P.createElement(w6, { className: me(L3("arrowDownIcon"), "flex-none h-5 w-5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") }))), c && M ? P.createElement("button", { type: "button", className: me("absolute inset-y-0 right-0 flex items-center mr-8"), onClick: I => { I.preventDefault(), C(""), i?.("") } }, P.createElement(z_, { className: me(L3("clearIcon"), "flex-none h-4 w-4", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })) : null, P.createElement(cp, { enter: "transition ease duration-100 transform", enterFrom: "opacity-0 -translate-y-4", enterTo: "opacity-100 translate-y-0", leave: "transition ease duration-100 transform", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 -translate-y-4" }, P.createElement(OP, { anchor: "bottom start", className: me("z-10 w-[var(--button-width)] divide-y overflow-y-auto outline-none rounded-tremor-default max-h-[228px]  border [--anchor-gap:4px]", "bg-tremor-background border-tremor-border divide-tremor-border shadow-tremor-dropdown", "dark:bg-dark-tremor-background dark:border-dark-tremor-border dark:divide-dark-tremor-border dark:shadow-dark-tremor-dropdown") }, d))) }))), h && m ? P.createElement("p", { className: me("errorMessage", "text-sm text-rose-500 mt-1") }, m) : null) })); Vst.displayName = "Select"; const WQ = Pn("SelectItem"), S6 = P.forwardRef(((t, e) => { const { value: n, icon: r, className: i, children: a } = t, s = Et(t, ["value", "icon", "className", "children"]), o = r; return P.createElement(l6, Object.assign({ className: me(WQ("root"), "flex justify-start items-center cursor-default text-tremor-default px-2.5 py-2.5", "data-[focus]:bg-tremor-background-muted  data-[focus]:text-tremor-content-strong data-[selected]:text-tremor-content-strong data-[selected]:bg-tremor-background-muted text-tremor-content-emphasis", "dark:data-[focus]:bg-dark-tremor-background-muted  dark:data-[focus]:text-dark-tremor-content-strong dark:data-[selected]:text-dark-tremor-content-strong dark:data-[selected]:bg-dark-tremor-background-muted dark:text-dark-tremor-content-emphasis", i), ref: e, key: n, value: n }, s), o && P.createElement(o, { className: me(WQ("icon"), "flex-none w-5 h-5 mr-1.5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") }), P.createElement("span", { className: "whitespace-nowrap truncate" }, a ?? n)) })); S6.displayName = "SelectItem"; const F3 = Rh(), Hst = P.forwardRef(((t, e) => { var n, r; const { value: i, defaultValue: a, onValueChange: s, enableSelect: o = !0, minDate: c, maxDate: u, placeholder: d = "Select range", selectPlaceholder: f = "Select range", disabled: h = !1, locale: m = b_, enableClear: g = !0, displayFormat: x, children: v, className: b, enableYearNavigation: E = !1, weekStartsOn: M = 0, disabledDates: C } = t, N = Et(t, ["value", "defaultValue", "onValueChange", "enableSelect", "minDate", "maxDate", "placeholder", "selectPlaceholder", "disabled", "locale", "enableClear", "displayFormat", "children", "className", "enableYearNavigation", "weekStartsOn", "disabledDates"]), [A, j] = up(a, i), [O, I] = S.useState(!1), [D, F] = S.useState(!1), B = S.useMemo((() => { const X = []; return c && X.push({ before: c }), u && X.push({ after: u }), [...X, ...C ?? []] }), [c, u, C]), G = S.useMemo((() => { const X = new Map; return v ? P.Children.forEach(v, (Q => { var re; X.set(Q.props.value, { text: (re = kS(Q)) !== null && re !== void 0 ? re : Q.props.value, from: Q.props.from, to: Q.props.to }) })) : D3.forEach((Q => { X.set(Q.value, { text: Q.text, from: Q.from, to: F3 }) })), X }), [v]), z = S.useMemo((() => { if (v) return b6(v); const X = new Map; return D3.forEach((Q => X.set(Q.value, Q.text))), X }), [v]), q = A?.selectValue || "", Y = Ust(A?.from, c, q, G), Z = Bst(A?.to, u, q, G), $ = Y || Z ? sme(Y, Z, m, x) : d, V = ds((r = (n = Z ?? Y) !== null && n !== void 0 ? n : u) !== null && r !== void 0 ? r : F3), K = g && !h; return P.createElement("div", Object.assign({ ref: e, className: me("w-full min-w-[10rem] relative flex justify-between text-tremor-default max-w-sm shadow-tremor-input dark:shadow-dark-tremor-input rounded-tremor-default", b) }, N), P.createElement(tme, { as: "div", className: me("w-full", o ? "rounded-l-tremor-default" : "rounded-tremor-default", O && "ring-2 ring-tremor-brand-muted dark:ring-dark-tremor-brand-muted z-10") }, P.createElement("div", { className: "relative w-full" }, P.createElement(h6, { onFocus: () => I(!0), onBlur: () => I(!1), disabled: h, className: me("w-full outline-none text-left whitespace-nowrap truncate focus:ring-2 transition duration-100 rounded-l-tremor-default flex flex-nowrap border pl-3 py-2", "rounded-l-tremor-default border-tremor-border text-tremor-content-emphasis focus:border-tremor-brand-subtle focus:ring-tremor-brand-muted", "dark:border-dark-tremor-border dark:text-dark-tremor-content-emphasis dark:focus:border-dark-tremor-brand-subtle dark:focus:ring-dark-tremor-brand-muted", o ? "rounded-l-tremor-default" : "rounded-tremor-default", K ? "pr-8" : "pr-4", dp(Lg(Y || Z), h)) }, P.createElement(ime, { className: me(HQ("calendarIcon"), "flex-none shrink-0 h-5 w-5 -ml-0.5 mr-2", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle"), "aria-hidden": "true" }), P.createElement("p", { className: "truncate" }, $)), K && Y ? P.createElement("button", { type: "button", className: me("absolute outline-none inset-y-0 right-0 flex items-center transition duration-100 mr-4"), onClick: X => { X.preventDefault(), s?.({}), j({}) } }, P.createElement(z_, { className: me(HQ("clearIcon"), "flex-none h-4 w-4", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })) : null), P.createElement(cp, { enter: "transition ease duration-100 transform", enterFrom: "opacity-0 -translate-y-4", enterTo: "opacity-100 translate-y-0", leave: "transition ease duration-100 transform", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 -translate-y-4" }, P.createElement(p6, { anchor: "bottom start", focus: !0, className: me("min-w-min divide-y overflow-y-auto outline-none rounded-tremor-default p-3 border [--anchor-gap:4px]", "bg-tremor-background border-tremor-border divide-tremor-border shadow-tremor-dropdown", "dark:bg-dark-tremor-background dark:border-dark-tremor-border dark:divide-dark-tremor-border dark:shadow-dark-tremor-dropdown") }, P.createElement(x6, Object.assign({ mode: "range", showOutsideDays: !0, defaultMonth: V, selected: { from: Y, to: Z }, onSelect: X => { s?.({ from: X?.from, to: X?.to }), j({ from: X?.from, to: X?.to }) }, locale: m, disabled: B, enableYearNavigation: E, classNames: { day_range_middle: me("!rounded-none aria-selected:!bg-tremor-background-subtle aria-selected:dark:!bg-dark-tremor-background-subtle aria-selected:!text-tremor-content aria-selected:dark:!bg-dark-tremor-background-subtle"), day_range_start: "rounded-r-none rounded-l-tremor-small aria-selected:text-tremor-brand-inverted dark:aria-selected:text-dark-tremor-brand-inverted", day_range_end: "rounded-l-none rounded-r-tremor-small aria-selected:text-tremor-brand-inverted dark:aria-selected:text-dark-tremor-brand-inverted" }, weekStartsOn: M }, t))))), o && P.createElement(c6, { as: "div", className: me("w-48 -ml-px rounded-r-tremor-default", D && "ring-2 ring-tremor-brand-muted dark:ring-dark-tremor-brand-muted z-10"), value: q, onChange: X => { const { from: Q, to: re } = G.get(X), ce = re ?? F3; s?.({ from: Q, to: ce, selectValue: X }), j({ from: Q, to: ce, selectValue: X }) }, disabled: h }, (({ value: X }) => { var Q; return P.createElement(P.Fragment, null, P.createElement(IP, { onFocus: () => F(!0), onBlur: () => F(!1), className: me("w-full outline-none text-left whitespace-nowrap truncate rounded-r-tremor-default transition duration-100 border px-4 py-2", "border-tremor-border text-tremor-content-emphasis focus:border-tremor-brand-subtle", "dark:border-dark-tremor-border  dark:text-dark-tremor-content-emphasis dark:focus:border-dark-tremor-brand-subtle", dp(Lg(X), h)) }, X && (Q = z.get(X)) !== null && Q !== void 0 ? Q : f), P.createElement(cp, { enter: "transition ease duration-100 transform", enterFrom: "opacity-0 -translate-y-4", enterTo: "opacity-100 translate-y-0", leave: "transition ease duration-100 transform", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 -translate-y-4" }, P.createElement(OP, { anchor: "bottom end", className: me("[--anchor-gap:4px] divide-y overflow-y-auto outline-none border min-w-44", "shadow-tremor-dropdown bg-tremor-background border-tremor-border divide-tremor-border rounded-tremor-default", "dark:shadow-dark-tremor-dropdown dark:bg-dark-tremor-background dark:border-dark-tremor-border dark:divide-dark-tremor-border") }, v ?? D3.map((re => P.createElement(S6, { key: re.value, value: re.value }, re.text)))))) }))) })); Hst.displayName = "DateRangePicker"; const Wst = P.forwardRef(((t, e) => { const { value: n, className: r, children: i } = t, a = Et(t, ["value", "className", "children"]); return P.createElement(S6, Object.assign({ ref: e, className: r, value: n }, a), i ?? n) })); Wst.displayName = "DateRangePickerItem"; const ome = S.createContext(Gt.Blue), lme = S.createContext(0), p1 = S.createContext(void 0), BP = S.createContext({ selectedValue: void 0, handleValueChange: void 0 }), Gst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M18.031 16.6168L22.3137 20.8995L20.8995 22.3137L16.6168 18.031C15.0769 19.263 13.124 20 11 20C6.032 20 2 15.968 2 11C2 6.032 6.032 2 11 2C15.968 2 20 6.032 20 11C20 13.124 19.263 15.0769 18.031 16.6168ZM16.0247 15.8748C17.2475 14.6146 18 12.8956 18 11C18 7.1325 14.8675 4 11 4C7.1325 4 4 7.1325 4 11C4 14.8675 7.1325 18 11 18C12.8956 18 14.6146 17.2475 15.8748 16.0247L16.0247 15.8748Z" })) }, qst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, e), P.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), P.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })) }, mT = Pn("MultiSelect"), Xst = P.forwardRef(((t, e) => { const { defaultValue: n = [], value: r, onValueChange: i, placeholder: a = "Select...", placeholderSearch: s = "Search", disabled: o = !1, icon: c, children: u, className: d, required: f, name: h, error: m = !1, errorMessage: g, id: x } = t, v = Et(t, ["defaultValue", "value", "onValueChange", "placeholder", "placeholderSearch", "disabled", "icon", "children", "className", "required", "name", "error", "errorMessage", "id"]), b = S.useRef(null), E = c, [M, C] = up(n, r), { reactElementChildren: N, optionsAvailable: A } = S.useMemo((() => { const B = P.Children.toArray(u).filter(S.isValidElement); return { reactElementChildren: B, optionsAvailable: t5("", B) } }), [u]), [j, O] = S.useState(""), I = (M ?? []).length > 0, D = S.useMemo((() => j ? t5(j, N) : A), [j, N, A]), F = () => { O("") }; return P.createElement("div", { className: me("w-full min-w-[10rem] text-tremor-default", d) }, P.createElement("div", { className: "relative" }, P.createElement("select", { title: "multi-select-hidden", required: f, className: me("h-full w-full absolute left-0 top-0 -z-10 opacity-0"), value: M, onChange: B => { B.preventDefault() }, name: h, disabled: o, multiple: !0, id: x, onFocus: () => { const B = b.current; B && B.focus() } }, P.createElement("option", { className: "hidden", value: "", disabled: !0, hidden: !0 }, a), D.map((B => { const G = B.props.value, z = B.props.children; return P.createElement("option", { className: "hidden", key: G, value: G }, z) }))), P.createElement(c6, Object.assign({ as: "div", ref: e, defaultValue: M, value: M, onChange: B => { i?.(B), C(B) }, disabled: o, id: x, multiple: !0 }, v), (({ value: B }) => P.createElement(P.Fragment, null, P.createElement(IP, { className: me("w-full outline-none text-left whitespace-nowrap truncate rounded-tremor-default focus:ring-2 transition duration-100 border pr-8 py-1.5", "border-tremor-border shadow-tremor-input focus:border-tremor-brand-subtle focus:ring-tremor-brand-muted", "dark:border-dark-tremor-border dark:shadow-dark-tremor-input dark:focus:border-dark-tremor-brand-subtle dark:focus:ring-dark-tremor-brand-muted", E ? "pl-11 -ml-0.5" : "pl-3", dp(B.length > 0, o, m)), ref: b }, E && P.createElement("span", { className: me("absolute inset-y-0 left-0 flex items-center ml-px pl-2.5") }, P.createElement(E, { className: me(mT("Icon"), "flex-none h-5 w-5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })), P.createElement("div", { className: "h-6 flex items-center" }, B.length > 0 ? P.createElement("div", { className: "flex flex-nowrap overflow-x-scroll [&::-webkit-scrollbar]:hidden [scrollbar-width:none] gap-x-1 mr-5 -ml-1.5 relative" }, A.filter((G => B.includes(G.props.value))).map(((G, z) => { var q; return P.createElement("div", { key: z, className: me("max-w-[100px] lg:max-w-[200px] flex justify-center items-center pl-2 pr-1.5 py-1 font-medium", "rounded-tremor-small", "bg-tremor-background-muted dark:bg-dark-tremor-background-muted", "bg-tremor-background-subtle dark:bg-dark-tremor-background-subtle", "text-tremor-content-default dark:text-dark-tremor-content-default", "text-tremor-content-emphasis dark:text-dark-tremor-content-emphasis") }, P.createElement("div", { className: "text-xs truncate " }, (q = G.props.children) !== null && q !== void 0 ? q : G.props.value), P.createElement("div", { onClick: Y => { Y.preventDefault(); const Z = B.filter(($ => $ !== G.props.value)); i?.(Z), C(Z) } }, P.createElement(qst, { className: me(mT("clearIconItem"), "cursor-pointer rounded-tremor-full w-3.5 h-3.5 ml-2", "text-tremor-content-subtle hover:text-tremor-content", "dark:text-dark-tremor-content-subtle dark:hover:text-tremor-content") }))) }))) : P.createElement("span", null, a)), P.createElement("span", { className: me("absolute inset-y-0 right-0 flex items-center mr-2.5") }, P.createElement(w6, { className: me(mT("arrowDownIcon"), "flex-none h-5 w-5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") }))), I && !o ? P.createElement("button", { type: "button", className: me("absolute inset-y-0 right-0 flex items-center mr-8"), onClick: G => { G.preventDefault(), C([]), i?.([]) } }, P.createElement(z_, { className: me(mT("clearIconAllItems"), "flex-none h-4 w-4", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })) : null, P.createElement(cp, { enter: "transition ease duration-100 transform", enterFrom: "opacity-0 -translate-y-4", enterTo: "opacity-100 translate-y-0", leave: "transition ease duration-100 transform", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 -translate-y-4" }, P.createElement(OP, { anchor: "bottom start", className: me("z-10 divide-y w-[var(--button-width)] overflow-y-auto outline-none rounded-tremor-default max-h-[228px]  border [--anchor-gap:4px]", "bg-tremor-background border-tremor-border divide-tremor-border shadow-tremor-dropdown", "dark:bg-dark-tremor-background dark:border-dark-tremor-border dark:divide-dark-tremor-border dark:shadow-dark-tremor-dropdown") }, P.createElement("div", { className: me("flex items-center w-full px-2.5", "bg-tremor-background-muted", "dark:bg-dark-tremor-background-muted") }, P.createElement("span", null, P.createElement(Gst, { className: me("flex-none w-4 h-4 mr-2", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })), P.createElement("input", { name: "search", type: "input", autoComplete: "off", placeholder: s, className: me("w-full focus:outline-none focus:ring-none bg-transparent text-tremor-default py-2", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-subtle"), onKeyDown: G => { G.code === "Space" && G.target.value !== "" && G.stopPropagation() }, onChange: G => O(G.target.value), value: j })), P.createElement(BP.Provider, Object.assign({}, { onBlur: { handleResetSearch: F } }, { value: { selectedValue: B } }), D))))))), m && g ? P.createElement("p", { className: me("errorMessage", "text-sm text-rose-500 mt-1") }, g) : null) })); Xst.displayName = "MultiSelect"; const GQ = Pn("MultiSelectItem"), Yst = P.forwardRef(((t, e) => { const { value: n, className: r, children: i } = t, a = Et(t, ["value", "className", "children"]), { selectedValue: s } = S.useContext(BP), o = Fet(n, s); return P.createElement(l6, Object.assign({ className: me(GQ("root"), "flex justify-start items-center cursor-default text-tremor-default p-2.5", "data-[focus]:bg-tremor-background-muted data-[focus]:text-tremor-content-strong data-[select]ed:text-tremor-content-strong text-tremor-content-emphasis", "dark:data-[focus]:bg-dark-tremor-background-muted dark:data-[focus]:text-dark-tremor-content-strong dark:data-[select]ed:text-dark-tremor-content-strong dark:data-[select]ed:bg-dark-tremor-background-muted dark:text-dark-tremor-content-emphasis", r), ref: e, key: n, value: n }, a), P.createElement("input", { type: "checkbox", className: me(GQ("checkbox"), "flex-none focus:ring-none focus:outline-none cursor-pointer mr-2.5", "accent-tremor-brand", "dark:accent-dark-tremor-brand"), checked: o, readOnly: !0 }), P.createElement("span", { className: "whitespace-nowrap truncate" }, i ?? n)) })); Yst.displayName = "MultiSelectItem"; const Kst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({}, e, { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2.5" }), P.createElement("path", { d: "M12 4v16m8-8H4" })) }, Zst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({}, e, { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2.5" }), P.createElement("path", { d: "M20 12H4" })) }, Qst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM11 15V17H13V15H11ZM11 7V13H13V7H11Z" })) }, Jst = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M1.18164 12C2.12215 6.87976 6.60812 3 12.0003 3C17.3924 3 21.8784 6.87976 22.8189 12C21.8784 17.1202 17.3924 21 12.0003 21C6.60812 21 2.12215 17.1202 1.18164 12ZM12.0003 17C14.7617 17 17.0003 14.7614 17.0003 12C17.0003 9.23858 14.7617 7 12.0003 7C9.23884 7 7.00026 9.23858 7.00026 12C7.00026 14.7614 9.23884 17 12.0003 17ZM12.0003 15C10.3434 15 9.00026 13.6569 9.00026 12C9.00026 10.3431 10.3434 9 12.0003 9C13.6571 9 15.0003 10.3431 15.0003 12C15.0003 13.6569 13.6571 15 12.0003 15Z" })) }, eot = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M4.52047 5.93457L1.39366 2.80777L2.80788 1.39355L22.6069 21.1925L21.1927 22.6068L17.8827 19.2968C16.1814 20.3755 14.1638 21.0002 12.0003 21.0002C6.60812 21.0002 2.12215 17.1204 1.18164 12.0002C1.61832 9.62282 2.81932 7.5129 4.52047 5.93457ZM14.7577 16.1718L13.2937 14.7078C12.902 14.8952 12.4634 15.0002 12.0003 15.0002C10.3434 15.0002 9.00026 13.657 9.00026 12.0002C9.00026 11.537 9.10522 11.0984 9.29263 10.7067L7.82866 9.24277C7.30514 10.0332 7.00026 10.9811 7.00026 12.0002C7.00026 14.7616 9.23884 17.0002 12.0003 17.0002C13.0193 17.0002 13.9672 16.6953 14.7577 16.1718ZM7.97446 3.76015C9.22127 3.26959 10.5793 3.00016 12.0003 3.00016C17.3924 3.00016 21.8784 6.87992 22.8189 12.0002C22.5067 13.6998 21.8038 15.2628 20.8068 16.5925L16.947 12.7327C16.9821 12.4936 17.0003 12.249 17.0003 12.0002C17.0003 9.23873 14.7617 7.00016 12.0003 7.00016C11.7514 7.00016 11.5068 7.01833 11.2677 7.05343L7.97446 3.76015Z" })) }, _6 = P.forwardRef(((t, e) => { const { value: n, defaultValue: r, type: i, placeholder: a = "Type...", icon: s, error: o = !1, errorMessage: c, disabled: u = !1, stepper: d, makeInputClassName: f, className: h, onChange: m, onValueChange: g, autoFocus: x, pattern: v } = t, b = Et(t, ["value", "defaultValue", "type", "placeholder", "icon", "error", "errorMessage", "disabled", "stepper", "makeInputClassName", "className", "onChange", "onValueChange", "autoFocus", "pattern"]), [E, M] = S.useState(x || !1), [C, N] = S.useState(!1), A = S.useCallback((() => N(!C)), [C, N]), j = s, O = S.useRef(null), I = Lg(n || r); return P.useEffect((() => { const D = () => M(!0), F = () => M(!1), B = O.current; return B && (B.addEventListener("focus", D), B.addEventListener("blur", F), x && B.focus()), () => { B && (B.removeEventListener("focus", D), B.removeEventListener("blur", F)) } }), [x]), P.createElement(P.Fragment, null, P.createElement("div", { className: me(f("root"), "relative w-full flex items-center min-w-[10rem] outline-none rounded-tremor-default transition duration-100 border", "shadow-tremor-input", "dark:shadow-dark-tremor-input", dp(I, u, o), E && me("ring-2", "border-tremor-brand-subtle ring-tremor-brand-muted", "dark:border-dark-tremor-brand-subtle dark:ring-dark-tremor-brand-muted"), h) }, j ? P.createElement(j, { className: me(f("icon"), "shrink-0 h-5 w-5 mx-2.5 absolute left-0 flex items-center", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") }) : null, P.createElement("input", Object.assign({ ref: jf([O, e]), defaultValue: r, value: n, type: C ? "text" : i, className: me(f("input"), "w-full bg-transparent focus:outline-none focus:ring-0 border-none text-tremor-default rounded-tremor-default transition duration-100 py-2", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis", "[appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none", i === "password" ? o ? "pr-16" : "pr-12" : o ? "pr-8" : "pr-3", j ? "pl-10" : "pl-3", u ? "placeholder:text-tremor-content-subtle dark:placeholder:text-dark-tremor-content-subtle" : "placeholder:text-tremor-content dark:placeholder:text-dark-tremor-content"), placeholder: a, disabled: u, "data-testid": "base-input", onChange: D => { m?.(D), g?.(D.target.value) }, pattern: v }, b)), i !== "password" || u ? null : P.createElement("button", { className: me(f("toggleButton"), "absolute inset-y-0 right-0 flex items-center px-2.5 rounded-lg"), type: "button", onClick: () => A(), "aria-label": C ? "Hide password" : "Show Password" }, C ? P.createElement(eot, { className: me("flex-none h-5 w-5 transition", "text-tremor-content-subtle hover:text-tremor-content", "dark:text-dark-tremor-content-subtle hover:dark:text-dark-tremor-content"), "aria-hidden": !0 }) : P.createElement(Jst, { className: me("flex-none h-5 w-5 transition", "text-tremor-content-subtle hover:text-tremor-content", "dark:text-dark-tremor-content-subtle hover:dark:text-dark-tremor-content"), "aria-hidden": !0 })), o ? P.createElement(Qst, { className: me(f("errorIcon"), "text-red-500 shrink-0 h-5 w-5 absolute right-0 flex items-center", i === "password" ? "mr-10" : i === "number" ? d ? "mr-20" : "mr-3" : "mx-2.5") }) : null, d ?? null), o && c ? P.createElement("p", { className: me(f("errorMessage"), "text-sm text-red-500 mt-1") }, c) : null) })); _6.displayName = "BaseInput"; const qQ = "flex mx-auto text-tremor-content-subtle dark:text-dark-tremor-content-subtle", XQ = "cursor-pointer hover:text-tremor-content dark:hover:text-dark-tremor-content", tot = P.forwardRef(((t, e) => { const { onSubmit: n, enableStepper: r = !0, disabled: i, onValueChange: a, onChange: s } = t, o = Et(t, ["onSubmit", "enableStepper", "disabled", "onValueChange", "onChange"]), c = S.useRef(null), [u, d] = P.useState(!1), f = P.useCallback((() => { d(!0) }), []), h = P.useCallback((() => { d(!1) }), []), [m, g] = P.useState(!1), x = P.useCallback((() => { g(!0) }), []), v = P.useCallback((() => { g(!1) }), []); return P.createElement(_6, Object.assign({ type: "number", ref: jf([c, e]), disabled: i, makeInputClassName: Pn("NumberInput"), onKeyDown: b => { var E; if (b.key === "Enter" && !b.ctrlKey && !b.altKey && !b.shiftKey) { const M = (E = c.current) === null || E === void 0 ? void 0 : E.value; n?.(parseFloat(M ?? "")) } b.key === "ArrowDown" && f(), b.key === "ArrowUp" && x() }, onKeyUp: b => { b.key === "ArrowDown" && h(), b.key === "ArrowUp" && v() }, onChange: b => { i || (a?.(parseFloat(b.target.value)), s?.(b)) }, stepper: r ? P.createElement("div", { className: me("flex justify-center align-middle") }, P.createElement("div", { tabIndex: -1, onClick: b => b.preventDefault(), onMouseDown: b => b.preventDefault(), onTouchStart: b => { b.cancelable && b.preventDefault() }, onMouseUp: () => { var b, E; i || ((b = c.current) === null || b === void 0 || b.stepDown(), (E = c.current) === null || E === void 0 || E.dispatchEvent(new Event("input", { bubbles: !0 }))) }, className: me(!i && XQ, qQ, "group py-[10px] px-2.5 border-l border-tremor-border dark:border-dark-tremor-border") }, P.createElement(Zst, { "data-testid": "step-down", className: (u ? "scale-95" : "") + " h-4 w-4 duration-75 transition group-active:scale-95" })), P.createElement("div", { tabIndex: -1, onClick: b => b.preventDefault(), onMouseDown: b => b.preventDefault(), onTouchStart: b => { b.cancelable && b.preventDefault() }, onMouseUp: () => { var b, E; i || ((b = c.current) === null || b === void 0 || b.stepUp(), (E = c.current) === null || E === void 0 || E.dispatchEvent(new Event("input", { bubbles: !0 }))) }, className: me(!i && XQ, qQ, "group py-[10px] px-2.5 border-l border-tremor-border dark:border-dark-tremor-border") }, P.createElement(Kst, { "data-testid": "step-up", className: (m ? "scale-95" : "") + " h-4 w-4 duration-75 transition group-active:scale-95" }))) : null }, o)) })); tot.displayName = "NumberInput"; const YQ = Pn("SearchSelect"), not = Pn("SearchSelect"), rot = P.forwardRef(((t, e) => { const { defaultValue: n = "", searchValue: r, onSearchValueChange: i, value: a, onValueChange: s, placeholder: o = "Select...", disabled: c = !1, icon: u, enableClear: d = !0, name: f, required: h, error: m = !1, errorMessage: g, children: x, className: v, id: b, autoComplete: E = "off" } = t, M = Et(t, ["defaultValue", "searchValue", "onSearchValueChange", "value", "onValueChange", "placeholder", "disabled", "icon", "enableClear", "name", "required", "error", "errorMessage", "children", "className", "id", "autoComplete"]), C = S.useRef(null), [N, A] = up("", r), [j, O] = up(n, a), I = u, { reactElementChildren: D, valueToNameMapping: F } = S.useMemo((() => { const G = P.Children.toArray(x).filter(S.isValidElement); return { reactElementChildren: G, valueToNameMapping: b6(G) } }), [x]), B = S.useMemo((() => t5(N ?? "", D)), [N, D]); return P.createElement("div", { className: me("w-full min-w-[10rem] text-tremor-default", v) }, P.createElement("div", { className: "relative" }, P.createElement("select", { title: "search-select-hidden", required: h, className: me("h-full w-full absolute left-0 top-0 -z-10 opacity-0"), value: j, onChange: G => { G.preventDefault() }, name: f, disabled: c, id: b, onFocus: () => { const G = C.current; G && G.focus() } }, P.createElement("option", { className: "hidden", value: "", disabled: !0, hidden: !0 }, o), B.map((G => { const z = G.props.value, q = G.props.children; return P.createElement("option", { className: "hidden", key: z, value: z }, q) }))), P.createElement(yit, Object.assign({ as: "div", ref: e, defaultValue: j, value: j, onChange: G => { s?.(G), O(G) }, disabled: c, id: b }, M), (({ value: G }) => P.createElement(P.Fragment, null, P.createElement(Lpe, { className: "w-full" }, I && P.createElement("span", { className: me("absolute inset-y-0 left-0 flex items-center ml-px pl-2.5") }, P.createElement(I, { className: me(YQ("Icon"), "flex-none h-5 w-5", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })), P.createElement(Fpe, { ref: C, className: me("w-full outline-none text-left whitespace-nowrap truncate rounded-tremor-default focus:ring-2 transition duration-100 text-tremor-default pr-14 border py-2", "border-tremor-border shadow-tremor-input focus:border-tremor-brand-subtle focus:ring-tremor-brand-muted", "dark:border-dark-tremor-border dark:shadow-dark-tremor-input dark:focus:border-dark-tremor-brand-subtle dark:focus:ring-dark-tremor-brand-muted", I ? "pl-10" : "pl-3", c ? "placeholder:text-tremor-content-subtle dark:placeholder:text-tremor-content-subtle" : "placeholder:text-tremor-content dark:placeholder:text-tremor-content", dp(Lg(G), c, m)), placeholder: o, onChange: z => { i?.(z.target.value), A(z.target.value) }, displayValue: z => { var q; return (q = F.get(z)) !== null && q !== void 0 ? q : "" }, autoComplete: E }), P.createElement("div", { className: me("absolute inset-y-0 right-0 flex items-center pr-2.5") }, P.createElement(w6, { className: me(YQ("arrowDownIcon"), "flex-none h-5 w-5", "!text-tremor-content-subtle", "!dark:text-dark-tremor-content-subtle") }))), d && j ? P.createElement("button", { type: "button", className: me("absolute inset-y-0 right-0 flex items-center mr-8"), onClick: z => { z.preventDefault(), O(""), A(""), s?.(""), i?.("") } }, P.createElement(z_, { className: me(not("clearIcon"), "flex-none h-4 w-4", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") })) : null, B.length > 0 && P.createElement(cp, { enter: "transition ease duration-100 transform", enterFrom: "opacity-0 -translate-y-4", enterTo: "opacity-100 translate-y-0", leave: "transition ease duration-100 transform", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 -translate-y-4" }, P.createElement(Upe, { anchor: "bottom start", className: me("z-10 divide-y w-[var(--button-width)] overflow-y-auto outline-none rounded-tremor-default text-tremor-default max-h-[228px] border [--anchor-gap:4px]", "bg-tremor-background border-tremor-border divide-tremor-border shadow-tremor-dropdown", "dark:bg-dark-tremor-background dark:border-dark-tremor-border dark:divide-dark-tremor-border dark:shadow-dark-tremor-dropdown") }, B)))))), m && g ? P.createElement("p", { className: me("errorMessage", "text-sm text-rose-500 mt-1") }, g) : null) })); rot.displayName = "SearchSelect"; const KQ = Pn("SearchSelectItem"), iot = P.forwardRef(((t, e) => { const { value: n, icon: r, className: i, children: a } = t, s = Et(t, ["value", "icon", "className", "children"]), o = r; return P.createElement(Bpe, Object.assign({ className: me(KQ("root"), "flex justify-start items-center cursor-default text-tremor-default p-2.5", "data-[focus]:bg-tremor-background-muted  data-[focus]:text-tremor-content-strong data-[selected]:text-tremor-content-strong data-[selected]:bg-tremor-background-muted text-tremor-content-emphasis", "dark:data-[focus]:bg-dark-tremor-background-muted  dark:data-[focus]:text-dark-tremor-content-strong dark:data-[selected]:text-dark-tremor-content-strong dark:data-[selected]:bg-dark-tremor-background-muted dark:text-dark-tremor-content-emphasis", i), ref: e, key: n, value: n }, s), o && P.createElement(o, { className: me(KQ("icon"), "flex-none h-5 w-5 mr-3", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle") }), P.createElement("span", { className: "whitespace-nowrap truncate" }, a ?? n)) })); iot.displayName = "SearchSelectItem"; const Om = Pn("Switch"), aot = P.forwardRef(((t, e) => { const { checked: n, defaultChecked: r = !1, onChange: i, color: a, name: s, error: o, errorMessage: c, disabled: u, required: d, tooltip: f, id: h } = t, m = Et(t, ["checked", "defaultChecked", "onChange", "color", "name", "error", "errorMessage", "disabled", "required", "tooltip", "id"]), g = (N => ({ bgColor: N ? jt(N, Dt.background).bgColor : "bg-tremor-brand dark:bg-dark-tremor-brand", ringColor: N ? jt(N, Dt.ring).ringColor : "ring-tremor-brand-muted dark:ring-dark-tremor-brand-muted" }))(a), [x, v] = up(r, n), [b, E] = S.useState(!1), { tooltipProps: M, getReferenceProps: C } = Xl(300); return P.createElement("div", { className: "flex flex-row items-center justify-start" }, P.createElement(gl, Object.assign({ text: f }, M)), P.createElement("div", Object.assign({ ref: jf([e, M.refs.setReference]), className: me(Om("root"), "flex flex-row relative h-5") }, m, C), P.createElement("input", { type: "checkbox", className: me(Om("input"), "absolute w-5 h-5 cursor-pointer left-0 top-0 opacity-0"), name: s, required: d, checked: x, onChange: N => { N.preventDefault() } }), P.createElement(dst, { checked: x, onChange: N => { v(N), i?.(N) }, disabled: u, className: me(Om("switch"), "w-10 h-5 group relative inline-flex shrink-0 cursor-pointer items-center justify-center rounded-tremor-full", "focus:outline-none", u ? "cursor-not-allowed" : ""), onFocus: () => E(!0), onBlur: () => E(!1), id: h }, P.createElement("span", { className: me(Om("sr-only"), "sr-only") }, "Switch ", x ? "on" : "off"), P.createElement("span", { "aria-hidden": "true", className: me(Om("background"), x ? g.bgColor : "bg-tremor-border dark:bg-dark-tremor-border", "pointer-events-none absolute mx-auto h-3 w-9 rounded-tremor-full transition-colors duration-100 ease-in-out") }), P.createElement("span", { "aria-hidden": "true", className: me(Om("round"), x ? me(g.bgColor, "translate-x-5 border-tremor-background dark:border-dark-tremor-background") : "translate-x-0 bg-tremor-border dark:bg-dark-tremor-border border-tremor-background dark:border-dark-tremor-background", "pointer-events-none absolute left-0 inline-block h-5 w-5 transform rounded-tremor-full border-2 shadow-tremor-input duration-100 ease-in-out transition", b ? me("ring-2", g.ringColor) : "") }))), o && c ? P.createElement("p", { className: me(Om("errorMessage"), "text-sm text-red-500 mt-1 ") }, c) : null) })); aot.displayName = "Switch"; const sot = Pn("TabList"), cme = S.createContext("line"), oot = { line: me("flex border-b space-x-4", "border-tremor-border", "dark:border-dark-tremor-border"), solid: me("inline-flex p-0.5 rounded-tremor-default space-x-1.5", "bg-tremor-background-subtle", "dark:bg-dark-tremor-background-subtle") }, lot = P.forwardRef(((t, e) => { const { color: n, variant: r = "line", children: i, className: a } = t, s = Et(t, ["color", "variant", "children", "className"]); return P.createElement(UP.List, Object.assign({ ref: e, className: me(sot("root"), "justify-start overflow-x-clip", oot[r], a) }, s), P.createElement(cme.Provider, { value: r }, P.createElement(ome.Provider, { value: n }, i))) })); lot.displayName = "TabList"; const ZQ = Pn("Tab"); function cot(t, e) { switch (t) { case "line": return me("data-[selected]:border-b-2 hover:border-b-2 border-transparent transition duration-100 -mb-px px-2 py-2", "hover:border-tremor-content hover:text-tremor-content-emphasis text-tremor-content", "[&:not([data-selected])]:dark:hover:border-dark-tremor-content-emphasis [&:not([data-selected])]:dark:hover:text-dark-tremor-content-emphasis [&:not([data-selected])]:dark:text-dark-tremor-content", e ? jt(e, Dt.border).selectBorderColor : ["data-[selected]:border-tremor-brand data-[selected]:text-tremor-brand", "data-[selected]:dark:border-dark-tremor-brand data-[selected]:dark:text-dark-tremor-brand"]); case "solid": return me("border-transparent border rounded-tremor-small px-2.5 py-1", "data-[selected]:border-tremor-border data-[selected]:bg-tremor-background data-[selected]:shadow-tremor-input [&:not([data-selected])]:hover:text-tremor-content-emphasis data-[selected]:text-tremor-brand [&:not([data-selected])]:text-tremor-content", "dark:data-[selected]:border-dark-tremor-border dark:data-[selected]:bg-dark-tremor-background dark:data-[selected]:shadow-dark-tremor-input dark:[&:not([data-selected])]:hover:text-dark-tremor-content-emphasis dark:data-[selected]:text-dark-tremor-brand dark:[&:not([data-selected])]:text-dark-tremor-content", e ? jt(e, Dt.text).selectTextColor : "text-tremor-content dark:text-dark-tremor-content") } } const uot = P.forwardRef(((t, e) => { const { icon: n, className: r, children: i } = t, a = Et(t, ["icon", "className", "children"]), s = S.useContext(cme), o = S.useContext(ome), c = n; return P.createElement(UP, Object.assign({ ref: e, className: me(ZQ("root"), "flex whitespace-nowrap truncate max-w-xs outline-none data-focus-visible:ring text-tremor-default transition duration-100", cot(s, o), r, o && jt(o, Dt.text).selectTextColor) }, a), c ? P.createElement(c, { className: me(ZQ("icon"), "flex-none h-5 w-5", i ? "mr-2" : "") }) : null, i ? P.createElement("span", null, i) : null) })); uot.displayName = "Tab"; const dot = Pn("TabGroup"), fot = P.forwardRef(((t, e) => { const { defaultIndex: n, index: r, onIndexChange: i, children: a, className: s } = t, o = Et(t, ["defaultIndex", "index", "onIndexChange", "children", "className"]); return P.createElement(UP.Group, Object.assign({ as: "div", ref: e, defaultIndex: n, selectedIndex: r, onChange: i, className: me(dot("root"), "w-full", s) }, o), a) })); fot.displayName = "TabGroup"; const hot = Pn("TabPanel"), pot = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]), { selectedValue: a } = S.useContext(BP), s = a === S.useContext(lme); return P.createElement("div", Object.assign({ ref: e, className: me(hot("root"), "w-full mt-2", s ? "" : "hidden", r), "aria-selected": s ? "true" : "false" }, i), n) })); pot.displayName = "TabPanel"; const mot = Pn("TabPanels"), got = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(UP.Panels, Object.assign({ as: "div", ref: e, className: me(mot("root"), "w-full", r) }, i), (({ selectedIndex: a }) => P.createElement(BP.Provider, { value: { selectedValue: a } }, P.Children.map(n, ((s, o) => P.createElement(lme.Provider, { value: o }, s)))))) })); got.displayName = "TabPanels"; const QQ = Pn("Textarea"), vot = P.forwardRef(((t, e) => { const { value: n, defaultValue: r = "", placeholder: i = "Type...", error: a = !1, errorMessage: s, disabled: o = !1, className: c, onChange: u, onValueChange: d, autoHeight: f = !1 } = t, h = Et(t, ["value", "defaultValue", "placeholder", "error", "errorMessage", "disabled", "className", "onChange", "onValueChange", "autoHeight"]), [m, g] = up(r, n), x = S.useRef(null), v = Lg(m); return S.useEffect((() => { const b = x.current; if (f && b) { b.style.height = "60px"; const E = b.scrollHeight; b.style.height = E + "px" } }), [f, x, m]), P.createElement(P.Fragment, null, P.createElement("textarea", Object.assign({ ref: jf([x, e]), value: m, placeholder: i, disabled: o, className: me(QQ("Textarea"), "w-full flex items-center outline-none rounded-tremor-default px-3 py-2 text-tremor-default focus:ring-2 transition duration-100 border", "shadow-tremor-input focus:border-tremor-brand-subtle focus:ring-tremor-brand-muted", "dark:shadow-dark-tremor-input focus:dark:border-dark-tremor-brand-subtle focus:dark:ring-dark-tremor-brand-muted", dp(v, o, a), o ? "placeholder:text-tremor-content-subtle dark:placeholder:text-dark-tremor-content-subtle" : "placeholder:text-tremor-content dark:placeholder:text-dark-tremor-content", c), "data-testid": "text-area", onChange: b => { u?.(b), g(b.target.value), d?.(b.target.value) } }, h)), a && s ? P.createElement("p", { className: me(QQ("errorMessage"), "text-sm text-red-500 mt-1") }, s) : null) })); vot.displayName = "Textarea"; const yot = Pn("TextInput"), xot = P.forwardRef(((t, e) => { const { type: n = "text" } = t, r = Et(t, ["type"]); return P.createElement(_6, Object.assign({ ref: e, type: n, makeInputClassName: yot }, r)) })); xot.displayName = "TextInput"; const bot = Pn("Accordion"), ume = S.createContext({ isOpen: !1 }), wot = P.forwardRef(((t, e) => { var n; const { defaultOpen: r = !1, children: i, className: a } = t, s = Et(t, ["defaultOpen", "children", "className"]), o = (n = S.useContext(p1)) !== null && n !== void 0 ? n : me("rounded-tremor-default border"); return P.createElement(s6, Object.assign({ as: "div", ref: e, className: me(bot("root"), "overflow-hidden", "bg-tremor-background border-tremor-border", "dark:bg-dark-tremor-background dark:border-dark-tremor-border", o, a), defaultOpen: r }, s), (({ open: c }) => P.createElement(ume.Provider, { value: { isOpen: c } }, i))) })); wot.displayName = "Accordion"; const Sot = Pn("AccordionBody"), _ot = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(s6.Panel, Object.assign({ ref: e, className: me(Sot("root"), "w-full text-tremor-default px-4 pb-3", "text-tremor-content", "dark:text-dark-tremor-content", r) }, i), n) })); _ot.displayName = "AccordionBody"; const Eot = t => { var e = Et(t, []); return P.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, e), P.createElement("path", { d: "M11.9999 10.8284L7.0502 15.7782L5.63599 14.364L11.9999 8L18.3639 14.364L16.9497 15.7782L11.9999 10.8284Z" })) }, U3 = Pn("AccordionHeader"), Mot = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]), { isOpen: a } = S.useContext(ume); return P.createElement(s6.Button, Object.assign({ ref: e, className: me(U3("root"), "w-full flex items-center justify-between px-4 py-3", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis", r) }, i), P.createElement("div", { className: me(U3("children"), "flex flex-1 text-inherit mr-4") }, n), P.createElement("div", null, P.createElement(Eot, { className: me(U3("arrowIcon"), "h-5 w-5 -mr-1", "text-tremor-content-subtle", "dark:text-dark-tremor-content-subtle", a ? "transition-all" : "transition-all -rotate-180") }))) })); Mot.displayName = "AccordionHeader"; const Tot = Pn("AccordionList"), Cot = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]), a = P.Children.count(n); return P.createElement("div", Object.assign({ ref: e, className: me(Tot("root"), "rounded-tremor-default", "shadow-tremor-card", "dark:shadow-dark-tremor-card", r) }, i), P.Children.map(n, ((s, o) => o === 0 ? P.createElement(p1.Provider, { value: me("rounded-t-tremor-default border") }, P.cloneElement(s)) : o === a - 1 ? P.createElement(p1.Provider, { value: me("rounded-b-tremor-default border-l border-r border-b") }, P.cloneElement(s)) : P.createElement(p1.Provider, { value: me("border-l border-r border-b") }, P.cloneElement(s))))) })); Cot.displayName = "AccordionList"; const Not = Pn("Card"), Aot = t => { if (!t) return ""; switch (t) { case ix.Left: return "border-l-4"; case nQ.Top: return "border-t-4"; case ix.Right: return "border-r-4"; case nQ.Bottom: return "border-b-4"; default: return "" } }, Pot = P.forwardRef(((t, e) => { const { decoration: n = "", decorationColor: r, children: i, className: a } = t, s = Et(t, ["decoration", "decorationColor", "children", "className"]); return P.createElement("div", Object.assign({ ref: e, className: me(Not("root"), "relative w-full text-left ring-1 rounded-tremor-default p-6", "bg-tremor-background ring-tremor-ring shadow-tremor-card", "dark:bg-dark-tremor-background dark:ring-dark-tremor-ring dark:shadow-dark-tremor-card", r ? jt(r, Dt.border).borderColor : "border-tremor-brand dark:border-dark-tremor-brand", Aot(n), a) }, s), i) })); Pot.displayName = "Card"; const jot = Pn("Divider"), Rot = P.forwardRef(((t, e) => { const { className: n, children: r } = t, i = Et(t, ["className", "children"]); return P.createElement("div", Object.assign({ ref: e, className: me(jot("root"), "w-full mx-auto my-6 flex justify-between gap-3 items-center text-tremor-default", "text-tremor-content", "dark:text-dark-tremor-content", n) }, i), r ? P.createElement(P.Fragment, null, P.createElement("div", { className: me("w-full h-[1px] bg-tremor-border dark:bg-dark-tremor-border") }), P.createElement("div", { className: me("text-inherit whitespace-nowrap") }, r), P.createElement("div", { className: me("w-full h-[1px] bg-tremor-border dark:bg-dark-tremor-border") })) : P.createElement("div", { className: me("w-full h-[1px] bg-tremor-border dark:bg-dark-tremor-border") })) })); Rot.displayName = "Divider"; const kot = Pn("Flex"), Iot = { start: "justify-start", end: "justify-end", center: "justify-center", between: "justify-between", around: "justify-around", evenly: "justify-evenly" }, Oot = { start: "items-start", end: "items-end", center: "items-center", baseline: "items-baseline", stretch: "items-stretch" }, Dot = { row: "flex-row", col: "flex-col", "row-reverse": "flex-row-reverse", "col-reverse": "flex-col-reverse" }, Lot = P.forwardRef(((t, e) => { const { flexDirection: n = "row", justifyContent: r = "between", alignItems: i = "center", children: a, className: s } = t, o = Et(t, ["flexDirection", "justifyContent", "alignItems", "children", "className"]); return P.createElement("div", Object.assign({ ref: e, className: me(kot("root"), "flex w-full", Dot[n], Iot[r], Oot[i], s) }, o), a) })); Lot.displayName = "Flex"; const Fot = { 0: "grid-cols-none", 1: "grid-cols-1", 2: "grid-cols-2", 3: "grid-cols-3", 4: "grid-cols-4", 5: "grid-cols-5", 6: "grid-cols-6", 7: "grid-cols-7", 8: "grid-cols-8", 9: "grid-cols-9", 10: "grid-cols-10", 11: "grid-cols-11", 12: "grid-cols-12" }, Uot = { 0: "sm:grid-cols-none", 1: "sm:grid-cols-1", 2: "sm:grid-cols-2", 3: "sm:grid-cols-3", 4: "sm:grid-cols-4", 5: "sm:grid-cols-5", 6: "sm:grid-cols-6", 7: "sm:grid-cols-7", 8: "sm:grid-cols-8", 9: "sm:grid-cols-9", 10: "sm:grid-cols-10", 11: "sm:grid-cols-11", 12: "sm:grid-cols-12" }, Bot = { 0: "md:grid-cols-none", 1: "md:grid-cols-1", 2: "md:grid-cols-2", 3: "md:grid-cols-3", 4: "md:grid-cols-4", 5: "md:grid-cols-5", 6: "md:grid-cols-6", 7: "md:grid-cols-7", 8: "md:grid-cols-8", 9: "md:grid-cols-9", 10: "md:grid-cols-10", 11: "md:grid-cols-11", 12: "md:grid-cols-12" }, $ot = { 0: "lg:grid-cols-none", 1: "lg:grid-cols-1", 2: "lg:grid-cols-2", 3: "lg:grid-cols-3", 4: "lg:grid-cols-4", 5: "lg:grid-cols-5", 6: "lg:grid-cols-6", 7: "lg:grid-cols-7", 8: "lg:grid-cols-8", 9: "lg:grid-cols-9", 10: "lg:grid-cols-10", 11: "lg:grid-cols-11", 12: "lg:grid-cols-12" }, zot = { 1: "col-span-1", 2: "col-span-2", 3: "col-span-3", 4: "col-span-4", 5: "col-span-5", 6: "col-span-6", 7: "col-span-7", 8: "col-span-8", 9: "col-span-9", 10: "col-span-10", 11: "col-span-11", 12: "col-span-12", 13: "col-span-13" }, Vot = { 1: "sm:col-span-1", 2: "sm:col-span-2", 3: "sm:col-span-3", 4: "sm:col-span-4", 5: "sm:col-span-5", 6: "sm:col-span-6", 7: "sm:col-span-7", 8: "sm:col-span-8", 9: "sm:col-span-9", 10: "sm:col-span-10", 11: "sm:col-span-11", 12: "sm:col-span-12", 13: "sm:col-span-13" }, Hot = { 1: "md:col-span-1", 2: "md:col-span-2", 3: "md:col-span-3", 4: "md:col-span-4", 5: "md:col-span-5", 6: "md:col-span-6", 7: "md:col-span-7", 8: "md:col-span-8", 9: "md:col-span-9", 10: "md:col-span-10", 11: "md:col-span-11", 12: "md:col-span-12", 13: "md:col-span-13" }, Wot = { 1: "lg:col-span-1", 2: "lg:col-span-2", 3: "lg:col-span-3", 4: "lg:col-span-4", 5: "lg:col-span-5", 6: "lg:col-span-6", 7: "lg:col-span-7", 8: "lg:col-span-8", 9: "lg:col-span-9", 10: "lg:col-span-10", 11: "lg:col-span-11", 12: "lg:col-span-12", 13: "lg:col-span-13" }, Got = Pn("Col"), qot = P.forwardRef(((t, e) => { const { numColSpan: n = 1, numColSpanSm: r, numColSpanMd: i, numColSpanLg: a, children: s, className: o } = t, c = Et(t, ["numColSpan", "numColSpanSm", "numColSpanMd", "numColSpanLg", "children", "className"]), u = (d, f) => d && Object.keys(f).includes(String(d)) ? f[d] : ""; return P.createElement("div", Object.assign({ ref: e, className: me(Got("root"), (() => { const d = u(n, zot), f = u(r, Vot), h = u(i, Hot), m = u(a, Wot); return me(d, f, h, m) })(), o) }, c), s) })); qot.displayName = "Col"; const Xot = Pn("Grid"), gT = (t, e) => t && Object.keys(e).includes(String(t)) ? e[t] : "", Yot = P.forwardRef(((t, e) => { const { numItems: n = 1, numItemsSm: r, numItemsMd: i, numItemsLg: a, children: s, className: o } = t, c = Et(t, ["numItems", "numItemsSm", "numItemsMd", "numItemsLg", "children", "className"]), u = gT(n, Fot), d = gT(r, Uot), f = gT(i, Bot), h = gT(a, $ot), m = me(u, d, f, h); return P.createElement("div", Object.assign({ ref: e, className: me(Xot("root"), "grid", m, o) }, c), s) })); Yot.displayName = "Grid"; const Kot = Pn("dialog"), Zot = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(cp, { appear: !0, show: t.open }, P.createElement(Zit, Object.assign({ ref: e }, i, { className: me(Kot("root"), "relative z-50", r) }), P.createElement(Yit, { transition: !0, className: "fixed bg-slate-950/30  dark:bg-slate-950/50  inset-0  transition-opacity data-[closed]:opacity-0 data-[enter]:duration-300 data-[leave]:duration-200 data-[enter]:ease-out data-[leave]:ease-in" }), P.createElement("div", { className: "fixed inset-0 overflow-y-auto w-screen" }, P.createElement("div", { className: "flex min-h-full items-center justify-center p-4" }, n)))) })); Zot.displayName = "Dialog"; const Qot = Pn("dialog"), Jot = P.forwardRef(((t, e) => { var n; const { children: r, className: i } = t, a = Et(t, ["children", "className"]), s = (n = P.useContext(p1)) !== null && n !== void 0 ? n : me("rounded-tremor-default p-6"); return P.createElement(PP, { enter: "ease-out duration-300", enterFrom: "opacity-0 scale-95", enterTo: "opacity-100 scale-100", leave: "ease-in duration-200", leaveFrom: "opacity-100 scale-100", leaveTo: "opacity-0 scale-95" }, P.createElement(Kpe, Object.assign({ ref: e, className: me(Qot("panel"), "w-full max-w-lg overflow-visible text-left ring-1 shadow-tremor transition-all transform", "bg-tremor-background  text-tremor-content ring-tremor-ring", "dark:bg-dark-tremor-background dark:text-dark-tremor-content dark:ring-dark-tremor-ring", s, i) }, a), r)) })); Jot.displayName = "DialogPanel"; const elt = Pn("List"), tlt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement("ul", Object.assign({ ref: e, className: me(elt("root"), "w-full divide-y", "divide-tremor-border text-tremor-content", "dark:divide-dark-tremor-border dark:text-dark-tremor-content", r) }, i), n) })); tlt.displayName = "List"; const nlt = Pn("ListItem"), rlt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("li", Object.assign({ ref: e, className: me(nlt("root"), "w-full flex justify-between items-center text-tremor-default py-2", r) }, i), n)) })); rlt.displayName = "ListItem"; const JQ = Pn("Table"), ilt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement("div", { className: me(JQ("root"), "overflow-auto", r) }, P.createElement("table", Object.assign({ ref: e, className: me(JQ("table"), "w-full text-tremor-default", "text-tremor-content", "dark:text-dark-tremor-content") }, i), n)) })); ilt.displayName = "Table"; const alt = Pn("TableBody"), slt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("tbody", Object.assign({ ref: e, className: me(alt("root"), "align-top divide-y", "divide-tremor-border", "dark:divide-dark-tremor-border", r) }, i), n)) })); slt.displayName = "TableBody"; const olt = Pn("TableCell"), llt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("td", Object.assign({ ref: e, className: me(olt("root"), "align-middle whitespace-nowrap text-left p-4", r) }, i), n)) })); llt.displayName = "TableCell"; const clt = Pn("TableFoot"), ult = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement("tfoot", Object.assign({ ref: e, className: me(clt("root"), "text-left font-medium border-t-[1px] ", "text-tremor-content border-tremor-border", "dark:text-dark-tremor-content dark:border-dark-tremor-border", r) }, i), n) })); ult.displayName = "TableFoot"; const dlt = Pn("TableFooterCell"), flt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("th", Object.assign({ ref: e, className: me(dlt("root"), "top-0 px-4 py-3.5", "text-tremor-content font-medium", "dark:text-dark-tremor-content", r) }, i), n)) })); flt.displayName = "TableFooterCell"; const hlt = Pn("TableHead"), plt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("thead", Object.assign({ ref: e, className: me(hlt("root"), "text-left", "text-tremor-content", "dark:text-dark-tremor-content", r) }, i), n)) })); plt.displayName = "TableHead"; const mlt = Pn("TableHeaderCell"), glt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("th", Object.assign({ ref: e, className: me(mlt("root"), "whitespace-nowrap text-left font-semibold top-0 px-4 py-3.5", "text-tremor-content-strong", "dark:text-dark-tremor-content-strong", r) }, i), n)) })); glt.displayName = "TableHeaderCell"; const vlt = Pn("TableRow"), ylt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement(P.Fragment, null, P.createElement("tr", Object.assign({ ref: e, className: me(vlt("row"), r) }, i), n)) })); ylt.displayName = "TableRow"; const xlt = P.forwardRef(((t, e) => { const { data: n = [], categories: r = [], index: i, colors: a = nd, stack: s = !1, relative: o = !1, animationDuration: c = 900, showAnimation: u = !1, noDataText: d, autoMinValue: f = !1, minValue: h, maxValue: m, className: g } = t, x = Et(t, ["data", "categories", "index", "colors", "stack", "relative", "animationDuration", "showAnimation", "noDataText", "autoMinValue", "minValue", "maxValue", "className"]), v = Qg(r, a), b = lp(f, h, m); return P.createElement("div", Object.assign({ ref: e, className: me("w-28 h-12", g) }, x), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Fhe, { data: n, stackOffset: o ? "expand" : "none", margin: { top: 0, left: -1.5, right: -1.5, bottom: 0 } }, P.createElement(zo, { hide: !0, domain: b }), P.createElement($o, { hide: !0, dataKey: i }), r.map((E => { var M; return P.createElement(Ap, { className: me(jt((M = v.get(E)) !== null && M !== void 0 ? M : Gt.Gray, Dt.background).fillColor), key: E, name: E, type: "linear", stackId: s || o ? "a" : void 0, dataKey: E, fill: "", isAnimationActive: u, animationDuration: c }) }))) : P.createElement(Rf, { noDataText: d }))) })); xlt.displayName = "SparkBarChart"; const blt = P.forwardRef(((t, e) => { const { data: n = [], categories: r = [], index: i, colors: a = nd, animationDuration: s = 900, showAnimation: o = !1, curveType: c = "linear", connectNulls: u = !1, noDataText: d, autoMinValue: f = !1, minValue: h, maxValue: m, className: g } = t, x = Et(t, ["data", "categories", "index", "colors", "animationDuration", "showAnimation", "curveType", "connectNulls", "noDataText", "autoMinValue", "minValue", "maxValue", "className"]), v = Qg(r, a), b = lp(f, h, m); return P.createElement("div", Object.assign({ ref: e, className: me("w-28 h-12", g) }, x), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Lhe, { data: n, margin: { top: 1, left: 1, right: 1, bottom: 1 } }, P.createElement(zo, { hide: !0, domain: b }), P.createElement($o, { hide: !0, dataKey: i }), r.map((E => { var M; return P.createElement(op, { className: me(jt((M = v.get(E)) !== null && M !== void 0 ? M : Gt.Gray, Dt.text).strokeColor), strokeOpacity: 1, dot: !1, key: E, name: E, type: c, dataKey: E, stroke: "", strokeWidth: 2, strokeLinejoin: "round", strokeLinecap: "round", isAnimationActive: o, animationDuration: s, connectNulls: u }) }))) : P.createElement(Rf, { noDataText: d }))) })); blt.displayName = "SparkLineChart"; const wlt = P.forwardRef(((t, e) => { const { data: n = [], categories: r = [], index: i, stack: a = !1, colors: s = nd, showAnimation: o = !1, animationDuration: c = 900, showGradient: u = !0, curveType: d = "linear", connectNulls: f = !1, noDataText: h, autoMinValue: m = !1, minValue: g, maxValue: x, className: v } = t, b = Et(t, ["data", "categories", "index", "stack", "colors", "showAnimation", "animationDuration", "showGradient", "curveType", "connectNulls", "noDataText", "autoMinValue", "minValue", "maxValue", "className"]), E = Qg(r, s), M = lp(m, g, x); return P.createElement("div", Object.assign({ ref: e, className: me("w-28 h-12", v) }, b), P.createElement(Mp, { className: "h-full w-full" }, n?.length ? P.createElement(Uhe, { data: n, margin: { top: 1, left: 1, right: 1, bottom: 1 } }, P.createElement(zo, { hide: !0, domain: M }), P.createElement($o, { hide: !0, dataKey: i }), r.map((C => { var N, A; return P.createElement("defs", { key: C }, u ? P.createElement("linearGradient", { className: jt((N = E.get(C)) !== null && N !== void 0 ? N : Gt.Gray, Dt.text).textColor, id: E.get(C), x1: "0", y1: "0", x2: "0", y2: "1" }, P.createElement("stop", { offset: "5%", stopColor: "currentColor", stopOpacity: .4 }), P.createElement("stop", { offset: "95%", stopColor: "currentColor", stopOpacity: 0 })) : P.createElement("linearGradient", { className: jt((A = E.get(C)) !== null && A !== void 0 ? A : Gt.Gray, Dt.text).textColor, id: E.get(C), x1: "0", y1: "0", x2: "0", y2: "1" }, P.createElement("stop", { stopColor: "currentColor", stopOpacity: .3 }))) })), r.map((C => { var N; return P.createElement(Pf, { className: jt((N = E.get(C)) !== null && N !== void 0 ? N : Gt.Gray, Dt.text).strokeColor, strokeOpacity: 1, dot: !1, key: C, name: C, type: d, dataKey: C, stroke: "", fill: `url(#${E.get(C)})`, strokeWidth: 2, strokeLinejoin: "round", strokeLinecap: "round", isAnimationActive: o, animationDuration: c, stackId: a ? "a" : void 0, connectNulls: f }) }))) : P.createElement(Rf, { noDataText: h }))) })); wlt.displayName = "AreaChart"; const Slt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement("b", Object.assign({ ref: e, className: me("text-inherit font-bold", r) }, i), n) })); Slt.displayName = "Bold"; const Tw = Pn("Callout"), _lt = P.forwardRef(((t, e) => { const { title: n, icon: r, color: i, className: a, children: s } = t, o = Et(t, ["title", "icon", "color", "className", "children"]), c = r; return P.createElement("div", Object.assign({ ref: e, className: me(Tw("root"), "flex flex-col overflow-hidden rounded-tremor-default text-tremor-default border-l-4 py-3 pr-3 pl-4", i ? me(jt(i, Dt.background).bgColor, jt(i, Dt.darkBorder).borderColor, jt(i, Dt.darkText).textColor, "dark:bg-opacity-10 bg-opacity-10") : me("bg-tremor-brand-faint border-tremor-brand-emphasis text-tremor-brand-emphasis", "dark:bg-dark-tremor-brand-muted/70 dark:border-dark-tremor-brand-emphasis dark:text-dark-tremor-brand-emphasis"), a) }, o), P.createElement("div", { className: me(Tw("header"), "flex items-start") }, c ? P.createElement(c, { className: me(Tw("icon"), "flex-none h-5 w-5 mr-1.5") }) : null, P.createElement("h4", { className: me(Tw("title"), "font-semibold") }, n)), P.createElement("p", { className: me(Tw("body"), "overflow-y-auto", s ? "mt-2" : "") }, s)) })); _lt.displayName = "Callout"; const Elt = P.forwardRef(((t, e) => { const { children: n, className: r } = t, i = Et(t, ["children", "className"]); return P.createElement("i", Object.assign({ ref: e, className: me("italic text-inherit", r) }, i), n) })); Elt.displayName = "Italic"; const Mlt = P.forwardRef(((t, e) => { const { color: n, children: r, className: i } = t, a = Et(t, ["color", "children", "className"]); return P.createElement("p", Object.assign({ ref: e, className: me("font-semibold text-tremor-metric", n ? jt(n, Dt.darkText).textColor : "text-tremor-content-strong dark:text-dark-tremor-content-strong", i) }, a), r) })); Mlt.displayName = "Metric"; const Tlt = P.forwardRef(((t, e) => { const { color: n, children: r, className: i } = t, a = Et(t, ["color", "children", "className"]); return P.createElement("p", Object.assign({ ref: e, className: me(n ? jt(n, Dt.lightText).textColor : "text-tremor-content-emphasis dark:text-dark-tremor-content-emphasis", i) }, a), r) })); Tlt.displayName = "Subtitle"; const Clt = P.forwardRef(((t, e) => { const { color: n, children: r, className: i } = t, a = Et(t, ["color", "children", "className"]); return P.createElement("p", Object.assign({ ref: e, className: me("font-medium text-tremor-title", n ? jt(n, Dt.darkText).textColor : "text-tremor-content-strong dark:text-dark-tremor-content-strong", i) }, a), r) })); Clt.displayName = "Title"; const Gd = Pn("BarList"); function dme(t, e) { const { data: n = [], color: r, valueFormatter: i = Ou, showAnimation: a = !1, onValueChange: s, sortOrder: o = "descending", className: c } = t, u = Et(t, ["data", "color", "valueFormatter", "showAnimation", "onValueChange", "sortOrder", "className"]), d = s ? "button" : "div", f = P.useMemo((() => o === "none" ? n : [...n].sort(((m, g) => o === "ascending" ? m.value - g.value : g.value - m.value))), [n, o]), h = P.useMemo((() => { const m = Math.max(...f.map((g => g.value)), 0); return f.map((g => g.value === 0 ? 0 : Math.max(g.value / m * 100, 2))) }), [f]); return P.createElement("div", Object.assign({ ref: e, className: me(Gd("root"), "flex justify-between space-x-6", c), "aria-sort": o }, u), P.createElement("div", { className: me(Gd("bars"), "relative w-full space-y-1.5") }, f.map(((m, g) => { var x, v, b; const E = m.icon; return P.createElement(d, { key: (x = m.key) !== null && x !== void 0 ? x : g, onClick: () => { s?.(m) }, className: me(Gd("bar"), "group w-full flex items-center rounded-tremor-small", s ? ["cursor-pointer", "hover:bg-tremor-background-muted dark:hover:bg-dark-tremor-background-subtle/40"] : "") }, P.createElement("div", { className: me("flex items-center rounded transition-all bg-opacity-40", "h-8", m.color || r ? [jt((v = m.color) !== null && v !== void 0 ? v : r, Dt.background).bgColor, s ? "group-hover:bg-opacity-30" : ""] : "bg-tremor-brand-subtle dark:bg-dark-tremor-brand-subtle/60", !s || m.color || r ? "" : "group-hover:bg-tremor-brand-subtle/30 group-hover:dark:bg-dark-tremor-brand-subtle/70", g === f.length - 1 ? "mb-0" : "", a ? "duration-500" : ""), style: { width: `${h[g]}%`, transition: a ? "all 1s" : "" } }, P.createElement("div", { className: me("absolute left-2 pr-4 flex max-w-full") }, E ? P.createElement(E, { className: me(Gd("barIcon"), "flex-none h-5 w-5 mr-2", "text-tremor-content", "dark:text-dark-tremor-content") }) : null, m.href ? P.createElement("a", { href: m.href, target: (b = m.target) !== null && b !== void 0 ? b : "_blank", rel: "noreferrer", className: me(Gd("barLink"), "whitespace-nowrap hover:underline truncate text-tremor-default", s ? "cursor-pointer" : "", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis"), onClick: M => M.stopPropagation() }, m.name) : P.createElement("p", { className: me(Gd("barText"), "whitespace-nowrap truncate text-tremor-default", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, m.name)))) }))), P.createElement("div", { className: Gd("labels") }, f.map(((m, g) => { var x; return P.createElement("div", { key: (x = m.key) !== null && x !== void 0 ? x : g, className: me(Gd("labelWrapper"), "flex justify-end items-center", "h-8", g === f.length - 1 ? "mb-0" : "mb-1.5") }, P.createElement("p", { className: me(Gd("labelText"), "whitespace-nowrap leading-none truncate text-tremor-default", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, i(m.value))) })))) } dme.displayName = "BarList"; P.forwardRef(dme); const Ry = Pn("CategoryBar"), fme = (t, e) => t ? t / e * 100 : 0, Nlt = ({ values: t }) => { const e = S.useMemo((() => _z(t)), [t]); let n = 0, r = 0; return P.createElement("div", { className: me(Ry("labels"), "relative flex w-full text-tremor-default h-5 mb-2", "text-tremor-content", "dark:text-dark-tremor-content") }, t.slice(0, t.length).map(((i, a) => { n += i; const s = (i >= .1 * e || r >= .09 * e) && e - n >= .15 * e && n >= .1 * e; r = s ? 0 : r += i; const o = fme(i, e); return P.createElement("div", { key: `item-${a}`, className: "flex items-center justify-end", style: { width: `${o}%` } }, P.createElement("span", { className: me(s ? "block" : "hidden", "left-1/2 translate-x-1/2") }, n)) })), P.createElement("div", { className: me("absolute bottom-0 flex items-center left-0") }, "0"), P.createElement("div", { className: me("absolute bottom-0 flex items-center right-0") }, e)) }, Alt = P.forwardRef(((t, e) => { const { values: n = [], colors: r = nd, markerValue: i, showLabels: a = !0, tooltip: s, showAnimation: o = !1, className: c } = t, u = Et(t, ["values", "colors", "markerValue", "showLabels", "tooltip", "showAnimation", "className"]), d = S.useMemo((() => ((x, v, b) => { if (x === void 0) return ""; let E = 0; for (let M = 0; M < v.length; M++) { const C = v[M], N = jt(b[M], Dt.background).bgColor; if (E += C, E >= x) return N } return "" })(i, n, r)), [i, n, r]), { tooltipProps: f, getReferenceProps: h } = Xl(), m = S.useMemo((() => _z(n)), [n]), g = S.useMemo((() => fme(i, m)), [i, m]); return P.createElement(P.Fragment, null, P.createElement(gl, Object.assign({ text: s }, f)), P.createElement("div", Object.assign({ ref: e, className: me(Ry("root"), c) }, u), a ? P.createElement(Nlt, { values: n }) : null, P.createElement("div", { className: me(Ry("barWrapper"), "relative w-full flex items-center h-2") }, P.createElement("div", { className: me("flex-1 flex items-center h-full overflow-hidden rounded-tremor-full") }, n.map(((x, v) => { var b; const E = (b = r[v]) !== null && b !== void 0 ? b : "gray", M = x / m * 100; return P.createElement("div", { key: `item-${v}`, className: me(Ry("categoryBar"), "h-full", jt(E, Dt.background).bgColor), style: { width: `${M}%` } }) }))), i !== void 0 ? P.createElement("div", Object.assign({ ref: f.refs.setReference, className: me(Ry("markerWrapper"), "absolute right-1/2 -translate-x-1/2 w-5"), style: { left: `${g}%`, transition: o ? "all 1s" : "" } }, h), P.createElement("div", { className: me(Ry("marker"), "ring-2 mx-auto rounded-tremor-full h-4 w-1", "ring-tremor-brand-inverted", "dark:ring-dark-tremor-brand-inverted", d) })) : null))) })); Alt.displayName = "CategoryBar"; const eJ = { [si.Increase]: { bgColor: jt(Gt.Emerald, Dt.background).bgColor }, [si.ModerateIncrease]: { bgColor: jt(Gt.Emerald, Dt.background).bgColor }, [si.Decrease]: { bgColor: jt(Gt.Rose, Dt.background).bgColor }, [si.ModerateDecrease]: { bgColor: jt(Gt.Rose, Dt.background).bgColor }, [si.Unchanged]: { bgColor: jt(Gt.Orange, Dt.background).bgColor } }, Cw = Pn("DeltaBar"), Plt = P.forwardRef(((t, e) => { const { value: n, isIncreasePositive: r = !0, showAnimation: i = !1, className: a, tooltip: s } = t, o = Et(t, ["value", "isIncreasePositive", "showAnimation", "className", "tooltip"]), c = Bhe((f => f >= 0 ? si.Increase : si.Decrease)(n), r), { tooltipProps: u, getReferenceProps: d } = Xl(); return P.createElement(P.Fragment, null, P.createElement(gl, Object.assign({ text: s }, u)), P.createElement("div", Object.assign({ ref: e, className: me(Cw("root"), "relative flex items-center w-full rounded-tremor-full h-2", "bg-tremor-background-subtle", "dark:bg-dark-tremor-background-subtle", a) }, o), P.createElement("div", { className: "flex justify-end h-full w-1/2" }, n < 0 ? P.createElement("div", Object.assign({ ref: u.refs.setReference, className: me(Cw("negativeDeltaBar"), "rounded-l-tremor-full", eJ[c].bgColor), style: { width: `${Math.abs(n)}%`, transition: i ? "all duration-300" : "" } }, d)) : null), P.createElement("div", { className: me(Cw("separator"), "ring-2 z-10 rounded-tremor-full h-4 w-1", "ring-tremor-brand-inverted bg-tremor-background-emphasis", "dark:ring-dark-tremor-brand-inverted dark:bg-dark-tremor-background-emphasis") }), P.createElement("div", { className: me(Cw("positiveDeltaBarWrapper"), "flex justify-start h-full w-1/2") }, n >= 0 ? P.createElement("div", Object.assign({ ref: u.refs.setReference, className: me(Cw("positiveDeltaBar"), "rounded-r-tremor-full", eJ[c].bgColor), style: { width: `${Math.abs(n)}%`, transition: i ? "all 1s" : "" } }, d)) : null))) })); Plt.displayName = "DeltaBar"; const vT = Pn("MarkerBar"), jlt = P.forwardRef(((t, e) => { const { value: n, minValue: r, maxValue: i, markerTooltip: a, rangeTooltip: s, showAnimation: o = !1, color: c, className: u } = t, d = Et(t, ["value", "minValue", "maxValue", "markerTooltip", "rangeTooltip", "showAnimation", "color", "className"]), { tooltipProps: f, getReferenceProps: h } = Xl(), { tooltipProps: m, getReferenceProps: g } = Xl(); return P.createElement("div", Object.assign({ ref: e, className: me(vT("root"), "relative flex items-center w-full rounded-tremor-full h-2", "bg-tremor-background-subtle", "dark:bg-dark-tremor-background-subtle", u) }, d), r !== void 0 && i !== void 0 ? P.createElement(P.Fragment, null, P.createElement(gl, Object.assign({ text: s }, m)), P.createElement("div", Object.assign({ ref: m.refs.setReference, className: me(vT("rangeBar"), "absolute h-full rounded-tremor-full", "bg-tremor-content-subtle", "dark:bg-dark-tremor-content-subtle"), style: { left: `${r}%`, width: i - r + "%", transition: o ? "all duration-300" : "" } }, g))) : null, P.createElement(gl, Object.assign({ text: a }, f)), P.createElement("div", Object.assign({ ref: f.refs.setReference, className: me(vT("markerWrapper"), "absolute right-1/2 -translate-x-1/2 w-5"), style: { left: `${n}%`, transition: o ? "all 1s" : "" } }, h), P.createElement("div", { className: me(vT("marker"), "ring-2 mx-auto rounded-tremor-full h-4 w-1", "ring-tremor-brand-inverted", "dark:ring-dark-tremor-brand-inverted", c ? jt(c, Dt.background).bgColor : "dark:bg-dark-tremor-brand bg-tremor-brand") }))) })); jlt.displayName = "MarkerBar"; const Nw = Pn("ProgressBar"), Rlt = P.forwardRef(((t, e) => { const { value: n, label: r, color: i, tooltip: a, showAnimation: s = !1, className: o } = t, c = Et(t, ["value", "label", "color", "tooltip", "showAnimation", "className"]), { tooltipProps: u, getReferenceProps: d } = Xl(); return P.createElement(P.Fragment, null, P.createElement(gl, Object.assign({ text: a }, u)), P.createElement("div", Object.assign({ ref: e, className: me(Nw("root"), "flex items-center w-full", o) }, c), P.createElement("div", Object.assign({ ref: u.refs.setReference, className: me(Nw("progressBarWrapper"), "relative flex items-center w-full rounded-tremor-full bg-opacity-20 h-2", i ? jt(i, Dt.background).bgColor : "bg-tremor-brand-muted/50 dark:bg-dark-tremor-brand-muted") }, d), P.createElement("div", { className: me(Nw("progressBar"), "flex-col h-full rounded-tremor-full", i ? jt(i, Dt.background).bgColor : "bg-tremor-brand dark:bg-dark-tremor-brand", s ? "transition-all duration-300 ease-in-out" : ""), style: { width: `${n}%` } })), r ? P.createElement("div", { className: me(Nw("labelWrapper"), "w-16 truncate text-right ml-2", "text-tremor-content-emphasis", "dark:text-dark-tremor-content-emphasis") }, P.createElement("p", { className: me(Nw("label"), "shrink-0 whitespace-nowrap truncate text-tremor-default") }, r)) : null)) })); Rlt.displayName = "ProgressBar"; const klt = Pn("ProgressBar"), tJ = { xs: { radius: 15, strokeWidth: 3 }, sm: { radius: 19, strokeWidth: 4 }, md: { radius: 32, strokeWidth: 6 }, lg: { radius: 52, strokeWidth: 8 }, xl: { radius: 80, strokeWidth: 10 } }, Ilt = P.forwardRef(((t, e) => { const { value: n, size: r = "md", className: i, showAnimation: a = !0, color: s, tooltip: o, radius: c, strokeWidth: u, children: d } = t, f = Et(t, ["value", "size", "className", "showAnimation", "color", "tooltip", "radius", "strokeWidth", "children"]), h = (m = n) === void 0 ? 0 : m > 100 ? 100 : m; var m; const g = c ?? tJ[r].radius, x = u ?? tJ[r].strokeWidth, v = g - x / 2, b = 2 * v * Math.PI, E = b - h / 100 * b, { tooltipProps: M, getReferenceProps: C } = Xl(); return P.createElement(P.Fragment, null, P.createElement(gl, Object.assign({ text: o }, M)), P.createElement("div", Object.assign({ ref: e, className: me(klt("root"), "flex flex-col items-center justify-center", i) }, f), P.createElement("svg", Object.assign({ ref: M.refs.setReference, width: 2 * g, height: 2 * g, viewBox: `0 0 ${2 * g} ${2 * g}`, className: "transform -rotate-90" }, C), P.createElement("circle", { r: v, cx: g, cy: g, strokeWidth: x, fill: "transparent", stroke: "", strokeLinecap: "round", className: me("transition-colors ease-linear", s ? `${jt(s, Dt.background).strokeColor} opacity-20 dark:opacity-25` : "stroke-tremor-brand-muted/50 dark:stroke-dark-tremor-brand-muted") }), h >= 0 ? P.createElement("circle", { r: v, cx: g, cy: g, strokeWidth: x, strokeDasharray: b + " " + b, strokeDashoffset: E, fill: "transparent", stroke: "", strokeLinecap: "round", className: me("transition-colors ease-linear", s ? jt(s, Dt.background).strokeColor : "stroke-tremor-brand dark:stroke-dark-tremor-brand", a ? "transition-all duration-300 ease-in-out" : "") }) : null), P.createElement("div", { className: me("absolute flex") }, d))) })); Ilt.displayName = "ProgressCircle"; const hme = Pn("Tracker"), pme = P.forwardRef(((t, e) => { const { color: n, tooltip: r } = t, i = Et(t, ["color", "tooltip"]), { tooltipProps: a, getReferenceProps: s } = Xl(); return P.createElement("div", Object.assign({ ref: jf([e, a.refs.setReference]), className: me(hme("trackingBlock"), "w-full h-full rounded-[1px] first:rounded-l-[4px] last:rounded-r-[4px]", jt(n ?? "gray", Dt.background).bgColor) }, i, s), P.createElement(gl, Object.assign({ text: r }, a))) })); pme.displayName = "TrackerBlock"; const Olt = P.forwardRef(((t, e) => { const { data: n = [], className: r } = t, i = Et(t, ["data", "className"]); return P.createElement("div", Object.assign({ ref: e, className: me(hme("root"), "h-10 flex items-center space-x-0.5", r) }, i), n.map(((a, s) => { var o; return P.createElement(pme, { key: (o = a.key) !== null && o !== void 0 ? o : s, color: a.color, tooltip: a.tooltip }) }))) })); Olt.displayName = "Tracker"; function Dlt() { const [t, e] = S.useState("month"), n = [{ title: "Total Interviews", value: "124", change: "+8.5%", trend: "up", icon: qc }, { title: "Avg. Duration", value: "52m", change: "-2.1%", trend: "down", icon: ni }, { title: "Success Rate", value: "92%", change: "+4.2%", trend: "up", icon: Fu }, { title: "This Month", value: "28", change: "+12.7%", trend: "up", icon: li }], r = { data: [{ date: "Week 1", Technical: 8, Behavioral: 6 }, { date: "Week 2", Technical: 12, Behavioral: 8 }, { date: "Week 3", Technical: 10, Behavioral: 7 }, { date: "Week 4", Technical: 14, Behavioral: 9 }] }, i = { data: [{ skill: "Technical Knowledge", value: 4.5 }, { skill: "Communication", value: 4.8 }, { skill: "Problem Solving", value: 4.2 }, { skill: "Time Management", value: 4.6 }, { skill: "Candidate Experience", value: 4.9 }, { skill: "Documentation", value: 4.3 }] }; return l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { className: "flex justify-between items-center", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-2xl font-bold", children: "Performance Statistics" }), l.jsx("p", { className: "text-muted-foreground", children: "Track your interviewing metrics and impact" })] }), l.jsxs("div", { className: "flex gap-2", children: [l.jsxs(Jn, { value: t, onValueChange: e, children: [l.jsx(qn, { className: "w-[180px]", children: l.jsx(er, { placeholder: "Select timeframe" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "week", children: "Last 7 days" }), l.jsx(ut, { value: "month", children: "Last 30 days" }), l.jsx(ut, { value: "quarter", children: "Last quarter" }), l.jsx(ut, { value: "year", children: "Last year" })] })] }), l.jsxs(vt, { variant: "outline", children: [l.jsx(FS, { className: "mr-2 h-4 w-4" }), "Export Report"] })] })] }), l.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-4 gap-4", children: n.map(a => l.jsxs(sn, { className: "p-4", children: [l.jsxs("div", { className: "flex justify-between items-start", children: [l.jsxs("div", { children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: a.title }), l.jsx("h3", { className: "text-2xl font-bold mt-1", children: a.value })] }), l.jsx(a.icon, { className: "h-5 w-5 text-muted-foreground" })] }), l.jsxs("div", { className: `text-sm mt-2 ${a.trend === "up" ? "text-success" : "text-destructive"}`, children: [a.change, " from last period"] })] }, a.title)) }), l.jsxs("div", { className: "grid lg:grid-cols-2 gap-6", children: [l.jsxs(sn, { className: "p-6", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Interview Activity" }), l.jsx(Az, { title: "Interview Activity", data: r.data, index: "date", categories: ["Technical", "Behavioral"] })] }), l.jsxs(sn, { className: "p-6", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Skills Assessment" }), l.jsx(i$, { className: "w-full flex justify-center items-center w-[100%] h-[80%]", data: i.data })] })] }), l.jsxs(sn, { className: "p-6", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Monthly Performance Breakdown" }), l.jsx(Nz, { data: [{ metric: "Technical Skills", Score: 4.8 }, { metric: "Communication", Score: 4.6 }, { metric: "Timeliness", Score: 4.9 }, { metric: "Feedback Quality", Score: 4.7 }, { metric: "Candidate Satisfaction", Score: 4.8 }], index: "metric", categories: ["Score"] })] })] }) } const $P = S.forwardRef(({ className: t, ...e }, n) => l.jsx("div", { className: "relative w-full overflow-auto", children: l.jsx("table", { ref: n, className: _t("w-full caption-bottom text-sm", t), ...e }) })); $P.displayName = "Table"; const zP = S.forwardRef(({ className: t, ...e }, n) => l.jsx("thead", { ref: n, className: _t("[&_tr]:border-b", t), ...e })); zP.displayName = "TableHeader"; const VP = S.forwardRef(({ className: t, ...e }, n) => l.jsx("tbody", { ref: n, className: _t("[&_tr:last-child]:border-0", t), ...e })); VP.displayName = "TableBody"; const Llt = S.forwardRef(({ className: t, ...e }, n) => l.jsx("tfoot", { ref: n, className: _t("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", t), ...e })); Llt.displayName = "TableFooter"; const Fg = S.forwardRef(({ className: t, ...e }, n) => l.jsx("tr", { ref: n, className: _t("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", t), ...e })); Fg.displayName = "TableRow"; const qa = S.forwardRef(({ className: t, ...e }, n) => l.jsx("th", { ref: n, className: _t("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", t), ...e })); qa.displayName = "TableHead"; const Xa = S.forwardRef(({ className: t, ...e }, n) => l.jsx("td", { ref: n, className: _t("p-4 align-middle [&:has([role=checkbox])]:pr-0", t), ...e })); Xa.displayName = "TableCell"; const Flt = S.forwardRef(({ className: t, ...e }, n) => l.jsx("caption", { ref: n, className: _t("mt-4 text-sm text-muted-foreground", t), ...e })); Flt.displayName = "TableCaption"; const B3 = ["09:00 AM", "10:00 AM", "11:00 AM", "12:00 PM", "02:00 PM", "03:00 PM", "04:00 PM", "05:00 PM"]; function Ult() { const t = Xc(), [e, n] = S.useState(new Date), [r, i] = S.useState(""), [a, s] = S.useState(void 0), { data: o, isLoading: c, error: u } = oo({ queryKey: ["interviewerAvailability", a ? xr(a, "yyyy-MM-dd") : "all"], queryFn: () => { const N = a ? xr(a, "yyyy-MM-dd") : void 0; return LT.getAvailability({ date: N, mode: "live", includeBooked: !0 }) }, enabled: !0 }), d = Cs({ mutationFn: N => LT.addAvailability({ date: N.date, time: N.time, mode: "live" }), onSuccess: () => { t.invalidateQueries({ queryKey: ["interviewerAvailability"] }), dt.success("Availability slot added successfully!"), i("") }, onError: N => { dt.error(N.message || "Failed to add availability slot") } }), f = Cs({ mutationFn: N => LT.deleteAvailability(N), onSuccess: () => { t.invalidateQueries({ queryKey: ["interviewerAvailability"] }), dt.success("Availability slot deleted successfully!") }, onError: N => { dt.error(N.message || "Failed to delete availability slot") } }), h = o?.data || [], m = new Date, g = vi(m), v = [...h.filter(N => { if (!N.date) return !1; try { const A = ao(N.date); if (isNaN(A.getTime())) return !1; const j = vi(A); if (tf(j, g)) return !1; if ($i(A, g)) { const O = m.getHours(), I = m.getMinutes(), D = O * 60 + I, [F, B, G] = N.time.split(/[: ]/); let z = parseInt(F); G === "PM" && z !== 12 && (z += 12), G === "AM" && z === 12 && (z = 0); const q = parseInt(B); return z * 60 + q > D } return !0 } catch { return !1 } })].sort((N, A) => { try { const j = ao(N.date).getTime(), O = ao(A.date).getTime(); return j !== O ? j - O : N.time.localeCompare(A.time) } catch { return 0 } }), b = () => { if (!e) { dt.error("Please select a date"); return } if (!r) { dt.error("Please select a time"); return } if (h.find(O => { if (!O.date) return !1; const I = xr(new Date(O.date), "yyyy-MM-dd"), D = xr(e, "yyyy-MM-dd"); return I === D && O.time === r && O.mode === "live" })) { dt.error("This time slot already exists for this date"); return } const A = vi(new Date), j = vi(e); if (tf(j, A)) { dt.error("Cannot add availability for past dates"); return } if ($i(j, A)) { const O = new Date, I = O.getHours(), D = O.getMinutes(), F = I * 60 + D, B = 30, [G, z, q] = r.split(/[: ]/); let Y = parseInt(G); q === "PM" && Y !== 12 && (Y += 12), q === "AM" && Y === 12 && (Y = 0); const Z = parseInt(z); if (Y * 60 + Z <= F + B) { dt.error("Cannot add availability for past times. Please select a time at least 30 minutes in the future"); return } } d.mutate({ date: xr(e, "yyyy-MM-dd"), time: r }) }, E = (N, A) => { if (A) { dt.error("Cannot delete a slot that has been booked"); return } confirm("Are you sure you want to delete this availability slot?") && f.mutate(N) }, M = N => new Date(N).toLocaleDateString("en-US", { weekday: "short", year: "numeric", month: "short", day: "numeric" }), C = N => { if (!N) return B3; const A = vi(new Date), j = vi(N); if ($i(j, A)) { const O = new Date, I = O.getHours(), D = O.getMinutes(), F = I * 60 + D, B = 30; return B3.filter(G => { const [z, q, Y] = G.split(/[: ]/); let Z = parseInt(z); Y === "PM" && Z !== 12 && (Z += 12), Y === "AM" && Z === 12 && (Z = 0); const $ = parseInt(q); return Z * 60 + $ > F + B }) } return B3 }; return l.jsxs("div", { className: "max-w-6xl mx-auto space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Availability Management" }), l.jsx("p", { className: "text-muted-foreground", children: "Set your available time slots for Live Mock Interviews" })] }), l.jsxs("div", { className: "grid lg:grid-cols-2 gap-6", children: [l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(HT, { className: "h-5 w-5 text-primary" }), "Add Availability"] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "calendar", children: "Select Date" }), l.jsx(kx, { mode: "single", selected: e, onSelect: n, className: "rounded-md mt-2 mx-auto flex justify-center items-center", disabled: N => { const A = vi(new Date), j = vi(N); return tf(j, A) } })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "time", children: "Select Time" }), l.jsxs(Jn, { value: r, onValueChange: i, children: [l.jsx(qn, { id: "time", children: l.jsx(er, { placeholder: "Select time slot" }) }), l.jsx(Xn, { children: C(e).map(N => l.jsx(ut, { value: N, children: N }, N)) })] })] }), l.jsx(vt, { onClick: b, disabled: !e || !r || d.isPending, className: "w-full", children: d.isPending ? l.jsxs(l.Fragment, { children: [l.jsx(sa, { className: "h-4 w-4 mr-2 animate-spin" }), "Adding..."] }) : l.jsxs(l.Fragment, { children: [l.jsx(HT, { className: "h-4 w-4 mr-2" }), "Add Slot"] }) })] })] }), l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(li, { className: "h-5 w-5 text-primary" }), "Filter by Date"] }), l.jsx(kx, { mode: "single", selected: a, onSelect: N => { s(N) }, className: "rounded-md mx-auto flex justify-center items-center", disabled: N => { const A = vi(new Date), j = vi(N); return tf(j, A) } }), a ? l.jsxs("div", { className: "mt-4 space-y-2", children: [l.jsxs("div", { className: "text-sm text-muted-foreground text-center", children: ["Showing slots for: ", l.jsx("span", { className: "font-medium", children: xr(a, "MMMM d, yyyy") })] }), l.jsx(vt, { variant: "outline", onClick: () => s(void 0), className: "w-full", children: "Clear Filter (Show All)" })] }) : l.jsx("div", { className: "text-sm text-muted-foreground text-center mt-4", children: "Select a date to filter slots" })] })] }), l.jsxs(Lt, { className: "p-6", children: [l.jsxs("h2", { className: "text-xl font-semibold mb-4 flex items-center gap-2", children: [l.jsx(ni, { className: "h-5 w-5 text-primary" }), "Your Availability Slots"] }), c ? l.jsxs("div", { className: "text-center py-8", children: [l.jsx(sa, { className: "h-8 w-8 animate-spin mx-auto text-muted-foreground" }), l.jsx("p", { className: "text-muted-foreground mt-2", children: "Loading availability slots..." })] }) : u ? l.jsx("div", { className: "text-center py-8 text-destructive", children: "Failed to load availability slots. Please try again." }) : v.length === 0 ? l.jsx("div", { className: "text-center py-8 text-muted-foreground", children: a ? `No availability slots found for ${xr(a, "MMMM d, yyyy")}. Try selecting a different date or add slots using the form above.` : "No availability slots set. Add slots using the form above." }) : l.jsx("div", { className: "overflow-x-auto", children: l.jsxs($P, { children: [l.jsx(zP, { children: l.jsxs(Fg, { children: [l.jsx(qa, { children: "Date" }), l.jsx(qa, { children: "Time" }), l.jsx(qa, { children: "Status" }), l.jsx(qa, { children: "Actions" })] }) }), l.jsx(VP, { children: v.map((N, A) => l.jsxs(Fg, { className: A % 2 === 0 ? "bg-muted/50" : "", children: [l.jsx(Xa, { className: "font-medium", children: M(N.date) }), l.jsx(Xa, { children: N.time }), l.jsx(Xa, { children: l.jsx(Jt, { variant: N.isBooked ? "default" : "secondary", className: N.isBooked ? "bg-green-500 hover:bg-green-600" : "", children: N.isBooked ? "Booked" : "Available" }) }), l.jsx(Xa, { children: l.jsx(vt, { variant: "ghost", size: "sm", onClick: () => E(N._id, N.isBooked), disabled: N.isBooked || f.isPending, className: "text-destructive hover:text-destructive hover:bg-destructive/10", children: f.isPending ? l.jsx(sa, { className: "h-4 w-4 animate-spin" }) : l.jsx(Bg, { className: "h-4 w-4" }) }) })] }, N._id)) })] }) })] })] }) } function Blt() { const t = ui(), { user: e } = La(), { data: n, isLoading: r, error: i } = oo({ queryKey: ["adminDashboard"], queryFn: () => s$.getAdminDashboard(), staleTime: 3e4 }), a = n?.data?.stats, s = n?.data?.recentNotifications || []; if (r) return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx(Ks, { className: "h-9 w-64 mb-2" }), l.jsx(Ks, { className: "h-5 w-96" })] }), l.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6", children: [1, 2, 3, 4].map(c => l.jsxs(Lt, { className: "p-6", children: [l.jsx(Ks, { className: "h-5 w-24 mb-4" }), l.jsx(Ks, { className: "h-8 w-20 mb-2" }), l.jsx(Ks, { className: "h-4 w-32" })] }, c)) })] }); if (i) return l.jsx("div", { className: "space-y-8 pb-20 lg:pb-8", children: l.jsx("div", { className: "flex items-center justify-center h-64", children: l.jsxs("div", { className: "text-center", children: [l.jsx(ji, { className: "h-12 w-12 text-destructive mx-auto mb-4" }), l.jsx("p", { className: "text-lg font-semibold mb-2", children: "Failed to load dashboard" }), l.jsx("p", { className: "text-muted-foreground mb-4", children: "Please try refreshing the page" }), l.jsx(vt, { onClick: () => window.location.reload(), children: "Refresh" })] }) }) }); const o = e?.name || "Admin"; return l.jsxs("div", { className: "space-y-6 sm:space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsxs("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: ["Welcome back, ", o, "! "] }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Platform overview and quick access to key management areas" })] }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6", children: [l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-2", children: [l.jsx("h3", { className: "text-xs sm:text-sm font-medium text-muted-foreground", children: "Total Users" }), l.jsx(qc, { className: "h-4 w-4 sm:h-5 sm:w-5 text-primary" })] }), l.jsx("p", { className: "text-2xl sm:text-3xl font-bold", children: a?.users?.total?.toLocaleString() || 0 }), a?.users?.growth !== void 0 && l.jsxs("p", { className: "text-xs sm:text-sm text-success mt-1", children: [l.jsx(Fu, { className: "h-3 w-3 inline mr-1" }), "+", a.users.growth, "% growth"] })] }), l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-2", children: [l.jsx("h3", { className: "text-xs sm:text-sm font-medium text-muted-foreground", children: "Active Users" }), l.jsx(oi, { className: "h-4 w-4 sm:h-5 sm:w-5 text-accent" })] }), l.jsx("p", { className: "text-2xl sm:text-3xl font-bold", children: a?.users?.active?.toLocaleString() || 0 }), l.jsxs("p", { className: "text-xs sm:text-sm text-muted-foreground mt-1", children: [a?.users?.total ? Math.round(a.users.active / a.users.total * 100) : 0, "% of total"] })] }), l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-2", children: [l.jsx("h3", { className: "text-xs sm:text-sm font-medium text-muted-foreground", children: "Total Interviews" }), l.jsx(Fo, { className: "h-4 w-4 sm:h-5 sm:w-5 text-success" })] }), l.jsx("p", { className: "text-2xl sm:text-3xl font-bold", children: a?.interviews?.total?.toLocaleString() || 0 }), l.jsxs("p", { className: "text-xs sm:text-sm text-muted-foreground mt-1", children: [a?.interviews?.newThisMonth || 0, " this month"] })] }), l.jsxs(Lt, { className: "p-4 sm:p-6 hover:shadow-md transition-shadow", children: [l.jsxs("div", { className: "flex items-center justify-between mb-2", children: [l.jsx("h3", { className: "text-xs sm:text-sm font-medium text-muted-foreground", children: "Success Rate" }), l.jsx(v1, { className: "h-4 w-4 sm:h-5 sm:w-5 text-warning" })] }), l.jsxs("p", { className: "text-2xl sm:text-3xl font-bold", children: [a?.interviews?.successRate || 0, "%"] }), l.jsxs("p", { className: "text-xs sm:text-sm text-muted-foreground mt-1", children: [a?.interviews?.completed || 0, " completed"] })] })] }), l.jsxs("div", { className: "grid lg:grid-cols-2 gap-4 sm:gap-6", children: [l.jsxs(Lt, { className: "p-4 sm:p-6", children: [l.jsxs("div", { className: "flex items-center justify-between mb-4 sm:mb-6", children: [l.jsxs("h3", { className: "text-base sm:text-lg font-semibold flex items-center gap-2", children: [l.jsx(ji, { className: "h-4 w-4 sm:h-5 sm:w-5 text-primary" }), "Recent Notifications"] }), l.jsx(vt, { variant: "ghost", size: "sm", onClick: () => t(cr.ADMIN_NOTIFICATIONS), className: "text-xs sm:text-sm", children: "View All" })] }), l.jsx("div", { className: "space-y-3 sm:space-y-4", children: s.length > 0 ? s.slice(0, 5).map(c => l.jsx($e.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, className: `p-3 rounded-lg border ${c.isRead ? "bg-muted/20" : "bg-primary/5 border-primary/20"}`, children: l.jsx("div", { className: "flex items-start justify-between gap-2", children: l.jsxs("div", { className: "flex-1 min-w-0", children: [l.jsx("p", { className: "text-xs sm:text-sm font-medium truncate", children: c.title }), l.jsx("p", { className: "text-xs text-muted-foreground mt-1 line-clamp-2", children: c.message }), c.createdAt && l.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: JFe(ao(c.createdAt), { addSuffix: !0 }) })] }) }) }, c._id)) : l.jsx("p", { className: "text-sm text-muted-foreground text-center py-8", children: "No recent notifications" }) })] }), l.jsxs(Lt, { className: "p-4 sm:p-6", children: [l.jsxs("h3", { className: "text-base sm:text-lg font-semibold mb-4 sm:mb-6 flex items-center gap-2", children: [l.jsx(h0, { className: "h-4 w-4 sm:h-5 sm:w-5 text-primary" }), "Quick Actions"] }), l.jsxs("div", { className: "grid grid-cols-2 gap-3 sm:gap-4", children: [l.jsxs(vt, { variant: "outline", className: "h-auto py-3 sm:py-4 flex flex-col items-center gap-2", onClick: () => t(cr.ADMIN_USERS), children: [l.jsx(bT, { className: "h-5 w-5 sm:h-6 sm:w-6" }), l.jsx("span", { className: "text-xs sm:text-sm", children: "Manage Users" })] }), l.jsxs(vt, { variant: "outline", className: "h-auto py-3 sm:py-4 flex flex-col items-center gap-2", onClick: () => t(cr.ADMIN_INTERVIEWS), children: [l.jsx(li, { className: "h-5 w-5 sm:h-6 sm:w-6" }), l.jsx("span", { className: "text-xs sm:text-sm", children: "Interviews" })] }), l.jsxs(vt, { variant: "outline", className: "h-auto py-3 sm:py-4 flex flex-col items-center gap-2", onClick: () => t(cr.ADMIN_RESOURCES), children: [l.jsx(TJ, { className: "h-5 w-5 sm:h-6 sm:w-6" }), l.jsx("span", { className: "text-xs sm:text-sm", children: "Resources" })] }), l.jsxs(vt, { variant: "outline", className: "h-auto py-3 sm:py-4 flex flex-col items-center gap-2", onClick: () => t(cr.ADMIN_NOTIFICATIONS), children: [l.jsx(ji, { className: "h-5 w-5 sm:h-6 sm:w-6" }), l.jsx("span", { className: "text-xs sm:text-sm", children: "Notifications" })] })] })] })] })] }) } function $lt() { const [t, e] = S.useState([]), [n, r] = S.useState(!0), [i, a] = S.useState(null), { addNotification: s } = OS(), o = f => { const h = "http://localhost:5000"; if (f.startsWith("http://") || f.startsWith("https://")) return f; let m = f; f.startsWith("/api/uploads/resumes/") && (m = f.replace("/api/uploads/resumes/", "")); const g = encodeURIComponent(m); return `${h}/api/uploads/resumes/${g}` }; S.useEffect(() => { c() }, []); const c = async () => { try { r(!0); const f = await t1.getPending(); e(f.data) } catch { dt.error("Failed to load pending interviewers") } finally { r(!1) } }, u = async f => { try { a(f); const h = t.find(m => m._id === f); await t1.approve(f), dt.success("Interviewer approved successfully"), s({ title: "Interviewer Approved", message: `${h?.name || "An interviewer"} has been approved and can now access the dashboard.`, type: "success" }), await c() } catch { dt.error("Failed to approve interviewer") } finally { a(null) } }, d = async f => { if (confirm("Are you sure you want to reject this interviewer application?")) try { a(f); const h = t.find(m => m._id === f); await t1.reject(f), dt.success("Interviewer application rejected"), s({ title: "Interviewer Rejected", message: `${h?.name || "An interviewer"} has been rejected.`, type: "info" }), await c() } catch { dt.error("Failed to reject interviewer") } finally { a(null) } }; return l.jsxs("div", { className: "space-y-6", children: [l.jsx($e.div, { initial: { opacity: 0, y: -20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .3 }, children: l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Pending Interviewer Applications" }), l.jsx("p", { className: "text-muted-foreground", children: "Review and manage interviewer applications awaiting approval" })] }), l.jsxs("div", { className: "flex items-center gap-3", children: [l.jsx(Jt, { variant: "outline", className: "text-lg px-4 py-2", children: n ? l.jsxs("span", { className: "flex items-center gap-2", children: [l.jsx(xT, { className: "h-4 w-4 animate-spin" }), "Loading..."] }) : l.jsxs("span", { className: "flex items-center gap-2", children: [l.jsx(ni, { className: "h-4 w-4" }), t.length, " Pending"] }) }), l.jsxs(on, { variant: "outline", onClick: c, disabled: n, children: [l.jsx(xT, { className: `h-4 w-4 mr-2 ${n ? "animate-spin" : ""}` }), "Refresh"] })] })] }) }), n ? l.jsx(sn, { className: "p-6", variant: "elevated", children: l.jsx("div", { className: "flex items-center justify-center h-64", children: l.jsxs("div", { className: "text-center", children: [l.jsx(xT, { className: "h-8 w-8 text-muted-foreground mx-auto mb-4 animate-spin" }), l.jsx("p", { className: "text-muted-foreground", children: "Loading pending interviewers..." })] }) }) }) : t.length === 0 ? l.jsx(sn, { className: "p-6", variant: "elevated", children: l.jsxs("div", { className: "text-center py-16", children: [l.jsx(ni, { className: "h-16 w-16 text-muted-foreground mx-auto mb-4" }), l.jsx("h3", { className: "text-xl font-semibold mb-2", children: "No Pending Applications" }), l.jsx("p", { className: "text-muted-foreground", children: "There are no pending interviewer applications at this time." })] }) }) : l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("div", { className: "mb-6", children: l.jsxs("p", { className: "text-sm text-muted-foreground", children: [t.length, " application", t.length !== 1 ? "s" : "", " pending review"] }) }), l.jsx("div", { className: "space-y-4", children: t.map((f, h) => l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: h * .1 }, className: "p-4 rounded-lg border border-border hover:border-primary/50 transition-colors", children: l.jsxs("div", { className: "flex items-start gap-4", children: [l.jsx(Vc, { className: "h-12 w-12", children: l.jsx(Hc, { children: f.name.split(" ").map(m => m[0]).join("").toUpperCase() }) }), l.jsxs("div", { className: "flex-1 space-y-3", children: [l.jsxs("div", { children: [l.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [l.jsx("h3", { className: "font-semibold", children: f.name }), l.jsxs(Jt, { variant: "outline", className: "text-xs", children: [l.jsx(ni, { className: "h-3 w-3 mr-1" }), "Pending"] })] }), l.jsxs("div", { className: "flex items-center gap-4 text-sm text-muted-foreground", children: [l.jsxs("span", { className: "flex items-center gap-1", children: [l.jsx(Lu, { className: "h-3 w-3" }), f.email] }), f.linkedin && l.jsxs("a", { href: f.linkedin, target: "_blank", rel: "noopener noreferrer", className: "flex items-center gap-1 hover:text-primary transition-colors", children: [l.jsx(SJ, { className: "h-3 w-3" }), "LinkedIn"] })] })] }), l.jsxs("div", { className: "grid md:grid-cols-2 gap-3 text-sm", children: [f.experience && l.jsxs("div", { className: "flex items-start gap-2", children: [l.jsx(G3, { className: "h-4 w-4 text-muted-foreground mt-0.5" }), l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Experience" }), l.jsx("p", { className: "text-muted-foreground", children: f.experience })] })] }), f.expertise && l.jsxs("div", { className: "flex items-start gap-2", children: [l.jsx(mA, { className: "h-4 w-4 text-muted-foreground mt-0.5" }), l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Expertise" }), l.jsx("p", { className: "text-muted-foreground", children: f.expertise })] })] }), f.resume && l.jsxs("div", { className: "flex items-start gap-2", children: [l.jsx(df, { className: "h-4 w-4 text-muted-foreground mt-0.5" }), l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Resume" }), l.jsx("a", { href: o(f.resume), target: "_blank", rel: "noopener noreferrer", className: "text-primary hover:underline text-xs", onClick: async m => { m.preventDefault(); const g = o(f.resume); try { const x = await fetch(g, { method: "HEAD" }); if (x.ok) window.open(g, "_blank"); else { const v = await x.json().catch(() => ({})); dt.error(v.message || "Resume file not found. The file may need to be re-uploaded.") } } catch { dt.error("Unable to access resume file.") } }, children: "View Resume" }), l.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: f.resume.includes("/") ? f.resume.split("/").pop() : f.resume })] })] }), l.jsxs("div", { className: "flex items-start gap-2", children: [l.jsx(hf, { className: "h-4 w-4 text-muted-foreground mt-0.5" }), l.jsxs("div", { children: [l.jsx("p", { className: "font-medium", children: "Applied" }), l.jsx("p", { className: "text-muted-foreground text-xs", children: new Date(f.createdAt).toLocaleDateString() })] })] })] }), l.jsxs("div", { className: "flex items-center gap-2 pt-2 border-t border-border", children: [l.jsxs(on, { onClick: () => u(f._id), disabled: i === f._id, className: "bg-success text-success-foreground hover:bg-success/90", size: "sm", children: [l.jsx(oi, { className: "h-4 w-4 mr-2" }), i === f._id ? "Approving..." : "Approve"] }), l.jsxs(on, { onClick: () => d(f._id), disabled: i === f._id, variant: "destructive", size: "sm", children: [l.jsx(LS, { className: "h-4 w-4 mr-2" }), i === f._id ? "Rejecting..." : "Reject"] })] })] })] }) }, f._id)) })] })] }) } const qd = { async getUsers(t) { const e = new URLSearchParams; t?.page && e.append("page", t.page.toString()), t?.limit && e.append("limit", t.limit.toString()), t?.role && e.append("role", t.role), t?.status && e.append("status", t.status), t?.search && e.append("search", t.search), t?.sortBy && e.append("sortBy", t.sortBy), t?.sortOrder && e.append("sortOrder", t.sortOrder); const n = e.toString(), r = n ? `${jn.users.getAll}?${n}` : jn.users.getAll; return Yn.get(r) }, async getUserById(t) { return Yn.get(jn.users.getById(t)) }, async createUser(t) { return Yn.post(jn.users.create, t) }, async updateUser(t, e) { return Yn.put(jn.users.update(t), e) }, async deleteUser(t) { return Yn.delete(jn.users.delete(t)) }, async changeRole(t, e) { return Yn.patch(jn.users.changeRole(t), e) }, async sendEmail(t, e) { return Yn.post(jn.users.sendEmail(t), e) }, async exportUsers(t) { const e = new URLSearchParams; t?.role && e.append("role", t.role), t?.status && e.append("status", t.status); const n = e.toString(), r = n ? `${jn.users.export}?${n}` : jn.users.export, i = await fetch(`http://localhost:5000${r}`, { method: "GET", credentials: "include" }); if (!i.ok) throw new Error("Failed to export users"); return i.blob() } }; function zlt() { const { user: t } = La(), e = Xc(), [n, r] = S.useState(1), i = 20, [a, s] = S.useState(""), [o, c] = S.useState("all"), [u, d] = S.useState("all"), [f, h] = S.useState(!1), [m, g] = S.useState(!1), [x, v] = S.useState(!1), [b, E] = S.useState(!1), [M, C] = S.useState(!1), [N, A] = S.useState(!1), [j, O] = S.useState(null), [I, D] = S.useState({ name: "", email: "", password: "", role: "trainee", status: "approved" }), [F, B] = S.useState({}), [G, z] = S.useState(""), [q, Y] = S.useState({ subject: "", message: "" }), { data: Z, isLoading: $, error: V, isFetching: K } = oo({ queryKey: ["adminUsers", o, u, a, n], queryFn: () => qd.getUsers({ page: n, limit: i, role: o !== "all" ? o : void 0, status: u !== "all" ? u : void 0, search: a || void 0 }), placeholderData: ee => ee, staleTime: 5e3 }), X = Z?.data || [], Q = Z?.pagination, re = Z?.stats || { total: 0, active: 0, inactive: 0, trainees: 0, interviewers: 0, admins: 0 }; S.useEffect(() => { const ee = setTimeout(() => { r(1) }, 500); return () => clearTimeout(ee) }, [a]); const ce = ee => { switch (ee) { case "approved": return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300"; case "pending_verification": return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300"; case "rejected": return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300"; default: return "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300" } }, be = ee => { switch (ee) { case "admin": return cx; case "interviewer": return bT; case "trainee": return lg; default: return lg } }, de = Cs({ mutationFn: ee => qd.createUser(ee), onSuccess: () => { e.invalidateQueries({ queryKey: ["adminUsers"] }), dt.success("User created successfully"), h(!1), D({ name: "", email: "", password: "", role: "trainee", status: "approved" }) }, onError: ee => { dt.error(ee.message || "Failed to create user") } }), ae = () => { if (!I.name || !I.email || !I.role) { dt.error("Please fill in all required fields"); return } if (I.password && I.password.length < 8) { dt.error("Password must be at least 8 characters"); return } de.mutate(I) }, se = Cs({ mutationFn: ({ id: ee, data: ne }) => qd.updateUser(ee, ne), onSuccess: () => { e.invalidateQueries({ queryKey: ["adminUsers"] }), dt.success("User updated successfully"), g(!1), O(null), B({}) }, onError: ee => { dt.error(ee.message || "Failed to update user") } }), he = () => { j && se.mutate({ id: j._id, data: F }) }, Ae = Cs({ mutationFn: ee => qd.deleteUser(ee), onSuccess: () => { e.invalidateQueries({ queryKey: ["adminUsers"] }), dt.success("User deleted successfully"), E(!1), O(null) }, onError: ee => { dt.error(ee.message || "Failed to delete user") } }), Ce = () => { j && Ae.mutate(j._id) }, fe = Cs({ mutationFn: ({ id: ee, role: ne }) => qd.changeRole(ee, { role: ne }), onSuccess: () => { e.invalidateQueries({ queryKey: ["adminUsers"] }), dt.success("User role updated successfully"), C(!1), O(null), z("") }, onError: ee => { dt.error(ee.message || "Failed to change user role") } }), oe = () => { !j || !G || fe.mutate({ id: j._id, role: G }) }, xe = Cs({ mutationFn: ({ id: ee, data: ne }) => qd.sendEmail(ee, ne), onSuccess: () => { dt.success("Email sent successfully"), A(!1), O(null), Y({ subject: "", message: "" }) }, onError: ee => { dt.error(ee.message || "Failed to send email") } }), _e = () => { if (!j || !q.subject || !q.message) { dt.error("Please fill in subject and message"); return } xe.mutate({ id: j._id, data: q }) }, je = async () => { try { const ee = await qd.exportUsers({ role: o !== "all" ? o : void 0, status: u !== "all" ? u : void 0 }), ne = window.URL.createObjectURL(ee), Re = document.createElement("a"); Re.href = ne, Re.download = `users-${new Date().getTime()}.csv`, document.body.appendChild(Re), Re.click(), window.URL.revokeObjectURL(ne), document.body.removeChild(Re), dt.success("Users exported successfully") } catch (ee) { dt.error(ee.message || "Failed to export users") } }, ke = ee => { O(ee), B({ name: ee.name, email: ee.email, role: ee.role, status: ee.status || "approved" }), g(!0) }, Ze = async ee => { try { const ne = await qd.getUserById(ee._id); O(ne.data), v(!0) } catch (ne) { dt.error(ne.message || "Failed to load user details") } }, Xe = ee => { O(ee), E(!0) }, nt = ee => { O(ee), z(ee.role || "trainee"), C(!0) }, Tt = ee => { O(ee), Y({ subject: "", message: "" }), A(!0) }, St = ee => { if (!ee) return "N/A"; try { return new Date(ee).toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" }) } catch { return "Invalid date" } }; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "User Management" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Manage users, roles, and permissions across the platform" })] }), Z && l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-4", children: [l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Total Users" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: re.total })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Active" }), l.jsx("p", { className: "text-2xl font-bold mt-1 text-green-500", children: re.active })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Inactive" }), l.jsx("p", { className: "text-2xl font-bold mt-1 text-muted-foreground", children: re.inactive })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Trainees" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: re.trainees })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Interviewers" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: re.interviewers })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Admins" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: re.admins })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("div", { className: "flex items-center justify-between mb-6", children: [l.jsxs("h2", { className: "text-xl font-semibold flex items-center gap-2", children: [l.jsx(bT, { className: "h-5 w-5 text-primary" }), "All Users"] }), l.jsxs(on, { onClick: () => h(!0), children: [l.jsx(bT, { className: "h-4 w-4 mr-2" }), "Add User"] })] }), l.jsxs("div", { className: "flex items-center gap-4 mb-6", children: [l.jsxs("div", { className: "relative flex-1", children: [l.jsx(lg, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { placeholder: "Search users by name or email...", className: "pl-10", value: a, onChange: ee => { s(ee.target.value), r(1) } })] }), l.jsxs(Jn, { value: o, onValueChange: ee => { c(ee), r(1) }, children: [l.jsx(qn, { className: "w-[180px]", children: l.jsx(er, { placeholder: "Role" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Roles" }), l.jsx(ut, { value: "admin", children: "Admin" }), l.jsx(ut, { value: "interviewer", children: "Interviewer" }), l.jsx(ut, { value: "trainee", children: "Trainee" })] })] }), l.jsxs(Jn, { value: u, onValueChange: ee => { d(ee), r(1) }, children: [l.jsx(qn, { className: "w-[180px]", children: l.jsx(er, { placeholder: "Status" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Status" }), l.jsx(ut, { value: "approved", children: "Approved" }), l.jsx(ut, { value: "pending_verification", children: "Pending" }), l.jsx(ut, { value: "rejected", children: "Rejected" })] })] }), l.jsxs(on, { variant: "outline", size: "sm", onClick: je, children: [l.jsx(FS, { className: "h-4 w-4 mr-2" }), "Export"] })] }), $ && !Z ? l.jsxs("div", { className: "text-center py-8", style: { minHeight: "200px" }, children: [l.jsx(sa, { className: "h-8 w-8 animate-spin mx-auto text-muted-foreground" }), l.jsx("p", { className: "text-muted-foreground mt-2", children: "Loading users..." })] }) : V ? l.jsx("div", { className: "text-center py-8 text-destructive", style: { minHeight: "200px" }, children: "Failed to load users. Please try again." }) : X.length === 0 && !K ? l.jsx("div", { className: "text-center py-8 text-muted-foreground", style: { minHeight: "200px" }, children: "No users found matching your filters." }) : l.jsxs(l.Fragment, { children: [l.jsx("div", { className: "overflow-x-auto -mx-4 sm:mx-0", style: { opacity: K && Z ? .6 : 1, transition: "opacity 0.2s" }, children: l.jsx("div", { className: "min-w-full inline-block align-middle", children: l.jsxs($P, { className: "min-w-[800px]", children: [l.jsx(zP, { children: l.jsxs(Fg, { children: [l.jsx(qa, { children: "Name" }), l.jsx(qa, { children: "Email" }), l.jsx(qa, { children: "Role" }), l.jsx(qa, { children: "Registration Date" }), l.jsx(qa, { children: "Status" }), l.jsx(qa, { className: "text-right", children: "Actions" })] }) }), l.jsx(VP, { children: X.map(ee => { const ne = be(ee.role), Re = ee && typeof ee == "object" && ("_id" in ee && ee._id || "id" in ee && ee.id) || "", et = (t && typeof t == "object" && ("_id" in t && t._id || "id" in t && t.id) || "") === Re; return l.jsxs(Fg, { children: [l.jsx(Xa, { children: l.jsxs("div", { className: "flex items-center gap-3", children: [l.jsxs(Vc, { className: "h-8 w-8", children: [l.jsx(xf, { src: `https://api.dicebear.com/7.x/avataaars/svg?seed=${ee.name || ee.email || "user"}` }), l.jsx(Hc, { children: ee.name?.split(" ").map(Ge => Ge[0]).join("") || ee.email?.[0]?.toUpperCase() || "U" })] }), l.jsx("div", { children: l.jsxs("div", { className: "font-medium flex items-center gap-2", children: [ee.name || "No name", et && l.jsx(Jt, { variant: "outline", className: "text-xs", children: "You" })] }) })] }) }), l.jsx(Xa, { children: l.jsx("div", { className: "text-sm", children: ee.email || "No email" }) }), l.jsx(Xa, { children: l.jsxs("div", { className: "flex items-center gap-2", children: [ne && l.jsx(ne, { className: "h-4 w-4" }), l.jsx("span", { className: "text-sm capitalize", children: ee.role || "trainee" })] }) }), l.jsx(Xa, { children: l.jsx("div", { className: "text-sm", children: St(ee.createdAt) }) }), l.jsx(Xa, { children: l.jsx(Jt, { className: ce(ee.status || "approved"), children: String(ee.status || "approved").replace(/_/g, " ") }) }), l.jsx(Xa, { className: "text-right", children: l.jsxs(e_, { children: [l.jsx(t_, { asChild: !0, children: l.jsx(vt, { variant: "ghost", size: "sm", disabled: et, children: l.jsx(u5, { className: "h-4 w-4" }) }) }), l.jsxs(T0, { align: "end", children: [l.jsxs(Xs, { onClick: () => Ze(ee), children: [l.jsx(Du, { className: "h-4 w-4 mr-2" }), "View Details"] }), l.jsxs(Xs, { onClick: () => ke(ee), disabled: et, children: [l.jsx(m5, { className: "h-4 w-4 mr-2" }), "Edit"] }), l.jsxs(Xs, { onClick: () => nt(ee), disabled: et, children: [l.jsx(cx, { className: "h-4 w-4 mr-2" }), "Change Role"] }), l.jsxs(Xs, { onClick: () => Tt(ee), disabled: et, children: [l.jsx(Lu, { className: "h-4 w-4 mr-2" }), "Send Email"] }), l.jsxs(Xs, { onClick: () => Xe(ee), className: "text-destructive", disabled: et, children: [l.jsx(Bg, { className: "h-4 w-4 mr-2" }), "Delete"] })] })] }) })] }, String(Re)) }) })] }) }) }), l.jsx("div", { className: "flex items-center justify-center mt-4 pt-4 border-t", children: l.jsxs("div", { className: "text-sm text-muted-foreground", children: ["Showing ", Q?.total || 0, " result", Q?.total !== 1 ? "s" : "", " out of ", re.total || 0, " total"] }) }), Q && Q.pages > 1 && l.jsxs("div", { className: "flex items-center justify-between mt-4", children: [l.jsxs("div", { className: "text-sm text-muted-foreground", children: ["Page ", Q.page, " of ", Q.pages] }), l.jsxs("div", { className: "flex gap-2", children: [l.jsx(vt, { variant: "outline", size: "sm", disabled: n === 1, onClick: () => r(n - 1), children: "Previous" }), l.jsx(vt, { variant: "outline", size: "sm", disabled: n >= Q.pages, onClick: () => r(n + 1), children: "Next" })] })] })] })] }), l.jsx(sl, { open: f, onOpenChange: h, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Add New User" }), l.jsx(ol, { children: "Create a new user account" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "name", children: "Name *" }), l.jsx(fn, { id: "name", value: I.name, onChange: ee => D({ ...I, name: ee.target.value }), placeholder: "John Doe" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "email", children: "Email *" }), l.jsx(fn, { id: "email", type: "email", value: I.email, onChange: ee => D({ ...I, email: ee.target.value }), placeholder: "john@example.com" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "password", children: "Password" }), l.jsx(fn, { id: "password", type: "password", value: I.password, onChange: ee => D({ ...I, password: ee.target.value }), placeholder: "Leave empty for user to set" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "role", children: "Role *" }), l.jsxs(Jn, { value: I.role, onValueChange: ee => D({ ...I, role: ee }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "trainee", children: "Trainee" }), l.jsx(ut, { value: "interviewer", children: "Interviewer" }), l.jsx(ut, { value: "admin", children: "Admin" })] })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "status", children: "Status" }), l.jsxs(Jn, { value: I.status, onValueChange: ee => D({ ...I, status: ee }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "approved", children: "Approved" }), l.jsx(ut, { value: "pending_verification", children: "Pending Verification" }), l.jsx(ut, { value: "rejected", children: "Rejected" })] })] })] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => h(!1), children: "Cancel" }), l.jsx(on, { onClick: ae, children: "Create User" })] })] }) }), l.jsx(sl, { open: m, onOpenChange: g, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Edit User" }), l.jsx(ol, { children: "Update user information" })] }), j && l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-name", children: "Name" }), l.jsx(fn, { id: "edit-name", value: F.name || j?.name || "", onChange: ee => B({ ...F, name: ee.target.value }) })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-email", children: "Email" }), l.jsx(fn, { id: "edit-email", type: "email", value: F.email || j?.email || "", onChange: ee => B({ ...F, email: ee.target.value }) })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-password", children: "New Password (leave empty to keep current)" }), l.jsx(fn, { id: "edit-password", type: "password", value: F.password || "", onChange: ee => B({ ...F, password: ee.target.value }), placeholder: "Enter new password" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-role", children: "Role" }), l.jsxs(Jn, { value: F.role || j?.role, onValueChange: ee => B({ ...F, role: ee }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "trainee", children: "Trainee" }), l.jsx(ut, { value: "interviewer", children: "Interviewer" }), l.jsx(ut, { value: "admin", children: "Admin" })] })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-status", children: "Status" }), l.jsxs(Jn, { value: F.status || j?.status || "approved", onValueChange: ee => B({ ...F, status: ee }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "approved", children: "Approved" }), l.jsx(ut, { value: "pending_verification", children: "Pending Verification" }), l.jsx(ut, { value: "rejected", children: "Rejected" })] })] })] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => g(!1), children: "Cancel" }), l.jsx(on, { onClick: he, children: "Save Changes" })] })] }) }), l.jsx(sl, { open: x, onOpenChange: v, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "User Details" }), l.jsx(ol, { children: "Complete user information" })] }), j && l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center gap-4", children: [l.jsxs(Vc, { className: "h-16 w-16", children: [l.jsx(xf, { src: `https://api.dicebear.com/7.x/avataaars/svg?seed=${j.name || j.email}` }), l.jsx(Hc, { children: j.name?.split(" ").map(ee => ee[0]).join("") || j.email[0].toUpperCase() })] }), l.jsxs("div", { children: [l.jsx("h3", { className: "font-semibold text-lg", children: j.name || "No name" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: j.email })] })] }), l.jsxs("div", { className: "grid grid-cols-2 gap-4 pt-4 border-t", children: [l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Role" }), l.jsx("p", { className: "font-medium", children: j.role.charAt(0).toUpperCase() + j.role.slice(1) })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Status" }), l.jsx(Jt, { className: ce(j.status || "approved"), children: String(j.status || "approved").replace(/_/g, " ") })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Created At" }), l.jsx("p", { className: "font-medium", children: St(j.createdAt) })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Last Updated" }), l.jsx("p", { className: "font-medium", children: St(j.updatedAt) })] })] })] }), l.jsx(kc, { children: l.jsx(on, { variant: "outline", onClick: () => v(!1), children: "Close" }) })] }) }), l.jsx(sl, { open: b, onOpenChange: E, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Delete User" }), l.jsxs(ol, { children: ["Are you sure you want to delete ", j?.name || j?.email, "? This action cannot be undone."] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => E(!1), children: "Cancel" }), l.jsx(on, { variant: "destructive", onClick: () => { Ce() }, children: "Delete" })] })] }) }), l.jsx(sl, { open: M, onOpenChange: C, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Change User Role" }), l.jsxs(ol, { children: ["Update the role for ", j?.name || j?.email] })] }), l.jsx("div", { className: "space-y-4", children: l.jsxs("div", { children: [l.jsx(We, { htmlFor: "role-select", children: "New Role" }), l.jsxs(Jn, { value: G, onValueChange: z, children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "trainee", children: "Trainee" }), l.jsx(ut, { value: "interviewer", children: "Interviewer" }), l.jsx(ut, { value: "admin", children: "Admin" })] })] })] }) }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => C(!1), children: "Cancel" }), l.jsx(on, { onClick: oe, children: "Update Role" })] })] }) }), l.jsx(sl, { open: N, onOpenChange: A, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Send Email" }), l.jsxs(ol, { children: ["Send an email to ", j?.name || j?.email] })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "email-subject", children: "Subject *" }), l.jsx(fn, { id: "email-subject", value: q.subject, onChange: ee => Y({ ...q, subject: ee.target.value }), placeholder: "Email subject" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "email-message", children: "Message *" }), l.jsx(Ag, { id: "email-message", value: q.message, onChange: ee => Y({ ...q, message: ee.target.value }), placeholder: "Email message", rows: 6 })] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => A(!1), children: "Cancel" }), l.jsx(on, { onClick: _e, children: "Send Email" })] })] }) })] }) } var mme = "AlertDialog", [Vlt] = oa(mme, [Zre]), If = Zre(), gme = t => { const { __scopeAlertDialog: e, ...n } = t, r = If(e); return l.jsx(hie, { ...r, ...n, modal: !0 }) }; gme.displayName = mme; var Hlt = "AlertDialogTrigger", Wlt = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, ...r } = t, i = If(n); return l.jsx(pie, { ...i, ...r, ref: e }) }); Wlt.displayName = Hlt; var Glt = "AlertDialogPortal", vme = t => { const { __scopeAlertDialog: e, ...n } = t, r = If(e); return l.jsx(mie, { ...r, ...n }) }; vme.displayName = Glt; var qlt = "AlertDialogOverlay", yme = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, ...r } = t, i = If(n); return l.jsx(OU, { ...i, ...r, ref: e }) }); yme.displayName = qlt; var ox = "AlertDialogContent", [Xlt, Ylt] = Vlt(ox), Klt = kJ("AlertDialogContent"), xme = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, children: r, ...i } = t, a = If(n), s = S.useRef(null), o = Mn(e, s), c = S.useRef(null); return l.jsx(jCe, { contentName: ox, titleName: bme, docsSlug: "alert-dialog", children: l.jsx(Xlt, { scope: n, cancelRef: c, children: l.jsxs(DU, { role: "alertdialog", ...a, ...i, ref: o, onOpenAutoFocus: Mt(i.onOpenAutoFocus, u => { u.preventDefault(), c.current?.focus({ preventScroll: !0 }) }), onPointerDownOutside: u => u.preventDefault(), onInteractOutside: u => u.preventDefault(), children: [l.jsx(Klt, { children: r }), l.jsx(Qlt, { contentRef: s })] }) }) }) }); xme.displayName = ox; var bme = "AlertDialogTitle", wme = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, ...r } = t, i = If(n); return l.jsx(LU, { ...i, ...r, ref: e }) }); wme.displayName = bme; var Sme = "AlertDialogDescription", _me = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, ...r } = t, i = If(n); return l.jsx(FU, { ...i, ...r, ref: e }) }); _me.displayName = Sme; var Zlt = "AlertDialogAction", Eme = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, ...r } = t, i = If(n); return l.jsx(UU, { ...i, ...r, ref: e }) }); Eme.displayName = Zlt; var Mme = "AlertDialogCancel", Tme = S.forwardRef((t, e) => { const { __scopeAlertDialog: n, ...r } = t, { cancelRef: i } = Ylt(Mme, n), a = If(n), s = Mn(e, i); return l.jsx(UU, { ...a, ...r, ref: s }) }); Tme.displayName = Mme; var Qlt = ({ contentRef: t }) => {
	const e = `\`${ox}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${ox}\` by passing a \`${Sme}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${ox}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`; return S.useEffect(() => { document.getElementById(t.current?.getAttribute("aria-describedby")) || console.warn(e) }, [e, t]), null
}, Jlt = gme, ect = vme, Cme = yme, Nme = xme, Ame = Eme, Pme = Tme, jme = wme, Rme = _me; const tct = Jlt, nct = ect, kme = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Cme, { className: _t("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", t), ...e, ref: n })); kme.displayName = Cme.displayName; const Ime = S.forwardRef(({ className: t, ...e }, n) => l.jsxs(nct, { children: [l.jsx(kme, {}), l.jsx(Nme, { ref: n, className: _t("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", t), ...e })] })); Ime.displayName = Nme.displayName; const Ome = ({ className: t, ...e }) => l.jsx("div", { className: _t("flex flex-col space-y-2 text-center sm:text-left", t), ...e }); Ome.displayName = "AlertDialogHeader"; const Dme = ({ className: t, ...e }) => l.jsx("div", { className: _t("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", t), ...e }); Dme.displayName = "AlertDialogFooter"; const Lme = S.forwardRef(({ className: t, ...e }, n) => l.jsx(jme, { ref: n, className: _t("text-lg font-semibold", t), ...e })); Lme.displayName = jme.displayName; const Fme = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Rme, { ref: n, className: _t("text-sm text-muted-foreground", t), ...e })); Fme.displayName = Rme.displayName; const Ume = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Ame, { ref: n, className: _t(b1(), t), ...e })); Ume.displayName = Ame.displayName; const Bme = S.forwardRef(({ className: t, ...e }, n) => l.jsx(Pme, { ref: n, className: _t(b1({ variant: "outline" }), "mt-2 sm:mt-0", t), ...e })); Bme.displayName = Pme.displayName; const $3 = { async getInterviews(t) { const e = new URLSearchParams; t?.mode && t.mode !== "all" && e.append("mode", t.mode), t?.status && t.status !== "all" && e.append("status", t.status), t?.search && e.append("search", t.search), t?.page && e.append("page", t.page.toString()), t?.limit && e.append("limit", t.limit.toString()); const n = e.toString() ? `?${e.toString()}` : ""; return Yn.get(`${jn.admin.interviews.getAll}${n}`) }, async updateInterview(t, e) { return Yn.put(jn.admin.interviews.update(t), e) }, async cancelInterview(t, e) { return Yn.post(jn.admin.interviews.cancel(t), e || {}) } }, rct = ["09:00 AM", "10:00 AM", "11:00 AM", "12:00 PM", "02:00 PM", "03:00 PM", "04:00 PM", "05:00 PM"]; function ict() { const t = Xc(), [e, n] = S.useState("all"), [r, i] = S.useState("all"), [a, s] = S.useState(""), [o, c] = S.useState(1), [u, d] = S.useState(!1), [f, h] = S.useState(!1), [m, g] = S.useState(null), [x, v] = S.useState(""), [b, E] = S.useState({ status: "", interviewerId: "", timeSlot: "", scheduledDate: "" }), { data: M, isLoading: C, error: N, isFetching: A } = oo({ queryKey: ["adminInterviews", e, r, a, o], queryFn: () => $3.getInterviews({ mode: e, status: r, search: a || void 0, page: o, limit: 20 }), placeholderData: V => V, staleTime: 5e3 }), { data: j } = oo({ queryKey: ["approvedInterviewers"], queryFn: () => qd.getUsers({ role: "interviewer", status: "approved", limit: 100 }), enabled: u && m?.mode === "live" }), O = Cs({ mutationFn: V => $3.updateInterview(m._id, V), onSuccess: () => { t.invalidateQueries({ queryKey: ["adminInterviews"] }), dt.success("Interview updated successfully"), d(!1), g(null), E({ status: "", interviewerId: "", timeSlot: "", scheduledDate: "" }) }, onError: V => { dt.error(V.message || "Failed to update interview") } }), I = Cs({ mutationFn: () => $3.cancelInterview(m._id, { reason: x || void 0 }), onSuccess: () => { t.invalidateQueries({ queryKey: ["adminInterviews"] }), dt.success("Interview cancelled successfully"), h(!1), g(null), v("") }, onError: V => { dt.error(V.message || "Failed to cancel interview") } }), D = M?.data || [], F = M?.pagination, B = V => { g(V), E({ status: V.status, interviewerId: V.interviewer?.id || "", timeSlot: V.timeSlot, scheduledDate: V.scheduledDate ? V.scheduledDate.split("T")[0] : "" }), d(!0) }, G = V => { g(V), v(""), h(!0) }, z = () => { if (!m) return; const V = {}; if (b.status && b.status !== m.status && (V.status = b.status), m.mode === "live" && (b.interviewerId && b.interviewerId !== m.interviewer?.id && (V.interviewerId = b.interviewerId || null), b.timeSlot && b.timeSlot !== m.timeSlot && (V.timeSlot = b.timeSlot), b.scheduledDate && (V.scheduledDate = b.scheduledDate)), Object.keys(V).length === 0) { dt.info("No changes to save"); return } O.mutate(V) }, q = V => { switch (V) { case "completed": return l.jsx(Jt, { className: "bg-green-500 hover:bg-green-600", children: "Completed" }); case "in_progress": return l.jsx(Jt, { className: "bg-yellow-500 hover:bg-yellow-600", children: "In Progress" }); case "scheduled": return l.jsx(Jt, { className: "bg-blue-500 hover:bg-blue-600", children: "Scheduled" }); case "cancelled": return l.jsx(Jt, { variant: "destructive", children: "Cancelled" }); case "no_show": return l.jsx(Jt, { variant: "secondary", children: "No Show" }); default: return l.jsx(Jt, { children: V }) } }, Y = V => { switch (V) { case "ai": return l.jsx(ro, { className: "h-4 w-4" }); case "peer": return l.jsx(qc, { className: "h-4 w-4" }); case "family": return l.jsx(US, { className: "h-4 w-4" }); case "live": return l.jsx(Fo, { className: "h-4 w-4" }) } }, Z = V => { switch (V) { case "ai": return "AI-Powered"; case "peer": return "Peer-to-Peer"; case "family": return "Family & Friends"; case "live": return "Live Mock" } }, $ = (V, K) => `${new Date(V).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" })} at ${K}`; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "Interviews Management" }), l.jsx("p", { className: "text-muted-foreground", children: "Monitor and manage interview sessions across the platform" })] }), M && l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "grid grid-cols-1 md:grid-cols-4 gap-4", children: [l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Total Interviews" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: M.stats?.total || 0 })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Scheduled" }), l.jsx("p", { className: "text-2xl font-bold mt-1 text-blue-500", children: M.stats?.scheduled || 0 })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "In Progress" }), l.jsx("p", { className: "text-2xl font-bold mt-1 text-yellow-500", children: M.stats?.in_progress || 0 })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Completed" }), l.jsx("p", { className: "text-2xl font-bold mt-1 text-green-500", children: M.stats?.completed || 0 })] })] }), l.jsxs(sn, { className: "p-4 sm:p-6", variant: "elevated", children: [l.jsxs("div", { className: "flex flex-col sm:flex-row items-stretch sm:items-center gap-3 sm:gap-4 mb-6", children: [l.jsxs("div", { className: "relative flex-1 min-w-0", children: [l.jsx(lg, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { placeholder: "Search by trainee or interviewer name...", className: "pl-10 w-full", value: a, onChange: V => { s(V.target.value), c(1) } })] }), l.jsxs(Jn, { value: e, onValueChange: V => { n(V), c(1) }, children: [l.jsx(qn, { className: "w-full sm:w-[180px]", children: l.jsx(er, { placeholder: "Mode" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Modes" }), l.jsx(ut, { value: "ai", children: "AI-Powered" }), l.jsx(ut, { value: "peer", children: "Peer-to-Peer" }), l.jsx(ut, { value: "family", children: "Family & Friends" }), l.jsx(ut, { value: "live", children: "Live Mock" })] })] }), l.jsxs(Jn, { value: r, onValueChange: V => { i(V), c(1) }, children: [l.jsx(qn, { className: "w-full sm:w-[180px]", children: l.jsx(er, { placeholder: "Status" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Status" }), l.jsx(ut, { value: "scheduled", children: "Scheduled" }), l.jsx(ut, { value: "in_progress", children: "In Progress" }), l.jsx(ut, { value: "completed", children: "Completed" }), l.jsx(ut, { value: "cancelled", children: "Cancelled" }), l.jsx(ut, { value: "no_show", children: "No Show" })] })] })] }), C && !M ? l.jsxs("div", { className: "text-center py-8", style: { minHeight: "200px" }, children: [l.jsx(sa, { className: "h-8 w-8 animate-spin mx-auto text-muted-foreground" }), l.jsx("p", { className: "text-muted-foreground mt-2", children: "Loading interviews..." })] }) : N ? l.jsx("div", { className: "text-center py-8 text-destructive", style: { minHeight: "200px" }, children: "Failed to load interviews. Please try again." }) : D.length === 0 && !A ? l.jsx("div", { className: "text-center py-8 text-muted-foreground", style: { minHeight: "200px" }, children: "No interviews found matching your filters." }) : l.jsxs(l.Fragment, { children: [l.jsx("div", { className: "overflow-x-auto -mx-4 sm:mx-0", style: { opacity: A && M ? .6 : 1, transition: "opacity 0.2s" }, children: l.jsx("div", { className: "min-w-full inline-block align-middle", children: l.jsxs($P, { className: "min-w-[800px]", children: [l.jsx(zP, { children: l.jsxs(Fg, { children: [l.jsx(qa, { children: "Booking ID" }), l.jsx(qa, { children: "Mode" }), l.jsx(qa, { children: "Trainee" }), l.jsx(qa, { children: "Interviewer" }), l.jsx(qa, { children: "Date & Time" }), l.jsx(qa, { children: "Status" }), l.jsx(qa, { className: "text-right", children: "Actions" })] }) }), l.jsx(VP, { children: D.map(V => l.jsxs(Fg, { children: [l.jsx(Xa, { className: "font-mono text-xs", children: V._id.slice(-8) }), l.jsx(Xa, { children: l.jsxs("div", { className: "flex items-center gap-2", children: [Y(V.mode), l.jsx("span", { className: "text-sm", children: Z(V.mode) })] }) }), l.jsx(Xa, { children: l.jsxs("div", { children: [l.jsx("div", { className: "font-medium", children: V.trainee?.name || "N/A" }), l.jsx("div", { className: "text-xs text-muted-foreground", children: V.trainee?.email })] }) }), l.jsx(Xa, { children: V.interviewer ? l.jsxs("div", { children: [l.jsx("div", { className: "font-medium", children: V.interviewer.name }), l.jsx("div", { className: "text-xs text-muted-foreground", children: V.interviewer.email })] }) : l.jsx("span", { className: "text-muted-foreground", children: "N/A" }) }), l.jsxs(Xa, { children: [l.jsx("div", { className: "text-sm", children: $(V.scheduledDate, V.timeSlot) }), l.jsxs("div", { className: "text-xs text-muted-foreground", children: [V.duration, " min"] })] }), l.jsx(Xa, { children: q(V.status) }), l.jsx(Xa, { className: "text-right", children: l.jsxs(e_, { children: [l.jsx(t_, { asChild: !0, children: l.jsx(vt, { variant: "ghost", size: "sm", children: l.jsx(u5, { className: "h-4 w-4" }) }) }), l.jsxs(T0, { align: "end", children: [l.jsxs(Xs, { onClick: () => B(V), children: [l.jsx(m5, { className: "h-4 w-4 mr-2" }), "Edit"] }), V.status !== "cancelled" && V.status !== "completed" && l.jsxs(Xs, { onClick: () => G(V), className: "text-destructive", children: [l.jsx(Bg, { className: "h-4 w-4 mr-2" }), "Cancel"] })] })] }) })] }, V._id)) })] }) }) }), l.jsx("div", { className: "flex items-center justify-center mt-4 pt-4 border-t", children: l.jsxs("div", { className: "text-sm text-muted-foreground", children: ["Showing ", F?.total || 0, " result", F?.total !== 1 ? "s" : "", " out of ", M?.stats?.total || 0, " total"] }) }), F && F.pages > 1 && l.jsxs("div", { className: "flex items-center justify-between mt-4", children: [l.jsxs("div", { className: "text-sm text-muted-foreground", children: ["Page ", F.page, " of ", F.pages] }), l.jsxs("div", { className: "flex gap-2", children: [l.jsx(vt, { variant: "outline", size: "sm", disabled: o === 1, onClick: () => c(o - 1), children: "Previous" }), l.jsx(vt, { variant: "outline", size: "sm", disabled: o >= F.pages, onClick: () => c(o + 1), children: "Next" })] })] })] })] }), l.jsx(sl, { open: u, onOpenChange: d, children: l.jsxs(jo, { className: "max-w-2xl", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Edit Interview" }), l.jsx(ol, { children: "Update interview details. Changes will be notified to the trainee and interviewer." })] }), m && l.jsxs("div", { className: "space-y-4 py-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "edit-status", children: "Status" }), l.jsxs(Jn, { value: b.status, onValueChange: V => E({ ...b, status: V }), children: [l.jsx(qn, { id: "edit-status", children: l.jsx(er, {}) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "scheduled", children: "Scheduled" }), l.jsx(ut, { value: "in_progress", children: "In Progress" }), l.jsx(ut, { value: "completed", children: "Completed" }), l.jsx(ut, { value: "no_show", children: "No Show" })] })] })] }), m.mode === "live" && l.jsxs(l.Fragment, { children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "edit-interviewer", children: "Interviewer" }), l.jsxs(Jn, { value: b.interviewerId, onValueChange: V => E({ ...b, interviewerId: V }), children: [l.jsx(qn, { id: "edit-interviewer", children: l.jsx(er, { placeholder: "Select interviewer" }) }), l.jsx(Xn, { children: j?.data.filter(V => V.status === "approved").map(V => l.jsxs(ut, { value: V._id, children: [V.name, " (", V.email, ")"] }, V._id)) })] })] }), l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "edit-date", children: "Date" }), l.jsx(fn, { id: "edit-date", type: "date", value: b.scheduledDate, onChange: V => E({ ...b, scheduledDate: V.target.value }), min: new Date().toISOString().split("T")[0] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "edit-time", children: "Time" }), l.jsxs(Jn, { value: b.timeSlot, onValueChange: V => E({ ...b, timeSlot: V }), children: [l.jsx(qn, { id: "edit-time", children: l.jsx(er, { placeholder: "Select time" }) }), l.jsx(Xn, { children: rct.map(V => l.jsx(ut, { value: V, children: V }, V)) })] })] })] })] })] }), l.jsxs(kc, { children: [l.jsx(vt, { variant: "outline", onClick: () => d(!1), children: "Cancel" }), l.jsx(vt, { onClick: z, disabled: O.isPending, children: O.isPending ? l.jsxs(l.Fragment, { children: [l.jsx(sa, { className: "h-4 w-4 mr-2 animate-spin" }), "Saving..."] }) : "Save Changes" })] })] }) }), l.jsx(tct, { open: f, onOpenChange: h, children: l.jsxs(Ime, { children: [l.jsxs(Ome, { children: [l.jsx(Lme, { children: "Cancel Interview" }), l.jsx(Fme, { children: "Are you sure you want to cancel this interview? This action will free up the time slot and notify both the trainee and interviewer." })] }), l.jsxs("div", { className: "space-y-2 py-4", children: [l.jsx(We, { htmlFor: "cancel-reason", children: "Reason (Optional)" }), l.jsx(Ag, { id: "cancel-reason", placeholder: "Enter cancellation reason...", value: x, onChange: V => v(V.target.value), rows: 3 })] }), l.jsxs(Dme, { children: [l.jsx(Bme, { children: "Keep Interview" }), l.jsx(Ume, { onClick: () => I.mutate(), className: "bg-destructive text-destructive-foreground hover:bg-destructive/90", disabled: I.isPending, children: I.isPending ? l.jsxs(l.Fragment, { children: [l.jsx(sa, { className: "h-4 w-4 mr-2 animate-spin" }), "Cancelling..."] }) : "Cancel Interview" })] })] }) })] }) } const Ny = [{ value: "guide", label: "Guide", icon: Kh }, { value: "video", label: "Video Tutorial", icon: Fo }, { value: "question_bank", label: "Question Bank", icon: df }, { value: "course", label: "Course", icon: MJ }, { value: "article", label: "Article", icon: yJ }], yT = [{ value: "beginner", label: "Beginner", color: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300" }, { value: "intermediate", label: "Intermediate", color: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300" }, { value: "advanced", label: "Advanced", color: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300" }]; function act() { const [t, e] = S.useState([]), [n, r] = S.useState(!0), [i, a] = S.useState({ total: 0, guides: 0, videos: 0, question_banks: 0, courses: 0, articles: 0 }), [s, o] = S.useState(""), [c, u] = S.useState("all"), [d, f] = S.useState("all"), [h, m] = S.useState("all"), [g, x] = S.useState("all"), [v, b] = S.useState([]), [E, M] = S.useState([]), [C, N] = S.useState(!1), [A, j] = S.useState(!1), [O, I] = S.useState(!1), [D, F] = S.useState(!1), [B, G] = S.useState(null), [z, q] = S.useState({ resourceType: "guide", title: "", description: "", difficulty: "beginner", category: "", contentUrl: "", thumbnailUrl: "", tags: [], duration: "", author: "" }), Y = S.useCallback(async () => { try { r(!0); const se = await Vy.getResources({ page: 1, limit: 100, resourceType: c !== "all" ? c : void 0, category: d !== "all" ? d : void 0, subcategory: h !== "all" ? h : void 0, difficulty: g !== "all" ? g : void 0, search: s || void 0 }); e(se.data), se.stats && a(se.stats), se.categoryStats && b(se.categoryStats), se.subcategoryStats && M(se.subcategoryStats) } catch (se) { dt.error(se.message || "Failed to fetch resources") } finally { r(!1) } }, [c, d, h, g, s]); S.useEffect(() => { d === "all" && m("all") }, [d]), S.useEffect(() => { Y() }, [Y]), Array.from(new Set(t.map(se => se.category))).sort(); const Z = se => yT.find(he => he.value === se)?.color || "bg-gray-100 text-gray-800", $ = se => Ny.find(he => he.value === se)?.icon || Kh, V = () => { q({ resourceType: "guide", title: "", description: "", difficulty: "beginner", category: "", subcategory: null, contentUrl: "", thumbnailUrl: "", tags: [], duration: "", author: "" }), G(null) }, K = () => { V(), N(!0) }, X = se => { G(se), q({ resourceType: se.resourceType, title: se.title, description: se.description, difficulty: se.difficulty, category: se.category, subcategory: se.subcategory || null, contentUrl: se.contentUrl || (se.contentUrl === null, ""), thumbnailUrl: se.thumbnailUrl || "", tags: se.tags || [], duration: se.duration || "", author: se.author || "", questionText: se.questionText || "", answerSample: se.answerSample || "" }), j(!0) }, Q = se => { G(se), I(!0) }, re = se => { G(se), F(!0) }, ce = async () => { try { if (!z.title || !z.description || !z.category || !z.contentUrl || !z.subcategory) { dt.error("Please fill in all required fields, including subcategory"); return } await Vy.createResource(z), dt.success("Resource created successfully"), N(!1), V(), Y() } catch (se) { dt.error(se.message || "Failed to create resource") } }, be = async () => { if (B) try { if (!z.title || !z.description || !z.category || !z.contentUrl) { dt.error("Please fill in all required fields"); return } await Vy.updateResource(B._id, z), dt.success("Resource updated successfully"), j(!1), V(), Y() } catch (se) { dt.error(se.message || "Failed to update resource") } }, de = async () => { if (B) try { await Vy.deleteResource(B._id), dt.success("Resource deleted successfully"), F(!1), G(null), Y() } catch (se) { dt.error(se.message || "Failed to delete resource") } }, ae = se => new Date(se).toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" }); return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: [l.jsx("h1", { className: "text-2xl sm:text-3xl font-bold mb-2", children: "Resource Management" }), l.jsx("p", { className: "text-sm sm:text-base text-muted-foreground", children: "Manage guides, videos, courses, articles, and question banks" })] }), l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-7 gap-4", children: [l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Total Resources" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: i.total })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Guides" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: i.guides })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Videos" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: i.videos })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Question Banks" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: i.question_banks })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Courses" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: i.courses })] }), l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: "Articles" }), l.jsx("p", { className: "text-2xl font-bold mt-1", children: i.articles })] })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("div", { className: "flex items-center justify-between mb-6", children: [l.jsxs("h2", { className: "text-xl font-semibold flex items-center gap-2", children: [l.jsx(Kh, { className: "h-5 w-5 text-primary" }), "All Resources"] }), l.jsxs(on, { onClick: K, children: [l.jsx(HT, { className: "h-4 w-4 mr-2" }), "Add Resource"] })] }), l.jsx("div", { className: "w-full", children: l.jsxs("div", { className: "flex flex-col sm:flex-row flex-wrap sm:flex-nowrap items-stretch sm:items-center gap-3 overflow-x-auto pb-2 mb-3 scrollbar-thin scrollbar-thumb-border scrollbar-track-transparent", children: [l.jsx("div", { className: "flex-shrink-0 min-w-[150px]", children: l.jsxs(Jn, { value: c, onValueChange: se => u(se), children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Type" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Types" }), Ny.map(se => l.jsx(ut, { value: se.value, children: se.label }, se.value))] })] }) }), l.jsxs("div", { className: "relative flex-1 min-w-full sm:min-w-[300px]", children: [l.jsx(lg, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground z-10" }), l.jsx(fn, { type: "text", placeholder: "Search resources...", value: s, onChange: se => o(se.target.value), className: "pl-10 pr-10 w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2" }), s && l.jsx("button", { onClick: () => o(""), className: "absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground z-10", children: l.jsx(Pa, { className: "h-4 w-4" }) })] }), l.jsx("div", { className: "flex-shrink-0 min-w-[200px]", children: l.jsxs(Jn, { value: d, onValueChange: f, children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Category", children: d === "all" ? "All Categories" : d }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Categories" }), v.map(se => { const he = se._id, Ae = se.count || 0; return l.jsxs(ut, { value: he, children: [he, " (", Ae, ")"] }, he) })] })] }) }), d && d !== "all" && l.jsx("div", { className: "flex-shrink-0 min-w-[200px]", children: l.jsxs(Jn, { value: h, onValueChange: m, children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Subcategory", children: h === "all" ? "All Subcategories" : h }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Subcategories" }), (() => { const se = E.find(he => he._id.toLowerCase() === d.toLowerCase()); return se && se.subcategories && se.subcategories.length > 0 ? se.subcategories.map(he => l.jsxs(ut, { value: he.name, children: [he.name, " (", he.count || 0, ")"] }, he.name)) : (Qd[d]?.subcategories || []).map(he => l.jsx(ut, { value: he, children: he }, he)) })()] })] }) }), l.jsx("div", { className: "flex-shrink-0 min-w-[150px]", children: l.jsxs(Jn, { value: g, onValueChange: se => x(se), children: [l.jsx(qn, { className: "w-full focus:border-2 focus:border-primary focus:border-t-2 focus:border-l-2", children: l.jsx(er, { placeholder: "Difficulty" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "all", children: "All Difficulties" }), yT.map(se => l.jsx(ut, { value: se.value, children: se.label }, se.value))] })] }) }), (c !== "all" || d !== "all" || h !== "all" || g !== "all" || s.trim()) && l.jsxs("button", { onClick: () => { u("all"), f("all"), m("all"), x("all"), o("") }, className: "flex-shrink-0 flex items-center gap-2 px-4 py-2 text-sm text-muted-foreground hover:text-foreground transition-colors whitespace-nowrap", children: [l.jsx(Pa, { className: "h-4 w-4" }), "Clear"] })] }) }), (c !== "all" || d !== "all" || h !== "all" || g !== "all" || s.trim()) && l.jsxs("div", { className: "flex flex-wrap gap-2 mb-4", children: [c !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: ["Type: ", Ny.find(se => se.value === c)?.label, l.jsx("button", { onClick: () => u("all"), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), d !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: [d, l.jsx("button", { onClick: () => { f("all"), m("all") }, className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), h !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: [h, l.jsx("button", { onClick: () => m("all"), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), g !== "all" && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: [g, l.jsx("button", { onClick: () => x("all"), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] }), s.trim() && l.jsxs(Jt, { variant: "secondary", className: "gap-2", children: ["Search: ", s, l.jsx("button", { onClick: () => o(""), className: "ml-1 hover:text-foreground", children: l.jsx(Pa, { className: "h-3 w-3" }) })] })] }), n ? l.jsx("div", { className: "flex items-center justify-center py-12", children: l.jsx(sa, { className: "h-8 w-8 animate-spin text-primary" }) }) : t.length === 0 ? l.jsx("div", { className: "text-center py-12", children: l.jsx("p", { className: "text-muted-foreground", children: "No resources found" }) }) : l.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: t.map(se => { const he = $(se.resourceType); return l.jsxs($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "border border-border rounded-lg p-4 hover:border-primary/50 transition-colors relative", children: [l.jsx("div", { className: "absolute top-2 right-2", children: l.jsxs(e_, { children: [l.jsx(t_, { asChild: !0, children: l.jsx(on, { variant: "ghost", size: "sm", className: "h-8 w-8 p-0", children: l.jsx(u5, { className: "h-4 w-4" }) }) }), l.jsxs(T0, { align: "end", children: [l.jsxs(Xs, { onClick: () => Q(se), children: [l.jsx(Du, { className: "h-4 w-4 mr-2" }), "View Details"] }), l.jsxs(Xs, { onClick: () => X(se), children: [l.jsx(m5, { className: "h-4 w-4 mr-2" }), "Edit"] }), l.jsxs(Xs, { onClick: () => re(se), className: "text-destructive", children: [l.jsx(Bg, { className: "h-4 w-4 mr-2" }), "Delete"] })] })] }) }), l.jsx("div", { className: "flex items-start justify-between mb-2 pr-8", children: l.jsxs("div", { className: "flex items-center gap-2", children: [l.jsx(he, { className: "h-4 w-4 text-primary" }), l.jsx(Jt, { className: Z(se.difficulty), children: se.difficulty })] }) }), l.jsx("h3", { className: "font-semibold mb-1", children: se.title || "Untitled Resource" }), l.jsx("p", { className: "text-sm text-muted-foreground mb-2 line-clamp-2", children: se.description || "No description" }), se.tags && se.tags.length > 0 && l.jsx("div", { className: "flex flex-wrap gap-1 mb-2", children: se.tags.map((Ae, Ce) => l.jsx(Jt, { variant: "outline", className: "text-xs", children: Ae }, Ce)) }), l.jsxs("div", { className: "flex items-center gap-4 text-xs text-muted-foreground", children: [l.jsx("span", { children: se.category || "Uncategorized" }), se.subcategory && l.jsx("span", { children: se.subcategory }), (se.views || 0) > 0 && l.jsxs("span", { children: [se.views, " views"] }), se.questionText && l.jsx("span", { className: "text-primary", children: "Has Question Text" })] })] }, se._id) }) })] }), l.jsx(sl, { open: C, onOpenChange: N, children: l.jsxs(jo, { className: "max-w-2xl max-h-[90vh] overflow-y-auto", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Add New Resource" }), l.jsx(ol, { children: "Create a new resource for the platform" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-type", children: "Resource Type *" }), l.jsxs(Jn, { value: z.resourceType, onValueChange: se => q({ ...z, resourceType: se }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsx(Xn, { children: Ny.map(se => l.jsx(ut, { value: se.value, children: se.label }, se.value)) })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-difficulty", children: "Difficulty Level *" }), l.jsxs(Jn, { value: z.difficulty, onValueChange: se => q({ ...z, difficulty: se }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsx(Xn, { children: yT.map(se => l.jsx(ut, { value: se.value, children: se.label }, se.value)) })] })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-title", children: "Title *" }), l.jsx(fn, { id: "add-title", value: z.title, onChange: se => q({ ...z, title: se.target.value }), placeholder: "Enter resource title" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-description", children: "Description *" }), l.jsx(Ag, { id: "add-description", value: z.description, onChange: se => q({ ...z, description: se.target.value }), placeholder: "Enter resource description", rows: 4 })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-category", children: "Category *" }), l.jsxs(Jn, { value: z.category || "", onValueChange: se => { q({ ...z, category: se, subcategory: null }) }, children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select category" }) }), l.jsxs(Xn, { children: [v.map(se => l.jsx(ut, { value: se._id, children: se._id }, se._id)), v.length === 0 && Object.keys(Qd).map(se => l.jsx(ut, { value: se, children: se }, se))] })] })] }), z.category && z.category !== "" && l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-subcategory", children: "Subcategory *" }), l.jsxs(Jn, { value: z.subcategory || "", onValueChange: se => { q({ ...z, subcategory: se }) }, children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select subcategory" }) }), l.jsx(Xn, { children: (() => { const se = Qd[z.category]; return se && se.subcategories && se.subcategories.length > 0 ? se.subcategories.map(he => l.jsx(ut, { value: he, children: he }, he)) : l.jsx(ut, { value: "none", disabled: !0, children: "No subcategories available" }) })() })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-content-url", children: "Content URL *" }), l.jsx(fn, { id: "add-content-url", value: z.contentUrl, onChange: se => q({ ...z, contentUrl: se.target.value }), placeholder: "URL to PDF, video, or external link" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-thumbnail-url", children: "Thumbnail URL" }), l.jsx(fn, { id: "add-thumbnail-url", value: z.thumbnailUrl, onChange: se => q({ ...z, thumbnailUrl: se.target.value }), placeholder: "Optional thumbnail image URL" })] }), l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-duration", children: "Duration" }), l.jsx(fn, { id: "add-duration", value: z.duration, onChange: se => q({ ...z, duration: se.target.value }), placeholder: "e.g., 2 hours" })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-author", children: "Author" }), l.jsx(fn, { id: "add-author", value: z.author, onChange: se => q({ ...z, author: se.target.value }), placeholder: "Author name" })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "add-tags", children: "Tags (comma-separated)" }), l.jsx(fn, { id: "add-tags", value: z.tags?.join(", ") || "", onChange: se => { const he = se.target.value.split(",").map(Ae => Ae.trim()).filter(Ae => Ae); q({ ...z, tags: he }) }, placeholder: "tag1, tag2, tag3" })] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => N(!1), children: "Cancel" }), l.jsx(on, { onClick: ce, children: "Create Resource" })] })] }) }), l.jsx(sl, { open: A, onOpenChange: j, children: l.jsxs(jo, { className: "max-w-2xl max-h-[90vh] overflow-y-auto", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Edit Resource" }), l.jsx(ol, { children: "Update resource information" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-type", children: "Resource Type *" }), l.jsxs(Jn, { value: z.resourceType, onValueChange: se => q({ ...z, resourceType: se }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsx(Xn, { children: Ny.map(se => l.jsx(ut, { value: se.value, children: se.label }, se.value)) })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-difficulty", children: "Difficulty Level *" }), l.jsxs(Jn, { value: z.difficulty, onValueChange: se => q({ ...z, difficulty: se }), children: [l.jsx(qn, { children: l.jsx(er, {}) }), l.jsx(Xn, { children: yT.map(se => l.jsx(ut, { value: se.value, children: se.label }, se.value)) })] })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-title", children: "Title *" }), l.jsx(fn, { id: "edit-title", value: z.title, onChange: se => q({ ...z, title: se.target.value }) })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-description", children: "Description *" }), l.jsx(Ag, { id: "edit-description", value: z.description, onChange: se => q({ ...z, description: se.target.value }), rows: 4 })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-category", children: "Category *" }), l.jsxs(Jn, { value: z.category || "", onValueChange: se => { q({ ...z, category: se, subcategory: null }) }, children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select category" }) }), l.jsxs(Xn, { children: [v.map(se => l.jsx(ut, { value: se._id, children: se._id }, se._id)), v.length === 0 && Object.keys(Qd).map(se => l.jsx(ut, { value: se, children: se }, se))] })] })] }), z.category && z.category !== "" && l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-subcategory", children: "Subcategory" }), l.jsxs(Jn, { value: z.subcategory || "", onValueChange: se => { q({ ...z, subcategory: se }) }, children: [l.jsx(qn, { children: l.jsx(er, { placeholder: "Select subcategory (optional)" }) }), l.jsx(Xn, { children: (() => { const se = Qd[z.category]; return se && se.subcategories && se.subcategories.length > 0 ? se.subcategories.map(he => l.jsx(ut, { value: he, children: he }, he)) : l.jsx(ut, { value: "none", disabled: !0, children: "No subcategories available" }) })() })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-content-url", children: "Content URL *" }), l.jsx(fn, { id: "edit-content-url", value: z.contentUrl, onChange: se => q({ ...z, contentUrl: se.target.value }) })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-thumbnail-url", children: "Thumbnail URL" }), l.jsx(fn, { id: "edit-thumbnail-url", value: z.thumbnailUrl, onChange: se => q({ ...z, thumbnailUrl: se.target.value }) })] }), l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-duration", children: "Duration" }), l.jsx(fn, { id: "edit-duration", value: z.duration, onChange: se => q({ ...z, duration: se.target.value }) })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-author", children: "Author" }), l.jsx(fn, { id: "edit-author", value: z.author, onChange: se => q({ ...z, author: se.target.value }) })] })] }), l.jsxs("div", { children: [l.jsx(We, { htmlFor: "edit-tags", children: "Tags (comma-separated)" }), l.jsx(fn, { id: "edit-tags", value: z.tags?.join(", ") || "", onChange: se => { const he = se.target.value.split(",").map(Ae => Ae.trim()).filter(Ae => Ae); q({ ...z, tags: he }) } })] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => j(!1), children: "Cancel" }), l.jsx(on, { onClick: be, children: "Update Resource" })] })] }) }), l.jsx(sl, { open: O, onOpenChange: I, children: l.jsxs(jo, { className: "max-w-2xl", children: [l.jsx(Ro, { children: l.jsx(ko, { children: B?.title }) }), B && l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Type" }), l.jsx("p", { className: "font-medium", children: Ny.find(se => se.value === B.resourceType)?.label })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Description" }), l.jsx("p", { className: "font-medium", children: B.description })] }), l.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Category" }), l.jsx("p", { className: "font-medium", children: B.category })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Difficulty" }), l.jsx(Jt, { className: Z(B.difficulty), children: B.difficulty })] })] }), B.tags && B.tags.length > 0 && l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Tags" }), l.jsx("div", { className: "flex flex-wrap gap-2 mt-1", children: B.tags.map((se, he) => l.jsx(Jt, { variant: "outline", className: "text-xs", children: se }, he)) })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Content URL" }), B.contentUrl ? l.jsx("a", { href: B.contentUrl, target: "_blank", rel: "noopener noreferrer", className: "text-primary hover:underline break-all", children: B.contentUrl }) : l.jsx("p", { className: "text-muted-foreground text-sm", children: "No content URL provided" })] }), B.thumbnailUrl && l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Thumbnail" }), l.jsx("img", { src: B.thumbnailUrl, alt: B.title, className: "mt-2 rounded-lg max-w-full h-auto max-h-48", onError: se => { const he = se.target; he.style.display = "none" } })] }), B.questionText && l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Question Text" }), l.jsx("p", { className: "font-medium mt-1", children: B.questionText })] }), B.answerSample && l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Sample Answer" }), l.jsx("p", { className: "font-medium mt-1", children: B.answerSample })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Views" }), l.jsx("p", { className: "font-medium", children: B.views || 0 })] }), B.subcategory && l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Subcategory" }), l.jsx("p", { className: "font-medium", children: B.subcategory })] }), l.jsxs("div", { children: [l.jsx(We, { className: "text-xs text-muted-foreground", children: "Created" }), l.jsx("p", { className: "font-medium", children: ae(B.createdAt) })] })] })] }) }), l.jsx(sl, { open: D, onOpenChange: F, children: l.jsxs(jo, { className: "max-w-md", children: [l.jsxs(Ro, { children: [l.jsx(ko, { children: "Delete Resource" }), l.jsxs(ol, { children: ['Are you sure you want to delete "', B?.title, '"? This action cannot be undone.'] })] }), l.jsxs(kc, { children: [l.jsx(on, { variant: "outline", onClick: () => F(!1), children: "Cancel" }), l.jsx(on, { variant: "destructive", onClick: de, children: "Delete" })] })] }) })] }) } function sct() { const [t, e] = S.useState("month"), n = [{ title: "Total Users", value: "2,847", change: "+12.5%", trend: "up", icon: qc }, { title: "Interviews Conducted", value: "15,634", change: "+23.1%", trend: "up", icon: li }, { title: "Success Rate", value: "87%", change: "+5.2%", trend: "up", icon: Fu }, { title: "Revenue", value: "$45,680", change: "+18.7%", trend: "up", icon: v1 }], r = { data: [156, 178, 198, 167, 189, 201, 234, 256, 278, 289, 301, 312].map((o, c) => ({ date: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][c], Interviews: o })) }, i = { data: [1200, 1350, 1500, 1750, 1900, 2100, 2300, 2500, 2650, 2750, 2847].map((o, c) => ({ date: ["Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][c], Users: o })) }, a = [{ label: "New Users", value: 234, color: "bg-primary" }, { label: "Active Users", value: 1923, color: "bg-accent" }, { label: "Returning Users", value: 1456, color: "bg-secondary" }, { label: "Churned Users", value: 89, color: "bg-destructive" }], s = [{ label: "System Uptime", value: "99.9%" }, { label: "Average Response Time", value: "245ms" }, { label: "Error Rate", value: "0.1%" }, { label: "User Satisfaction", value: "4.6/5" }]; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: l.jsxs("div", { className: "flex justify-between items-center", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Analytics & Reports" }), l.jsx("p", { className: "text-muted-foreground", children: "Comprehensive platform analytics and performance metrics" })] }), l.jsxs("div", { className: "flex gap-2", children: [l.jsxs(Jn, { value: t, onValueChange: e, children: [l.jsx(qn, { className: "w-[180px]", children: l.jsx(er, { placeholder: "Select timeframe" }) }), l.jsxs(Xn, { children: [l.jsx(ut, { value: "week", children: "Last 7 days" }), l.jsx(ut, { value: "month", children: "Last 30 days" }), l.jsx(ut, { value: "quarter", children: "Last quarter" }), l.jsx(ut, { value: "year", children: "Last year" })] })] }), l.jsxs(on, { variant: "outline", children: [l.jsx(FS, { className: "mr-2 h-4 w-4" }), "Export"] })] })] }) }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5, delay: .1 }, className: "grid md:grid-cols-2 lg:grid-cols-4 gap-4", children: n.map((o, c) => l.jsxs(sn, { className: "p-4", variant: "elevated", children: [l.jsxs("div", { className: "flex justify-between items-start", children: [l.jsxs("div", { children: [l.jsx("p", { className: "text-sm text-muted-foreground", children: o.title }), l.jsx("h3", { className: "text-2xl font-bold mt-1", children: o.value })] }), l.jsx(o.icon, { className: "h-5 w-5 text-muted-foreground" })] }), l.jsxs("div", { className: `text-sm mt-2 ${o.trend === "up" ? "text-success" : "text-destructive"}`, children: [o.change, " from last period"] })] }, o.title)) }), l.jsxs("div", { className: "grid lg:grid-cols-2 gap-6", children: [l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Interview Activity" }), l.jsx(Az, { data: r.data, index: "date", categories: ["Interviews"], colors: ["blue"], yAxisWidth: 40 })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsx("h3", { className: "text-lg font-semibold mb-4", children: "User Growth" }), l.jsx(Nz, { data: i.data, index: "date", categories: ["Users"], colors: ["green"], yAxisWidth: 40 })] })] }), l.jsxs("div", { className: "grid lg:grid-cols-2 gap-6", children: [l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(v1, { className: "h-5 w-5 text-primary" }), "User Growth Breakdown"] }), l.jsx("div", { className: "space-y-4", children: a.map((o, c) => l.jsxs("div", { className: "space-y-2", children: [l.jsxs("div", { className: "flex justify-between text-sm", children: [l.jsx("span", { children: o.label }), l.jsx("span", { children: o.value.toLocaleString() })] }), l.jsx("div", { className: "w-full bg-muted rounded-full h-2", children: l.jsx($e.div, { className: `h-2 rounded-full ${o.color}`, initial: { width: 0 }, animate: { width: `${o.value / 2e3 * 100}%` }, transition: { delay: .5 + c * .1, duration: .8 } }) })] }, o.label)) })] }), l.jsxs(sn, { className: "p-6", variant: "elevated", children: [l.jsxs("h3", { className: "text-lg font-semibold mb-4 flex items-center gap-2", children: [l.jsx(Fu, { className: "h-5 w-5 text-accent" }), "Platform Performance"] }), l.jsx("div", { className: "space-y-4", children: s.map(o => l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsx("span", { className: "text-sm", children: o.label }), l.jsx("span", { className: "font-medium", children: o.value })] }, o.label)) })] })] })] }) } function oct() { const { user: t } = La(), [e, n] = S.useState(!1), [r, i] = S.useState("general"), [a, s] = S.useState({ platformName: "MockRise Interview Platform", supportEmail: "support@mockrise.com", maintenanceMode: !1, allowRegistration: !0, requireEmailVerification: !0, sessionTimeout: "30", maxFileUploadSize: "10", enableTwoFactor: !1, passwordMinLength: "8", enableRateLimiting: !0, maxLoginAttempts: "5", databaseBackupFrequency: "daily", enableAnalytics: !0, enableErrorTracking: !0 }), o = async () => { n(!0), await new Promise(u => setTimeout(u, 1e3)), n(!1), dt.success("System configuration saved successfully!") }, c = (u, d) => { s(f => ({ ...f, [u]: d })) }; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "System Configuration" }), l.jsx("p", { className: "text-muted-foreground", children: "Manage system-wide settings and platform configurations" })] }), l.jsxs(Sp, { value: r, onValueChange: i, className: "space-y-6", children: [l.jsxs(Ef, { className: "grid w-full grid-cols-5", children: [l.jsx(Rr, { value: "general", children: "General" }), l.jsx(Rr, { value: "security", children: "Security" }), l.jsx(Rr, { value: "features", children: "Features" }), l.jsx(Rr, { value: "database", children: "Database" }), l.jsx(Rr, { value: "advanced", children: "Advanced" })] }), l.jsx(Dr, { value: "general", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-6", children: [l.jsx(EJ, { className: "h-5 w-5 text-primary" }), l.jsx("h2", { className: "text-xl font-semibold", children: "General Settings" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "platformName", children: "Platform Name" }), l.jsx(fn, { id: "platformName", value: a.platformName, onChange: u => c("platformName", u.target.value) })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "supportEmail", children: "Support Email" }), l.jsx(fn, { id: "supportEmail", type: "email", value: a.supportEmail, onChange: u => c("supportEmail", u.target.value) })] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "maintenanceMode", children: "Maintenance Mode" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Temporarily disable access to the platform for all users" })] }), l.jsx(Aa, { id: "maintenanceMode", checked: a.maintenanceMode, onCheckedChange: u => c("maintenanceMode", u) })] }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "allowRegistration", children: "Allow New Registrations" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Enable or disable new user registration" })] }), l.jsx(Aa, { id: "allowRegistration", checked: a.allowRegistration, onCheckedChange: u => c("allowRegistration", u) })] })] })] }) }), l.jsx(Dr, { value: "security", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-6", children: [l.jsx(cx, { className: "h-5 w-5 text-primary" }), l.jsx("h2", { className: "text-xl font-semibold", children: "Security Settings" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "requireEmailVerification", children: "Require Email Verification" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Users must verify their email before accessing the platform" })] }), l.jsx(Aa, { id: "requireEmailVerification", checked: a.requireEmailVerification, onCheckedChange: u => c("requireEmailVerification", u) })] }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "enableTwoFactor", children: "Enable Two-Factor Authentication" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Allow users to enable 2FA for their accounts" })] }), l.jsx(Aa, { id: "enableTwoFactor", checked: a.enableTwoFactor, onCheckedChange: u => c("enableTwoFactor", u) })] }), l.jsx(Na, {}), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "passwordMinLength", children: "Minimum Password Length" }), l.jsx(fn, { id: "passwordMinLength", type: "number", value: a.passwordMinLength, onChange: u => c("passwordMinLength", u.target.value) })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "sessionTimeout", children: "Session Timeout (minutes)" }), l.jsx(fn, { id: "sessionTimeout", type: "number", value: a.sessionTimeout, onChange: u => c("sessionTimeout", u.target.value) })] }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "enableRateLimiting", children: "Enable Rate Limiting" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Protect against brute force attacks" })] }), l.jsx(Aa, { id: "enableRateLimiting", checked: a.enableRateLimiting, onCheckedChange: u => c("enableRateLimiting", u) })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "maxLoginAttempts", children: "Max Login Attempts" }), l.jsx(fn, { id: "maxLoginAttempts", type: "number", value: a.maxLoginAttempts, onChange: u => c("maxLoginAttempts", u.target.value) }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Account will be locked after this many failed attempts" })] })] })] }) }), l.jsx(Dr, { value: "features", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-6", children: [l.jsx(lx, { className: "h-5 w-5 text-primary" }), l.jsx("h2", { className: "text-xl font-semibold", children: "Feature Flags" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "maxFileUploadSize", children: "Max File Upload Size (MB)" }), l.jsx(fn, { id: "maxFileUploadSize", type: "number", value: a.maxFileUploadSize, onChange: u => c("maxFileUploadSize", u.target.value) })] }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "enableAnalytics", children: "Enable Analytics" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Track user behavior and platform usage" })] }), l.jsx(Aa, { id: "enableAnalytics", checked: a.enableAnalytics, onCheckedChange: u => c("enableAnalytics", u) })] }), l.jsxs("div", { className: "flex items-center justify-between", children: [l.jsxs("div", { className: "space-y-0.5", children: [l.jsx(We, { htmlFor: "enableErrorTracking", children: "Enable Error Tracking" }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "Automatically track and report application errors" })] }), l.jsx(Aa, { id: "enableErrorTracking", checked: a.enableErrorTracking, onCheckedChange: u => c("enableErrorTracking", u) })] })] })] }) }), l.jsx(Dr, { value: "database", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-6", children: [l.jsx(y8, { className: "h-5 w-5 text-primary" }), l.jsx("h2", { className: "text-xl font-semibold", children: "Database Settings" })] }), l.jsxs("div", { className: "space-y-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "databaseBackupFrequency", children: "Backup Frequency" }), l.jsxs("select", { id: "databaseBackupFrequency", className: "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", value: a.databaseBackupFrequency, onChange: u => c("databaseBackupFrequency", u.target.value), children: [l.jsx("option", { value: "hourly", children: "Hourly" }), l.jsx("option", { value: "daily", children: "Daily" }), l.jsx("option", { value: "weekly", children: "Weekly" }), l.jsx("option", { value: "monthly", children: "Monthly" })] })] }), l.jsxs(tN, { children: [l.jsx(y8, { className: "h-4 w-4" }), l.jsx(nN, { children: "Last backup: 2 hours ago. Next backup: In 22 hours" })] })] })] }) }), l.jsx(Dr, { value: "advanced", className: "space-y-6", children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-2 mb-6", children: [l.jsx(Gve, { className: "h-5 w-5 text-primary" }), l.jsx("h2", { className: "text-xl font-semibold", children: "Advanced Settings" })] }), l.jsxs(tN, { children: [l.jsx(p0, { className: "h-4 w-4" }), l.jsx(nN, { children: "These settings are for advanced users only. Incorrect configuration may affect platform functionality." })] }), l.jsx("div", { className: "space-y-4 mt-4", children: l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "apiKey", children: "API Configuration" }), l.jsx(fn, { id: "apiKey", type: "password", placeholder: "API Key", readOnly: !0 }), l.jsx("p", { className: "text-sm text-muted-foreground", children: "API keys are managed separately for security reasons" })] }) })] }) })] }), l.jsxs("div", { className: "flex justify-end gap-4", children: [l.jsx(vt, { variant: "outline", onClick: () => s({ platformName: "MockRise Interview Platform", supportEmail: "support@mockrise.com", maintenanceMode: !1, allowRegistration: !0, requireEmailVerification: !0, sessionTimeout: "30", maxFileUploadSize: "10", enableTwoFactor: !1, passwordMinLength: "8", enableRateLimiting: !0, maxLoginAttempts: "5", databaseBackupFrequency: "daily", enableAnalytics: !0, enableErrorTracking: !0 }), children: "Reset" }), l.jsxs(vt, { onClick: o, disabled: e, children: [l.jsx(PJ, { className: "mr-2 h-4 w-4" }), e ? "Saving..." : "Save Changes"] })] })] }) } function lct() { const { user: t } = La(), [e, n] = S.useState(!1), [r, i] = S.useState({ firstName: t?.name?.split(" ")[0] || "", lastName: t?.name?.split(" ").slice(1).join(" ") || "", email: t?.email || "", phone: "", title: "System Administrator", department: "IT", location: "", bio: "" }), a = async () => { n(!0), await new Promise(o => setTimeout(o, 1e3)), n(!1), dt.success("Profile updated successfully!") }, s = (o, c) => { i(u => ({ ...u, [o]: c })) }; return l.jsxs("div", { className: "space-y-8 pb-20 lg:pb-8", children: [l.jsxs("div", { children: [l.jsx("h1", { className: "text-3xl font-bold mb-2", children: "Admin Profile" }), l.jsx("p", { className: "text-muted-foreground", children: "Manage your admin account profile and information" })] }), l.jsx($e.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .5 }, children: l.jsxs(Lt, { className: "p-6", children: [l.jsxs("div", { className: "flex items-center gap-6 mb-6", children: [l.jsxs(Vc, { className: "h-24 w-24", children: [l.jsx(xf, { src: `https://api.dicebear.com/7.x/avataaars/svg?seed=${t?.name || t?.email || "admin"}` }), l.jsx(Hc, { children: t?.name ? t.name.substring(0, 2).toUpperCase() : t?.email ? t.email.substring(0, 2).toUpperCase() : "AD" })] }), l.jsxs("div", { children: [l.jsxs(vt, { variant: "outline", size: "sm", children: [l.jsx($S, { className: "h-4 w-4 mr-2" }), "Upload Photo"] }), l.jsx("p", { className: "text-xs text-muted-foreground mt-2", children: "JPG, PNG or GIF. Max size 2MB." })] })] }), l.jsx(Na, { className: "mb-6" }), l.jsxs("div", { className: "space-y-6", children: [l.jsxs("div", { className: "grid sm:grid-cols-2 gap-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "firstName", children: "First Name" }), l.jsx(fn, { id: "firstName", value: r.firstName, onChange: o => s("firstName", o.target.value) })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "lastName", children: "Last Name" }), l.jsx(fn, { id: "lastName", value: r.lastName, onChange: o => s("lastName", o.target.value) })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "email", children: "Email" }), l.jsxs("div", { className: "relative", children: [l.jsx(Lu, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "email", type: "email", value: r.email, onChange: o => s("email", o.target.value), className: "pl-10" })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "phone", children: "Phone Number" }), l.jsxs("div", { className: "relative", children: [l.jsx(AJ, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "phone", type: "tel", value: r.phone, onChange: o => s("phone", o.target.value), className: "pl-10", placeholder: "+1 (555) 123-4567" })] })] }), l.jsxs("div", { className: "grid sm:grid-cols-2 gap-4", children: [l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "title", children: "Job Title" }), l.jsxs("div", { className: "relative", children: [l.jsx(Uve, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "title", value: r.title, onChange: o => s("title", o.target.value), className: "pl-10" })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "department", children: "Department" }), l.jsx(fn, { id: "department", value: r.department, onChange: o => s("department", o.target.value) })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "location", children: "Location" }), l.jsxs("div", { className: "relative", children: [l.jsx(Yve, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }), l.jsx(fn, { id: "location", value: r.location, onChange: o => s("location", o.target.value), className: "pl-10", placeholder: "City, Country" })] })] }), l.jsxs("div", { className: "space-y-2", children: [l.jsx(We, { htmlFor: "bio", children: "Bio" }), l.jsx("textarea", { id: "bio", className: "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", value: r.bio, onChange: o => s("bio", o.target.value), placeholder: "Tell us about yourself...", rows: 4 })] }), l.jsx(Na, {}), l.jsxs("div", { className: "flex justify-end gap-4", children: [l.jsx(vt, { variant: "outline", onClick: () => { i({ firstName: t?.name?.split(" ")[0] || "", lastName: t?.name?.split(" ").slice(1).join(" ") || "", email: t?.email || "", phone: "", title: "System Administrator", department: "IT", location: "", bio: "" }) }, children: "Cancel" }), l.jsxs(vt, { onClick: a, disabled: e, children: [l.jsx(PJ, { className: "mr-2 h-4 w-4" }), e ? "Saving..." : "Save Changes"] })] })] })] }) })] }) } const cct = l.jsxs(l.Fragment, { children: [l.jsxs(Gn, { path: cr.TRAINEE_DASHBOARD, element: l.jsx(qM, { requiredRoles: ["trainee"], children: l.jsx(pk, {}) }), children: [l.jsx(Gn, { index: !0, element: l.jsx(M5e, {}) }), l.jsx(Gn, { path: "schedule", element: l.jsx(iBe, {}) }), l.jsx(Gn, { path: "sessions", element: l.jsx(oBe, {}) }), l.jsx(Gn, { path: "sessions/:sessionId", element: l.jsx(lBe, {}) }), l.jsx(Gn, { path: "sessions/:sessionId/reschedule", element: l.jsx(hBe, {}) }), l.jsx(Gn, { path: "speech-analysis", element: l.jsx(pBe, {}) }), l.jsx(Gn, { path: "feedback", element: l.jsx(mBe, {}) }), l.jsx(Gn, { path: "settings", element: l.jsx(Q7, {}) }), l.jsx(Gn, { path: "notifications", element: l.jsx(Sk, {}) })] }), l.jsxs(Gn, { path: cr.INTERVIEWER_DASHBOARD, element: l.jsx(qM, { requiredRoles: ["interviewer"], children: l.jsx(pk, {}) }), children: [l.jsx(Gn, { index: !0, element: l.jsx(_Be, {}) }), l.jsx(Gn, { path: "assigned", element: l.jsx(EBe, {}) }), l.jsx(Gn, { path: "calendar", element: l.jsx(TBe, {}) }), l.jsx(Gn, { path: "availability", element: l.jsx(Ult, {}) }), l.jsx(Gn, { path: "questions", element: l.jsx(CBe, {}) }), l.jsx(Gn, { path: "feedback", element: l.jsx(NBe, {}) }), l.jsx(Gn, { path: "stats", element: l.jsx(Dlt, {}) }), l.jsx(Gn, { path: "settings", element: l.jsx(Q7, {}) }), l.jsx(Gn, { path: "notifications", element: l.jsx(Sk, {}) })] }), l.jsxs(Gn, { path: cr.ADMIN_DASHBOARD, element: l.jsx(qM, { requiredRoles: ["admin", "super_admin", "hr_admin"], children: l.jsx(pk, {}) }), children: [l.jsx(Gn, { index: !0, element: l.jsx(Blt, {}) }), l.jsx(Gn, { path: "pending-interviewers", element: l.jsx($lt, {}) }), l.jsx(Gn, { path: "users", element: l.jsx(zlt, {}) }), l.jsx(Gn, { path: "interviews", element: l.jsx(ict, {}) }), l.jsx(Gn, { path: "resources", element: l.jsx(act, {}) }), l.jsx(Gn, { path: "analytics", element: l.jsx(sct, {}) }), l.jsx(Gn, { path: "config", element: l.jsx(qM, { requiredRoles: ["admin"], children: l.jsx(oct, {}) }) }), l.jsx(Gn, { path: "profile", element: l.jsx(lct, {}) }), l.jsx(Gn, { path: "notifications", element: l.jsx(Sk, {}) })] })] }), uct = () => (fs(), l.jsx("div", { className: "flex min-h-screen items-center justify-center bg-gray-100", children: l.jsxs("div", { className: "text-center", children: [l.jsx("h1", { className: "mb-4 text-4xl font-bold", children: "404" }), l.jsx("p", { className: "mb-4 text-xl text-gray-600", children: "Oops! Page not found" }), l.jsx("a", { href: "/", className: "text-blue-500 underline hover:text-blue-700", children: "Return to Home" })] }) })), dct = () => l.jsxs(pve, { children: [F4e, cct, l.jsx(Gn, { path: cr.NOT_FOUND, element: l.jsx(uct, {}) })] }), fct = new uwe, hct = () => l.jsx(oye, { children: l.jsx(Sve, { children: l.jsx(jve, { children: l.jsx(Ive, { children: l.jsx(mwe, { client: fct, children: l.jsxs(qbe, { children: [l.jsx($xe, {}), l.jsx(x0e, {}), l.jsx(lye, {}), l.jsx(dct, {})] }) }) }) }) }) }); xge.createRoot(document.getElementById("root")).render(l.jsx(hct, {}));
